[dral]include header.dral[#dral]

class Field:
    def __init__(self, name: str, position: int, width: int) -> None:
        self._name = name
        self._position = position
        self._width = width
        self._mask = (1 << width) - 1
        self._value = 0

    @property
    def name(self) -> str:
        return self._name

    @property
    def position(self) -> int:
        return self._position

    @property
    def mask(self) -> int:
        return self._mask

    @property
    def width(self) -> int:
        return self._width

    @property
    def value(self) -> int:
        return self._value

    @value.setter
    def value(self, value: int) -> None:
        self._value = value & self._mask


class Register:
    def __init__(self, name: str, address: int) -> None:
        self._name = name
        self._address = address
        self._value = 0
        self._fields = self._get_all_fields()
        self._index = 0

    def _get_all_fields(self) -> tuple[Field]:
        fields = list(filter(lambda x: isinstance(x, Field), self.__dict__.values()))
        sorted_fields = sorted(fields, key=lambda x: x.position)
        return tuple(sorted_fields)

    def __iter__(self):
        return self

    def __next__(self):
        if self._index < len(self._fields):
            item = self._fields[self._index]
            self._index += 1
            return item
        else:
            raise StopIteration

    @property
    def name(self) -> str:
        return self._name

    @property
    def address(self) -> int:
        return self._address

    @property
    def value(self) -> int:
        return self._value

    @value.setter
    def value(self, value: int) -> None:
        for _, field in self.__dict__.items():
            if isinstance(field, Field):
                field.value = (value >> field.position) & field.mask
        self._value = value


class Peripheral:
    def __init__(self, name: str, address: int) -> None:
        self._name = name
        self._address = address
        self._registers = self._get_all_registers()
        self._index = 0

    def _get_all_registers(self) -> tuple[Register]:
        registers = list(filter(lambda x: isinstance(x, Register), self.__dict__.values()))
        sorted_registers = sorted(registers, key=lambda x: x.address)
        return tuple(sorted_registers)

    def __iter__(self):
        return self

    def __next__(self):
        if self._index < len(self._registers):
            item = self._registers[self._index]
            self._index += 1
            return item
        else:
            raise StopIteration

    @property
    def name(self) -> str:
        return self._name

    @property
    def address(self) -> int:
        return self._address
