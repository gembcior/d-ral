{% include 'header.dral' %}

#ifndef DRAL_REGISTER_MODEL_H
#define DRAL_REGISTER_MODEL_H

#include <cstdint>

namespace dral {

/**
 * Group Address Policy
 */
template<std::uintptr_t Address, unsigned int GroupOffset = 0>
class GroupAddressPolicy
{
public:
  static uintptr_t getAddress(const unsigned int& index)
  {
    return Address + (index * GroupOffset);
  }
};

template<uintptr_t Address>
class GroupAddressPolicy<Address>
{
public:
  static constexpr uintptr_t getAddress()
  {
    return Address;
  }
};

/**
 * Register Model Template
 */
template<typename SizeType, typename IndexPolicy>
class RegisterModel
{
public:
  /**
   * Read value from the register
   *
   * @return Register value
   */
  template<typename... Index>
  static SizeType read(Index&&... index)
  {
    volatile const SizeType* const reg = reinterpret_cast<volatile const SizeType*>(IndexPolicy::getAddress(index...));
    return *reg;
  }

  /**
   * @brief Write value to the register
   *
   * @param value Value to be written
   */
  template<typename... Index>
  static void write(SizeType value, Index&&... index)
  {
    volatile SizeType* const reg = reinterpret_cast<volatile SizeType*>(IndexPolicy::getAddress(index...));
    *reg = value;
  }

  /**
   * @brief Get register address
   *
   * @param index
   */
  template<typename... Index>
  static constexpr std::uintptr_t getAddress(Index&&... index)
  {
    return IndexPolicy::getAddress(index...);
  }
};

/**
 * Field Model Template
 */
template<typename SizeType, typename IndexPolicy, unsigned int Position, unsigned int Width>
class FieldModel
{
public:
  /**
   * @brief Read the field value from the register
   *
   * @return Field value
   */
  template<typename... Index>
  static SizeType read(Index&&... index)
  {
    volatile const SizeType* const reg = reinterpret_cast<volatile const SizeType*>(IndexPolicy::getAddress(index...));
    return (*reg >> Position) & getMask();
  }

  /**
   * @brief Write value to the register's field
   *
   * @param value Value to be written
   */
  template<typename... Index>
  static void write(SizeType value, Index&&... index)
  {
    volatile SizeType* const reg = reinterpret_cast<volatile SizeType*>(IndexPolicy::getAddress(index...));
    *reg = (*reg & ~(getMask() << Position)) | ((value & getMask()) << Position);
  }

  /**
   * @brief Get field width
   *
   * @return Field width
   */
  static constexpr unsigned int getWidth()
  {
    return Width;
  }

  /**
   * @brief Get field position
   *
   * @return Field position
   */
  static constexpr unsigned int getPosition()
  {
    return Position;
  }

  /**
   * @brief Get field mask calculated as (1 << width) - 1
   *
   * @return Field mask
   */
  static constexpr unsigned int getMask()
  {
    return (1U << getWidth()) - 1U;
  }

  static_assert(Position >= 0 && Position <= (sizeof(SizeType) * 8 - 1),
                "The position of the field can't exceed the register size or be less than 0.");
  static_assert(Width >= 1 && Width <= ((sizeof(SizeType) * 8) - Position),
                "The width of the field starting from the position can't exceed the register size or be less than 1.");
};

/**
 * Bit Field Mode Template
 */
template<typename SizeType, unsigned int Position, unsigned int Width = 1>
class BitFieldModel
{
public:
  /**
   * @brief Get field width
   *
   * @return Field width
   */
  static constexpr unsigned int getWidth()
  {
    return Width;
  }

  /**
   * @brief Get field position
   *
   * @return Field position
   */
  static constexpr unsigned int getPosition()
  {
    return Position;
  }

  /**
   * @brief Get field mask calculated as (1 << width) - 1
   *
   * @return Field mask
   */
  static constexpr unsigned int getMask()
  {
    return (1U << getWidth()) - 1U;
  }

  template<typename T>
  BitFieldModel& operator=(T value)
  {
    m_value = (m_value & ~(getMask() << Position)) | ((value & getMask()) << Position);
    return *this;
  }

  operator SizeType() const
  {
    return (m_value >> Position) & getMask();
  }

  explicit operator bool() const
  {
    return m_value & (getMask() << Position);
  }

  BitFieldModel& operator++()
  {
    return *this = *this + 1U;
  }

  SizeType operator++(int)
  {
    const SizeType result = *this;
    ++*this;
    return result;
  }

  BitFieldModel& operator--()
  {
    return *this = *this - 1U;
  }

  SizeType operator--(int)
  {
    const SizeType result = *this;
    --*this;
    return result;
  }

private:
  SizeType m_value;

  static_assert(Position >= 0 && Position <= (sizeof(SizeType) * 8 - 1),
                "The position of the field can't exceed the register size or be less than 0.");
  static_assert(Width >= 1 && Width <= ((sizeof(SizeType) * 8) - Position),
                "The width of the field starting from the position can't exceed the register size or be less than 1.");
};

/**
 * Bit Field Mode Template specialization for 1 bit field
 */
template<typename SizeType, unsigned int Position>
class BitFieldModel<SizeType, Position>
{
public:
  /**
   * @brief Get field width
   *
   * @return Field width
   */
  static constexpr unsigned int getWidth()
  {
    return 1U;
  }

  /**
   * @brief Get field position
   *
   * @return Field position
   */
  static constexpr unsigned int getPosition()
  {
    return Position;
  }

  /**
   * @brief Get field mask calculated as (1 << width) - 1
   *
   * @return Field mask
   */
  static constexpr unsigned int getMask()
  {
    return 1U;
  }

  BitFieldModel& operator=(bool value)
  {
    m_value = (m_value & ~(getMask() << Position)) | (value << Position);
    return *this;
  }

  explicit operator bool() const
  {
    return m_value & (getMask() << Position);
  }

private:
  SizeType m_value;

  static_assert(Position >= 0 && Position <= (sizeof(SizeType) * 8 - 1),
                "The position of the field can't exceed the register size or be less than 0.");
};

}

#endif /* DRAL_REGISTER_MODEL_H */
