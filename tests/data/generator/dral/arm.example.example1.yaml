- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n * \n * Copyright (c) 2023 Gembcior\n * \n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n * \n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_ARM_EXAMPLE_TIMER0_H\n#define DRAL_ARM_EXAMPLE_TIMER0_H\n\
    \n#include \"register_model.h\"\n\nnamespace dral::arm_example {\n\nclass timer0\n\
    {\npublic:\n  static constexpr uint32_t BaseAddress = 0x40010000;\n\nprivate:\n\
    \  template <uint32_t address>\n  class CrReg: public RegisterModel<address>\n\
    \  {\n  public:\n    using en = FieldModel<address, 0, 0x00000001>;\n    using\
    \ rst = FieldModel<address, 1, 0x00000001>;\n    using cnt = FieldModel<address,\
    \ 2, 0x00000003>;\n    using mode = FieldModel<address, 4, 0x00000007>;\n    using\
    \ psc = FieldModel<address, 7, 0x00000001>;\n    using cntsrc = FieldModel<address,\
    \ 8, 0x0000000F>;\n    using capsrc = FieldModel<address, 12, 0x0000000F>;\n \
    \   using capedge = FieldModel<address, 16, 0x00000003>;\n    using trgext = FieldModel<address,\
    \ 20, 0x00000003>;\n    using reload = FieldModel<address, 24, 0x00000003>;\n\
    \    using idr = FieldModel<address, 26, 0x00000003>;\n    using s = FieldModel<address,\
    \ 31, 0x00000001>;\n  };\n\npublic:\n  using cr = CrReg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template <uint32_t address>\n  class SrReg: public RegisterModel<address>\n\
    \  {\n  public:\n    using run = FieldModel<address, 0, 0x00000001>;\n    using\
    \ match = FieldModel<address, 8, 0x00000001>;\n    using un = FieldModel<address,\
    \ 9, 0x00000001>;\n    using ov = FieldModel<address, 10, 0x00000001>;\n    using\
    \ rst = FieldModel<address, 12, 0x00000001>;\n    using reload = FieldModel<address,\
    \ 14, 0x00000003>;\n  };\n\npublic:\n  using sr = SrReg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template <uint32_t address>\n  class IntReg: public RegisterModel<address>\n\
    \  {\n  public:\n    using en = FieldModel<address, 0, 0x00000001>;\n    using\
    \ mode = FieldModel<address, 4, 0x00000007>;\n  };\n\npublic:\n  using int = IntReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template <uint32_t address>\n  class CountReg: public\
    \ RegisterModel<address>\n  {\n  public:\n    \n  };\n\npublic:\n  using count\
    \ = CountReg<BaseAddress + 0x0020>;\n\nprivate:\n  template <uint32_t address>\n\
    \  class MatchReg: public RegisterModel<address>\n  {\n  public:\n    \n  };\n\
    \npublic:\n  using match = MatchReg<BaseAddress + 0x0024>;\n\nprivate:\n  template\
    \ <uint32_t address>\n  class Prescale_rdReg: public RegisterModel<address>\n\
    \  {\n  public:\n    \n  };\n\npublic:\n  using prescale_rd = Prescale_rdReg<BaseAddress\
    \ + 0x0028>;\n\nprivate:\n  template <uint32_t address>\n  class Prescale_wrReg:\
    \ public RegisterModel<address>\n  {\n  public:\n    \n  };\n\npublic:\n  using\
    \ prescale_wr = Prescale_wrReg<BaseAddress + 0x0028>;\n\nprivate:\n  template\
    \ <uint32_t address>\n  class Reload[0]Reg: public RegisterModel<address>\n  {\n\
    \  public:\n    \n  };\n\npublic:\n  using reload[0] = Reload[0]Reg<BaseAddress\
    \ + 0x0050>;\n\nprivate:\n  template <uint32_t address>\n  class Reload[1]Reg:\
    \ public RegisterModel<address>\n  {\n  public:\n    \n  };\n\npublic:\n  using\
    \ reload[1] = Reload[1]Reg<BaseAddress + 0x0054>;\n\nprivate:\n  template <uint32_t\
    \ address>\n  class Reload[2]Reg: public RegisterModel<address>\n  {\n  public:\n\
    \    \n  };\n\npublic:\n  using reload[2] = Reload[2]Reg<BaseAddress + 0x0058>;\n\
    \nprivate:\n  template <uint32_t address>\n  class Reload[3]Reg: public RegisterModel<address>\n\
    \  {\n  public:\n    \n  };\n\npublic:\n  using reload[3] = Reload[3]Reg<BaseAddress\
    \ + 0x005C>;\nprivate:\n  template <uint32_t address, uint32_t bankOffset>\n \
    \ class Reload[x]BankReg: public RegisterBankModel<address, bankOffset>\n  {\n\
    \  public:\n    \n  };\n\npublic:\n  using reload[x] = Reload[x]BankReg<BaseAddress\
    \ + 0x0050, 0x0004>;\n};\n\n}\n\n#endif /* DRAL_ARM_EXAMPLE_TIMER0_H */\n"
  name: TIMER0
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n * \n * Copyright (c) 2023 Gembcior\n * \n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n * \n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_ARM_EXAMPLE_TIMER1_H\n#define DRAL_ARM_EXAMPLE_TIMER1_H\n\
    \n#include \"register_model.h\"\n\nnamespace dral::arm_example {\n\nclass timer1\n\
    {\npublic:\n  static constexpr uint32_t BaseAddress = 0x40010100;\n\nprivate:\n\
    \  template <uint32_t address>\n  class CrReg: public RegisterModel<address>\n\
    \  {\n  public:\n    using en = FieldModel<address, 0, 0x00000001>;\n    using\
    \ rst = FieldModel<address, 1, 0x00000001>;\n    using cnt = FieldModel<address,\
    \ 2, 0x00000003>;\n    using mode = FieldModel<address, 4, 0x00000007>;\n    using\
    \ psc = FieldModel<address, 7, 0x00000001>;\n    using cntsrc = FieldModel<address,\
    \ 8, 0x0000000F>;\n    using capsrc = FieldModel<address, 12, 0x0000000F>;\n \
    \   using capedge = FieldModel<address, 16, 0x00000003>;\n    using trgext = FieldModel<address,\
    \ 20, 0x00000003>;\n    using reload = FieldModel<address, 24, 0x00000003>;\n\
    \    using idr = FieldModel<address, 26, 0x00000003>;\n    using s = FieldModel<address,\
    \ 31, 0x00000001>;\n  };\n\npublic:\n  using cr = CrReg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template <uint32_t address>\n  class SrReg: public RegisterModel<address>\n\
    \  {\n  public:\n    using run = FieldModel<address, 0, 0x00000001>;\n    using\
    \ match = FieldModel<address, 8, 0x00000001>;\n    using un = FieldModel<address,\
    \ 9, 0x00000001>;\n    using ov = FieldModel<address, 10, 0x00000001>;\n    using\
    \ rst = FieldModel<address, 12, 0x00000001>;\n    using reload = FieldModel<address,\
    \ 14, 0x00000003>;\n  };\n\npublic:\n  using sr = SrReg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template <uint32_t address>\n  class IntReg: public RegisterModel<address>\n\
    \  {\n  public:\n    using en = FieldModel<address, 0, 0x00000001>;\n    using\
    \ mode = FieldModel<address, 4, 0x00000007>;\n  };\n\npublic:\n  using int = IntReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template <uint32_t address>\n  class CountReg: public\
    \ RegisterModel<address>\n  {\n  public:\n    \n  };\n\npublic:\n  using count\
    \ = CountReg<BaseAddress + 0x0020>;\n\nprivate:\n  template <uint32_t address>\n\
    \  class MatchReg: public RegisterModel<address>\n  {\n  public:\n    \n  };\n\
    \npublic:\n  using match = MatchReg<BaseAddress + 0x0024>;\n\nprivate:\n  template\
    \ <uint32_t address>\n  class Prescale_rdReg: public RegisterModel<address>\n\
    \  {\n  public:\n    \n  };\n\npublic:\n  using prescale_rd = Prescale_rdReg<BaseAddress\
    \ + 0x0028>;\n\nprivate:\n  template <uint32_t address>\n  class Prescale_wrReg:\
    \ public RegisterModel<address>\n  {\n  public:\n    \n  };\n\npublic:\n  using\
    \ prescale_wr = Prescale_wrReg<BaseAddress + 0x0028>;\n\nprivate:\n  template\
    \ <uint32_t address>\n  class Reload[0]Reg: public RegisterModel<address>\n  {\n\
    \  public:\n    \n  };\n\npublic:\n  using reload[0] = Reload[0]Reg<BaseAddress\
    \ + 0x0050>;\n\nprivate:\n  template <uint32_t address>\n  class Reload[1]Reg:\
    \ public RegisterModel<address>\n  {\n  public:\n    \n  };\n\npublic:\n  using\
    \ reload[1] = Reload[1]Reg<BaseAddress + 0x0054>;\n\nprivate:\n  template <uint32_t\
    \ address>\n  class Reload[2]Reg: public RegisterModel<address>\n  {\n  public:\n\
    \    \n  };\n\npublic:\n  using reload[2] = Reload[2]Reg<BaseAddress + 0x0058>;\n\
    \nprivate:\n  template <uint32_t address>\n  class Reload[3]Reg: public RegisterModel<address>\n\
    \  {\n  public:\n    \n  };\n\npublic:\n  using reload[3] = Reload[3]Reg<BaseAddress\
    \ + 0x005C>;\nprivate:\n  template <uint32_t address, uint32_t bankOffset>\n \
    \ class Reload[x]BankReg: public RegisterBankModel<address, bankOffset>\n  {\n\
    \  public:\n    \n  };\n\npublic:\n  using reload[x] = Reload[x]BankReg<BaseAddress\
    \ + 0x0050, 0x0004>;\n};\n\n}\n\n#endif /* DRAL_ARM_EXAMPLE_TIMER1_H */\n"
  name: TIMER1
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n * \n * Copyright (c) 2023 Gembcior\n * \n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n * \n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_ARM_EXAMPLE_TIMER2_H\n#define DRAL_ARM_EXAMPLE_TIMER2_H\n\
    \n#include \"register_model.h\"\n\nnamespace dral::arm_example {\n\nclass timer2\n\
    {\npublic:\n  static constexpr uint32_t BaseAddress = 0x40010200;\n\nprivate:\n\
    \  template <uint32_t address>\n  class CrReg: public RegisterModel<address>\n\
    \  {\n  public:\n    using en = FieldModel<address, 0, 0x00000001>;\n    using\
    \ rst = FieldModel<address, 1, 0x00000001>;\n    using cnt = FieldModel<address,\
    \ 2, 0x00000003>;\n    using mode = FieldModel<address, 4, 0x00000007>;\n    using\
    \ psc = FieldModel<address, 7, 0x00000001>;\n    using cntsrc = FieldModel<address,\
    \ 8, 0x0000000F>;\n    using capsrc = FieldModel<address, 12, 0x0000000F>;\n \
    \   using capedge = FieldModel<address, 16, 0x00000003>;\n    using trgext = FieldModel<address,\
    \ 20, 0x00000003>;\n    using reload = FieldModel<address, 24, 0x00000003>;\n\
    \    using idr = FieldModel<address, 26, 0x00000003>;\n    using s = FieldModel<address,\
    \ 31, 0x00000001>;\n  };\n\npublic:\n  using cr = CrReg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template <uint32_t address>\n  class SrReg: public RegisterModel<address>\n\
    \  {\n  public:\n    using run = FieldModel<address, 0, 0x00000001>;\n    using\
    \ match = FieldModel<address, 8, 0x00000001>;\n    using un = FieldModel<address,\
    \ 9, 0x00000001>;\n    using ov = FieldModel<address, 10, 0x00000001>;\n    using\
    \ rst = FieldModel<address, 12, 0x00000001>;\n    using reload = FieldModel<address,\
    \ 14, 0x00000003>;\n  };\n\npublic:\n  using sr = SrReg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template <uint32_t address>\n  class IntReg: public RegisterModel<address>\n\
    \  {\n  public:\n    using en = FieldModel<address, 0, 0x00000001>;\n    using\
    \ mode = FieldModel<address, 4, 0x00000007>;\n  };\n\npublic:\n  using int = IntReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template <uint32_t address>\n  class CountReg: public\
    \ RegisterModel<address>\n  {\n  public:\n    \n  };\n\npublic:\n  using count\
    \ = CountReg<BaseAddress + 0x0020>;\n\nprivate:\n  template <uint32_t address>\n\
    \  class MatchReg: public RegisterModel<address>\n  {\n  public:\n    \n  };\n\
    \npublic:\n  using match = MatchReg<BaseAddress + 0x0024>;\n\nprivate:\n  template\
    \ <uint32_t address>\n  class Prescale_rdReg: public RegisterModel<address>\n\
    \  {\n  public:\n    \n  };\n\npublic:\n  using prescale_rd = Prescale_rdReg<BaseAddress\
    \ + 0x0028>;\n\nprivate:\n  template <uint32_t address>\n  class Prescale_wrReg:\
    \ public RegisterModel<address>\n  {\n  public:\n    \n  };\n\npublic:\n  using\
    \ prescale_wr = Prescale_wrReg<BaseAddress + 0x0028>;\n\nprivate:\n  template\
    \ <uint32_t address>\n  class Reload[0]Reg: public RegisterModel<address>\n  {\n\
    \  public:\n    \n  };\n\npublic:\n  using reload[0] = Reload[0]Reg<BaseAddress\
    \ + 0x0050>;\n\nprivate:\n  template <uint32_t address>\n  class Reload[1]Reg:\
    \ public RegisterModel<address>\n  {\n  public:\n    \n  };\n\npublic:\n  using\
    \ reload[1] = Reload[1]Reg<BaseAddress + 0x0054>;\n\nprivate:\n  template <uint32_t\
    \ address>\n  class Reload[2]Reg: public RegisterModel<address>\n  {\n  public:\n\
    \    \n  };\n\npublic:\n  using reload[2] = Reload[2]Reg<BaseAddress + 0x0058>;\n\
    \nprivate:\n  template <uint32_t address>\n  class Reload[3]Reg: public RegisterModel<address>\n\
    \  {\n  public:\n    \n  };\n\npublic:\n  using reload[3] = Reload[3]Reg<BaseAddress\
    \ + 0x005C>;\nprivate:\n  template <uint32_t address, uint32_t bankOffset>\n \
    \ class Reload[x]BankReg: public RegisterBankModel<address, bankOffset>\n  {\n\
    \  public:\n    \n  };\n\npublic:\n  using reload[x] = Reload[x]BankReg<BaseAddress\
    \ + 0x0050, 0x0004>;\n};\n\n}\n\n#endif /* DRAL_ARM_EXAMPLE_TIMER2_H */\n"
  name: TIMER2
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n * \n * Copyright (c) 2023 Gembcior\n * \n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n * \n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_REGISTER_MODEL_H\n#define DRAL_REGISTER_MODEL_H\n\
    \n#include <cstdint>\n\nnamespace dral {\n\ntemplate <uint32_t address>\nclass\
    \ RegisterModel\n{\npublic:\n  static constexpr uint32_t Address = address;\n\n\
    public:\n  static uint32_t read()\n  {\n    volatile uint32_t* reg = reinterpret_cast<volatile\
    \ uint32_t*>(address);\n    return *reg;\n  }\n\n  static void write(uint32_t\
    \ value)\n  {\n    volatile uint32_t* reg = reinterpret_cast<volatile uint32_t*>(address);\n\
    \    *reg = value;\n  }\n};\n\n\ntemplate <uint32_t address, uint32_t bankOffset>\n\
    class RegisterBankModel\n{\npublic:\n  static constexpr uint32_t Address = address;\n\
    \npublic:\n  static uint32_t read(uint32_t bank)\n  {\n    volatile uint32_t*\
    \ reg = reinterpret_cast<volatile uint32_t*>(address + (bankOffset * bank));\n\
    \    return *reg;\n  }\n\n  static void write(uint32_t bank, uint32_t value)\n\
    \  {\n    volatile uint32_t* reg = reinterpret_cast<volatile uint32_t*>(address\
    \ + (bankOffset * bank));\n    *reg = value;\n  }\n};\n\n\ntemplate <uint32_t\
    \ address, uint32_t position, uint32_t mask, uint32_t bankOffset = 0>\nclass FieldModel\n\
    {\npublic:\n  static constexpr uint32_t Mask = mask;\n  static constexpr uint32_t\
    \ Position = position;\n\npublic:\n  static void write(uint32_t bank, uint32_t\
    \ value)\n  {\n    volatile uint32_t* reg = reinterpret_cast<volatile uint32_t*>(address\
    \ + (bankOffset * bank));\n    *reg = (*reg & ~(mask << position)) | ((value &\
    \ mask) << position);\n  }\n\n  static uint32_t read(uint32_t bank)\n  {\n   \
    \ volatile uint32_t* reg = reinterpret_cast<volatile uint32_t*>(address + (bankOffset\
    \ * bank));\n    return (*reg >> position) & mask;\n  }\n\n  static uint32_t set(uint32_t\
    \ value)\n  {\n    return (value & mask) << position;\n  }\n\n  static void set(uint32_t&\
    \ reg, uint32_t value)\n  {\n    reg |= (value & mask) << position;\n  }\n\n \
    \ static uint32_t clear()\n  {\n    return ~mask;\n  }\n\n  static void clear(uint32_t&\
    \ reg)\n  {\n    reg &= ~mask;\n  }\n\n  static uint32_t getFromRegValue(uint32_t\
    \ regValue)\n  {\n    return (regValue >> position) & mask;\n  }\n};\n\n\ntemplate\
    \ <uint32_t address, uint32_t position, uint32_t mask>\nclass FieldModel<address,\
    \ position, mask, 0>\n{\npublic:\n  static constexpr uint32_t Mask = mask;\n \
    \ static constexpr uint32_t Position = position;\n\npublic:\n  static void write(uint32_t\
    \ value)\n  {\n    volatile uint32_t* reg = reinterpret_cast<volatile uint32_t*>(address);\n\
    \    *reg = (*reg & ~(mask << position)) | ((value & mask) << position);\n  }\n\
    \n  static uint32_t read()\n  {\n    volatile uint32_t* reg = reinterpret_cast<volatile\
    \ uint32_t*>(address);\n    return (*reg >> position) & mask;\n  }\n\n  static\
    \ uint32_t set(uint32_t value)\n  {\n    return (value & mask) << position;\n\
    \  }\n\n  static void set(uint32_t& reg, uint32_t value)\n  {\n    reg |= (value\
    \ & mask) << position;\n  }\n\n  static uint32_t clear()\n  {\n    return ~mask;\n\
    \  }\n\n  static void clear(uint32_t& reg)\n  {\n    reg &= ~mask;\n  }\n\n  static\
    \ uint32_t getFromRegValue(uint32_t regValue)\n  {\n    return (regValue >> position)\
    \ & mask;\n  }\n};\n\n} // namespace\n\n#endif /* DRAL_REGISTER_MODEL_H */\n"
  name: register_model
