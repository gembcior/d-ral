[
    {
        "name": "TIMER0",
        "content": "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n *\n * MIT License\n *\n * Copyright (c) 2024 Gembcior\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not modify!\n */\n\n#ifndef DRAL_ARM_EXAMPLE_TIMER0_H\n#define DRAL_ARM_EXAMPLE_TIMER0_H\n\n#include \"dral/bitfield_model.h\"\n#include \"dral/group_address_policy.h\"\n#include \"dral/layer_offset_policy.h\"\n#include \"dral/register_model.h\"\n\nnamespace dral::arm_example {\n\nclass Timer0\n{\npublic:\n  static constexpr uintptr_t Timer0BaseAddress = 0x40010000;\n\nprivate:\n  template<std::uintptr_t Address>\n  using Timer0AddressPolicy = GroupAddressPolicy<Address>;\n\n/**\n * REGISTER CR\n */\nprivate:\n  template<typename SizeType>\n  class CrRegisterUnion\n  {\n  public:\n    union\n    {\n      SizeType value;\n      BitFieldModel<SizeType, 0, 1> en;\n      BitFieldModel<SizeType, 1, 1> rst;\n      BitFieldModel<SizeType, 2, 2> cnt;\n      BitFieldModel<SizeType, 4, 3> mode;\n      BitFieldModel<SizeType, 7, 1> psc;\n      BitFieldModel<SizeType, 8, 4> cntsrc;\n      BitFieldModel<SizeType, 12, 4> capsrc;\n      BitFieldModel<SizeType, 16, 2> capedge;\n      BitFieldModel<SizeType, 20, 2> trgext;\n      BitFieldModel<SizeType, 24, 2> reload;\n      BitFieldModel<SizeType, 26, 2> idr;\n      BitFieldModel<SizeType, 31, 1> s;\n    };\n  };\n\nprivate:\n  template<typename SizeType, std::uintptr_t Address>\n  class CrRegisterModel : public RegisterModel<CrRegisterUnion<SizeType>, Timer0AddressPolicy<Address>>\n  {\n  public:\n    using reg = CrRegisterUnion<SizeType>;\n\n  public:\n    using en = FieldModel<reg, Timer0AddressPolicy<Address>, 0, 1>;\n    using rst = FieldModel<reg, Timer0AddressPolicy<Address>, 1, 1>;\n    using cnt = FieldModel<reg, Timer0AddressPolicy<Address>, 2, 2>;\n    using mode = FieldModel<reg, Timer0AddressPolicy<Address>, 4, 3>;\n    using psc = FieldModel<reg, Timer0AddressPolicy<Address>, 7, 1>;\n    using cntsrc = FieldModel<reg, Timer0AddressPolicy<Address>, 8, 4>;\n    using capsrc = FieldModel<reg, Timer0AddressPolicy<Address>, 12, 4>;\n    using capedge = FieldModel<reg, Timer0AddressPolicy<Address>, 16, 2>;\n    using trgext = FieldModel<reg, Timer0AddressPolicy<Address>, 20, 2>;\n    using reload = FieldModel<reg, Timer0AddressPolicy<Address>, 24, 2>;\n    using idr = FieldModel<reg, Timer0AddressPolicy<Address>, 26, 2>;\n    using s = FieldModel<reg, Timer0AddressPolicy<Address>, 31, 1>;\n  };\n\npublic:\n  using cr = CrRegisterModel<uint32_t, Timer0BaseAddress + 0x00000000>;\n\n/**\n * REGISTER SR\n */\nprivate:\n  template<typename SizeType>\n  class SrRegisterUnion\n  {\n  public:\n    union\n    {\n      SizeType value;\n      BitFieldModel<SizeType, 0, 1> run;\n      BitFieldModel<SizeType, 8, 1> match;\n      BitFieldModel<SizeType, 9, 1> un;\n      BitFieldModel<SizeType, 10, 1> ov;\n      BitFieldModel<SizeType, 12, 1> rst;\n      BitFieldModel<SizeType, 14, 2> reload;\n    };\n  };\n\nprivate:\n  template<typename SizeType, std::uintptr_t Address>\n  class SrRegisterModel : public RegisterModel<SrRegisterUnion<SizeType>, Timer0AddressPolicy<Address>>\n  {\n  public:\n    using reg = SrRegisterUnion<SizeType>;\n\n  public:\n    using run = FieldModel<reg, Timer0AddressPolicy<Address>, 0, 1>;\n    using match = FieldModel<reg, Timer0AddressPolicy<Address>, 8, 1>;\n    using un = FieldModel<reg, Timer0AddressPolicy<Address>, 9, 1>;\n    using ov = FieldModel<reg, Timer0AddressPolicy<Address>, 10, 1>;\n    using rst = FieldModel<reg, Timer0AddressPolicy<Address>, 12, 1>;\n    using reload = FieldModel<reg, Timer0AddressPolicy<Address>, 14, 2>;\n  };\n\npublic:\n  using sr = SrRegisterModel<uint32_t, Timer0BaseAddress + 0x00000004>;\n\n/**\n * REGISTER INT\n */\nprivate:\n  template<typename SizeType>\n  class IntRegisterUnion\n  {\n  public:\n    union\n    {\n      SizeType value;\n      BitFieldModel<SizeType, 0, 1> en;\n      BitFieldModel<SizeType, 4, 3> mode;\n    };\n  };\n\nprivate:\n  template<typename SizeType, std::uintptr_t Address>\n  class IntRegisterModel : public RegisterModel<IntRegisterUnion<SizeType>, Timer0AddressPolicy<Address>>\n  {\n  public:\n    using reg = IntRegisterUnion<SizeType>;\n\n  public:\n    using en = FieldModel<reg, Timer0AddressPolicy<Address>, 0, 1>;\n    using mode = FieldModel<reg, Timer0AddressPolicy<Address>, 4, 3>;\n  };\n\npublic:\n  using int_ = IntRegisterModel<uint32_t, Timer0BaseAddress + 0x00000010>;\n\n/**\n * REGISTER COUNT\n */\nprivate:\n  template<typename SizeType>\n  class CountRegisterUnion\n  {\n  public:\n    union\n    {\n      SizeType value;\n    };\n  };\n\nprivate:\n  template<typename SizeType, std::uintptr_t Address>\n  class CountRegisterModel : public RegisterModel<CountRegisterUnion<SizeType>, Timer0AddressPolicy<Address>>\n  {\n  public:\n    using reg = CountRegisterUnion<SizeType>;\n\n  public:\n  };\n\npublic:\n  using count = CountRegisterModel<uint32_t, Timer0BaseAddress + 0x00000020>;\n\n/**\n * REGISTER MATCH\n */\nprivate:\n  template<typename SizeType>\n  class MatchRegisterUnion\n  {\n  public:\n    union\n    {\n      SizeType value;\n    };\n  };\n\nprivate:\n  template<typename SizeType, std::uintptr_t Address>\n  class MatchRegisterModel : public RegisterModel<MatchRegisterUnion<SizeType>, Timer0AddressPolicy<Address>>\n  {\n  public:\n    using reg = MatchRegisterUnion<SizeType>;\n\n  public:\n  };\n\npublic:\n  using match = MatchRegisterModel<uint32_t, Timer0BaseAddress + 0x00000024>;\n\n/**\n * REGISTER PRESCALE_RD\n */\nprivate:\n  template<typename SizeType>\n  class PrescaleRdRegisterUnion\n  {\n  public:\n    union\n    {\n      SizeType value;\n    };\n  };\n\nprivate:\n  template<typename SizeType, std::uintptr_t Address>\n  class PrescaleRdRegisterModel : public RegisterModel<PrescaleRdRegisterUnion<SizeType>, Timer0AddressPolicy<Address>>\n  {\n  public:\n    using reg = PrescaleRdRegisterUnion<SizeType>;\n\n  public:\n  };\n\npublic:\n  using prescaleRd = PrescaleRdRegisterModel<uint32_t, Timer0BaseAddress + 0x00000028>;\n\n/**\n * REGISTER PRESCALE_WR\n */\nprivate:\n  template<typename SizeType>\n  class PrescaleWrRegisterUnion\n  {\n  public:\n    union\n    {\n      SizeType value;\n    };\n  };\n\nprivate:\n  template<typename SizeType, std::uintptr_t Address>\n  class PrescaleWrRegisterModel : public RegisterModel<PrescaleWrRegisterUnion<SizeType>, Timer0AddressPolicy<Address>>\n  {\n  public:\n    using reg = PrescaleWrRegisterUnion<SizeType>;\n\n  public:\n  };\n\npublic:\n  using prescaleWr = PrescaleWrRegisterModel<uint32_t, Timer0BaseAddress + 0x00000028>;\n\n\n};\n\n}\n\n#endif /* DRAL_ARM_EXAMPLE_TIMER0_H */"
    },
    {
        "name": "TIMER1",
        "content": "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n *\n * MIT License\n *\n * Copyright (c) 2024 Gembcior\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not modify!\n */\n\n#ifndef DRAL_ARM_EXAMPLE_TIMER1_H\n#define DRAL_ARM_EXAMPLE_TIMER1_H\n\n#include \"dral/bitfield_model.h\"\n#include \"dral/group_address_policy.h\"\n#include \"dral/layer_offset_policy.h\"\n#include \"dral/register_model.h\"\n\nnamespace dral::arm_example {\n\nclass Timer1\n{\npublic:\n  static constexpr uintptr_t Timer1BaseAddress = 0x40010100;\n\nprivate:\n  template<std::uintptr_t Address>\n  using Timer1AddressPolicy = GroupAddressPolicy<Address>;\n\n/**\n * REGISTER CR\n */\nprivate:\n  template<typename SizeType>\n  class CrRegisterUnion\n  {\n  public:\n    union\n    {\n      SizeType value;\n      BitFieldModel<SizeType, 0, 1> en;\n      BitFieldModel<SizeType, 1, 1> rst;\n      BitFieldModel<SizeType, 2, 2> cnt;\n      BitFieldModel<SizeType, 4, 3> mode;\n      BitFieldModel<SizeType, 7, 1> psc;\n      BitFieldModel<SizeType, 8, 4> cntsrc;\n      BitFieldModel<SizeType, 12, 4> capsrc;\n      BitFieldModel<SizeType, 16, 2> capedge;\n      BitFieldModel<SizeType, 20, 2> trgext;\n      BitFieldModel<SizeType, 24, 2> reload;\n      BitFieldModel<SizeType, 26, 2> idr;\n      BitFieldModel<SizeType, 31, 1> s;\n    };\n  };\n\nprivate:\n  template<typename SizeType, std::uintptr_t Address>\n  class CrRegisterModel : public RegisterModel<CrRegisterUnion<SizeType>, Timer1AddressPolicy<Address>>\n  {\n  public:\n    using reg = CrRegisterUnion<SizeType>;\n\n  public:\n    using en = FieldModel<reg, Timer1AddressPolicy<Address>, 0, 1>;\n    using rst = FieldModel<reg, Timer1AddressPolicy<Address>, 1, 1>;\n    using cnt = FieldModel<reg, Timer1AddressPolicy<Address>, 2, 2>;\n    using mode = FieldModel<reg, Timer1AddressPolicy<Address>, 4, 3>;\n    using psc = FieldModel<reg, Timer1AddressPolicy<Address>, 7, 1>;\n    using cntsrc = FieldModel<reg, Timer1AddressPolicy<Address>, 8, 4>;\n    using capsrc = FieldModel<reg, Timer1AddressPolicy<Address>, 12, 4>;\n    using capedge = FieldModel<reg, Timer1AddressPolicy<Address>, 16, 2>;\n    using trgext = FieldModel<reg, Timer1AddressPolicy<Address>, 20, 2>;\n    using reload = FieldModel<reg, Timer1AddressPolicy<Address>, 24, 2>;\n    using idr = FieldModel<reg, Timer1AddressPolicy<Address>, 26, 2>;\n    using s = FieldModel<reg, Timer1AddressPolicy<Address>, 31, 1>;\n  };\n\npublic:\n  using cr = CrRegisterModel<uint32_t, Timer1BaseAddress + 0x00000000>;\n\n/**\n * REGISTER SR\n */\nprivate:\n  template<typename SizeType>\n  class SrRegisterUnion\n  {\n  public:\n    union\n    {\n      SizeType value;\n      BitFieldModel<SizeType, 0, 1> run;\n      BitFieldModel<SizeType, 8, 1> match;\n      BitFieldModel<SizeType, 9, 1> un;\n      BitFieldModel<SizeType, 10, 1> ov;\n      BitFieldModel<SizeType, 12, 1> rst;\n      BitFieldModel<SizeType, 14, 2> reload;\n    };\n  };\n\nprivate:\n  template<typename SizeType, std::uintptr_t Address>\n  class SrRegisterModel : public RegisterModel<SrRegisterUnion<SizeType>, Timer1AddressPolicy<Address>>\n  {\n  public:\n    using reg = SrRegisterUnion<SizeType>;\n\n  public:\n    using run = FieldModel<reg, Timer1AddressPolicy<Address>, 0, 1>;\n    using match = FieldModel<reg, Timer1AddressPolicy<Address>, 8, 1>;\n    using un = FieldModel<reg, Timer1AddressPolicy<Address>, 9, 1>;\n    using ov = FieldModel<reg, Timer1AddressPolicy<Address>, 10, 1>;\n    using rst = FieldModel<reg, Timer1AddressPolicy<Address>, 12, 1>;\n    using reload = FieldModel<reg, Timer1AddressPolicy<Address>, 14, 2>;\n  };\n\npublic:\n  using sr = SrRegisterModel<uint32_t, Timer1BaseAddress + 0x00000004>;\n\n/**\n * REGISTER INT\n */\nprivate:\n  template<typename SizeType>\n  class IntRegisterUnion\n  {\n  public:\n    union\n    {\n      SizeType value;\n      BitFieldModel<SizeType, 0, 1> en;\n      BitFieldModel<SizeType, 4, 3> mode;\n    };\n  };\n\nprivate:\n  template<typename SizeType, std::uintptr_t Address>\n  class IntRegisterModel : public RegisterModel<IntRegisterUnion<SizeType>, Timer1AddressPolicy<Address>>\n  {\n  public:\n    using reg = IntRegisterUnion<SizeType>;\n\n  public:\n    using en = FieldModel<reg, Timer1AddressPolicy<Address>, 0, 1>;\n    using mode = FieldModel<reg, Timer1AddressPolicy<Address>, 4, 3>;\n  };\n\npublic:\n  using int_ = IntRegisterModel<uint32_t, Timer1BaseAddress + 0x00000010>;\n\n/**\n * REGISTER COUNT\n */\nprivate:\n  template<typename SizeType>\n  class CountRegisterUnion\n  {\n  public:\n    union\n    {\n      SizeType value;\n    };\n  };\n\nprivate:\n  template<typename SizeType, std::uintptr_t Address>\n  class CountRegisterModel : public RegisterModel<CountRegisterUnion<SizeType>, Timer1AddressPolicy<Address>>\n  {\n  public:\n    using reg = CountRegisterUnion<SizeType>;\n\n  public:\n  };\n\npublic:\n  using count = CountRegisterModel<uint32_t, Timer1BaseAddress + 0x00000020>;\n\n/**\n * REGISTER MATCH\n */\nprivate:\n  template<typename SizeType>\n  class MatchRegisterUnion\n  {\n  public:\n    union\n    {\n      SizeType value;\n    };\n  };\n\nprivate:\n  template<typename SizeType, std::uintptr_t Address>\n  class MatchRegisterModel : public RegisterModel<MatchRegisterUnion<SizeType>, Timer1AddressPolicy<Address>>\n  {\n  public:\n    using reg = MatchRegisterUnion<SizeType>;\n\n  public:\n  };\n\npublic:\n  using match = MatchRegisterModel<uint32_t, Timer1BaseAddress + 0x00000024>;\n\n/**\n * REGISTER PRESCALE_RD\n */\nprivate:\n  template<typename SizeType>\n  class PrescaleRdRegisterUnion\n  {\n  public:\n    union\n    {\n      SizeType value;\n    };\n  };\n\nprivate:\n  template<typename SizeType, std::uintptr_t Address>\n  class PrescaleRdRegisterModel : public RegisterModel<PrescaleRdRegisterUnion<SizeType>, Timer1AddressPolicy<Address>>\n  {\n  public:\n    using reg = PrescaleRdRegisterUnion<SizeType>;\n\n  public:\n  };\n\npublic:\n  using prescaleRd = PrescaleRdRegisterModel<uint32_t, Timer1BaseAddress + 0x00000028>;\n\n/**\n * REGISTER PRESCALE_WR\n */\nprivate:\n  template<typename SizeType>\n  class PrescaleWrRegisterUnion\n  {\n  public:\n    union\n    {\n      SizeType value;\n    };\n  };\n\nprivate:\n  template<typename SizeType, std::uintptr_t Address>\n  class PrescaleWrRegisterModel : public RegisterModel<PrescaleWrRegisterUnion<SizeType>, Timer1AddressPolicy<Address>>\n  {\n  public:\n    using reg = PrescaleWrRegisterUnion<SizeType>;\n\n  public:\n  };\n\npublic:\n  using prescaleWr = PrescaleWrRegisterModel<uint32_t, Timer1BaseAddress + 0x00000028>;\n\n\n};\n\n}\n\n#endif /* DRAL_ARM_EXAMPLE_TIMER1_H */"
    },
    {
        "name": "TIMER2",
        "content": "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n *\n * MIT License\n *\n * Copyright (c) 2024 Gembcior\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not modify!\n */\n\n#ifndef DRAL_ARM_EXAMPLE_TIMER2_H\n#define DRAL_ARM_EXAMPLE_TIMER2_H\n\n#include \"dral/bitfield_model.h\"\n#include \"dral/group_address_policy.h\"\n#include \"dral/layer_offset_policy.h\"\n#include \"dral/register_model.h\"\n\nnamespace dral::arm_example {\n\nclass Timer2\n{\npublic:\n  static constexpr uintptr_t Timer2BaseAddress = 0x40010200;\n\nprivate:\n  template<std::uintptr_t Address>\n  using Timer2AddressPolicy = GroupAddressPolicy<Address>;\n\n/**\n * REGISTER CR\n */\nprivate:\n  template<typename SizeType>\n  class CrRegisterUnion\n  {\n  public:\n    union\n    {\n      SizeType value;\n      BitFieldModel<SizeType, 0, 1> en;\n      BitFieldModel<SizeType, 1, 1> rst;\n      BitFieldModel<SizeType, 2, 2> cnt;\n      BitFieldModel<SizeType, 4, 3> mode;\n      BitFieldModel<SizeType, 7, 1> psc;\n      BitFieldModel<SizeType, 8, 4> cntsrc;\n      BitFieldModel<SizeType, 12, 4> capsrc;\n      BitFieldModel<SizeType, 16, 2> capedge;\n      BitFieldModel<SizeType, 20, 2> trgext;\n      BitFieldModel<SizeType, 24, 2> reload;\n      BitFieldModel<SizeType, 26, 2> idr;\n      BitFieldModel<SizeType, 31, 1> s;\n    };\n  };\n\nprivate:\n  template<typename SizeType, std::uintptr_t Address>\n  class CrRegisterModel : public RegisterModel<CrRegisterUnion<SizeType>, Timer2AddressPolicy<Address>>\n  {\n  public:\n    using reg = CrRegisterUnion<SizeType>;\n\n  public:\n    using en = FieldModel<reg, Timer2AddressPolicy<Address>, 0, 1>;\n    using rst = FieldModel<reg, Timer2AddressPolicy<Address>, 1, 1>;\n    using cnt = FieldModel<reg, Timer2AddressPolicy<Address>, 2, 2>;\n    using mode = FieldModel<reg, Timer2AddressPolicy<Address>, 4, 3>;\n    using psc = FieldModel<reg, Timer2AddressPolicy<Address>, 7, 1>;\n    using cntsrc = FieldModel<reg, Timer2AddressPolicy<Address>, 8, 4>;\n    using capsrc = FieldModel<reg, Timer2AddressPolicy<Address>, 12, 4>;\n    using capedge = FieldModel<reg, Timer2AddressPolicy<Address>, 16, 2>;\n    using trgext = FieldModel<reg, Timer2AddressPolicy<Address>, 20, 2>;\n    using reload = FieldModel<reg, Timer2AddressPolicy<Address>, 24, 2>;\n    using idr = FieldModel<reg, Timer2AddressPolicy<Address>, 26, 2>;\n    using s = FieldModel<reg, Timer2AddressPolicy<Address>, 31, 1>;\n  };\n\npublic:\n  using cr = CrRegisterModel<uint32_t, Timer2BaseAddress + 0x00000000>;\n\n/**\n * REGISTER SR\n */\nprivate:\n  template<typename SizeType>\n  class SrRegisterUnion\n  {\n  public:\n    union\n    {\n      SizeType value;\n      BitFieldModel<SizeType, 0, 1> run;\n      BitFieldModel<SizeType, 8, 1> match;\n      BitFieldModel<SizeType, 9, 1> un;\n      BitFieldModel<SizeType, 10, 1> ov;\n      BitFieldModel<SizeType, 12, 1> rst;\n      BitFieldModel<SizeType, 14, 2> reload;\n    };\n  };\n\nprivate:\n  template<typename SizeType, std::uintptr_t Address>\n  class SrRegisterModel : public RegisterModel<SrRegisterUnion<SizeType>, Timer2AddressPolicy<Address>>\n  {\n  public:\n    using reg = SrRegisterUnion<SizeType>;\n\n  public:\n    using run = FieldModel<reg, Timer2AddressPolicy<Address>, 0, 1>;\n    using match = FieldModel<reg, Timer2AddressPolicy<Address>, 8, 1>;\n    using un = FieldModel<reg, Timer2AddressPolicy<Address>, 9, 1>;\n    using ov = FieldModel<reg, Timer2AddressPolicy<Address>, 10, 1>;\n    using rst = FieldModel<reg, Timer2AddressPolicy<Address>, 12, 1>;\n    using reload = FieldModel<reg, Timer2AddressPolicy<Address>, 14, 2>;\n  };\n\npublic:\n  using sr = SrRegisterModel<uint32_t, Timer2BaseAddress + 0x00000004>;\n\n/**\n * REGISTER INT\n */\nprivate:\n  template<typename SizeType>\n  class IntRegisterUnion\n  {\n  public:\n    union\n    {\n      SizeType value;\n      BitFieldModel<SizeType, 0, 1> en;\n      BitFieldModel<SizeType, 4, 3> mode;\n    };\n  };\n\nprivate:\n  template<typename SizeType, std::uintptr_t Address>\n  class IntRegisterModel : public RegisterModel<IntRegisterUnion<SizeType>, Timer2AddressPolicy<Address>>\n  {\n  public:\n    using reg = IntRegisterUnion<SizeType>;\n\n  public:\n    using en = FieldModel<reg, Timer2AddressPolicy<Address>, 0, 1>;\n    using mode = FieldModel<reg, Timer2AddressPolicy<Address>, 4, 3>;\n  };\n\npublic:\n  using int_ = IntRegisterModel<uint32_t, Timer2BaseAddress + 0x00000010>;\n\n/**\n * REGISTER COUNT\n */\nprivate:\n  template<typename SizeType>\n  class CountRegisterUnion\n  {\n  public:\n    union\n    {\n      SizeType value;\n    };\n  };\n\nprivate:\n  template<typename SizeType, std::uintptr_t Address>\n  class CountRegisterModel : public RegisterModel<CountRegisterUnion<SizeType>, Timer2AddressPolicy<Address>>\n  {\n  public:\n    using reg = CountRegisterUnion<SizeType>;\n\n  public:\n  };\n\npublic:\n  using count = CountRegisterModel<uint32_t, Timer2BaseAddress + 0x00000020>;\n\n/**\n * REGISTER MATCH\n */\nprivate:\n  template<typename SizeType>\n  class MatchRegisterUnion\n  {\n  public:\n    union\n    {\n      SizeType value;\n    };\n  };\n\nprivate:\n  template<typename SizeType, std::uintptr_t Address>\n  class MatchRegisterModel : public RegisterModel<MatchRegisterUnion<SizeType>, Timer2AddressPolicy<Address>>\n  {\n  public:\n    using reg = MatchRegisterUnion<SizeType>;\n\n  public:\n  };\n\npublic:\n  using match = MatchRegisterModel<uint32_t, Timer2BaseAddress + 0x00000024>;\n\n/**\n * REGISTER PRESCALE_RD\n */\nprivate:\n  template<typename SizeType>\n  class PrescaleRdRegisterUnion\n  {\n  public:\n    union\n    {\n      SizeType value;\n    };\n  };\n\nprivate:\n  template<typename SizeType, std::uintptr_t Address>\n  class PrescaleRdRegisterModel : public RegisterModel<PrescaleRdRegisterUnion<SizeType>, Timer2AddressPolicy<Address>>\n  {\n  public:\n    using reg = PrescaleRdRegisterUnion<SizeType>;\n\n  public:\n  };\n\npublic:\n  using prescaleRd = PrescaleRdRegisterModel<uint32_t, Timer2BaseAddress + 0x00000028>;\n\n/**\n * REGISTER PRESCALE_WR\n */\nprivate:\n  template<typename SizeType>\n  class PrescaleWrRegisterUnion\n  {\n  public:\n    union\n    {\n      SizeType value;\n    };\n  };\n\nprivate:\n  template<typename SizeType, std::uintptr_t Address>\n  class PrescaleWrRegisterModel : public RegisterModel<PrescaleWrRegisterUnion<SizeType>, Timer2AddressPolicy<Address>>\n  {\n  public:\n    using reg = PrescaleWrRegisterUnion<SizeType>;\n\n  public:\n  };\n\npublic:\n  using prescaleWr = PrescaleWrRegisterModel<uint32_t, Timer2BaseAddress + 0x00000028>;\n\n\n};\n\n}\n\n#endif /* DRAL_ARM_EXAMPLE_TIMER2_H */"
    }
]