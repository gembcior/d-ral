- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_DCMI_H\n#define DRAL_STM32F446_DCMI_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass dcmi\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x50050000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class CrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using capture = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    using cm = FieldModel<uint32_t, address, 1, 1>;\n    using crop\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    using jpeg = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using ess = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ pckpol = FieldModel<uint32_t, address, 5, 1>;\n    using hspol = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using vspol = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using edm = FieldModel<uint32_t, address, 10, 2>;\n    using enable = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using bsm = FieldModel<uint32_t, address, 16, 2>;\n  \
    \  using oebs = FieldModel<uint32_t, address, 18, 1>;\n    using lsm = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using oels = FieldModel<uint32_t, address, 20, 1>;\n \
    \   using fcrc = FieldModel<uint32_t, address, 8, 2>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> capture;\n\
    \      BitFieldModel<uint32_t, 1, 1> cm;\n      BitFieldModel<uint32_t, 2, 1>\
    \ crop;\n      BitFieldModel<uint32_t, 3, 1> jpeg;\n      BitFieldModel<uint32_t,\
    \ 4, 1> ess;\n      BitFieldModel<uint32_t, 5, 1> pckpol;\n      BitFieldModel<uint32_t,\
    \ 6, 1> hspol;\n      BitFieldModel<uint32_t, 7, 1> vspol;\n      BitFieldModel<uint32_t,\
    \ 10, 2> edm;\n      BitFieldModel<uint32_t, 14, 1> enable;\n      BitFieldModel<uint32_t,\
    \ 16, 2> bsm;\n      BitFieldModel<uint32_t, 18, 1> oebs;\n      BitFieldModel<uint32_t,\
    \ 19, 1> lsm;\n      BitFieldModel<uint32_t, 20, 1> oels;\n      BitFieldModel<uint32_t,\
    \ 8, 2> fcrc;\n    };\n  };\n\npublic:\n  using cr = CrReg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using fne = FieldModel<uint32_t, address, 2, 1>;\n\
    \    using vsync = FieldModel<uint32_t, address, 1, 1>;\n    using hsync = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 2, 1> fne;\n      BitFieldModel<uint32_t, 1, 1>\
    \ vsync;\n      BitFieldModel<uint32_t, 0, 1> hsync;\n    };\n  };\n\npublic:\n\
    \  using sr = SrReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class RisReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using line_ris = FieldModel<uint32_t, address, 4, 1>;\n    using vsync_ris\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using err_ris = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using ovr_ris = FieldModel<uint32_t, address, 1, 1>;\n\
    \    using frame_ris = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n   \
    \ union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 4, 1>\
    \ line_ris;\n      BitFieldModel<uint32_t, 3, 1> vsync_ris;\n      BitFieldModel<uint32_t,\
    \ 2, 1> err_ris;\n      BitFieldModel<uint32_t, 1, 1> ovr_ris;\n      BitFieldModel<uint32_t,\
    \ 0, 1> frame_ris;\n    };\n  };\n\npublic:\n  using ris = RisReg<BaseAddress\
    \ + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class IerReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using line_ie = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using vsync_ie = FieldModel<uint32_t, address, 3, 1>;\n\
    \    using err_ie = FieldModel<uint32_t, address, 2, 1>;\n    using ovr_ie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using frame_ie = FieldModel<uint32_t, address, 0, 1>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 4, 1> line_ie;\n      BitFieldModel<uint32_t, 3, 1> vsync_ie;\n      BitFieldModel<uint32_t,\
    \ 2, 1> err_ie;\n      BitFieldModel<uint32_t, 1, 1> ovr_ie;\n      BitFieldModel<uint32_t,\
    \ 0, 1> frame_ie;\n    };\n  };\n\npublic:\n  using ier = IerReg<BaseAddress +\
    \ 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class MisReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using line_mis = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using vsync_mis = FieldModel<uint32_t, address, 3, 1>;\n\
    \    using err_mis = FieldModel<uint32_t, address, 2, 1>;\n    using ovr_mis =\
    \ FieldModel<uint32_t, address, 1, 1>;\n    using frame_mis = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 4, 1> line_mis;\n      BitFieldModel<uint32_t,\
    \ 3, 1> vsync_mis;\n      BitFieldModel<uint32_t, 2, 1> err_mis;\n      BitFieldModel<uint32_t,\
    \ 1, 1> ovr_mis;\n      BitFieldModel<uint32_t, 0, 1> frame_mis;\n    };\n  };\n\
    \npublic:\n  using mis = MisReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class IcrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using line_isc = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ vsync_isc = FieldModel<uint32_t, address, 3, 1>;\n    using err_isc = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using ovr_isc = FieldModel<uint32_t, address, 1, 1>;\n\
    \    using frame_isc = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n   \
    \ union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 4, 1>\
    \ line_isc;\n      BitFieldModel<uint32_t, 3, 1> vsync_isc;\n      BitFieldModel<uint32_t,\
    \ 2, 1> err_isc;\n      BitFieldModel<uint32_t, 1, 1> ovr_isc;\n      BitFieldModel<uint32_t,\
    \ 0, 1> frame_isc;\n    };\n  };\n\npublic:\n  using icr = IcrReg<BaseAddress\
    \ + 0x0014>;\n\nprivate:\n  template<unsigned int address>\n  class EscrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using fec = FieldModel<uint32_t,\
    \ address, 24, 8>;\n    using lec = FieldModel<uint32_t, address, 16, 8>;\n  \
    \  using lsc = FieldModel<uint32_t, address, 8, 8>;\n    using fsc = FieldModel<uint32_t,\
    \ address, 0, 8>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 24, 8> fec;\n      BitFieldModel<uint32_t, 16,\
    \ 8> lec;\n      BitFieldModel<uint32_t, 8, 8> lsc;\n      BitFieldModel<uint32_t,\
    \ 0, 8> fsc;\n    };\n  };\n\npublic:\n  using escr = EscrReg<BaseAddress + 0x0018>;\n\
    \nprivate:\n  template<unsigned int address>\n  class EsurReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using feu = FieldModel<uint32_t, address, 24,\
    \ 8>;\n    using leu = FieldModel<uint32_t, address, 16, 8>;\n    using lsu =\
    \ FieldModel<uint32_t, address, 8, 8>;\n    using fsu = FieldModel<uint32_t, address,\
    \ 0, 8>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> feu;\n      BitFieldModel<uint32_t, 16, 8> leu;\n      BitFieldModel<uint32_t,\
    \ 8, 8> lsu;\n      BitFieldModel<uint32_t, 0, 8> fsu;\n    };\n  };\n\npublic:\n\
    \  using esur = EsurReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CwstrtReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using vst = FieldModel<uint32_t, address, 16, 13>;\n    using\
    \ hoffcnt = FieldModel<uint32_t, address, 0, 14>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16, 13> vst;\n  \
    \    BitFieldModel<uint32_t, 0, 14> hoffcnt;\n    };\n  };\n\npublic:\n  using\
    \ cwstrt = CwstrtReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class CwsizeReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using vline = FieldModel<uint32_t, address, 16, 14>;\n    using\
    \ capcnt = FieldModel<uint32_t, address, 0, 14>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16, 14> vline;\n\
    \      BitFieldModel<uint32_t, 0, 14> capcnt;\n    };\n  };\n\npublic:\n  using\
    \ cwsize = CwsizeReg<BaseAddress + 0x0024>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class DrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using byte3 = FieldModel<uint32_t, address, 24, 8>;\n    using byte2 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using byte1 = FieldModel<uint32_t, address, 8, 8>;\n \
    \   using byte0 = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 24, 8> byte3;\n\
    \      BitFieldModel<uint32_t, 16, 8> byte2;\n      BitFieldModel<uint32_t, 8,\
    \ 8> byte1;\n      BitFieldModel<uint32_t, 0, 8> byte0;\n    };\n  };\n\npublic:\n\
    \  using dr = DrReg<BaseAddress + 0x0028>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_DCMI_H\
    \ */\n"
  name: DCMI
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_FMC_H\n#define DRAL_STM32F446_FMC_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass fmc\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0xA0000000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Bcr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cclken = FieldModel<uint32_t, address, 20,\
    \ 1>;\n    using cburstrw = FieldModel<uint32_t, address, 19, 1>;\n    using asyncwait\
    \ = FieldModel<uint32_t, address, 15, 1>;\n    using extmod = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using waiten = FieldModel<uint32_t, address, 13, 1>;\n\
    \    using wren = FieldModel<uint32_t, address, 12, 1>;\n    using waitcfg = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using waitpol = FieldModel<uint32_t, address, 9, 1>;\n\
    \    using bursten = FieldModel<uint32_t, address, 8, 1>;\n    using faccen =\
    \ FieldModel<uint32_t, address, 6, 1>;\n    using mwid = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    using mtyp = FieldModel<uint32_t, address, 2, 2>;\n   \
    \ using muxen = FieldModel<uint32_t, address, 1, 1>;\n    using mbken = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 20, 1> cclken;\n      BitFieldModel<uint32_t, 19,\
    \ 1> cburstrw;\n      BitFieldModel<uint32_t, 15, 1> asyncwait;\n      BitFieldModel<uint32_t,\
    \ 14, 1> extmod;\n      BitFieldModel<uint32_t, 13, 1> waiten;\n      BitFieldModel<uint32_t,\
    \ 12, 1> wren;\n      BitFieldModel<uint32_t, 11, 1> waitcfg;\n      BitFieldModel<uint32_t,\
    \ 9, 1> waitpol;\n      BitFieldModel<uint32_t, 8, 1> bursten;\n      BitFieldModel<uint32_t,\
    \ 6, 1> faccen;\n      BitFieldModel<uint32_t, 4, 2> mwid;\n      BitFieldModel<uint32_t,\
    \ 2, 2> mtyp;\n      BitFieldModel<uint32_t, 1, 1> muxen;\n      BitFieldModel<uint32_t,\
    \ 0, 1> mbken;\n    };\n  };\n\npublic:\n  using bcr1 = Bcr1Reg<BaseAddress +\
    \ 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class Btr1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using accmod = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    using datlat = FieldModel<uint32_t, address, 24, 4>;\n\
    \    using clkdiv = FieldModel<uint32_t, address, 20, 4>;\n    using busturn =\
    \ FieldModel<uint32_t, address, 16, 4>;\n    using datast = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using addhld = FieldModel<uint32_t, address, 4, 4>;\n \
    \   using addset = FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 28, 2> accmod;\n\
    \      BitFieldModel<uint32_t, 24, 4> datlat;\n      BitFieldModel<uint32_t, 20,\
    \ 4> clkdiv;\n      BitFieldModel<uint32_t, 16, 4> busturn;\n      BitFieldModel<uint32_t,\
    \ 8, 8> datast;\n      BitFieldModel<uint32_t, 4, 4> addhld;\n      BitFieldModel<uint32_t,\
    \ 0, 4> addset;\n    };\n  };\n\npublic:\n  using btr1 = Btr1Reg<BaseAddress +\
    \ 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class Bcr2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using cburstrw = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using asyncwait = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using extmod = FieldModel<uint32_t, address, 14, 1>;\n    using waiten =\
    \ FieldModel<uint32_t, address, 13, 1>;\n    using wren = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using waitcfg = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using wrapmod = FieldModel<uint32_t, address, 10, 1>;\n    using waitpol\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    using bursten = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using faccen = FieldModel<uint32_t, address, 6, 1>;\n \
    \   using mwid = FieldModel<uint32_t, address, 4, 2>;\n    using mtyp = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    using muxen = FieldModel<uint32_t, address, 1, 1>;\n  \
    \  using mbken = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 19, 1> cburstrw;\n\
    \      BitFieldModel<uint32_t, 15, 1> asyncwait;\n      BitFieldModel<uint32_t,\
    \ 14, 1> extmod;\n      BitFieldModel<uint32_t, 13, 1> waiten;\n      BitFieldModel<uint32_t,\
    \ 12, 1> wren;\n      BitFieldModel<uint32_t, 11, 1> waitcfg;\n      BitFieldModel<uint32_t,\
    \ 10, 1> wrapmod;\n      BitFieldModel<uint32_t, 9, 1> waitpol;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bursten;\n      BitFieldModel<uint32_t, 6, 1> faccen;\n      BitFieldModel<uint32_t,\
    \ 4, 2> mwid;\n      BitFieldModel<uint32_t, 2, 2> mtyp;\n      BitFieldModel<uint32_t,\
    \ 1, 1> muxen;\n      BitFieldModel<uint32_t, 0, 1> mbken;\n    };\n  };\n\npublic:\n\
    \  using bcr2 = Bcr2Reg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Btr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using accmod = FieldModel<uint32_t, address, 28, 2>;\n    using\
    \ datlat = FieldModel<uint32_t, address, 24, 4>;\n    using clkdiv = FieldModel<uint32_t,\
    \ address, 20, 4>;\n    using busturn = FieldModel<uint32_t, address, 16, 4>;\n\
    \    using datast = FieldModel<uint32_t, address, 8, 8>;\n    using addhld = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using addset = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 28, 2> accmod;\n      BitFieldModel<uint32_t, 24, 4> datlat;\n      BitFieldModel<uint32_t,\
    \ 20, 4> clkdiv;\n      BitFieldModel<uint32_t, 16, 4> busturn;\n      BitFieldModel<uint32_t,\
    \ 8, 8> datast;\n      BitFieldModel<uint32_t, 4, 4> addhld;\n      BitFieldModel<uint32_t,\
    \ 0, 4> addset;\n    };\n  };\n\npublic:\n  using btr2 = Btr2Reg<BaseAddress +\
    \ 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class Bcr3Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using cburstrw = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using asyncwait = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using extmod = FieldModel<uint32_t, address, 14, 1>;\n    using waiten =\
    \ FieldModel<uint32_t, address, 13, 1>;\n    using wren = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using waitcfg = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using wrapmod = FieldModel<uint32_t, address, 10, 1>;\n    using waitpol\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    using bursten = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using faccen = FieldModel<uint32_t, address, 6, 1>;\n \
    \   using mwid = FieldModel<uint32_t, address, 4, 2>;\n    using mtyp = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    using muxen = FieldModel<uint32_t, address, 1, 1>;\n  \
    \  using mbken = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 19, 1> cburstrw;\n\
    \      BitFieldModel<uint32_t, 15, 1> asyncwait;\n      BitFieldModel<uint32_t,\
    \ 14, 1> extmod;\n      BitFieldModel<uint32_t, 13, 1> waiten;\n      BitFieldModel<uint32_t,\
    \ 12, 1> wren;\n      BitFieldModel<uint32_t, 11, 1> waitcfg;\n      BitFieldModel<uint32_t,\
    \ 10, 1> wrapmod;\n      BitFieldModel<uint32_t, 9, 1> waitpol;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bursten;\n      BitFieldModel<uint32_t, 6, 1> faccen;\n      BitFieldModel<uint32_t,\
    \ 4, 2> mwid;\n      BitFieldModel<uint32_t, 2, 2> mtyp;\n      BitFieldModel<uint32_t,\
    \ 1, 1> muxen;\n      BitFieldModel<uint32_t, 0, 1> mbken;\n    };\n  };\n\npublic:\n\
    \  using bcr3 = Bcr3Reg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Btr3Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using accmod = FieldModel<uint32_t, address, 28, 2>;\n    using\
    \ datlat = FieldModel<uint32_t, address, 24, 4>;\n    using clkdiv = FieldModel<uint32_t,\
    \ address, 20, 4>;\n    using busturn = FieldModel<uint32_t, address, 16, 4>;\n\
    \    using datast = FieldModel<uint32_t, address, 8, 8>;\n    using addhld = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using addset = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 28, 2> accmod;\n      BitFieldModel<uint32_t, 24, 4> datlat;\n      BitFieldModel<uint32_t,\
    \ 20, 4> clkdiv;\n      BitFieldModel<uint32_t, 16, 4> busturn;\n      BitFieldModel<uint32_t,\
    \ 8, 8> datast;\n      BitFieldModel<uint32_t, 4, 4> addhld;\n      BitFieldModel<uint32_t,\
    \ 0, 4> addset;\n    };\n  };\n\npublic:\n  using btr3 = Btr3Reg<BaseAddress +\
    \ 0x0014>;\n\nprivate:\n  template<unsigned int address>\n  class Bcr4Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using cburstrw = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using asyncwait = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using extmod = FieldModel<uint32_t, address, 14, 1>;\n    using waiten =\
    \ FieldModel<uint32_t, address, 13, 1>;\n    using wren = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using waitcfg = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using wrapmod = FieldModel<uint32_t, address, 10, 1>;\n    using waitpol\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    using bursten = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using faccen = FieldModel<uint32_t, address, 6, 1>;\n \
    \   using mwid = FieldModel<uint32_t, address, 4, 2>;\n    using mtyp = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    using muxen = FieldModel<uint32_t, address, 1, 1>;\n  \
    \  using mbken = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 19, 1> cburstrw;\n\
    \      BitFieldModel<uint32_t, 15, 1> asyncwait;\n      BitFieldModel<uint32_t,\
    \ 14, 1> extmod;\n      BitFieldModel<uint32_t, 13, 1> waiten;\n      BitFieldModel<uint32_t,\
    \ 12, 1> wren;\n      BitFieldModel<uint32_t, 11, 1> waitcfg;\n      BitFieldModel<uint32_t,\
    \ 10, 1> wrapmod;\n      BitFieldModel<uint32_t, 9, 1> waitpol;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bursten;\n      BitFieldModel<uint32_t, 6, 1> faccen;\n      BitFieldModel<uint32_t,\
    \ 4, 2> mwid;\n      BitFieldModel<uint32_t, 2, 2> mtyp;\n      BitFieldModel<uint32_t,\
    \ 1, 1> muxen;\n      BitFieldModel<uint32_t, 0, 1> mbken;\n    };\n  };\n\npublic:\n\
    \  using bcr4 = Bcr4Reg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Btr4Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using accmod = FieldModel<uint32_t, address, 28, 2>;\n    using\
    \ datlat = FieldModel<uint32_t, address, 24, 4>;\n    using clkdiv = FieldModel<uint32_t,\
    \ address, 20, 4>;\n    using busturn = FieldModel<uint32_t, address, 16, 4>;\n\
    \    using datast = FieldModel<uint32_t, address, 8, 8>;\n    using addhld = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using addset = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 28, 2> accmod;\n      BitFieldModel<uint32_t, 24, 4> datlat;\n      BitFieldModel<uint32_t,\
    \ 20, 4> clkdiv;\n      BitFieldModel<uint32_t, 16, 4> busturn;\n      BitFieldModel<uint32_t,\
    \ 8, 8> datast;\n      BitFieldModel<uint32_t, 4, 4> addhld;\n      BitFieldModel<uint32_t,\
    \ 0, 4> addset;\n    };\n  };\n\npublic:\n  using btr4 = Btr4Reg<BaseAddress +\
    \ 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class Pcr2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using eccps = FieldModel<uint32_t,\
    \ address, 17, 3>;\n    using tar = FieldModel<uint32_t, address, 13, 4>;\n  \
    \  using tclr = FieldModel<uint32_t, address, 9, 4>;\n    using eccen = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using pwid = FieldModel<uint32_t, address, 4, 2>;\n   \
    \ using ptyp = FieldModel<uint32_t, address, 3, 1>;\n    using pbken = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using pwaiten = FieldModel<uint32_t, address, 1, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 17, 3> eccps;\n      BitFieldModel<uint32_t, 13, 4> tar;\n      BitFieldModel<uint32_t,\
    \ 9, 4> tclr;\n      BitFieldModel<uint32_t, 6, 1> eccen;\n      BitFieldModel<uint32_t,\
    \ 4, 2> pwid;\n      BitFieldModel<uint32_t, 3, 1> ptyp;\n      BitFieldModel<uint32_t,\
    \ 2, 1> pbken;\n      BitFieldModel<uint32_t, 1, 1> pwaiten;\n    };\n  };\n\n\
    public:\n  using pcr2 = Pcr2Reg<BaseAddress + 0x0060>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Sr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fempt = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ ifen = FieldModel<uint32_t, address, 5, 1>;\n    using ilen = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using iren = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using ifs = FieldModel<uint32_t, address, 2, 1>;\n    using ils = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using irs = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 6,\
    \ 1> fempt;\n      BitFieldModel<uint32_t, 5, 1> ifen;\n      BitFieldModel<uint32_t,\
    \ 4, 1> ilen;\n      BitFieldModel<uint32_t, 3, 1> iren;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ifs;\n      BitFieldModel<uint32_t, 1, 1> ils;\n      BitFieldModel<uint32_t,\
    \ 0, 1> irs;\n    };\n  };\n\npublic:\n  using sr2 = Sr2Reg<BaseAddress + 0x0064>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Pmem2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using memhizx = FieldModel<uint32_t, address,\
    \ 24, 8>;\n    using memholdx = FieldModel<uint32_t, address, 16, 8>;\n    using\
    \ memwaitx = FieldModel<uint32_t, address, 8, 8>;\n    using memsetx = FieldModel<uint32_t,\
    \ address, 0, 8>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 24, 8> memhizx;\n      BitFieldModel<uint32_t,\
    \ 16, 8> memholdx;\n      BitFieldModel<uint32_t, 8, 8> memwaitx;\n      BitFieldModel<uint32_t,\
    \ 0, 8> memsetx;\n    };\n  };\n\npublic:\n  using pmem2 = Pmem2Reg<BaseAddress\
    \ + 0x0068>;\n\nprivate:\n  template<unsigned int address>\n  class Patt2Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using atthizx =\
    \ FieldModel<uint32_t, address, 24, 8>;\n    using attholdx = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using attwaitx = FieldModel<uint32_t, address, 8, 8>;\n\
    \    using attsetx = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 24, 8> atthizx;\n\
    \      BitFieldModel<uint32_t, 16, 8> attholdx;\n      BitFieldModel<uint32_t,\
    \ 8, 8> attwaitx;\n      BitFieldModel<uint32_t, 0, 8> attsetx;\n    };\n  };\n\
    \npublic:\n  using patt2 = Patt2Reg<BaseAddress + 0x006C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Eccr2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using eccx = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 32> eccx;\n    };\n  };\n\npublic:\n  using eccr2 = Eccr2Reg<BaseAddress + 0x0074>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Pcr3Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using eccps = FieldModel<uint32_t, address, 17,\
    \ 3>;\n    using tar = FieldModel<uint32_t, address, 13, 4>;\n    using tclr =\
    \ FieldModel<uint32_t, address, 9, 4>;\n    using eccen = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using pwid = FieldModel<uint32_t, address, 4, 2>;\n   \
    \ using ptyp = FieldModel<uint32_t, address, 3, 1>;\n    using pbken = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using pwaiten = FieldModel<uint32_t, address, 1, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 17, 3> eccps;\n      BitFieldModel<uint32_t, 13, 4> tar;\n      BitFieldModel<uint32_t,\
    \ 9, 4> tclr;\n      BitFieldModel<uint32_t, 6, 1> eccen;\n      BitFieldModel<uint32_t,\
    \ 4, 2> pwid;\n      BitFieldModel<uint32_t, 3, 1> ptyp;\n      BitFieldModel<uint32_t,\
    \ 2, 1> pbken;\n      BitFieldModel<uint32_t, 1, 1> pwaiten;\n    };\n  };\n\n\
    public:\n  using pcr3 = Pcr3Reg<BaseAddress + 0x0080>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Sr3Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fempt = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ ifen = FieldModel<uint32_t, address, 5, 1>;\n    using ilen = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using iren = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using ifs = FieldModel<uint32_t, address, 2, 1>;\n    using ils = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using irs = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 6,\
    \ 1> fempt;\n      BitFieldModel<uint32_t, 5, 1> ifen;\n      BitFieldModel<uint32_t,\
    \ 4, 1> ilen;\n      BitFieldModel<uint32_t, 3, 1> iren;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ifs;\n      BitFieldModel<uint32_t, 1, 1> ils;\n      BitFieldModel<uint32_t,\
    \ 0, 1> irs;\n    };\n  };\n\npublic:\n  using sr3 = Sr3Reg<BaseAddress + 0x0084>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Pmem3Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using memhizx = FieldModel<uint32_t, address,\
    \ 24, 8>;\n    using memholdx = FieldModel<uint32_t, address, 16, 8>;\n    using\
    \ memwaitx = FieldModel<uint32_t, address, 8, 8>;\n    using memsetx = FieldModel<uint32_t,\
    \ address, 0, 8>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 24, 8> memhizx;\n      BitFieldModel<uint32_t,\
    \ 16, 8> memholdx;\n      BitFieldModel<uint32_t, 8, 8> memwaitx;\n      BitFieldModel<uint32_t,\
    \ 0, 8> memsetx;\n    };\n  };\n\npublic:\n  using pmem3 = Pmem3Reg<BaseAddress\
    \ + 0x0088>;\n\nprivate:\n  template<unsigned int address>\n  class Patt3Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using atthizx =\
    \ FieldModel<uint32_t, address, 24, 8>;\n    using attholdx = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using attwaitx = FieldModel<uint32_t, address, 8, 8>;\n\
    \    using attsetx = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 24, 8> atthizx;\n\
    \      BitFieldModel<uint32_t, 16, 8> attholdx;\n      BitFieldModel<uint32_t,\
    \ 8, 8> attwaitx;\n      BitFieldModel<uint32_t, 0, 8> attsetx;\n    };\n  };\n\
    \npublic:\n  using patt3 = Patt3Reg<BaseAddress + 0x008C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Eccr3Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using eccx = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 32> eccx;\n    };\n  };\n\npublic:\n  using eccr3 = Eccr3Reg<BaseAddress + 0x0094>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Pcr4Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using eccps = FieldModel<uint32_t, address, 17,\
    \ 3>;\n    using tar = FieldModel<uint32_t, address, 13, 4>;\n    using tclr =\
    \ FieldModel<uint32_t, address, 9, 4>;\n    using eccen = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using pwid = FieldModel<uint32_t, address, 4, 2>;\n   \
    \ using ptyp = FieldModel<uint32_t, address, 3, 1>;\n    using pbken = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using pwaiten = FieldModel<uint32_t, address, 1, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 17, 3> eccps;\n      BitFieldModel<uint32_t, 13, 4> tar;\n      BitFieldModel<uint32_t,\
    \ 9, 4> tclr;\n      BitFieldModel<uint32_t, 6, 1> eccen;\n      BitFieldModel<uint32_t,\
    \ 4, 2> pwid;\n      BitFieldModel<uint32_t, 3, 1> ptyp;\n      BitFieldModel<uint32_t,\
    \ 2, 1> pbken;\n      BitFieldModel<uint32_t, 1, 1> pwaiten;\n    };\n  };\n\n\
    public:\n  using pcr4 = Pcr4Reg<BaseAddress + 0x00A0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Sr4Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fempt = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ ifen = FieldModel<uint32_t, address, 5, 1>;\n    using ilen = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using iren = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using ifs = FieldModel<uint32_t, address, 2, 1>;\n    using ils = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using irs = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 6,\
    \ 1> fempt;\n      BitFieldModel<uint32_t, 5, 1> ifen;\n      BitFieldModel<uint32_t,\
    \ 4, 1> ilen;\n      BitFieldModel<uint32_t, 3, 1> iren;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ifs;\n      BitFieldModel<uint32_t, 1, 1> ils;\n      BitFieldModel<uint32_t,\
    \ 0, 1> irs;\n    };\n  };\n\npublic:\n  using sr4 = Sr4Reg<BaseAddress + 0x00A4>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Pmem4Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using memhizx = FieldModel<uint32_t, address,\
    \ 24, 8>;\n    using memholdx = FieldModel<uint32_t, address, 16, 8>;\n    using\
    \ memwaitx = FieldModel<uint32_t, address, 8, 8>;\n    using memsetx = FieldModel<uint32_t,\
    \ address, 0, 8>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 24, 8> memhizx;\n      BitFieldModel<uint32_t,\
    \ 16, 8> memholdx;\n      BitFieldModel<uint32_t, 8, 8> memwaitx;\n      BitFieldModel<uint32_t,\
    \ 0, 8> memsetx;\n    };\n  };\n\npublic:\n  using pmem4 = Pmem4Reg<BaseAddress\
    \ + 0x00A8>;\n\nprivate:\n  template<unsigned int address>\n  class Patt4Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using atthizx =\
    \ FieldModel<uint32_t, address, 24, 8>;\n    using attholdx = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using attwaitx = FieldModel<uint32_t, address, 8, 8>;\n\
    \    using attsetx = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 24, 8> atthizx;\n\
    \      BitFieldModel<uint32_t, 16, 8> attholdx;\n      BitFieldModel<uint32_t,\
    \ 8, 8> attwaitx;\n      BitFieldModel<uint32_t, 0, 8> attsetx;\n    };\n  };\n\
    \npublic:\n  using patt4 = Patt4Reg<BaseAddress + 0x00AC>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Pio4Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using iohizx = FieldModel<uint32_t, address, 24, 8>;\n    using\
    \ ioholdx = FieldModel<uint32_t, address, 16, 8>;\n    using iowaitx = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using iosetx = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> iohizx;\n      BitFieldModel<uint32_t, 16, 8> ioholdx;\n      BitFieldModel<uint32_t,\
    \ 8, 8> iowaitx;\n      BitFieldModel<uint32_t, 0, 8> iosetx;\n    };\n  };\n\n\
    public:\n  using pio4 = Pio4Reg<BaseAddress + 0x00B0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Bwtr1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using accmod = FieldModel<uint32_t, address, 28, 2>;\n   \
    \ using datlat = FieldModel<uint32_t, address, 24, 4>;\n    using clkdiv = FieldModel<uint32_t,\
    \ address, 20, 4>;\n    using datast = FieldModel<uint32_t, address, 8, 8>;\n\
    \    using addhld = FieldModel<uint32_t, address, 4, 4>;\n    using addset = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 28, 2> accmod;\n      BitFieldModel<uint32_t, 24,\
    \ 4> datlat;\n      BitFieldModel<uint32_t, 20, 4> clkdiv;\n      BitFieldModel<uint32_t,\
    \ 8, 8> datast;\n      BitFieldModel<uint32_t, 4, 4> addhld;\n      BitFieldModel<uint32_t,\
    \ 0, 4> addset;\n    };\n  };\n\npublic:\n  using bwtr1 = Bwtr1Reg<BaseAddress\
    \ + 0x0104>;\n\nprivate:\n  template<unsigned int address>\n  class Bwtr2Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using accmod =\
    \ FieldModel<uint32_t, address, 28, 2>;\n    using datlat = FieldModel<uint32_t,\
    \ address, 24, 4>;\n    using clkdiv = FieldModel<uint32_t, address, 20, 4>;\n\
    \    using datast = FieldModel<uint32_t, address, 8, 8>;\n    using addhld = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using addset = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 28, 2> accmod;\n      BitFieldModel<uint32_t, 24, 4> datlat;\n      BitFieldModel<uint32_t,\
    \ 20, 4> clkdiv;\n      BitFieldModel<uint32_t, 8, 8> datast;\n      BitFieldModel<uint32_t,\
    \ 4, 4> addhld;\n      BitFieldModel<uint32_t, 0, 4> addset;\n    };\n  };\n\n\
    public:\n  using bwtr2 = Bwtr2Reg<BaseAddress + 0x010C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Bwtr3Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using accmod = FieldModel<uint32_t, address, 28, 2>;\n   \
    \ using datlat = FieldModel<uint32_t, address, 24, 4>;\n    using clkdiv = FieldModel<uint32_t,\
    \ address, 20, 4>;\n    using datast = FieldModel<uint32_t, address, 8, 8>;\n\
    \    using addhld = FieldModel<uint32_t, address, 4, 4>;\n    using addset = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 28, 2> accmod;\n      BitFieldModel<uint32_t, 24,\
    \ 4> datlat;\n      BitFieldModel<uint32_t, 20, 4> clkdiv;\n      BitFieldModel<uint32_t,\
    \ 8, 8> datast;\n      BitFieldModel<uint32_t, 4, 4> addhld;\n      BitFieldModel<uint32_t,\
    \ 0, 4> addset;\n    };\n  };\n\npublic:\n  using bwtr3 = Bwtr3Reg<BaseAddress\
    \ + 0x0114>;\n\nprivate:\n  template<unsigned int address>\n  class Bwtr4Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using accmod =\
    \ FieldModel<uint32_t, address, 28, 2>;\n    using datlat = FieldModel<uint32_t,\
    \ address, 24, 4>;\n    using clkdiv = FieldModel<uint32_t, address, 20, 4>;\n\
    \    using datast = FieldModel<uint32_t, address, 8, 8>;\n    using addhld = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using addset = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 28, 2> accmod;\n      BitFieldModel<uint32_t, 24, 4> datlat;\n      BitFieldModel<uint32_t,\
    \ 20, 4> clkdiv;\n      BitFieldModel<uint32_t, 8, 8> datast;\n      BitFieldModel<uint32_t,\
    \ 4, 4> addhld;\n      BitFieldModel<uint32_t, 0, 4> addset;\n    };\n  };\n\n\
    public:\n  using bwtr4 = Bwtr4Reg<BaseAddress + 0x011C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Sdcr1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using nc = FieldModel<uint32_t, address, 0, 2>;\n    using\
    \ nr = FieldModel<uint32_t, address, 2, 2>;\n    using mwid = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    using nb = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ cas = FieldModel<uint32_t, address, 7, 2>;\n    using wp = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using sdclk = FieldModel<uint32_t, address, 10, 2>;\n \
    \   using rburst = FieldModel<uint32_t, address, 12, 1>;\n    using rpipe = FieldModel<uint32_t,\
    \ address, 13, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 2> nc;\n      BitFieldModel<uint32_t, 2, 2>\
    \ nr;\n      BitFieldModel<uint32_t, 4, 2> mwid;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nb;\n      BitFieldModel<uint32_t, 7, 2> cas;\n      BitFieldModel<uint32_t,\
    \ 9, 1> wp;\n      BitFieldModel<uint32_t, 10, 2> sdclk;\n      BitFieldModel<uint32_t,\
    \ 12, 1> rburst;\n      BitFieldModel<uint32_t, 13, 2> rpipe;\n    };\n  };\n\n\
    public:\n  using sdcr1 = Sdcr1Reg<BaseAddress + 0x0140>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Sdcr2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using nc = FieldModel<uint32_t, address, 0, 2>;\n    using\
    \ nr = FieldModel<uint32_t, address, 2, 2>;\n    using mwid = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    using nb = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ cas = FieldModel<uint32_t, address, 7, 2>;\n    using wp = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using sdclk = FieldModel<uint32_t, address, 10, 2>;\n \
    \   using rburst = FieldModel<uint32_t, address, 12, 1>;\n    using rpipe = FieldModel<uint32_t,\
    \ address, 13, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 2> nc;\n      BitFieldModel<uint32_t, 2, 2>\
    \ nr;\n      BitFieldModel<uint32_t, 4, 2> mwid;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nb;\n      BitFieldModel<uint32_t, 7, 2> cas;\n      BitFieldModel<uint32_t,\
    \ 9, 1> wp;\n      BitFieldModel<uint32_t, 10, 2> sdclk;\n      BitFieldModel<uint32_t,\
    \ 12, 1> rburst;\n      BitFieldModel<uint32_t, 13, 2> rpipe;\n    };\n  };\n\n\
    public:\n  using sdcr2 = Sdcr2Reg<BaseAddress + 0x0144>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Sdtr1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using tmrd = FieldModel<uint32_t, address, 0, 4>;\n    using\
    \ txsr = FieldModel<uint32_t, address, 4, 4>;\n    using tras = FieldModel<uint32_t,\
    \ address, 8, 4>;\n    using trc = FieldModel<uint32_t, address, 12, 4>;\n   \
    \ using twr = FieldModel<uint32_t, address, 16, 4>;\n    using trp = FieldModel<uint32_t,\
    \ address, 20, 4>;\n    using trcd = FieldModel<uint32_t, address, 24, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 4> tmrd;\n      BitFieldModel<uint32_t, 4, 4> txsr;\n      BitFieldModel<uint32_t,\
    \ 8, 4> tras;\n      BitFieldModel<uint32_t, 12, 4> trc;\n      BitFieldModel<uint32_t,\
    \ 16, 4> twr;\n      BitFieldModel<uint32_t, 20, 4> trp;\n      BitFieldModel<uint32_t,\
    \ 24, 4> trcd;\n    };\n  };\n\npublic:\n  using sdtr1 = Sdtr1Reg<BaseAddress\
    \ + 0x0148>;\n\nprivate:\n  template<unsigned int address>\n  class Sdtr2Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using tmrd = FieldModel<uint32_t,\
    \ address, 0, 4>;\n    using txsr = FieldModel<uint32_t, address, 4, 4>;\n   \
    \ using tras = FieldModel<uint32_t, address, 8, 4>;\n    using trc = FieldModel<uint32_t,\
    \ address, 12, 4>;\n    using twr = FieldModel<uint32_t, address, 16, 4>;\n  \
    \  using trp = FieldModel<uint32_t, address, 20, 4>;\n    using trcd = FieldModel<uint32_t,\
    \ address, 24, 4>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 4> tmrd;\n      BitFieldModel<uint32_t, 4, 4>\
    \ txsr;\n      BitFieldModel<uint32_t, 8, 4> tras;\n      BitFieldModel<uint32_t,\
    \ 12, 4> trc;\n      BitFieldModel<uint32_t, 16, 4> twr;\n      BitFieldModel<uint32_t,\
    \ 20, 4> trp;\n      BitFieldModel<uint32_t, 24, 4> trcd;\n    };\n  };\n\npublic:\n\
    \  using sdtr2 = Sdtr2Reg<BaseAddress + 0x014C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class SdcmrReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using mode = FieldModel<uint32_t, address, 0, 3>;\n    using\
    \ ctb2 = FieldModel<uint32_t, address, 3, 1>;\n    using ctb1 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using nrfs = FieldModel<uint32_t, address, 5, 4>;\n   \
    \ using mrd = FieldModel<uint32_t, address, 9, 13>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 3> mode;\n   \
    \   BitFieldModel<uint32_t, 3, 1> ctb2;\n      BitFieldModel<uint32_t, 4, 1> ctb1;\n\
    \      BitFieldModel<uint32_t, 5, 4> nrfs;\n      BitFieldModel<uint32_t, 9, 13>\
    \ mrd;\n    };\n  };\n\npublic:\n  using sdcmr = SdcmrReg<BaseAddress + 0x0150>;\n\
    \nprivate:\n  template<unsigned int address>\n  class SdrtrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cre = FieldModel<uint32_t, address, 0, 1>;\n\
    \    using count = FieldModel<uint32_t, address, 1, 13>;\n    using reie = FieldModel<uint32_t,\
    \ address, 14, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> cre;\n      BitFieldModel<uint32_t, 1, 13>\
    \ count;\n      BitFieldModel<uint32_t, 14, 1> reie;\n    };\n  };\n\npublic:\n\
    \  using sdrtr = SdrtrReg<BaseAddress + 0x0154>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class SdsrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using re = FieldModel<uint32_t, address, 0, 1>;\n    using modes1\
    \ = FieldModel<uint32_t, address, 1, 2>;\n    using modes2 = FieldModel<uint32_t,\
    \ address, 3, 2>;\n    using busy = FieldModel<uint32_t, address, 5, 1>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> re;\n      BitFieldModel<uint32_t, 1, 2> modes1;\n      BitFieldModel<uint32_t,\
    \ 3, 2> modes2;\n      BitFieldModel<uint32_t, 5, 1> busy;\n    };\n  };\n\npublic:\n\
    \  using sdsr = SdsrReg<BaseAddress + 0x0158>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class BtrxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using accmod = FieldModel<uint32_t,\
    \ address, 28, 2, bankOffset>;\n    using datlat = FieldModel<uint32_t, address,\
    \ 24, 4, bankOffset>;\n    using clkdiv = FieldModel<uint32_t, address, 20, 4,\
    \ bankOffset>;\n    using busturn = FieldModel<uint32_t, address, 16, 4, bankOffset>;\n\
    \    using datast = FieldModel<uint32_t, address, 8, 8, bankOffset>;\n    using\
    \ addhld = FieldModel<uint32_t, address, 4, 4, bankOffset>;\n    using addset\
    \ = FieldModel<uint32_t, address, 0, 4, bankOffset>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 28, 2> accmod;\n\
    \      BitFieldModel<uint32_t, 24, 4> datlat;\n      BitFieldModel<uint32_t, 20,\
    \ 4> clkdiv;\n      BitFieldModel<uint32_t, 16, 4> busturn;\n      BitFieldModel<uint32_t,\
    \ 8, 8> datast;\n      BitFieldModel<uint32_t, 4, 4> addhld;\n      BitFieldModel<uint32_t,\
    \ 0, 4> addset;\n    };\n  };\n\npublic:\n  using btrx = BtrxBankReg<BaseAddress\
    \ + 0x0004, 0x0008>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class BcrxBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using cburstrw = FieldModel<uint32_t, address,\
    \ 19, 1, bankOffset>;\n    using asyncwait = FieldModel<uint32_t, address, 15,\
    \ 1, bankOffset>;\n    using extmod = FieldModel<uint32_t, address, 14, 1, bankOffset>;\n\
    \    using waiten = FieldModel<uint32_t, address, 13, 1, bankOffset>;\n    using\
    \ wren = FieldModel<uint32_t, address, 12, 1, bankOffset>;\n    using waitcfg\
    \ = FieldModel<uint32_t, address, 11, 1, bankOffset>;\n    using wrapmod = FieldModel<uint32_t,\
    \ address, 10, 1, bankOffset>;\n    using waitpol = FieldModel<uint32_t, address,\
    \ 9, 1, bankOffset>;\n    using bursten = FieldModel<uint32_t, address, 8, 1,\
    \ bankOffset>;\n    using faccen = FieldModel<uint32_t, address, 6, 1, bankOffset>;\n\
    \    using mwid = FieldModel<uint32_t, address, 4, 2, bankOffset>;\n    using\
    \ mtyp = FieldModel<uint32_t, address, 2, 2, bankOffset>;\n    using muxen = FieldModel<uint32_t,\
    \ address, 1, 1, bankOffset>;\n    using mbken = FieldModel<uint32_t, address,\
    \ 0, 1, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 19, 1> cburstrw;\n      BitFieldModel<uint32_t,\
    \ 15, 1> asyncwait;\n      BitFieldModel<uint32_t, 14, 1> extmod;\n      BitFieldModel<uint32_t,\
    \ 13, 1> waiten;\n      BitFieldModel<uint32_t, 12, 1> wren;\n      BitFieldModel<uint32_t,\
    \ 11, 1> waitcfg;\n      BitFieldModel<uint32_t, 10, 1> wrapmod;\n      BitFieldModel<uint32_t,\
    \ 9, 1> waitpol;\n      BitFieldModel<uint32_t, 8, 1> bursten;\n      BitFieldModel<uint32_t,\
    \ 6, 1> faccen;\n      BitFieldModel<uint32_t, 4, 2> mwid;\n      BitFieldModel<uint32_t,\
    \ 2, 2> mtyp;\n      BitFieldModel<uint32_t, 1, 1> muxen;\n      BitFieldModel<uint32_t,\
    \ 0, 1> mbken;\n    };\n  };\n\npublic:\n  using bcrx = BcrxBankReg<BaseAddress\
    \ + 0x0008, 0x0008>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class PcrxBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using eccps = FieldModel<uint32_t, address,\
    \ 17, 3, bankOffset>;\n    using tar = FieldModel<uint32_t, address, 13, 4, bankOffset>;\n\
    \    using tclr = FieldModel<uint32_t, address, 9, 4, bankOffset>;\n    using\
    \ eccen = FieldModel<uint32_t, address, 6, 1, bankOffset>;\n    using pwid = FieldModel<uint32_t,\
    \ address, 4, 2, bankOffset>;\n    using ptyp = FieldModel<uint32_t, address,\
    \ 3, 1, bankOffset>;\n    using pbken = FieldModel<uint32_t, address, 2, 1, bankOffset>;\n\
    \    using pwaiten = FieldModel<uint32_t, address, 1, 1, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 17,\
    \ 3> eccps;\n      BitFieldModel<uint32_t, 13, 4> tar;\n      BitFieldModel<uint32_t,\
    \ 9, 4> tclr;\n      BitFieldModel<uint32_t, 6, 1> eccen;\n      BitFieldModel<uint32_t,\
    \ 4, 2> pwid;\n      BitFieldModel<uint32_t, 3, 1> ptyp;\n      BitFieldModel<uint32_t,\
    \ 2, 1> pbken;\n      BitFieldModel<uint32_t, 1, 1> pwaiten;\n    };\n  };\n\n\
    public:\n  using pcrx = PcrxBankReg<BaseAddress + 0x0060, 0x0020>;\n\nprivate:\n\
    \  template<unsigned int address, unsigned int bankOffset>\n  class SrxBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    using fempt = FieldModel<uint32_t, address, 6, 1, bankOffset>;\n    using\
    \ ifen = FieldModel<uint32_t, address, 5, 1, bankOffset>;\n    using ilen = FieldModel<uint32_t,\
    \ address, 4, 1, bankOffset>;\n    using iren = FieldModel<uint32_t, address,\
    \ 3, 1, bankOffset>;\n    using ifs = FieldModel<uint32_t, address, 2, 1, bankOffset>;\n\
    \    using ils = FieldModel<uint32_t, address, 1, 1, bankOffset>;\n    using irs\
    \ = FieldModel<uint32_t, address, 0, 1, bankOffset>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 6, 1> fempt;\n  \
    \    BitFieldModel<uint32_t, 5, 1> ifen;\n      BitFieldModel<uint32_t, 4, 1>\
    \ ilen;\n      BitFieldModel<uint32_t, 3, 1> iren;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ifs;\n      BitFieldModel<uint32_t, 1, 1> ils;\n      BitFieldModel<uint32_t,\
    \ 0, 1> irs;\n    };\n  };\n\npublic:\n  using srx = SrxBankReg<BaseAddress +\
    \ 0x0064, 0x0020>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class PmemxBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using memhizx = FieldModel<uint32_t, address,\
    \ 24, 8, bankOffset>;\n    using memholdx = FieldModel<uint32_t, address, 16,\
    \ 8, bankOffset>;\n    using memwaitx = FieldModel<uint32_t, address, 8, 8, bankOffset>;\n\
    \    using memsetx = FieldModel<uint32_t, address, 0, 8, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 24,\
    \ 8> memhizx;\n      BitFieldModel<uint32_t, 16, 8> memholdx;\n      BitFieldModel<uint32_t,\
    \ 8, 8> memwaitx;\n      BitFieldModel<uint32_t, 0, 8> memsetx;\n    };\n  };\n\
    \npublic:\n  using pmemx = PmemxBankReg<BaseAddress + 0x0068, 0x0020>;\n\nprivate:\n\
    \  template<unsigned int address, unsigned int bankOffset>\n  class PattxBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    using atthizx = FieldModel<uint32_t, address, 24, 8, bankOffset>;\n    using\
    \ attholdx = FieldModel<uint32_t, address, 16, 8, bankOffset>;\n    using attwaitx\
    \ = FieldModel<uint32_t, address, 8, 8, bankOffset>;\n    using attsetx = FieldModel<uint32_t,\
    \ address, 0, 8, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      BitFieldModel<uint32_t, 24, 8> atthizx;\n      BitFieldModel<uint32_t,\
    \ 16, 8> attholdx;\n      BitFieldModel<uint32_t, 8, 8> attwaitx;\n      BitFieldModel<uint32_t,\
    \ 0, 8> attsetx;\n    };\n  };\n\npublic:\n  using pattx = PattxBankReg<BaseAddress\
    \ + 0x006C, 0x0020>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class EccrxBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using eccx = FieldModel<uint32_t, address,\
    \ 0, 32, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> eccx;\n    };\n  };\n\npublic:\n  using\
    \ eccrx = EccrxBankReg<BaseAddress + 0x0074, 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class BwtrxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using accmod = FieldModel<uint32_t,\
    \ address, 28, 2, bankOffset>;\n    using datlat = FieldModel<uint32_t, address,\
    \ 24, 4, bankOffset>;\n    using clkdiv = FieldModel<uint32_t, address, 20, 4,\
    \ bankOffset>;\n    using datast = FieldModel<uint32_t, address, 8, 8, bankOffset>;\n\
    \    using addhld = FieldModel<uint32_t, address, 4, 4, bankOffset>;\n    using\
    \ addset = FieldModel<uint32_t, address, 0, 4, bankOffset>;\n\n  public:\n   \
    \ union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 28, 2>\
    \ accmod;\n      BitFieldModel<uint32_t, 24, 4> datlat;\n      BitFieldModel<uint32_t,\
    \ 20, 4> clkdiv;\n      BitFieldModel<uint32_t, 8, 8> datast;\n      BitFieldModel<uint32_t,\
    \ 4, 4> addhld;\n      BitFieldModel<uint32_t, 0, 4> addset;\n    };\n  };\n\n\
    public:\n  using bwtrx = BwtrxBankReg<BaseAddress + 0x0104, 0x0008>;\n\nprivate:\n\
    \  template<unsigned int address, unsigned int bankOffset>\n  class SdcrxBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    using nc = FieldModel<uint32_t, address, 0, 2, bankOffset>;\n    using nr\
    \ = FieldModel<uint32_t, address, 2, 2, bankOffset>;\n    using mwid = FieldModel<uint32_t,\
    \ address, 4, 2, bankOffset>;\n    using nb = FieldModel<uint32_t, address, 6,\
    \ 1, bankOffset>;\n    using cas = FieldModel<uint32_t, address, 7, 2, bankOffset>;\n\
    \    using wp = FieldModel<uint32_t, address, 9, 1, bankOffset>;\n    using sdclk\
    \ = FieldModel<uint32_t, address, 10, 2, bankOffset>;\n    using rburst = FieldModel<uint32_t,\
    \ address, 12, 1, bankOffset>;\n    using rpipe = FieldModel<uint32_t, address,\
    \ 13, 2, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 2> nc;\n      BitFieldModel<uint32_t, 2, 2>\
    \ nr;\n      BitFieldModel<uint32_t, 4, 2> mwid;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nb;\n      BitFieldModel<uint32_t, 7, 2> cas;\n      BitFieldModel<uint32_t,\
    \ 9, 1> wp;\n      BitFieldModel<uint32_t, 10, 2> sdclk;\n      BitFieldModel<uint32_t,\
    \ 12, 1> rburst;\n      BitFieldModel<uint32_t, 13, 2> rpipe;\n    };\n  };\n\n\
    public:\n  using sdcrx = SdcrxBankReg<BaseAddress + 0x0140, 0x0004>;\n\nprivate:\n\
    \  template<unsigned int address, unsigned int bankOffset>\n  class SdtrxBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    using tmrd = FieldModel<uint32_t, address, 0, 4, bankOffset>;\n    using\
    \ txsr = FieldModel<uint32_t, address, 4, 4, bankOffset>;\n    using tras = FieldModel<uint32_t,\
    \ address, 8, 4, bankOffset>;\n    using trc = FieldModel<uint32_t, address, 12,\
    \ 4, bankOffset>;\n    using twr = FieldModel<uint32_t, address, 16, 4, bankOffset>;\n\
    \    using trp = FieldModel<uint32_t, address, 20, 4, bankOffset>;\n    using\
    \ trcd = FieldModel<uint32_t, address, 24, 4, bankOffset>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 4> tmrd;\n\
    \      BitFieldModel<uint32_t, 4, 4> txsr;\n      BitFieldModel<uint32_t, 8, 4>\
    \ tras;\n      BitFieldModel<uint32_t, 12, 4> trc;\n      BitFieldModel<uint32_t,\
    \ 16, 4> twr;\n      BitFieldModel<uint32_t, 20, 4> trp;\n      BitFieldModel<uint32_t,\
    \ 24, 4> trcd;\n    };\n  };\n\npublic:\n  using sdtrx = SdtrxBankReg<BaseAddress\
    \ + 0x0148, 0x0004>;\n};\n\n}\n\n#endif /* DRAL_STM32F446_FMC_H */\n"
  name: FMC
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_DBG_H\n#define DRAL_STM32F446_DBG_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass dbg\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0xE0042000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Dbgmcu_idcodeReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dev_id = FieldModel<uint32_t, address, 0,\
    \ 12>;\n    using rev_id = FieldModel<uint32_t, address, 16, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 12> dev_id;\n      BitFieldModel<uint32_t, 16, 16> rev_id;\n    };\n  };\n\n\
    public:\n  using dbgmcu_idcode = Dbgmcu_idcodeReg<BaseAddress + 0x0000>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Dbgmcu_crReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dbg_sleep = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    using dbg_stop = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ dbg_standby = FieldModel<uint32_t, address, 2, 1>;\n    using trace_ioen = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using trace_mode = FieldModel<uint32_t, address, 6, 2>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> dbg_sleep;\n      BitFieldModel<uint32_t, 1, 1> dbg_stop;\n      BitFieldModel<uint32_t,\
    \ 2, 1> dbg_standby;\n      BitFieldModel<uint32_t, 5, 1> trace_ioen;\n      BitFieldModel<uint32_t,\
    \ 6, 2> trace_mode;\n    };\n  };\n\npublic:\n  using dbgmcu_cr = Dbgmcu_crReg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class Dbgmcu_apb1_fzReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using dbg_tim2_stop\
    \ = FieldModel<uint32_t, address, 0, 1>;\n    using dbg_tim3_stop = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using dbg_tim4_stop = FieldModel<uint32_t, address, 2,\
    \ 1>;\n    using dbg_tim5_stop = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ dbg_tim6_stop = FieldModel<uint32_t, address, 4, 1>;\n    using dbg_tim7_stop\
    \ = FieldModel<uint32_t, address, 5, 1>;\n    using dbg_tim12_stop = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using dbg_tim13_stop = FieldModel<uint32_t, address, 7,\
    \ 1>;\n    using dbg_tim14_stop = FieldModel<uint32_t, address, 8, 1>;\n    using\
    \ dbg_rtc_stop = FieldModel<uint32_t, address, 10, 1>;\n    using dbg_wwdg_stop\
    \ = FieldModel<uint32_t, address, 11, 1>;\n    using dbg_iwdeg_stop = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using dbg_j2c1_smbus_timeout = FieldModel<uint32_t, address,\
    \ 21, 1>;\n    using dbg_j2c2_smbus_timeout = FieldModel<uint32_t, address, 22,\
    \ 1>;\n    using dbg_j2c3smbus_timeout = FieldModel<uint32_t, address, 23, 1>;\n\
    \    using dbg_i2cfmp_smbus_timeout = FieldModel<uint32_t, address, 24, 1>;\n\
    \    using dbg_can1_stop = FieldModel<uint32_t, address, 25, 1>;\n    using dbg_can2_stop\
    \ = FieldModel<uint32_t, address, 26, 1>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> dbg_tim2_stop;\n \
    \     BitFieldModel<uint32_t, 1, 1> dbg_tim3_stop;\n      BitFieldModel<uint32_t,\
    \ 2, 1> dbg_tim4_stop;\n      BitFieldModel<uint32_t, 3, 1> dbg_tim5_stop;\n \
    \     BitFieldModel<uint32_t, 4, 1> dbg_tim6_stop;\n      BitFieldModel<uint32_t,\
    \ 5, 1> dbg_tim7_stop;\n      BitFieldModel<uint32_t, 6, 1> dbg_tim12_stop;\n\
    \      BitFieldModel<uint32_t, 7, 1> dbg_tim13_stop;\n      BitFieldModel<uint32_t,\
    \ 8, 1> dbg_tim14_stop;\n      BitFieldModel<uint32_t, 10, 1> dbg_rtc_stop;\n\
    \      BitFieldModel<uint32_t, 11, 1> dbg_wwdg_stop;\n      BitFieldModel<uint32_t,\
    \ 12, 1> dbg_iwdeg_stop;\n      BitFieldModel<uint32_t, 21, 1> dbg_j2c1_smbus_timeout;\n\
    \      BitFieldModel<uint32_t, 22, 1> dbg_j2c2_smbus_timeout;\n      BitFieldModel<uint32_t,\
    \ 23, 1> dbg_j2c3smbus_timeout;\n      BitFieldModel<uint32_t, 24, 1> dbg_i2cfmp_smbus_timeout;\n\
    \      BitFieldModel<uint32_t, 25, 1> dbg_can1_stop;\n      BitFieldModel<uint32_t,\
    \ 26, 1> dbg_can2_stop;\n    };\n  };\n\npublic:\n  using dbgmcu_apb1_fz = Dbgmcu_apb1_fzReg<BaseAddress\
    \ + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class Dbgmcu_apb2_fzReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using dbg_tim1_stop\
    \ = FieldModel<uint32_t, address, 0, 1>;\n    using dbg_tim8_stop = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using dbg_tim9_stop = FieldModel<uint32_t, address, 16,\
    \ 1>;\n    using dbg_tim10_stop = FieldModel<uint32_t, address, 17, 1>;\n    using\
    \ dbg_tim11_stop = FieldModel<uint32_t, address, 18, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> dbg_tim1_stop;\n\
    \      BitFieldModel<uint32_t, 1, 1> dbg_tim8_stop;\n      BitFieldModel<uint32_t,\
    \ 16, 1> dbg_tim9_stop;\n      BitFieldModel<uint32_t, 17, 1> dbg_tim10_stop;\n\
    \      BitFieldModel<uint32_t, 18, 1> dbg_tim11_stop;\n    };\n  };\n\npublic:\n\
    \  using dbgmcu_apb2_fz = Dbgmcu_apb2_fzReg<BaseAddress + 0x000C>;\n\n\n};\n\n\
    }\n\n#endif /* DRAL_STM32F446_DBG_H */\n"
  name: DBG
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_DMA2_H\n#define DRAL_STM32F446_DMA2_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass dma2\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40026400;\n\nprivate:\n\
    \  template<unsigned int address>\n  class LisrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using tcif3 = FieldModel<uint32_t, address, 27,\
    \ 1>;\n    using htif3 = FieldModel<uint32_t, address, 26, 1>;\n    using teif3\
    \ = FieldModel<uint32_t, address, 25, 1>;\n    using dmeif3 = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    using feif3 = FieldModel<uint32_t, address, 22, 1>;\n\
    \    using tcif2 = FieldModel<uint32_t, address, 21, 1>;\n    using htif2 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using teif2 = FieldModel<uint32_t, address, 19, 1>;\n\
    \    using dmeif2 = FieldModel<uint32_t, address, 18, 1>;\n    using feif2 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using tcif1 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using htif1 = FieldModel<uint32_t, address, 10, 1>;\n    using teif1 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dmeif1 = FieldModel<uint32_t, address, 8, 1>;\n \
    \   using feif1 = FieldModel<uint32_t, address, 6, 1>;\n    using tcif0 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using htif0 = FieldModel<uint32_t, address, 4, 1>;\n  \
    \  using teif0 = FieldModel<uint32_t, address, 3, 1>;\n    using dmeif0 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using feif0 = FieldModel<uint32_t, address, 0, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 27, 1> tcif3;\n      BitFieldModel<uint32_t, 26, 1> htif3;\n      BitFieldModel<uint32_t,\
    \ 25, 1> teif3;\n      BitFieldModel<uint32_t, 24, 1> dmeif3;\n      BitFieldModel<uint32_t,\
    \ 22, 1> feif3;\n      BitFieldModel<uint32_t, 21, 1> tcif2;\n      BitFieldModel<uint32_t,\
    \ 20, 1> htif2;\n      BitFieldModel<uint32_t, 19, 1> teif2;\n      BitFieldModel<uint32_t,\
    \ 18, 1> dmeif2;\n      BitFieldModel<uint32_t, 16, 1> feif2;\n      BitFieldModel<uint32_t,\
    \ 11, 1> tcif1;\n      BitFieldModel<uint32_t, 10, 1> htif1;\n      BitFieldModel<uint32_t,\
    \ 9, 1> teif1;\n      BitFieldModel<uint32_t, 8, 1> dmeif1;\n      BitFieldModel<uint32_t,\
    \ 6, 1> feif1;\n      BitFieldModel<uint32_t, 5, 1> tcif0;\n      BitFieldModel<uint32_t,\
    \ 4, 1> htif0;\n      BitFieldModel<uint32_t, 3, 1> teif0;\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmeif0;\n      BitFieldModel<uint32_t, 0, 1> feif0;\n    };\n  };\n\n\
    public:\n  using lisr = LisrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class HisrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using tcif7 = FieldModel<uint32_t, address, 27, 1>;\n    using\
    \ htif7 = FieldModel<uint32_t, address, 26, 1>;\n    using teif7 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using dmeif7 = FieldModel<uint32_t, address, 24, 1>;\n\
    \    using feif7 = FieldModel<uint32_t, address, 22, 1>;\n    using tcif6 = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    using htif6 = FieldModel<uint32_t, address, 20, 1>;\n\
    \    using teif6 = FieldModel<uint32_t, address, 19, 1>;\n    using dmeif6 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    using feif6 = FieldModel<uint32_t, address, 16, 1>;\n\
    \    using tcif5 = FieldModel<uint32_t, address, 11, 1>;\n    using htif5 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using teif5 = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using dmeif5 = FieldModel<uint32_t, address, 8, 1>;\n    using feif5 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using tcif4 = FieldModel<uint32_t, address, 5, 1>;\n  \
    \  using htif4 = FieldModel<uint32_t, address, 4, 1>;\n    using teif4 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using dmeif4 = FieldModel<uint32_t, address, 2, 1>;\n \
    \   using feif4 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 27, 1> tcif7;\n\
    \      BitFieldModel<uint32_t, 26, 1> htif7;\n      BitFieldModel<uint32_t, 25,\
    \ 1> teif7;\n      BitFieldModel<uint32_t, 24, 1> dmeif7;\n      BitFieldModel<uint32_t,\
    \ 22, 1> feif7;\n      BitFieldModel<uint32_t, 21, 1> tcif6;\n      BitFieldModel<uint32_t,\
    \ 20, 1> htif6;\n      BitFieldModel<uint32_t, 19, 1> teif6;\n      BitFieldModel<uint32_t,\
    \ 18, 1> dmeif6;\n      BitFieldModel<uint32_t, 16, 1> feif6;\n      BitFieldModel<uint32_t,\
    \ 11, 1> tcif5;\n      BitFieldModel<uint32_t, 10, 1> htif5;\n      BitFieldModel<uint32_t,\
    \ 9, 1> teif5;\n      BitFieldModel<uint32_t, 8, 1> dmeif5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> feif5;\n      BitFieldModel<uint32_t, 5, 1> tcif4;\n      BitFieldModel<uint32_t,\
    \ 4, 1> htif4;\n      BitFieldModel<uint32_t, 3, 1> teif4;\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmeif4;\n      BitFieldModel<uint32_t, 0, 1> feif4;\n    };\n  };\n\n\
    public:\n  using hisr = HisrReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class LifcrReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using ctcif3 = FieldModel<uint32_t, address, 27, 1>;\n   \
    \ using chtif3 = FieldModel<uint32_t, address, 26, 1>;\n    using cteif3 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using cdmeif3 = FieldModel<uint32_t, address, 24, 1>;\n\
    \    using cfeif3 = FieldModel<uint32_t, address, 22, 1>;\n    using ctcif2 =\
    \ FieldModel<uint32_t, address, 21, 1>;\n    using chtif2 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using cteif2 = FieldModel<uint32_t, address, 19, 1>;\n\
    \    using cdmeif2 = FieldModel<uint32_t, address, 18, 1>;\n    using cfeif2 =\
    \ FieldModel<uint32_t, address, 16, 1>;\n    using ctcif1 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using chtif1 = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using cteif1 = FieldModel<uint32_t, address, 9, 1>;\n    using cdmeif1 =\
    \ FieldModel<uint32_t, address, 8, 1>;\n    using cfeif1 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using ctcif0 = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using chtif0 = FieldModel<uint32_t, address, 4, 1>;\n    using cteif0 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using cdmeif0 = FieldModel<uint32_t, address, 2, 1>;\n\
    \    using cfeif0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 27, 1> ctcif3;\n\
    \      BitFieldModel<uint32_t, 26, 1> chtif3;\n      BitFieldModel<uint32_t, 25,\
    \ 1> cteif3;\n      BitFieldModel<uint32_t, 24, 1> cdmeif3;\n      BitFieldModel<uint32_t,\
    \ 22, 1> cfeif3;\n      BitFieldModel<uint32_t, 21, 1> ctcif2;\n      BitFieldModel<uint32_t,\
    \ 20, 1> chtif2;\n      BitFieldModel<uint32_t, 19, 1> cteif2;\n      BitFieldModel<uint32_t,\
    \ 18, 1> cdmeif2;\n      BitFieldModel<uint32_t, 16, 1> cfeif2;\n      BitFieldModel<uint32_t,\
    \ 11, 1> ctcif1;\n      BitFieldModel<uint32_t, 10, 1> chtif1;\n      BitFieldModel<uint32_t,\
    \ 9, 1> cteif1;\n      BitFieldModel<uint32_t, 8, 1> cdmeif1;\n      BitFieldModel<uint32_t,\
    \ 6, 1> cfeif1;\n      BitFieldModel<uint32_t, 5, 1> ctcif0;\n      BitFieldModel<uint32_t,\
    \ 4, 1> chtif0;\n      BitFieldModel<uint32_t, 3, 1> cteif0;\n      BitFieldModel<uint32_t,\
    \ 2, 1> cdmeif0;\n      BitFieldModel<uint32_t, 0, 1> cfeif0;\n    };\n  };\n\n\
    public:\n  using lifcr = LifcrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class HifcrReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using ctcif7 = FieldModel<uint32_t, address, 27, 1>;\n   \
    \ using chtif7 = FieldModel<uint32_t, address, 26, 1>;\n    using cteif7 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using cdmeif7 = FieldModel<uint32_t, address, 24, 1>;\n\
    \    using cfeif7 = FieldModel<uint32_t, address, 22, 1>;\n    using ctcif6 =\
    \ FieldModel<uint32_t, address, 21, 1>;\n    using chtif6 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using cteif6 = FieldModel<uint32_t, address, 19, 1>;\n\
    \    using cdmeif6 = FieldModel<uint32_t, address, 18, 1>;\n    using cfeif6 =\
    \ FieldModel<uint32_t, address, 16, 1>;\n    using ctcif5 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using chtif5 = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using cteif5 = FieldModel<uint32_t, address, 9, 1>;\n    using cdmeif5 =\
    \ FieldModel<uint32_t, address, 8, 1>;\n    using cfeif5 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using ctcif4 = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using chtif4 = FieldModel<uint32_t, address, 4, 1>;\n    using cteif4 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using cdmeif4 = FieldModel<uint32_t, address, 2, 1>;\n\
    \    using cfeif4 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 27, 1> ctcif7;\n\
    \      BitFieldModel<uint32_t, 26, 1> chtif7;\n      BitFieldModel<uint32_t, 25,\
    \ 1> cteif7;\n      BitFieldModel<uint32_t, 24, 1> cdmeif7;\n      BitFieldModel<uint32_t,\
    \ 22, 1> cfeif7;\n      BitFieldModel<uint32_t, 21, 1> ctcif6;\n      BitFieldModel<uint32_t,\
    \ 20, 1> chtif6;\n      BitFieldModel<uint32_t, 19, 1> cteif6;\n      BitFieldModel<uint32_t,\
    \ 18, 1> cdmeif6;\n      BitFieldModel<uint32_t, 16, 1> cfeif6;\n      BitFieldModel<uint32_t,\
    \ 11, 1> ctcif5;\n      BitFieldModel<uint32_t, 10, 1> chtif5;\n      BitFieldModel<uint32_t,\
    \ 9, 1> cteif5;\n      BitFieldModel<uint32_t, 8, 1> cdmeif5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> cfeif5;\n      BitFieldModel<uint32_t, 5, 1> ctcif4;\n      BitFieldModel<uint32_t,\
    \ 4, 1> chtif4;\n      BitFieldModel<uint32_t, 3, 1> cteif4;\n      BitFieldModel<uint32_t,\
    \ 2, 1> cdmeif4;\n      BitFieldModel<uint32_t, 0, 1> cfeif4;\n    };\n  };\n\n\
    public:\n  using hifcr = HifcrReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S0crReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using chsel = FieldModel<uint32_t, address, 25, 3>;\n    using\
    \ mburst = FieldModel<uint32_t, address, 23, 2>;\n    using pburst = FieldModel<uint32_t,\
    \ address, 21, 2>;\n    using ct = FieldModel<uint32_t, address, 19, 1>;\n   \
    \ using dbm = FieldModel<uint32_t, address, 18, 1>;\n    using pl = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    using pincos = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using msize = FieldModel<uint32_t, address, 13, 2>;\n    using psize = FieldModel<uint32_t,\
    \ address, 11, 2>;\n    using minc = FieldModel<uint32_t, address, 10, 1>;\n \
    \   using pinc = FieldModel<uint32_t, address, 9, 1>;\n    using circ = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using dir = FieldModel<uint32_t, address, 6, 2>;\n    using\
    \ pfctrl = FieldModel<uint32_t, address, 5, 1>;\n    using tcie = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using htie = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using teie = FieldModel<uint32_t, address, 2, 1>;\n    using dmeie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using en = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 25,\
    \ 3> chsel;\n      BitFieldModel<uint32_t, 23, 2> mburst;\n      BitFieldModel<uint32_t,\
    \ 21, 2> pburst;\n      BitFieldModel<uint32_t, 19, 1> ct;\n      BitFieldModel<uint32_t,\
    \ 18, 1> dbm;\n      BitFieldModel<uint32_t, 16, 2> pl;\n      BitFieldModel<uint32_t,\
    \ 15, 1> pincos;\n      BitFieldModel<uint32_t, 13, 2> msize;\n      BitFieldModel<uint32_t,\
    \ 11, 2> psize;\n      BitFieldModel<uint32_t, 10, 1> minc;\n      BitFieldModel<uint32_t,\
    \ 9, 1> pinc;\n      BitFieldModel<uint32_t, 8, 1> circ;\n      BitFieldModel<uint32_t,\
    \ 6, 2> dir;\n      BitFieldModel<uint32_t, 5, 1> pfctrl;\n      BitFieldModel<uint32_t,\
    \ 4, 1> tcie;\n      BitFieldModel<uint32_t, 3, 1> htie;\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      BitFieldModel<uint32_t, 1, 1> dmeie;\n      BitFieldModel<uint32_t,\
    \ 0, 1> en;\n    };\n  };\n\npublic:\n  using s0cr = S0crReg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S0ndtrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ndt = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ndt;\n    };\n  };\n\npublic:\n  using s0ndtr = S0ndtrReg<BaseAddress\
    \ + 0x0014>;\n\nprivate:\n  template<unsigned int address>\n  class S0parReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using pa = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n  using s0par\
    \ = S0parReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S0m0arReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> m0a;\n\
    \    };\n  };\n\npublic:\n  using s0m0ar = S0m0arReg<BaseAddress + 0x001C>;\n\n\
    private:\n  template<unsigned int address>\n  class S0m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> m1a;\n    };\n  };\n\npublic:\n  using s0m1ar = S0m1arReg<BaseAddress\
    \ + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n  class S0fcrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using feie = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using fs = FieldModel<uint32_t, address, 3, 3>;\n    using\
    \ dmdis = FieldModel<uint32_t, address, 2, 1>;\n    using fth = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> feie;\n      BitFieldModel<uint32_t, 3, 3>\
    \ fs;\n      BitFieldModel<uint32_t, 2, 1> dmdis;\n      BitFieldModel<uint32_t,\
    \ 0, 2> fth;\n    };\n  };\n\npublic:\n  using s0fcr = S0fcrReg<BaseAddress +\
    \ 0x0024>;\n\nprivate:\n  template<unsigned int address>\n  class S1crReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using chsel = FieldModel<uint32_t,\
    \ address, 25, 3>;\n    using mburst = FieldModel<uint32_t, address, 23, 2>;\n\
    \    using pburst = FieldModel<uint32_t, address, 21, 2>;\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using pl = FieldModel<uint32_t, address, 16, 2>;\n    using pincos = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using msize = FieldModel<uint32_t, address, 13, 2>;\n\
    \    using psize = FieldModel<uint32_t, address, 11, 2>;\n    using minc = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using pinc = FieldModel<uint32_t, address, 9, 1>;\n  \
    \  using circ = FieldModel<uint32_t, address, 8, 1>;\n    using dir = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using tcie = FieldModel<uint32_t, address, 4, 1>;\n    using htie = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using teie = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using dmeie = FieldModel<uint32_t, address, 1, 1>;\n    using en = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 25, 3> chsel;\n      BitFieldModel<uint32_t, 23,\
    \ 2> mburst;\n      BitFieldModel<uint32_t, 21, 2> pburst;\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pl;\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      BitFieldModel<uint32_t, 11, 2> psize;\n      BitFieldModel<uint32_t,\
    \ 10, 1> minc;\n      BitFieldModel<uint32_t, 9, 1> pinc;\n      BitFieldModel<uint32_t,\
    \ 8, 1> circ;\n      BitFieldModel<uint32_t, 6, 2> dir;\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      BitFieldModel<uint32_t, 4, 1> tcie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      BitFieldModel<uint32_t, 2, 1> teie;\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n\
    \  using s1cr = S1crReg<BaseAddress + 0x0028>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S1ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ndt = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> ndt;\n    };\n  };\n\npublic:\n  using s1ndtr = S1ndtrReg<BaseAddress +\
    \ 0x002C>;\n\nprivate:\n  template<unsigned int address>\n  class S1parReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using pa = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n  using s1par\
    \ = S1parReg<BaseAddress + 0x0030>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S1m0arReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> m0a;\n\
    \    };\n  };\n\npublic:\n  using s1m0ar = S1m0arReg<BaseAddress + 0x0034>;\n\n\
    private:\n  template<unsigned int address>\n  class S1m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> m1a;\n    };\n  };\n\npublic:\n  using s1m1ar = S1m1arReg<BaseAddress\
    \ + 0x0038>;\n\nprivate:\n  template<unsigned int address>\n  class S1fcrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using feie = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using fs = FieldModel<uint32_t, address, 3, 3>;\n    using\
    \ dmdis = FieldModel<uint32_t, address, 2, 1>;\n    using fth = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> feie;\n      BitFieldModel<uint32_t, 3, 3>\
    \ fs;\n      BitFieldModel<uint32_t, 2, 1> dmdis;\n      BitFieldModel<uint32_t,\
    \ 0, 2> fth;\n    };\n  };\n\npublic:\n  using s1fcr = S1fcrReg<BaseAddress +\
    \ 0x003C>;\n\nprivate:\n  template<unsigned int address>\n  class S2crReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using chsel = FieldModel<uint32_t,\
    \ address, 25, 3>;\n    using mburst = FieldModel<uint32_t, address, 23, 2>;\n\
    \    using pburst = FieldModel<uint32_t, address, 21, 2>;\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using pl = FieldModel<uint32_t, address, 16, 2>;\n    using pincos = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using msize = FieldModel<uint32_t, address, 13, 2>;\n\
    \    using psize = FieldModel<uint32_t, address, 11, 2>;\n    using minc = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using pinc = FieldModel<uint32_t, address, 9, 1>;\n  \
    \  using circ = FieldModel<uint32_t, address, 8, 1>;\n    using dir = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using tcie = FieldModel<uint32_t, address, 4, 1>;\n    using htie = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using teie = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using dmeie = FieldModel<uint32_t, address, 1, 1>;\n    using en = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 25, 3> chsel;\n      BitFieldModel<uint32_t, 23,\
    \ 2> mburst;\n      BitFieldModel<uint32_t, 21, 2> pburst;\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pl;\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      BitFieldModel<uint32_t, 11, 2> psize;\n      BitFieldModel<uint32_t,\
    \ 10, 1> minc;\n      BitFieldModel<uint32_t, 9, 1> pinc;\n      BitFieldModel<uint32_t,\
    \ 8, 1> circ;\n      BitFieldModel<uint32_t, 6, 2> dir;\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      BitFieldModel<uint32_t, 4, 1> tcie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      BitFieldModel<uint32_t, 2, 1> teie;\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n\
    \  using s2cr = S2crReg<BaseAddress + 0x0040>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S2ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ndt = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> ndt;\n    };\n  };\n\npublic:\n  using s2ndtr = S2ndtrReg<BaseAddress +\
    \ 0x0044>;\n\nprivate:\n  template<unsigned int address>\n  class S2parReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using pa = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n  using s2par\
    \ = S2parReg<BaseAddress + 0x0048>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S2m0arReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> m0a;\n\
    \    };\n  };\n\npublic:\n  using s2m0ar = S2m0arReg<BaseAddress + 0x004C>;\n\n\
    private:\n  template<unsigned int address>\n  class S2m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> m1a;\n    };\n  };\n\npublic:\n  using s2m1ar = S2m1arReg<BaseAddress\
    \ + 0x0050>;\n\nprivate:\n  template<unsigned int address>\n  class S2fcrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using feie = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using fs = FieldModel<uint32_t, address, 3, 3>;\n    using\
    \ dmdis = FieldModel<uint32_t, address, 2, 1>;\n    using fth = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> feie;\n      BitFieldModel<uint32_t, 3, 3>\
    \ fs;\n      BitFieldModel<uint32_t, 2, 1> dmdis;\n      BitFieldModel<uint32_t,\
    \ 0, 2> fth;\n    };\n  };\n\npublic:\n  using s2fcr = S2fcrReg<BaseAddress +\
    \ 0x0054>;\n\nprivate:\n  template<unsigned int address>\n  class S3crReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using chsel = FieldModel<uint32_t,\
    \ address, 25, 3>;\n    using mburst = FieldModel<uint32_t, address, 23, 2>;\n\
    \    using pburst = FieldModel<uint32_t, address, 21, 2>;\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using pl = FieldModel<uint32_t, address, 16, 2>;\n    using pincos = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using msize = FieldModel<uint32_t, address, 13, 2>;\n\
    \    using psize = FieldModel<uint32_t, address, 11, 2>;\n    using minc = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using pinc = FieldModel<uint32_t, address, 9, 1>;\n  \
    \  using circ = FieldModel<uint32_t, address, 8, 1>;\n    using dir = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using tcie = FieldModel<uint32_t, address, 4, 1>;\n    using htie = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using teie = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using dmeie = FieldModel<uint32_t, address, 1, 1>;\n    using en = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 25, 3> chsel;\n      BitFieldModel<uint32_t, 23,\
    \ 2> mburst;\n      BitFieldModel<uint32_t, 21, 2> pburst;\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pl;\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      BitFieldModel<uint32_t, 11, 2> psize;\n      BitFieldModel<uint32_t,\
    \ 10, 1> minc;\n      BitFieldModel<uint32_t, 9, 1> pinc;\n      BitFieldModel<uint32_t,\
    \ 8, 1> circ;\n      BitFieldModel<uint32_t, 6, 2> dir;\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      BitFieldModel<uint32_t, 4, 1> tcie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      BitFieldModel<uint32_t, 2, 1> teie;\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n\
    \  using s3cr = S3crReg<BaseAddress + 0x0058>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S3ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ndt = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> ndt;\n    };\n  };\n\npublic:\n  using s3ndtr = S3ndtrReg<BaseAddress +\
    \ 0x005C>;\n\nprivate:\n  template<unsigned int address>\n  class S3parReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using pa = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n  using s3par\
    \ = S3parReg<BaseAddress + 0x0060>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S3m0arReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> m0a;\n\
    \    };\n  };\n\npublic:\n  using s3m0ar = S3m0arReg<BaseAddress + 0x0064>;\n\n\
    private:\n  template<unsigned int address>\n  class S3m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> m1a;\n    };\n  };\n\npublic:\n  using s3m1ar = S3m1arReg<BaseAddress\
    \ + 0x0068>;\n\nprivate:\n  template<unsigned int address>\n  class S3fcrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using feie = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using fs = FieldModel<uint32_t, address, 3, 3>;\n    using\
    \ dmdis = FieldModel<uint32_t, address, 2, 1>;\n    using fth = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> feie;\n      BitFieldModel<uint32_t, 3, 3>\
    \ fs;\n      BitFieldModel<uint32_t, 2, 1> dmdis;\n      BitFieldModel<uint32_t,\
    \ 0, 2> fth;\n    };\n  };\n\npublic:\n  using s3fcr = S3fcrReg<BaseAddress +\
    \ 0x006C>;\n\nprivate:\n  template<unsigned int address>\n  class S4crReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using chsel = FieldModel<uint32_t,\
    \ address, 25, 3>;\n    using mburst = FieldModel<uint32_t, address, 23, 2>;\n\
    \    using pburst = FieldModel<uint32_t, address, 21, 2>;\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using pl = FieldModel<uint32_t, address, 16, 2>;\n    using pincos = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using msize = FieldModel<uint32_t, address, 13, 2>;\n\
    \    using psize = FieldModel<uint32_t, address, 11, 2>;\n    using minc = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using pinc = FieldModel<uint32_t, address, 9, 1>;\n  \
    \  using circ = FieldModel<uint32_t, address, 8, 1>;\n    using dir = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using tcie = FieldModel<uint32_t, address, 4, 1>;\n    using htie = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using teie = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using dmeie = FieldModel<uint32_t, address, 1, 1>;\n    using en = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 25, 3> chsel;\n      BitFieldModel<uint32_t, 23,\
    \ 2> mburst;\n      BitFieldModel<uint32_t, 21, 2> pburst;\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pl;\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      BitFieldModel<uint32_t, 11, 2> psize;\n      BitFieldModel<uint32_t,\
    \ 10, 1> minc;\n      BitFieldModel<uint32_t, 9, 1> pinc;\n      BitFieldModel<uint32_t,\
    \ 8, 1> circ;\n      BitFieldModel<uint32_t, 6, 2> dir;\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      BitFieldModel<uint32_t, 4, 1> tcie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      BitFieldModel<uint32_t, 2, 1> teie;\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n\
    \  using s4cr = S4crReg<BaseAddress + 0x0070>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S4ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ndt = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> ndt;\n    };\n  };\n\npublic:\n  using s4ndtr = S4ndtrReg<BaseAddress +\
    \ 0x0074>;\n\nprivate:\n  template<unsigned int address>\n  class S4parReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using pa = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n  using s4par\
    \ = S4parReg<BaseAddress + 0x0078>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S4m0arReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> m0a;\n\
    \    };\n  };\n\npublic:\n  using s4m0ar = S4m0arReg<BaseAddress + 0x007C>;\n\n\
    private:\n  template<unsigned int address>\n  class S4m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> m1a;\n    };\n  };\n\npublic:\n  using s4m1ar = S4m1arReg<BaseAddress\
    \ + 0x0080>;\n\nprivate:\n  template<unsigned int address>\n  class S4fcrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using feie = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using fs = FieldModel<uint32_t, address, 3, 3>;\n    using\
    \ dmdis = FieldModel<uint32_t, address, 2, 1>;\n    using fth = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> feie;\n      BitFieldModel<uint32_t, 3, 3>\
    \ fs;\n      BitFieldModel<uint32_t, 2, 1> dmdis;\n      BitFieldModel<uint32_t,\
    \ 0, 2> fth;\n    };\n  };\n\npublic:\n  using s4fcr = S4fcrReg<BaseAddress +\
    \ 0x0084>;\n\nprivate:\n  template<unsigned int address>\n  class S5crReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using chsel = FieldModel<uint32_t,\
    \ address, 25, 3>;\n    using mburst = FieldModel<uint32_t, address, 23, 2>;\n\
    \    using pburst = FieldModel<uint32_t, address, 21, 2>;\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using pl = FieldModel<uint32_t, address, 16, 2>;\n    using pincos = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using msize = FieldModel<uint32_t, address, 13, 2>;\n\
    \    using psize = FieldModel<uint32_t, address, 11, 2>;\n    using minc = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using pinc = FieldModel<uint32_t, address, 9, 1>;\n  \
    \  using circ = FieldModel<uint32_t, address, 8, 1>;\n    using dir = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using tcie = FieldModel<uint32_t, address, 4, 1>;\n    using htie = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using teie = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using dmeie = FieldModel<uint32_t, address, 1, 1>;\n    using en = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 25, 3> chsel;\n      BitFieldModel<uint32_t, 23,\
    \ 2> mburst;\n      BitFieldModel<uint32_t, 21, 2> pburst;\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pl;\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      BitFieldModel<uint32_t, 11, 2> psize;\n      BitFieldModel<uint32_t,\
    \ 10, 1> minc;\n      BitFieldModel<uint32_t, 9, 1> pinc;\n      BitFieldModel<uint32_t,\
    \ 8, 1> circ;\n      BitFieldModel<uint32_t, 6, 2> dir;\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      BitFieldModel<uint32_t, 4, 1> tcie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      BitFieldModel<uint32_t, 2, 1> teie;\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n\
    \  using s5cr = S5crReg<BaseAddress + 0x0088>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S5ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ndt = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> ndt;\n    };\n  };\n\npublic:\n  using s5ndtr = S5ndtrReg<BaseAddress +\
    \ 0x008C>;\n\nprivate:\n  template<unsigned int address>\n  class S5parReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using pa = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n  using s5par\
    \ = S5parReg<BaseAddress + 0x0090>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S5m0arReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> m0a;\n\
    \    };\n  };\n\npublic:\n  using s5m0ar = S5m0arReg<BaseAddress + 0x0094>;\n\n\
    private:\n  template<unsigned int address>\n  class S5m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> m1a;\n    };\n  };\n\npublic:\n  using s5m1ar = S5m1arReg<BaseAddress\
    \ + 0x0098>;\n\nprivate:\n  template<unsigned int address>\n  class S5fcrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using feie = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using fs = FieldModel<uint32_t, address, 3, 3>;\n    using\
    \ dmdis = FieldModel<uint32_t, address, 2, 1>;\n    using fth = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> feie;\n      BitFieldModel<uint32_t, 3, 3>\
    \ fs;\n      BitFieldModel<uint32_t, 2, 1> dmdis;\n      BitFieldModel<uint32_t,\
    \ 0, 2> fth;\n    };\n  };\n\npublic:\n  using s5fcr = S5fcrReg<BaseAddress +\
    \ 0x009C>;\n\nprivate:\n  template<unsigned int address>\n  class S6crReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using chsel = FieldModel<uint32_t,\
    \ address, 25, 3>;\n    using mburst = FieldModel<uint32_t, address, 23, 2>;\n\
    \    using pburst = FieldModel<uint32_t, address, 21, 2>;\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using pl = FieldModel<uint32_t, address, 16, 2>;\n    using pincos = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using msize = FieldModel<uint32_t, address, 13, 2>;\n\
    \    using psize = FieldModel<uint32_t, address, 11, 2>;\n    using minc = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using pinc = FieldModel<uint32_t, address, 9, 1>;\n  \
    \  using circ = FieldModel<uint32_t, address, 8, 1>;\n    using dir = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using tcie = FieldModel<uint32_t, address, 4, 1>;\n    using htie = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using teie = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using dmeie = FieldModel<uint32_t, address, 1, 1>;\n    using en = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 25, 3> chsel;\n      BitFieldModel<uint32_t, 23,\
    \ 2> mburst;\n      BitFieldModel<uint32_t, 21, 2> pburst;\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pl;\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      BitFieldModel<uint32_t, 11, 2> psize;\n      BitFieldModel<uint32_t,\
    \ 10, 1> minc;\n      BitFieldModel<uint32_t, 9, 1> pinc;\n      BitFieldModel<uint32_t,\
    \ 8, 1> circ;\n      BitFieldModel<uint32_t, 6, 2> dir;\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      BitFieldModel<uint32_t, 4, 1> tcie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      BitFieldModel<uint32_t, 2, 1> teie;\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n\
    \  using s6cr = S6crReg<BaseAddress + 0x00A0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S6ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ndt = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> ndt;\n    };\n  };\n\npublic:\n  using s6ndtr = S6ndtrReg<BaseAddress +\
    \ 0x00A4>;\n\nprivate:\n  template<unsigned int address>\n  class S6parReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using pa = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n  using s6par\
    \ = S6parReg<BaseAddress + 0x00A8>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S6m0arReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> m0a;\n\
    \    };\n  };\n\npublic:\n  using s6m0ar = S6m0arReg<BaseAddress + 0x00AC>;\n\n\
    private:\n  template<unsigned int address>\n  class S6m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> m1a;\n    };\n  };\n\npublic:\n  using s6m1ar = S6m1arReg<BaseAddress\
    \ + 0x00B0>;\n\nprivate:\n  template<unsigned int address>\n  class S6fcrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using feie = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using fs = FieldModel<uint32_t, address, 3, 3>;\n    using\
    \ dmdis = FieldModel<uint32_t, address, 2, 1>;\n    using fth = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> feie;\n      BitFieldModel<uint32_t, 3, 3>\
    \ fs;\n      BitFieldModel<uint32_t, 2, 1> dmdis;\n      BitFieldModel<uint32_t,\
    \ 0, 2> fth;\n    };\n  };\n\npublic:\n  using s6fcr = S6fcrReg<BaseAddress +\
    \ 0x00B4>;\n\nprivate:\n  template<unsigned int address>\n  class S7crReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using chsel = FieldModel<uint32_t,\
    \ address, 25, 3>;\n    using mburst = FieldModel<uint32_t, address, 23, 2>;\n\
    \    using pburst = FieldModel<uint32_t, address, 21, 2>;\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using pl = FieldModel<uint32_t, address, 16, 2>;\n    using pincos = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using msize = FieldModel<uint32_t, address, 13, 2>;\n\
    \    using psize = FieldModel<uint32_t, address, 11, 2>;\n    using minc = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using pinc = FieldModel<uint32_t, address, 9, 1>;\n  \
    \  using circ = FieldModel<uint32_t, address, 8, 1>;\n    using dir = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using tcie = FieldModel<uint32_t, address, 4, 1>;\n    using htie = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using teie = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using dmeie = FieldModel<uint32_t, address, 1, 1>;\n    using en = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 25, 3> chsel;\n      BitFieldModel<uint32_t, 23,\
    \ 2> mburst;\n      BitFieldModel<uint32_t, 21, 2> pburst;\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pl;\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      BitFieldModel<uint32_t, 11, 2> psize;\n      BitFieldModel<uint32_t,\
    \ 10, 1> minc;\n      BitFieldModel<uint32_t, 9, 1> pinc;\n      BitFieldModel<uint32_t,\
    \ 8, 1> circ;\n      BitFieldModel<uint32_t, 6, 2> dir;\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      BitFieldModel<uint32_t, 4, 1> tcie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      BitFieldModel<uint32_t, 2, 1> teie;\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n\
    \  using s7cr = S7crReg<BaseAddress + 0x00B8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S7ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ndt = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> ndt;\n    };\n  };\n\npublic:\n  using s7ndtr = S7ndtrReg<BaseAddress +\
    \ 0x00BC>;\n\nprivate:\n  template<unsigned int address>\n  class S7parReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using pa = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n  using s7par\
    \ = S7parReg<BaseAddress + 0x00C0>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S7m0arReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> m0a;\n\
    \    };\n  };\n\npublic:\n  using s7m0ar = S7m0arReg<BaseAddress + 0x00C4>;\n\n\
    private:\n  template<unsigned int address>\n  class S7m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> m1a;\n    };\n  };\n\npublic:\n  using s7m1ar = S7m1arReg<BaseAddress\
    \ + 0x00C8>;\n\nprivate:\n  template<unsigned int address>\n  class S7fcrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using feie = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using fs = FieldModel<uint32_t, address, 3, 3>;\n    using\
    \ dmdis = FieldModel<uint32_t, address, 2, 1>;\n    using fth = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> feie;\n      BitFieldModel<uint32_t, 3, 3>\
    \ fs;\n      BitFieldModel<uint32_t, 2, 1> dmdis;\n      BitFieldModel<uint32_t,\
    \ 0, 2> fth;\n    };\n  };\n\npublic:\n  using s7fcr = S7fcrReg<BaseAddress +\
    \ 0x00CC>;\n\nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n\
    \  class SxcrBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n\
    \  {\n  public:\n    using chsel = FieldModel<uint32_t, address, 25, 3, bankOffset>;\n\
    \    using mburst = FieldModel<uint32_t, address, 23, 2, bankOffset>;\n    using\
    \ pburst = FieldModel<uint32_t, address, 21, 2, bankOffset>;\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1, bankOffset>;\n    using dbm = FieldModel<uint32_t, address,\
    \ 18, 1, bankOffset>;\n    using pl = FieldModel<uint32_t, address, 16, 2, bankOffset>;\n\
    \    using pincos = FieldModel<uint32_t, address, 15, 1, bankOffset>;\n    using\
    \ msize = FieldModel<uint32_t, address, 13, 2, bankOffset>;\n    using psize =\
    \ FieldModel<uint32_t, address, 11, 2, bankOffset>;\n    using minc = FieldModel<uint32_t,\
    \ address, 10, 1, bankOffset>;\n    using pinc = FieldModel<uint32_t, address,\
    \ 9, 1, bankOffset>;\n    using circ = FieldModel<uint32_t, address, 8, 1, bankOffset>;\n\
    \    using dir = FieldModel<uint32_t, address, 6, 2, bankOffset>;\n    using pfctrl\
    \ = FieldModel<uint32_t, address, 5, 1, bankOffset>;\n    using tcie = FieldModel<uint32_t,\
    \ address, 4, 1, bankOffset>;\n    using htie = FieldModel<uint32_t, address,\
    \ 3, 1, bankOffset>;\n    using teie = FieldModel<uint32_t, address, 2, 1, bankOffset>;\n\
    \    using dmeie = FieldModel<uint32_t, address, 1, 1, bankOffset>;\n    using\
    \ en = FieldModel<uint32_t, address, 0, 1, bankOffset>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 25, 3> chsel;\n\
    \      BitFieldModel<uint32_t, 23, 2> mburst;\n      BitFieldModel<uint32_t, 21,\
    \ 2> pburst;\n      BitFieldModel<uint32_t, 19, 1> ct;\n      BitFieldModel<uint32_t,\
    \ 18, 1> dbm;\n      BitFieldModel<uint32_t, 16, 2> pl;\n      BitFieldModel<uint32_t,\
    \ 15, 1> pincos;\n      BitFieldModel<uint32_t, 13, 2> msize;\n      BitFieldModel<uint32_t,\
    \ 11, 2> psize;\n      BitFieldModel<uint32_t, 10, 1> minc;\n      BitFieldModel<uint32_t,\
    \ 9, 1> pinc;\n      BitFieldModel<uint32_t, 8, 1> circ;\n      BitFieldModel<uint32_t,\
    \ 6, 2> dir;\n      BitFieldModel<uint32_t, 5, 1> pfctrl;\n      BitFieldModel<uint32_t,\
    \ 4, 1> tcie;\n      BitFieldModel<uint32_t, 3, 1> htie;\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      BitFieldModel<uint32_t, 1, 1> dmeie;\n      BitFieldModel<uint32_t,\
    \ 0, 1> en;\n    };\n  };\n\npublic:\n  using sxcr = SxcrBankReg<BaseAddress +\
    \ 0x0010, 0x0018>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class SxndtrBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using ndt = FieldModel<uint32_t, address, 0,\
    \ 16, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> ndt;\n    };\n  };\n\npublic:\n  using sxndtr\
    \ = SxndtrBankReg<BaseAddress + 0x0014, 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class SxparBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using pa = FieldModel<uint32_t, address,\
    \ 0, 32, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n  using sxpar\
    \ = SxparBankReg<BaseAddress + 0x0018, 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class Sxm0arBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using m0a = FieldModel<uint32_t, address,\
    \ 0, 32, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> m0a;\n    };\n  };\n\npublic:\n  using sxm0ar\
    \ = Sxm0arBankReg<BaseAddress + 0x001C, 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class Sxm1arBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using m1a = FieldModel<uint32_t, address,\
    \ 0, 32, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> m1a;\n    };\n  };\n\npublic:\n  using sxm1ar\
    \ = Sxm1arBankReg<BaseAddress + 0x0020, 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class SxfcrBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using feie = FieldModel<uint32_t,\
    \ address, 7, 1, bankOffset>;\n    using fs = FieldModel<uint32_t, address, 3,\
    \ 3, bankOffset>;\n    using dmdis = FieldModel<uint32_t, address, 2, 1, bankOffset>;\n\
    \    using fth = FieldModel<uint32_t, address, 0, 2, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 7,\
    \ 1> feie;\n      BitFieldModel<uint32_t, 3, 3> fs;\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmdis;\n      BitFieldModel<uint32_t, 0, 2> fth;\n    };\n  };\n\npublic:\n\
    \  using sxfcr = SxfcrBankReg<BaseAddress + 0x0024, 0x0018>;\n};\n\n}\n\n#endif\
    \ /* DRAL_STM32F446_DMA2_H */\n"
  name: DMA2
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_DMA1_H\n#define DRAL_STM32F446_DMA1_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass dma1\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40026000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class LisrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using tcif3 = FieldModel<uint32_t, address, 27,\
    \ 1>;\n    using htif3 = FieldModel<uint32_t, address, 26, 1>;\n    using teif3\
    \ = FieldModel<uint32_t, address, 25, 1>;\n    using dmeif3 = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    using feif3 = FieldModel<uint32_t, address, 22, 1>;\n\
    \    using tcif2 = FieldModel<uint32_t, address, 21, 1>;\n    using htif2 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using teif2 = FieldModel<uint32_t, address, 19, 1>;\n\
    \    using dmeif2 = FieldModel<uint32_t, address, 18, 1>;\n    using feif2 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using tcif1 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using htif1 = FieldModel<uint32_t, address, 10, 1>;\n    using teif1 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dmeif1 = FieldModel<uint32_t, address, 8, 1>;\n \
    \   using feif1 = FieldModel<uint32_t, address, 6, 1>;\n    using tcif0 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using htif0 = FieldModel<uint32_t, address, 4, 1>;\n  \
    \  using teif0 = FieldModel<uint32_t, address, 3, 1>;\n    using dmeif0 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using feif0 = FieldModel<uint32_t, address, 0, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 27, 1> tcif3;\n      BitFieldModel<uint32_t, 26, 1> htif3;\n      BitFieldModel<uint32_t,\
    \ 25, 1> teif3;\n      BitFieldModel<uint32_t, 24, 1> dmeif3;\n      BitFieldModel<uint32_t,\
    \ 22, 1> feif3;\n      BitFieldModel<uint32_t, 21, 1> tcif2;\n      BitFieldModel<uint32_t,\
    \ 20, 1> htif2;\n      BitFieldModel<uint32_t, 19, 1> teif2;\n      BitFieldModel<uint32_t,\
    \ 18, 1> dmeif2;\n      BitFieldModel<uint32_t, 16, 1> feif2;\n      BitFieldModel<uint32_t,\
    \ 11, 1> tcif1;\n      BitFieldModel<uint32_t, 10, 1> htif1;\n      BitFieldModel<uint32_t,\
    \ 9, 1> teif1;\n      BitFieldModel<uint32_t, 8, 1> dmeif1;\n      BitFieldModel<uint32_t,\
    \ 6, 1> feif1;\n      BitFieldModel<uint32_t, 5, 1> tcif0;\n      BitFieldModel<uint32_t,\
    \ 4, 1> htif0;\n      BitFieldModel<uint32_t, 3, 1> teif0;\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmeif0;\n      BitFieldModel<uint32_t, 0, 1> feif0;\n    };\n  };\n\n\
    public:\n  using lisr = LisrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class HisrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using tcif7 = FieldModel<uint32_t, address, 27, 1>;\n    using\
    \ htif7 = FieldModel<uint32_t, address, 26, 1>;\n    using teif7 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using dmeif7 = FieldModel<uint32_t, address, 24, 1>;\n\
    \    using feif7 = FieldModel<uint32_t, address, 22, 1>;\n    using tcif6 = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    using htif6 = FieldModel<uint32_t, address, 20, 1>;\n\
    \    using teif6 = FieldModel<uint32_t, address, 19, 1>;\n    using dmeif6 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    using feif6 = FieldModel<uint32_t, address, 16, 1>;\n\
    \    using tcif5 = FieldModel<uint32_t, address, 11, 1>;\n    using htif5 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using teif5 = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using dmeif5 = FieldModel<uint32_t, address, 8, 1>;\n    using feif5 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using tcif4 = FieldModel<uint32_t, address, 5, 1>;\n  \
    \  using htif4 = FieldModel<uint32_t, address, 4, 1>;\n    using teif4 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using dmeif4 = FieldModel<uint32_t, address, 2, 1>;\n \
    \   using feif4 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 27, 1> tcif7;\n\
    \      BitFieldModel<uint32_t, 26, 1> htif7;\n      BitFieldModel<uint32_t, 25,\
    \ 1> teif7;\n      BitFieldModel<uint32_t, 24, 1> dmeif7;\n      BitFieldModel<uint32_t,\
    \ 22, 1> feif7;\n      BitFieldModel<uint32_t, 21, 1> tcif6;\n      BitFieldModel<uint32_t,\
    \ 20, 1> htif6;\n      BitFieldModel<uint32_t, 19, 1> teif6;\n      BitFieldModel<uint32_t,\
    \ 18, 1> dmeif6;\n      BitFieldModel<uint32_t, 16, 1> feif6;\n      BitFieldModel<uint32_t,\
    \ 11, 1> tcif5;\n      BitFieldModel<uint32_t, 10, 1> htif5;\n      BitFieldModel<uint32_t,\
    \ 9, 1> teif5;\n      BitFieldModel<uint32_t, 8, 1> dmeif5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> feif5;\n      BitFieldModel<uint32_t, 5, 1> tcif4;\n      BitFieldModel<uint32_t,\
    \ 4, 1> htif4;\n      BitFieldModel<uint32_t, 3, 1> teif4;\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmeif4;\n      BitFieldModel<uint32_t, 0, 1> feif4;\n    };\n  };\n\n\
    public:\n  using hisr = HisrReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class LifcrReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using ctcif3 = FieldModel<uint32_t, address, 27, 1>;\n   \
    \ using chtif3 = FieldModel<uint32_t, address, 26, 1>;\n    using cteif3 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using cdmeif3 = FieldModel<uint32_t, address, 24, 1>;\n\
    \    using cfeif3 = FieldModel<uint32_t, address, 22, 1>;\n    using ctcif2 =\
    \ FieldModel<uint32_t, address, 21, 1>;\n    using chtif2 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using cteif2 = FieldModel<uint32_t, address, 19, 1>;\n\
    \    using cdmeif2 = FieldModel<uint32_t, address, 18, 1>;\n    using cfeif2 =\
    \ FieldModel<uint32_t, address, 16, 1>;\n    using ctcif1 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using chtif1 = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using cteif1 = FieldModel<uint32_t, address, 9, 1>;\n    using cdmeif1 =\
    \ FieldModel<uint32_t, address, 8, 1>;\n    using cfeif1 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using ctcif0 = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using chtif0 = FieldModel<uint32_t, address, 4, 1>;\n    using cteif0 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using cdmeif0 = FieldModel<uint32_t, address, 2, 1>;\n\
    \    using cfeif0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 27, 1> ctcif3;\n\
    \      BitFieldModel<uint32_t, 26, 1> chtif3;\n      BitFieldModel<uint32_t, 25,\
    \ 1> cteif3;\n      BitFieldModel<uint32_t, 24, 1> cdmeif3;\n      BitFieldModel<uint32_t,\
    \ 22, 1> cfeif3;\n      BitFieldModel<uint32_t, 21, 1> ctcif2;\n      BitFieldModel<uint32_t,\
    \ 20, 1> chtif2;\n      BitFieldModel<uint32_t, 19, 1> cteif2;\n      BitFieldModel<uint32_t,\
    \ 18, 1> cdmeif2;\n      BitFieldModel<uint32_t, 16, 1> cfeif2;\n      BitFieldModel<uint32_t,\
    \ 11, 1> ctcif1;\n      BitFieldModel<uint32_t, 10, 1> chtif1;\n      BitFieldModel<uint32_t,\
    \ 9, 1> cteif1;\n      BitFieldModel<uint32_t, 8, 1> cdmeif1;\n      BitFieldModel<uint32_t,\
    \ 6, 1> cfeif1;\n      BitFieldModel<uint32_t, 5, 1> ctcif0;\n      BitFieldModel<uint32_t,\
    \ 4, 1> chtif0;\n      BitFieldModel<uint32_t, 3, 1> cteif0;\n      BitFieldModel<uint32_t,\
    \ 2, 1> cdmeif0;\n      BitFieldModel<uint32_t, 0, 1> cfeif0;\n    };\n  };\n\n\
    public:\n  using lifcr = LifcrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class HifcrReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using ctcif7 = FieldModel<uint32_t, address, 27, 1>;\n   \
    \ using chtif7 = FieldModel<uint32_t, address, 26, 1>;\n    using cteif7 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using cdmeif7 = FieldModel<uint32_t, address, 24, 1>;\n\
    \    using cfeif7 = FieldModel<uint32_t, address, 22, 1>;\n    using ctcif6 =\
    \ FieldModel<uint32_t, address, 21, 1>;\n    using chtif6 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using cteif6 = FieldModel<uint32_t, address, 19, 1>;\n\
    \    using cdmeif6 = FieldModel<uint32_t, address, 18, 1>;\n    using cfeif6 =\
    \ FieldModel<uint32_t, address, 16, 1>;\n    using ctcif5 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using chtif5 = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using cteif5 = FieldModel<uint32_t, address, 9, 1>;\n    using cdmeif5 =\
    \ FieldModel<uint32_t, address, 8, 1>;\n    using cfeif5 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using ctcif4 = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using chtif4 = FieldModel<uint32_t, address, 4, 1>;\n    using cteif4 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using cdmeif4 = FieldModel<uint32_t, address, 2, 1>;\n\
    \    using cfeif4 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 27, 1> ctcif7;\n\
    \      BitFieldModel<uint32_t, 26, 1> chtif7;\n      BitFieldModel<uint32_t, 25,\
    \ 1> cteif7;\n      BitFieldModel<uint32_t, 24, 1> cdmeif7;\n      BitFieldModel<uint32_t,\
    \ 22, 1> cfeif7;\n      BitFieldModel<uint32_t, 21, 1> ctcif6;\n      BitFieldModel<uint32_t,\
    \ 20, 1> chtif6;\n      BitFieldModel<uint32_t, 19, 1> cteif6;\n      BitFieldModel<uint32_t,\
    \ 18, 1> cdmeif6;\n      BitFieldModel<uint32_t, 16, 1> cfeif6;\n      BitFieldModel<uint32_t,\
    \ 11, 1> ctcif5;\n      BitFieldModel<uint32_t, 10, 1> chtif5;\n      BitFieldModel<uint32_t,\
    \ 9, 1> cteif5;\n      BitFieldModel<uint32_t, 8, 1> cdmeif5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> cfeif5;\n      BitFieldModel<uint32_t, 5, 1> ctcif4;\n      BitFieldModel<uint32_t,\
    \ 4, 1> chtif4;\n      BitFieldModel<uint32_t, 3, 1> cteif4;\n      BitFieldModel<uint32_t,\
    \ 2, 1> cdmeif4;\n      BitFieldModel<uint32_t, 0, 1> cfeif4;\n    };\n  };\n\n\
    public:\n  using hifcr = HifcrReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S0crReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using chsel = FieldModel<uint32_t, address, 25, 3>;\n    using\
    \ mburst = FieldModel<uint32_t, address, 23, 2>;\n    using pburst = FieldModel<uint32_t,\
    \ address, 21, 2>;\n    using ct = FieldModel<uint32_t, address, 19, 1>;\n   \
    \ using dbm = FieldModel<uint32_t, address, 18, 1>;\n    using pl = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    using pincos = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using msize = FieldModel<uint32_t, address, 13, 2>;\n    using psize = FieldModel<uint32_t,\
    \ address, 11, 2>;\n    using minc = FieldModel<uint32_t, address, 10, 1>;\n \
    \   using pinc = FieldModel<uint32_t, address, 9, 1>;\n    using circ = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using dir = FieldModel<uint32_t, address, 6, 2>;\n    using\
    \ pfctrl = FieldModel<uint32_t, address, 5, 1>;\n    using tcie = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using htie = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using teie = FieldModel<uint32_t, address, 2, 1>;\n    using dmeie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using en = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 25,\
    \ 3> chsel;\n      BitFieldModel<uint32_t, 23, 2> mburst;\n      BitFieldModel<uint32_t,\
    \ 21, 2> pburst;\n      BitFieldModel<uint32_t, 19, 1> ct;\n      BitFieldModel<uint32_t,\
    \ 18, 1> dbm;\n      BitFieldModel<uint32_t, 16, 2> pl;\n      BitFieldModel<uint32_t,\
    \ 15, 1> pincos;\n      BitFieldModel<uint32_t, 13, 2> msize;\n      BitFieldModel<uint32_t,\
    \ 11, 2> psize;\n      BitFieldModel<uint32_t, 10, 1> minc;\n      BitFieldModel<uint32_t,\
    \ 9, 1> pinc;\n      BitFieldModel<uint32_t, 8, 1> circ;\n      BitFieldModel<uint32_t,\
    \ 6, 2> dir;\n      BitFieldModel<uint32_t, 5, 1> pfctrl;\n      BitFieldModel<uint32_t,\
    \ 4, 1> tcie;\n      BitFieldModel<uint32_t, 3, 1> htie;\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      BitFieldModel<uint32_t, 1, 1> dmeie;\n      BitFieldModel<uint32_t,\
    \ 0, 1> en;\n    };\n  };\n\npublic:\n  using s0cr = S0crReg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S0ndtrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ndt = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ndt;\n    };\n  };\n\npublic:\n  using s0ndtr = S0ndtrReg<BaseAddress\
    \ + 0x0014>;\n\nprivate:\n  template<unsigned int address>\n  class S0parReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using pa = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n  using s0par\
    \ = S0parReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S0m0arReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> m0a;\n\
    \    };\n  };\n\npublic:\n  using s0m0ar = S0m0arReg<BaseAddress + 0x001C>;\n\n\
    private:\n  template<unsigned int address>\n  class S0m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> m1a;\n    };\n  };\n\npublic:\n  using s0m1ar = S0m1arReg<BaseAddress\
    \ + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n  class S0fcrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using feie = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using fs = FieldModel<uint32_t, address, 3, 3>;\n    using\
    \ dmdis = FieldModel<uint32_t, address, 2, 1>;\n    using fth = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> feie;\n      BitFieldModel<uint32_t, 3, 3>\
    \ fs;\n      BitFieldModel<uint32_t, 2, 1> dmdis;\n      BitFieldModel<uint32_t,\
    \ 0, 2> fth;\n    };\n  };\n\npublic:\n  using s0fcr = S0fcrReg<BaseAddress +\
    \ 0x0024>;\n\nprivate:\n  template<unsigned int address>\n  class S1crReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using chsel = FieldModel<uint32_t,\
    \ address, 25, 3>;\n    using mburst = FieldModel<uint32_t, address, 23, 2>;\n\
    \    using pburst = FieldModel<uint32_t, address, 21, 2>;\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using pl = FieldModel<uint32_t, address, 16, 2>;\n    using pincos = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using msize = FieldModel<uint32_t, address, 13, 2>;\n\
    \    using psize = FieldModel<uint32_t, address, 11, 2>;\n    using minc = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using pinc = FieldModel<uint32_t, address, 9, 1>;\n  \
    \  using circ = FieldModel<uint32_t, address, 8, 1>;\n    using dir = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using tcie = FieldModel<uint32_t, address, 4, 1>;\n    using htie = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using teie = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using dmeie = FieldModel<uint32_t, address, 1, 1>;\n    using en = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 25, 3> chsel;\n      BitFieldModel<uint32_t, 23,\
    \ 2> mburst;\n      BitFieldModel<uint32_t, 21, 2> pburst;\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pl;\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      BitFieldModel<uint32_t, 11, 2> psize;\n      BitFieldModel<uint32_t,\
    \ 10, 1> minc;\n      BitFieldModel<uint32_t, 9, 1> pinc;\n      BitFieldModel<uint32_t,\
    \ 8, 1> circ;\n      BitFieldModel<uint32_t, 6, 2> dir;\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      BitFieldModel<uint32_t, 4, 1> tcie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      BitFieldModel<uint32_t, 2, 1> teie;\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n\
    \  using s1cr = S1crReg<BaseAddress + 0x0028>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S1ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ndt = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> ndt;\n    };\n  };\n\npublic:\n  using s1ndtr = S1ndtrReg<BaseAddress +\
    \ 0x002C>;\n\nprivate:\n  template<unsigned int address>\n  class S1parReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using pa = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n  using s1par\
    \ = S1parReg<BaseAddress + 0x0030>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S1m0arReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> m0a;\n\
    \    };\n  };\n\npublic:\n  using s1m0ar = S1m0arReg<BaseAddress + 0x0034>;\n\n\
    private:\n  template<unsigned int address>\n  class S1m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> m1a;\n    };\n  };\n\npublic:\n  using s1m1ar = S1m1arReg<BaseAddress\
    \ + 0x0038>;\n\nprivate:\n  template<unsigned int address>\n  class S1fcrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using feie = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using fs = FieldModel<uint32_t, address, 3, 3>;\n    using\
    \ dmdis = FieldModel<uint32_t, address, 2, 1>;\n    using fth = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> feie;\n      BitFieldModel<uint32_t, 3, 3>\
    \ fs;\n      BitFieldModel<uint32_t, 2, 1> dmdis;\n      BitFieldModel<uint32_t,\
    \ 0, 2> fth;\n    };\n  };\n\npublic:\n  using s1fcr = S1fcrReg<BaseAddress +\
    \ 0x003C>;\n\nprivate:\n  template<unsigned int address>\n  class S2crReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using chsel = FieldModel<uint32_t,\
    \ address, 25, 3>;\n    using mburst = FieldModel<uint32_t, address, 23, 2>;\n\
    \    using pburst = FieldModel<uint32_t, address, 21, 2>;\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using pl = FieldModel<uint32_t, address, 16, 2>;\n    using pincos = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using msize = FieldModel<uint32_t, address, 13, 2>;\n\
    \    using psize = FieldModel<uint32_t, address, 11, 2>;\n    using minc = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using pinc = FieldModel<uint32_t, address, 9, 1>;\n  \
    \  using circ = FieldModel<uint32_t, address, 8, 1>;\n    using dir = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using tcie = FieldModel<uint32_t, address, 4, 1>;\n    using htie = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using teie = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using dmeie = FieldModel<uint32_t, address, 1, 1>;\n    using en = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 25, 3> chsel;\n      BitFieldModel<uint32_t, 23,\
    \ 2> mburst;\n      BitFieldModel<uint32_t, 21, 2> pburst;\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pl;\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      BitFieldModel<uint32_t, 11, 2> psize;\n      BitFieldModel<uint32_t,\
    \ 10, 1> minc;\n      BitFieldModel<uint32_t, 9, 1> pinc;\n      BitFieldModel<uint32_t,\
    \ 8, 1> circ;\n      BitFieldModel<uint32_t, 6, 2> dir;\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      BitFieldModel<uint32_t, 4, 1> tcie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      BitFieldModel<uint32_t, 2, 1> teie;\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n\
    \  using s2cr = S2crReg<BaseAddress + 0x0040>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S2ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ndt = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> ndt;\n    };\n  };\n\npublic:\n  using s2ndtr = S2ndtrReg<BaseAddress +\
    \ 0x0044>;\n\nprivate:\n  template<unsigned int address>\n  class S2parReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using pa = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n  using s2par\
    \ = S2parReg<BaseAddress + 0x0048>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S2m0arReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> m0a;\n\
    \    };\n  };\n\npublic:\n  using s2m0ar = S2m0arReg<BaseAddress + 0x004C>;\n\n\
    private:\n  template<unsigned int address>\n  class S2m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> m1a;\n    };\n  };\n\npublic:\n  using s2m1ar = S2m1arReg<BaseAddress\
    \ + 0x0050>;\n\nprivate:\n  template<unsigned int address>\n  class S2fcrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using feie = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using fs = FieldModel<uint32_t, address, 3, 3>;\n    using\
    \ dmdis = FieldModel<uint32_t, address, 2, 1>;\n    using fth = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> feie;\n      BitFieldModel<uint32_t, 3, 3>\
    \ fs;\n      BitFieldModel<uint32_t, 2, 1> dmdis;\n      BitFieldModel<uint32_t,\
    \ 0, 2> fth;\n    };\n  };\n\npublic:\n  using s2fcr = S2fcrReg<BaseAddress +\
    \ 0x0054>;\n\nprivate:\n  template<unsigned int address>\n  class S3crReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using chsel = FieldModel<uint32_t,\
    \ address, 25, 3>;\n    using mburst = FieldModel<uint32_t, address, 23, 2>;\n\
    \    using pburst = FieldModel<uint32_t, address, 21, 2>;\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using pl = FieldModel<uint32_t, address, 16, 2>;\n    using pincos = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using msize = FieldModel<uint32_t, address, 13, 2>;\n\
    \    using psize = FieldModel<uint32_t, address, 11, 2>;\n    using minc = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using pinc = FieldModel<uint32_t, address, 9, 1>;\n  \
    \  using circ = FieldModel<uint32_t, address, 8, 1>;\n    using dir = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using tcie = FieldModel<uint32_t, address, 4, 1>;\n    using htie = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using teie = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using dmeie = FieldModel<uint32_t, address, 1, 1>;\n    using en = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 25, 3> chsel;\n      BitFieldModel<uint32_t, 23,\
    \ 2> mburst;\n      BitFieldModel<uint32_t, 21, 2> pburst;\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pl;\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      BitFieldModel<uint32_t, 11, 2> psize;\n      BitFieldModel<uint32_t,\
    \ 10, 1> minc;\n      BitFieldModel<uint32_t, 9, 1> pinc;\n      BitFieldModel<uint32_t,\
    \ 8, 1> circ;\n      BitFieldModel<uint32_t, 6, 2> dir;\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      BitFieldModel<uint32_t, 4, 1> tcie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      BitFieldModel<uint32_t, 2, 1> teie;\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n\
    \  using s3cr = S3crReg<BaseAddress + 0x0058>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S3ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ndt = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> ndt;\n    };\n  };\n\npublic:\n  using s3ndtr = S3ndtrReg<BaseAddress +\
    \ 0x005C>;\n\nprivate:\n  template<unsigned int address>\n  class S3parReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using pa = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n  using s3par\
    \ = S3parReg<BaseAddress + 0x0060>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S3m0arReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> m0a;\n\
    \    };\n  };\n\npublic:\n  using s3m0ar = S3m0arReg<BaseAddress + 0x0064>;\n\n\
    private:\n  template<unsigned int address>\n  class S3m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> m1a;\n    };\n  };\n\npublic:\n  using s3m1ar = S3m1arReg<BaseAddress\
    \ + 0x0068>;\n\nprivate:\n  template<unsigned int address>\n  class S3fcrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using feie = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using fs = FieldModel<uint32_t, address, 3, 3>;\n    using\
    \ dmdis = FieldModel<uint32_t, address, 2, 1>;\n    using fth = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> feie;\n      BitFieldModel<uint32_t, 3, 3>\
    \ fs;\n      BitFieldModel<uint32_t, 2, 1> dmdis;\n      BitFieldModel<uint32_t,\
    \ 0, 2> fth;\n    };\n  };\n\npublic:\n  using s3fcr = S3fcrReg<BaseAddress +\
    \ 0x006C>;\n\nprivate:\n  template<unsigned int address>\n  class S4crReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using chsel = FieldModel<uint32_t,\
    \ address, 25, 3>;\n    using mburst = FieldModel<uint32_t, address, 23, 2>;\n\
    \    using pburst = FieldModel<uint32_t, address, 21, 2>;\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using pl = FieldModel<uint32_t, address, 16, 2>;\n    using pincos = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using msize = FieldModel<uint32_t, address, 13, 2>;\n\
    \    using psize = FieldModel<uint32_t, address, 11, 2>;\n    using minc = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using pinc = FieldModel<uint32_t, address, 9, 1>;\n  \
    \  using circ = FieldModel<uint32_t, address, 8, 1>;\n    using dir = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using tcie = FieldModel<uint32_t, address, 4, 1>;\n    using htie = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using teie = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using dmeie = FieldModel<uint32_t, address, 1, 1>;\n    using en = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 25, 3> chsel;\n      BitFieldModel<uint32_t, 23,\
    \ 2> mburst;\n      BitFieldModel<uint32_t, 21, 2> pburst;\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pl;\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      BitFieldModel<uint32_t, 11, 2> psize;\n      BitFieldModel<uint32_t,\
    \ 10, 1> minc;\n      BitFieldModel<uint32_t, 9, 1> pinc;\n      BitFieldModel<uint32_t,\
    \ 8, 1> circ;\n      BitFieldModel<uint32_t, 6, 2> dir;\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      BitFieldModel<uint32_t, 4, 1> tcie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      BitFieldModel<uint32_t, 2, 1> teie;\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n\
    \  using s4cr = S4crReg<BaseAddress + 0x0070>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S4ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ndt = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> ndt;\n    };\n  };\n\npublic:\n  using s4ndtr = S4ndtrReg<BaseAddress +\
    \ 0x0074>;\n\nprivate:\n  template<unsigned int address>\n  class S4parReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using pa = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n  using s4par\
    \ = S4parReg<BaseAddress + 0x0078>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S4m0arReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> m0a;\n\
    \    };\n  };\n\npublic:\n  using s4m0ar = S4m0arReg<BaseAddress + 0x007C>;\n\n\
    private:\n  template<unsigned int address>\n  class S4m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> m1a;\n    };\n  };\n\npublic:\n  using s4m1ar = S4m1arReg<BaseAddress\
    \ + 0x0080>;\n\nprivate:\n  template<unsigned int address>\n  class S4fcrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using feie = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using fs = FieldModel<uint32_t, address, 3, 3>;\n    using\
    \ dmdis = FieldModel<uint32_t, address, 2, 1>;\n    using fth = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> feie;\n      BitFieldModel<uint32_t, 3, 3>\
    \ fs;\n      BitFieldModel<uint32_t, 2, 1> dmdis;\n      BitFieldModel<uint32_t,\
    \ 0, 2> fth;\n    };\n  };\n\npublic:\n  using s4fcr = S4fcrReg<BaseAddress +\
    \ 0x0084>;\n\nprivate:\n  template<unsigned int address>\n  class S5crReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using chsel = FieldModel<uint32_t,\
    \ address, 25, 3>;\n    using mburst = FieldModel<uint32_t, address, 23, 2>;\n\
    \    using pburst = FieldModel<uint32_t, address, 21, 2>;\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using pl = FieldModel<uint32_t, address, 16, 2>;\n    using pincos = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using msize = FieldModel<uint32_t, address, 13, 2>;\n\
    \    using psize = FieldModel<uint32_t, address, 11, 2>;\n    using minc = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using pinc = FieldModel<uint32_t, address, 9, 1>;\n  \
    \  using circ = FieldModel<uint32_t, address, 8, 1>;\n    using dir = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using tcie = FieldModel<uint32_t, address, 4, 1>;\n    using htie = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using teie = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using dmeie = FieldModel<uint32_t, address, 1, 1>;\n    using en = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 25, 3> chsel;\n      BitFieldModel<uint32_t, 23,\
    \ 2> mburst;\n      BitFieldModel<uint32_t, 21, 2> pburst;\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pl;\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      BitFieldModel<uint32_t, 11, 2> psize;\n      BitFieldModel<uint32_t,\
    \ 10, 1> minc;\n      BitFieldModel<uint32_t, 9, 1> pinc;\n      BitFieldModel<uint32_t,\
    \ 8, 1> circ;\n      BitFieldModel<uint32_t, 6, 2> dir;\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      BitFieldModel<uint32_t, 4, 1> tcie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      BitFieldModel<uint32_t, 2, 1> teie;\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n\
    \  using s5cr = S5crReg<BaseAddress + 0x0088>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S5ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ndt = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> ndt;\n    };\n  };\n\npublic:\n  using s5ndtr = S5ndtrReg<BaseAddress +\
    \ 0x008C>;\n\nprivate:\n  template<unsigned int address>\n  class S5parReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using pa = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n  using s5par\
    \ = S5parReg<BaseAddress + 0x0090>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S5m0arReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> m0a;\n\
    \    };\n  };\n\npublic:\n  using s5m0ar = S5m0arReg<BaseAddress + 0x0094>;\n\n\
    private:\n  template<unsigned int address>\n  class S5m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> m1a;\n    };\n  };\n\npublic:\n  using s5m1ar = S5m1arReg<BaseAddress\
    \ + 0x0098>;\n\nprivate:\n  template<unsigned int address>\n  class S5fcrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using feie = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using fs = FieldModel<uint32_t, address, 3, 3>;\n    using\
    \ dmdis = FieldModel<uint32_t, address, 2, 1>;\n    using fth = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> feie;\n      BitFieldModel<uint32_t, 3, 3>\
    \ fs;\n      BitFieldModel<uint32_t, 2, 1> dmdis;\n      BitFieldModel<uint32_t,\
    \ 0, 2> fth;\n    };\n  };\n\npublic:\n  using s5fcr = S5fcrReg<BaseAddress +\
    \ 0x009C>;\n\nprivate:\n  template<unsigned int address>\n  class S6crReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using chsel = FieldModel<uint32_t,\
    \ address, 25, 3>;\n    using mburst = FieldModel<uint32_t, address, 23, 2>;\n\
    \    using pburst = FieldModel<uint32_t, address, 21, 2>;\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using pl = FieldModel<uint32_t, address, 16, 2>;\n    using pincos = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using msize = FieldModel<uint32_t, address, 13, 2>;\n\
    \    using psize = FieldModel<uint32_t, address, 11, 2>;\n    using minc = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using pinc = FieldModel<uint32_t, address, 9, 1>;\n  \
    \  using circ = FieldModel<uint32_t, address, 8, 1>;\n    using dir = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using tcie = FieldModel<uint32_t, address, 4, 1>;\n    using htie = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using teie = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using dmeie = FieldModel<uint32_t, address, 1, 1>;\n    using en = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 25, 3> chsel;\n      BitFieldModel<uint32_t, 23,\
    \ 2> mburst;\n      BitFieldModel<uint32_t, 21, 2> pburst;\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pl;\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      BitFieldModel<uint32_t, 11, 2> psize;\n      BitFieldModel<uint32_t,\
    \ 10, 1> minc;\n      BitFieldModel<uint32_t, 9, 1> pinc;\n      BitFieldModel<uint32_t,\
    \ 8, 1> circ;\n      BitFieldModel<uint32_t, 6, 2> dir;\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      BitFieldModel<uint32_t, 4, 1> tcie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      BitFieldModel<uint32_t, 2, 1> teie;\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n\
    \  using s6cr = S6crReg<BaseAddress + 0x00A0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S6ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ndt = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> ndt;\n    };\n  };\n\npublic:\n  using s6ndtr = S6ndtrReg<BaseAddress +\
    \ 0x00A4>;\n\nprivate:\n  template<unsigned int address>\n  class S6parReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using pa = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n  using s6par\
    \ = S6parReg<BaseAddress + 0x00A8>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S6m0arReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> m0a;\n\
    \    };\n  };\n\npublic:\n  using s6m0ar = S6m0arReg<BaseAddress + 0x00AC>;\n\n\
    private:\n  template<unsigned int address>\n  class S6m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> m1a;\n    };\n  };\n\npublic:\n  using s6m1ar = S6m1arReg<BaseAddress\
    \ + 0x00B0>;\n\nprivate:\n  template<unsigned int address>\n  class S6fcrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using feie = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using fs = FieldModel<uint32_t, address, 3, 3>;\n    using\
    \ dmdis = FieldModel<uint32_t, address, 2, 1>;\n    using fth = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> feie;\n      BitFieldModel<uint32_t, 3, 3>\
    \ fs;\n      BitFieldModel<uint32_t, 2, 1> dmdis;\n      BitFieldModel<uint32_t,\
    \ 0, 2> fth;\n    };\n  };\n\npublic:\n  using s6fcr = S6fcrReg<BaseAddress +\
    \ 0x00B4>;\n\nprivate:\n  template<unsigned int address>\n  class S7crReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using chsel = FieldModel<uint32_t,\
    \ address, 25, 3>;\n    using mburst = FieldModel<uint32_t, address, 23, 2>;\n\
    \    using pburst = FieldModel<uint32_t, address, 21, 2>;\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using pl = FieldModel<uint32_t, address, 16, 2>;\n    using pincos = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using msize = FieldModel<uint32_t, address, 13, 2>;\n\
    \    using psize = FieldModel<uint32_t, address, 11, 2>;\n    using minc = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using pinc = FieldModel<uint32_t, address, 9, 1>;\n  \
    \  using circ = FieldModel<uint32_t, address, 8, 1>;\n    using dir = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using tcie = FieldModel<uint32_t, address, 4, 1>;\n    using htie = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using teie = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using dmeie = FieldModel<uint32_t, address, 1, 1>;\n    using en = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 25, 3> chsel;\n      BitFieldModel<uint32_t, 23,\
    \ 2> mburst;\n      BitFieldModel<uint32_t, 21, 2> pburst;\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pl;\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      BitFieldModel<uint32_t, 11, 2> psize;\n      BitFieldModel<uint32_t,\
    \ 10, 1> minc;\n      BitFieldModel<uint32_t, 9, 1> pinc;\n      BitFieldModel<uint32_t,\
    \ 8, 1> circ;\n      BitFieldModel<uint32_t, 6, 2> dir;\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      BitFieldModel<uint32_t, 4, 1> tcie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      BitFieldModel<uint32_t, 2, 1> teie;\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n\
    \  using s7cr = S7crReg<BaseAddress + 0x00B8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S7ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ndt = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> ndt;\n    };\n  };\n\npublic:\n  using s7ndtr = S7ndtrReg<BaseAddress +\
    \ 0x00BC>;\n\nprivate:\n  template<unsigned int address>\n  class S7parReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using pa = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n  using s7par\
    \ = S7parReg<BaseAddress + 0x00C0>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S7m0arReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> m0a;\n\
    \    };\n  };\n\npublic:\n  using s7m0ar = S7m0arReg<BaseAddress + 0x00C4>;\n\n\
    private:\n  template<unsigned int address>\n  class S7m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> m1a;\n    };\n  };\n\npublic:\n  using s7m1ar = S7m1arReg<BaseAddress\
    \ + 0x00C8>;\n\nprivate:\n  template<unsigned int address>\n  class S7fcrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using feie = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using fs = FieldModel<uint32_t, address, 3, 3>;\n    using\
    \ dmdis = FieldModel<uint32_t, address, 2, 1>;\n    using fth = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> feie;\n      BitFieldModel<uint32_t, 3, 3>\
    \ fs;\n      BitFieldModel<uint32_t, 2, 1> dmdis;\n      BitFieldModel<uint32_t,\
    \ 0, 2> fth;\n    };\n  };\n\npublic:\n  using s7fcr = S7fcrReg<BaseAddress +\
    \ 0x00CC>;\n\nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n\
    \  class SxcrBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n\
    \  {\n  public:\n    using chsel = FieldModel<uint32_t, address, 25, 3, bankOffset>;\n\
    \    using mburst = FieldModel<uint32_t, address, 23, 2, bankOffset>;\n    using\
    \ pburst = FieldModel<uint32_t, address, 21, 2, bankOffset>;\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1, bankOffset>;\n    using dbm = FieldModel<uint32_t, address,\
    \ 18, 1, bankOffset>;\n    using pl = FieldModel<uint32_t, address, 16, 2, bankOffset>;\n\
    \    using pincos = FieldModel<uint32_t, address, 15, 1, bankOffset>;\n    using\
    \ msize = FieldModel<uint32_t, address, 13, 2, bankOffset>;\n    using psize =\
    \ FieldModel<uint32_t, address, 11, 2, bankOffset>;\n    using minc = FieldModel<uint32_t,\
    \ address, 10, 1, bankOffset>;\n    using pinc = FieldModel<uint32_t, address,\
    \ 9, 1, bankOffset>;\n    using circ = FieldModel<uint32_t, address, 8, 1, bankOffset>;\n\
    \    using dir = FieldModel<uint32_t, address, 6, 2, bankOffset>;\n    using pfctrl\
    \ = FieldModel<uint32_t, address, 5, 1, bankOffset>;\n    using tcie = FieldModel<uint32_t,\
    \ address, 4, 1, bankOffset>;\n    using htie = FieldModel<uint32_t, address,\
    \ 3, 1, bankOffset>;\n    using teie = FieldModel<uint32_t, address, 2, 1, bankOffset>;\n\
    \    using dmeie = FieldModel<uint32_t, address, 1, 1, bankOffset>;\n    using\
    \ en = FieldModel<uint32_t, address, 0, 1, bankOffset>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 25, 3> chsel;\n\
    \      BitFieldModel<uint32_t, 23, 2> mburst;\n      BitFieldModel<uint32_t, 21,\
    \ 2> pburst;\n      BitFieldModel<uint32_t, 19, 1> ct;\n      BitFieldModel<uint32_t,\
    \ 18, 1> dbm;\n      BitFieldModel<uint32_t, 16, 2> pl;\n      BitFieldModel<uint32_t,\
    \ 15, 1> pincos;\n      BitFieldModel<uint32_t, 13, 2> msize;\n      BitFieldModel<uint32_t,\
    \ 11, 2> psize;\n      BitFieldModel<uint32_t, 10, 1> minc;\n      BitFieldModel<uint32_t,\
    \ 9, 1> pinc;\n      BitFieldModel<uint32_t, 8, 1> circ;\n      BitFieldModel<uint32_t,\
    \ 6, 2> dir;\n      BitFieldModel<uint32_t, 5, 1> pfctrl;\n      BitFieldModel<uint32_t,\
    \ 4, 1> tcie;\n      BitFieldModel<uint32_t, 3, 1> htie;\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      BitFieldModel<uint32_t, 1, 1> dmeie;\n      BitFieldModel<uint32_t,\
    \ 0, 1> en;\n    };\n  };\n\npublic:\n  using sxcr = SxcrBankReg<BaseAddress +\
    \ 0x0010, 0x0018>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class SxndtrBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using ndt = FieldModel<uint32_t, address, 0,\
    \ 16, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> ndt;\n    };\n  };\n\npublic:\n  using sxndtr\
    \ = SxndtrBankReg<BaseAddress + 0x0014, 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class SxparBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using pa = FieldModel<uint32_t, address,\
    \ 0, 32, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n  using sxpar\
    \ = SxparBankReg<BaseAddress + 0x0018, 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class Sxm0arBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using m0a = FieldModel<uint32_t, address,\
    \ 0, 32, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> m0a;\n    };\n  };\n\npublic:\n  using sxm0ar\
    \ = Sxm0arBankReg<BaseAddress + 0x001C, 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class Sxm1arBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using m1a = FieldModel<uint32_t, address,\
    \ 0, 32, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> m1a;\n    };\n  };\n\npublic:\n  using sxm1ar\
    \ = Sxm1arBankReg<BaseAddress + 0x0020, 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class SxfcrBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using feie = FieldModel<uint32_t,\
    \ address, 7, 1, bankOffset>;\n    using fs = FieldModel<uint32_t, address, 3,\
    \ 3, bankOffset>;\n    using dmdis = FieldModel<uint32_t, address, 2, 1, bankOffset>;\n\
    \    using fth = FieldModel<uint32_t, address, 0, 2, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 7,\
    \ 1> feie;\n      BitFieldModel<uint32_t, 3, 3> fs;\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmdis;\n      BitFieldModel<uint32_t, 0, 2> fth;\n    };\n  };\n\npublic:\n\
    \  using sxfcr = SxfcrBankReg<BaseAddress + 0x0024, 0x0018>;\n};\n\n}\n\n#endif\
    \ /* DRAL_STM32F446_DMA1_H */\n"
  name: DMA1
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_RCC_H\n#define DRAL_STM32F446_RCC_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass rcc\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40023800;\n\nprivate:\n\
    \  template<unsigned int address>\n  class CrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using plli2srdy = FieldModel<uint32_t, address,\
    \ 27, 1>;\n    using plli2son = FieldModel<uint32_t, address, 26, 1>;\n    using\
    \ pllrdy = FieldModel<uint32_t, address, 25, 1>;\n    using pllon = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    using csson = FieldModel<uint32_t, address, 19, 1>;\n\
    \    using hsebyp = FieldModel<uint32_t, address, 18, 1>;\n    using hserdy =\
    \ FieldModel<uint32_t, address, 17, 1>;\n    using hseon = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using hsical = FieldModel<uint32_t, address, 8, 8>;\n\
    \    using hsitrim = FieldModel<uint32_t, address, 3, 5>;\n    using hsirdy =\
    \ FieldModel<uint32_t, address, 1, 1>;\n    using hsion = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 27, 1> plli2srdy;\n      BitFieldModel<uint32_t,\
    \ 26, 1> plli2son;\n      BitFieldModel<uint32_t, 25, 1> pllrdy;\n      BitFieldModel<uint32_t,\
    \ 24, 1> pllon;\n      BitFieldModel<uint32_t, 19, 1> csson;\n      BitFieldModel<uint32_t,\
    \ 18, 1> hsebyp;\n      BitFieldModel<uint32_t, 17, 1> hserdy;\n      BitFieldModel<uint32_t,\
    \ 16, 1> hseon;\n      BitFieldModel<uint32_t, 8, 8> hsical;\n      BitFieldModel<uint32_t,\
    \ 3, 5> hsitrim;\n      BitFieldModel<uint32_t, 1, 1> hsirdy;\n      BitFieldModel<uint32_t,\
    \ 0, 1> hsion;\n    };\n  };\n\npublic:\n  using cr = CrReg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class PllcfgrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using pllq3 = FieldModel<uint32_t, address, 27,\
    \ 1>;\n    using pllq2 = FieldModel<uint32_t, address, 26, 1>;\n    using pllq1\
    \ = FieldModel<uint32_t, address, 25, 1>;\n    using pllq0 = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    using pllsrc = FieldModel<uint32_t, address, 22, 1>;\n\
    \    using pllp1 = FieldModel<uint32_t, address, 17, 1>;\n    using pllp0 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using plln8 = FieldModel<uint32_t, address, 14, 1>;\n\
    \    using plln7 = FieldModel<uint32_t, address, 13, 1>;\n    using plln6 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using plln5 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using plln4 = FieldModel<uint32_t, address, 10, 1>;\n    using plln3 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using plln2 = FieldModel<uint32_t, address, 8, 1>;\n  \
    \  using plln1 = FieldModel<uint32_t, address, 7, 1>;\n    using plln0 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using pllm5 = FieldModel<uint32_t, address, 5, 1>;\n  \
    \  using pllm4 = FieldModel<uint32_t, address, 4, 1>;\n    using pllm3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using pllm2 = FieldModel<uint32_t, address, 2, 1>;\n  \
    \  using pllm1 = FieldModel<uint32_t, address, 1, 1>;\n    using pllm0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 27, 1> pllq3;\n      BitFieldModel<uint32_t, 26,\
    \ 1> pllq2;\n      BitFieldModel<uint32_t, 25, 1> pllq1;\n      BitFieldModel<uint32_t,\
    \ 24, 1> pllq0;\n      BitFieldModel<uint32_t, 22, 1> pllsrc;\n      BitFieldModel<uint32_t,\
    \ 17, 1> pllp1;\n      BitFieldModel<uint32_t, 16, 1> pllp0;\n      BitFieldModel<uint32_t,\
    \ 14, 1> plln8;\n      BitFieldModel<uint32_t, 13, 1> plln7;\n      BitFieldModel<uint32_t,\
    \ 12, 1> plln6;\n      BitFieldModel<uint32_t, 11, 1> plln5;\n      BitFieldModel<uint32_t,\
    \ 10, 1> plln4;\n      BitFieldModel<uint32_t, 9, 1> plln3;\n      BitFieldModel<uint32_t,\
    \ 8, 1> plln2;\n      BitFieldModel<uint32_t, 7, 1> plln1;\n      BitFieldModel<uint32_t,\
    \ 6, 1> plln0;\n      BitFieldModel<uint32_t, 5, 1> pllm5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> pllm4;\n      BitFieldModel<uint32_t, 3, 1> pllm3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> pllm2;\n      BitFieldModel<uint32_t, 1, 1> pllm1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> pllm0;\n    };\n  };\n\npublic:\n  using pllcfgr = PllcfgrReg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class CfgrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mco2 = FieldModel<uint32_t,\
    \ address, 30, 2>;\n    using mco2pre = FieldModel<uint32_t, address, 27, 3>;\n\
    \    using mco1pre = FieldModel<uint32_t, address, 24, 3>;\n    using i2ssrc =\
    \ FieldModel<uint32_t, address, 23, 1>;\n    using mco1 = FieldModel<uint32_t,\
    \ address, 21, 2>;\n    using rtcpre = FieldModel<uint32_t, address, 16, 5>;\n\
    \    using ppre2 = FieldModel<uint32_t, address, 13, 3>;\n    using ppre1 = FieldModel<uint32_t,\
    \ address, 10, 3>;\n    using hpre = FieldModel<uint32_t, address, 4, 4>;\n  \
    \  using sws1 = FieldModel<uint32_t, address, 3, 1>;\n    using sws0 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using sw1 = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ sw0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n   \
    \ {\n      uint32_t value;\n      BitFieldModel<uint32_t, 30, 2> mco2;\n     \
    \ BitFieldModel<uint32_t, 27, 3> mco2pre;\n      BitFieldModel<uint32_t, 24, 3>\
    \ mco1pre;\n      BitFieldModel<uint32_t, 23, 1> i2ssrc;\n      BitFieldModel<uint32_t,\
    \ 21, 2> mco1;\n      BitFieldModel<uint32_t, 16, 5> rtcpre;\n      BitFieldModel<uint32_t,\
    \ 13, 3> ppre2;\n      BitFieldModel<uint32_t, 10, 3> ppre1;\n      BitFieldModel<uint32_t,\
    \ 4, 4> hpre;\n      BitFieldModel<uint32_t, 3, 1> sws1;\n      BitFieldModel<uint32_t,\
    \ 2, 1> sws0;\n      BitFieldModel<uint32_t, 1, 1> sw1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> sw0;\n    };\n  };\n\npublic:\n  using cfgr = CfgrReg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CirReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cssc = FieldModel<uint32_t, address, 23,\
    \ 1>;\n    using pllsairdyc = FieldModel<uint32_t, address, 22, 1>;\n    using\
    \ plli2srdyc = FieldModel<uint32_t, address, 21, 1>;\n    using pllrdyc = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using hserdyc = FieldModel<uint32_t, address, 19, 1>;\n\
    \    using hsirdyc = FieldModel<uint32_t, address, 18, 1>;\n    using lserdyc\
    \ = FieldModel<uint32_t, address, 17, 1>;\n    using lsirdyc = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using pllsairdyie = FieldModel<uint32_t, address, 14,\
    \ 1>;\n    using plli2srdyie = FieldModel<uint32_t, address, 13, 1>;\n    using\
    \ pllrdyie = FieldModel<uint32_t, address, 12, 1>;\n    using hserdyie = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using hsirdyie = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using lserdyie = FieldModel<uint32_t, address, 9, 1>;\n    using lsirdyie\
    \ = FieldModel<uint32_t, address, 8, 1>;\n    using cssf = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using pllsairdyf = FieldModel<uint32_t, address, 6, 1>;\n\
    \    using plli2srdyf = FieldModel<uint32_t, address, 5, 1>;\n    using pllrdyf\
    \ = FieldModel<uint32_t, address, 4, 1>;\n    using hserdyf = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using hsirdyf = FieldModel<uint32_t, address, 2, 1>;\n\
    \    using lserdyf = FieldModel<uint32_t, address, 1, 1>;\n    using lsirdyf =\
    \ FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n    {\n  \
    \    uint32_t value;\n      BitFieldModel<uint32_t, 23, 1> cssc;\n      BitFieldModel<uint32_t,\
    \ 22, 1> pllsairdyc;\n      BitFieldModel<uint32_t, 21, 1> plli2srdyc;\n     \
    \ BitFieldModel<uint32_t, 20, 1> pllrdyc;\n      BitFieldModel<uint32_t, 19, 1>\
    \ hserdyc;\n      BitFieldModel<uint32_t, 18, 1> hsirdyc;\n      BitFieldModel<uint32_t,\
    \ 17, 1> lserdyc;\n      BitFieldModel<uint32_t, 16, 1> lsirdyc;\n      BitFieldModel<uint32_t,\
    \ 14, 1> pllsairdyie;\n      BitFieldModel<uint32_t, 13, 1> plli2srdyie;\n   \
    \   BitFieldModel<uint32_t, 12, 1> pllrdyie;\n      BitFieldModel<uint32_t, 11,\
    \ 1> hserdyie;\n      BitFieldModel<uint32_t, 10, 1> hsirdyie;\n      BitFieldModel<uint32_t,\
    \ 9, 1> lserdyie;\n      BitFieldModel<uint32_t, 8, 1> lsirdyie;\n      BitFieldModel<uint32_t,\
    \ 7, 1> cssf;\n      BitFieldModel<uint32_t, 6, 1> pllsairdyf;\n      BitFieldModel<uint32_t,\
    \ 5, 1> plli2srdyf;\n      BitFieldModel<uint32_t, 4, 1> pllrdyf;\n      BitFieldModel<uint32_t,\
    \ 3, 1> hserdyf;\n      BitFieldModel<uint32_t, 2, 1> hsirdyf;\n      BitFieldModel<uint32_t,\
    \ 1, 1> lserdyf;\n      BitFieldModel<uint32_t, 0, 1> lsirdyf;\n    };\n  };\n\
    \npublic:\n  using cir = CirReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ahb1rstrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using otghsrst = FieldModel<uint32_t, address, 29, 1>;\n\
    \    using dma2rst = FieldModel<uint32_t, address, 22, 1>;\n    using dma1rst\
    \ = FieldModel<uint32_t, address, 21, 1>;\n    using crcrst = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using gpiohrst = FieldModel<uint32_t, address, 7, 1>;\n\
    \    using gpiogrst = FieldModel<uint32_t, address, 6, 1>;\n    using gpiofrst\
    \ = FieldModel<uint32_t, address, 5, 1>;\n    using gpioerst = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using gpiodrst = FieldModel<uint32_t, address, 3, 1>;\n\
    \    using gpiocrst = FieldModel<uint32_t, address, 2, 1>;\n    using gpiobrst\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using gpioarst = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 29, 1> otghsrst;\n      BitFieldModel<uint32_t,\
    \ 22, 1> dma2rst;\n      BitFieldModel<uint32_t, 21, 1> dma1rst;\n      BitFieldModel<uint32_t,\
    \ 12, 1> crcrst;\n      BitFieldModel<uint32_t, 7, 1> gpiohrst;\n      BitFieldModel<uint32_t,\
    \ 6, 1> gpiogrst;\n      BitFieldModel<uint32_t, 5, 1> gpiofrst;\n      BitFieldModel<uint32_t,\
    \ 4, 1> gpioerst;\n      BitFieldModel<uint32_t, 3, 1> gpiodrst;\n      BitFieldModel<uint32_t,\
    \ 2, 1> gpiocrst;\n      BitFieldModel<uint32_t, 1, 1> gpiobrst;\n      BitFieldModel<uint32_t,\
    \ 0, 1> gpioarst;\n    };\n  };\n\npublic:\n  using ahb1rstr = Ahb1rstrReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class Ahb2rstrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using otgfsrst\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    using dcmirst = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> otgfsrst;\n      BitFieldModel<uint32_t,\
    \ 0, 1> dcmirst;\n    };\n  };\n\npublic:\n  using ahb2rstr = Ahb2rstrReg<BaseAddress\
    \ + 0x0014>;\n\nprivate:\n  template<unsigned int address>\n  class Ahb3rstrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using fmcrst\
    \ = FieldModel<uint32_t, address, 0, 1>;\n    using qspirst = FieldModel<uint32_t,\
    \ address, 1, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> fmcrst;\n      BitFieldModel<uint32_t, 1,\
    \ 1> qspirst;\n    };\n  };\n\npublic:\n  using ahb3rstr = Ahb3rstrReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class Apb1rstrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using tim2rst\
    \ = FieldModel<uint32_t, address, 0, 1>;\n    using tim3rst = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using tim4rst = FieldModel<uint32_t, address, 2, 1>;\n\
    \    using tim5rst = FieldModel<uint32_t, address, 3, 1>;\n    using tim6rst =\
    \ FieldModel<uint32_t, address, 4, 1>;\n    using tim7rst = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using tim12rst = FieldModel<uint32_t, address, 6, 1>;\n\
    \    using tim13rst = FieldModel<uint32_t, address, 7, 1>;\n    using tim14rst\
    \ = FieldModel<uint32_t, address, 8, 1>;\n    using wwdgrst = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using spi2rst = FieldModel<uint32_t, address, 14, 1>;\n\
    \    using spi3rst = FieldModel<uint32_t, address, 15, 1>;\n    using spdifrst\
    \ = FieldModel<uint32_t, address, 16, 1>;\n    using uart2rst = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using uart3rst = FieldModel<uint32_t, address, 18, 1>;\n\
    \    using uart4rst = FieldModel<uint32_t, address, 19, 1>;\n    using uart5rst\
    \ = FieldModel<uint32_t, address, 20, 1>;\n    using i2c1rst = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    using i2c2rst = FieldModel<uint32_t, address, 22, 1>;\n\
    \    using i2c3rst = FieldModel<uint32_t, address, 23, 1>;\n    using i2cfmp1rst\
    \ = FieldModel<uint32_t, address, 24, 1>;\n    using can1rst = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using can2rst = FieldModel<uint32_t, address, 26, 1>;\n\
    \    using pwrrst = FieldModel<uint32_t, address, 28, 1>;\n    using dacrst =\
    \ FieldModel<uint32_t, address, 29, 1>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> tim2rst;\n      BitFieldModel<uint32_t,\
    \ 1, 1> tim3rst;\n      BitFieldModel<uint32_t, 2, 1> tim4rst;\n      BitFieldModel<uint32_t,\
    \ 3, 1> tim5rst;\n      BitFieldModel<uint32_t, 4, 1> tim6rst;\n      BitFieldModel<uint32_t,\
    \ 5, 1> tim7rst;\n      BitFieldModel<uint32_t, 6, 1> tim12rst;\n      BitFieldModel<uint32_t,\
    \ 7, 1> tim13rst;\n      BitFieldModel<uint32_t, 8, 1> tim14rst;\n      BitFieldModel<uint32_t,\
    \ 11, 1> wwdgrst;\n      BitFieldModel<uint32_t, 14, 1> spi2rst;\n      BitFieldModel<uint32_t,\
    \ 15, 1> spi3rst;\n      BitFieldModel<uint32_t, 16, 1> spdifrst;\n      BitFieldModel<uint32_t,\
    \ 17, 1> uart2rst;\n      BitFieldModel<uint32_t, 18, 1> uart3rst;\n      BitFieldModel<uint32_t,\
    \ 19, 1> uart4rst;\n      BitFieldModel<uint32_t, 20, 1> uart5rst;\n      BitFieldModel<uint32_t,\
    \ 21, 1> i2c1rst;\n      BitFieldModel<uint32_t, 22, 1> i2c2rst;\n      BitFieldModel<uint32_t,\
    \ 23, 1> i2c3rst;\n      BitFieldModel<uint32_t, 24, 1> i2cfmp1rst;\n      BitFieldModel<uint32_t,\
    \ 25, 1> can1rst;\n      BitFieldModel<uint32_t, 26, 1> can2rst;\n      BitFieldModel<uint32_t,\
    \ 28, 1> pwrrst;\n      BitFieldModel<uint32_t, 29, 1> dacrst;\n    };\n  };\n\
    \npublic:\n  using apb1rstr = Apb1rstrReg<BaseAddress + 0x0020>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Apb2rstrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using tim1rst = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    using tim8rst = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ usart1rst = FieldModel<uint32_t, address, 4, 1>;\n    using usart6rst = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using adcrst = FieldModel<uint32_t, address, 8, 1>;\n \
    \   using sdiorst = FieldModel<uint32_t, address, 11, 1>;\n    using spi1rst =\
    \ FieldModel<uint32_t, address, 12, 1>;\n    using spi4rst = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using syscfgrst = FieldModel<uint32_t, address, 14, 1>;\n\
    \    using tim9rst = FieldModel<uint32_t, address, 16, 1>;\n    using tim10rst\
    \ = FieldModel<uint32_t, address, 17, 1>;\n    using tim11rst = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    using sai1rst = FieldModel<uint32_t, address, 22, 1>;\n\
    \    using sai2rst = FieldModel<uint32_t, address, 23, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> tim1rst;\n\
    \      BitFieldModel<uint32_t, 1, 1> tim8rst;\n      BitFieldModel<uint32_t, 4,\
    \ 1> usart1rst;\n      BitFieldModel<uint32_t, 5, 1> usart6rst;\n      BitFieldModel<uint32_t,\
    \ 8, 1> adcrst;\n      BitFieldModel<uint32_t, 11, 1> sdiorst;\n      BitFieldModel<uint32_t,\
    \ 12, 1> spi1rst;\n      BitFieldModel<uint32_t, 13, 1> spi4rst;\n      BitFieldModel<uint32_t,\
    \ 14, 1> syscfgrst;\n      BitFieldModel<uint32_t, 16, 1> tim9rst;\n      BitFieldModel<uint32_t,\
    \ 17, 1> tim10rst;\n      BitFieldModel<uint32_t, 18, 1> tim11rst;\n      BitFieldModel<uint32_t,\
    \ 22, 1> sai1rst;\n      BitFieldModel<uint32_t, 23, 1> sai2rst;\n    };\n  };\n\
    \npublic:\n  using apb2rstr = Apb2rstrReg<BaseAddress + 0x0024>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Ahb1enrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using otghsulpien = FieldModel<uint32_t, address,\
    \ 30, 1>;\n    using otghsen = FieldModel<uint32_t, address, 29, 1>;\n    using\
    \ dma2en = FieldModel<uint32_t, address, 22, 1>;\n    using dma1en = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    using bkpsramen = FieldModel<uint32_t, address, 18, 1>;\n\
    \    using crcen = FieldModel<uint32_t, address, 12, 1>;\n    using gpiohen =\
    \ FieldModel<uint32_t, address, 7, 1>;\n    using gpiogen = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using gpiofen = FieldModel<uint32_t, address, 5, 1>;\n\
    \    using gpioeen = FieldModel<uint32_t, address, 4, 1>;\n    using gpioden =\
    \ FieldModel<uint32_t, address, 3, 1>;\n    using gpiocen = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using gpioben = FieldModel<uint32_t, address, 1, 1>;\n\
    \    using gpioaen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 30, 1> otghsulpien;\n\
    \      BitFieldModel<uint32_t, 29, 1> otghsen;\n      BitFieldModel<uint32_t,\
    \ 22, 1> dma2en;\n      BitFieldModel<uint32_t, 21, 1> dma1en;\n      BitFieldModel<uint32_t,\
    \ 18, 1> bkpsramen;\n      BitFieldModel<uint32_t, 12, 1> crcen;\n      BitFieldModel<uint32_t,\
    \ 7, 1> gpiohen;\n      BitFieldModel<uint32_t, 6, 1> gpiogen;\n      BitFieldModel<uint32_t,\
    \ 5, 1> gpiofen;\n      BitFieldModel<uint32_t, 4, 1> gpioeen;\n      BitFieldModel<uint32_t,\
    \ 3, 1> gpioden;\n      BitFieldModel<uint32_t, 2, 1> gpiocen;\n      BitFieldModel<uint32_t,\
    \ 1, 1> gpioben;\n      BitFieldModel<uint32_t, 0, 1> gpioaen;\n    };\n  };\n\
    \npublic:\n  using ahb1enr = Ahb1enrReg<BaseAddress + 0x0030>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Ahb2enrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using otgfsen = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    using dcmien = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 7,\
    \ 1> otgfsen;\n      BitFieldModel<uint32_t, 0, 1> dcmien;\n    };\n  };\n\npublic:\n\
    \  using ahb2enr = Ahb2enrReg<BaseAddress + 0x0034>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ahb3enrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using fmcen = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ qspien = FieldModel<uint32_t, address, 1, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fmcen;\n  \
    \    BitFieldModel<uint32_t, 1, 1> qspien;\n    };\n  };\n\npublic:\n  using ahb3enr\
    \ = Ahb3enrReg<BaseAddress + 0x0038>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Apb1enrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using tim2en = FieldModel<uint32_t, address, 0, 1>;\n    using tim3en = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using tim4en = FieldModel<uint32_t, address, 2, 1>;\n \
    \   using tim5en = FieldModel<uint32_t, address, 3, 1>;\n    using tim6en = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using tim7en = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using tim12en = FieldModel<uint32_t, address, 6, 1>;\n    using tim13en =\
    \ FieldModel<uint32_t, address, 7, 1>;\n    using tim14en = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using wwdgen = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using spi2en = FieldModel<uint32_t, address, 14, 1>;\n    using spi3en =\
    \ FieldModel<uint32_t, address, 15, 1>;\n    using spdifen = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using usart2en = FieldModel<uint32_t, address, 17, 1>;\n\
    \    using usart3en = FieldModel<uint32_t, address, 18, 1>;\n    using uart4en\
    \ = FieldModel<uint32_t, address, 19, 1>;\n    using uart5en = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using i2c1en = FieldModel<uint32_t, address, 21, 1>;\n\
    \    using i2c2en = FieldModel<uint32_t, address, 22, 1>;\n    using i2c3en =\
    \ FieldModel<uint32_t, address, 23, 1>;\n    using i2cfmp1en = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    using can1en = FieldModel<uint32_t, address, 25, 1>;\n\
    \    using can2en = FieldModel<uint32_t, address, 26, 1>;\n    using cec = FieldModel<uint32_t,\
    \ address, 27, 1>;\n    using pwren = FieldModel<uint32_t, address, 28, 1>;\n\
    \    using dacen = FieldModel<uint32_t, address, 29, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> tim2en;\n\
    \      BitFieldModel<uint32_t, 1, 1> tim3en;\n      BitFieldModel<uint32_t, 2,\
    \ 1> tim4en;\n      BitFieldModel<uint32_t, 3, 1> tim5en;\n      BitFieldModel<uint32_t,\
    \ 4, 1> tim6en;\n      BitFieldModel<uint32_t, 5, 1> tim7en;\n      BitFieldModel<uint32_t,\
    \ 6, 1> tim12en;\n      BitFieldModel<uint32_t, 7, 1> tim13en;\n      BitFieldModel<uint32_t,\
    \ 8, 1> tim14en;\n      BitFieldModel<uint32_t, 11, 1> wwdgen;\n      BitFieldModel<uint32_t,\
    \ 14, 1> spi2en;\n      BitFieldModel<uint32_t, 15, 1> spi3en;\n      BitFieldModel<uint32_t,\
    \ 16, 1> spdifen;\n      BitFieldModel<uint32_t, 17, 1> usart2en;\n      BitFieldModel<uint32_t,\
    \ 18, 1> usart3en;\n      BitFieldModel<uint32_t, 19, 1> uart4en;\n      BitFieldModel<uint32_t,\
    \ 20, 1> uart5en;\n      BitFieldModel<uint32_t, 21, 1> i2c1en;\n      BitFieldModel<uint32_t,\
    \ 22, 1> i2c2en;\n      BitFieldModel<uint32_t, 23, 1> i2c3en;\n      BitFieldModel<uint32_t,\
    \ 24, 1> i2cfmp1en;\n      BitFieldModel<uint32_t, 25, 1> can1en;\n      BitFieldModel<uint32_t,\
    \ 26, 1> can2en;\n      BitFieldModel<uint32_t, 27, 1> cec;\n      BitFieldModel<uint32_t,\
    \ 28, 1> pwren;\n      BitFieldModel<uint32_t, 29, 1> dacen;\n    };\n  };\n\n\
    public:\n  using apb1enr = Apb1enrReg<BaseAddress + 0x0040>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Apb2enrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using tim1en = FieldModel<uint32_t, address, 0, 1>;\n   \
    \ using tim8en = FieldModel<uint32_t, address, 1, 1>;\n    using usart1en = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using usart6en = FieldModel<uint32_t, address, 5, 1>;\n\
    \    using adc1en = FieldModel<uint32_t, address, 8, 1>;\n    using adc2en = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using adc3en = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using sdioen = FieldModel<uint32_t, address, 11, 1>;\n    using spi1en =\
    \ FieldModel<uint32_t, address, 12, 1>;\n    using spi4enr = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using syscfgen = FieldModel<uint32_t, address, 14, 1>;\n\
    \    using tim9en = FieldModel<uint32_t, address, 16, 1>;\n    using tim10en =\
    \ FieldModel<uint32_t, address, 17, 1>;\n    using tim11en = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    using sai1en = FieldModel<uint32_t, address, 22, 1>;\n\
    \    using sai2en = FieldModel<uint32_t, address, 23, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> tim1en;\n\
    \      BitFieldModel<uint32_t, 1, 1> tim8en;\n      BitFieldModel<uint32_t, 4,\
    \ 1> usart1en;\n      BitFieldModel<uint32_t, 5, 1> usart6en;\n      BitFieldModel<uint32_t,\
    \ 8, 1> adc1en;\n      BitFieldModel<uint32_t, 9, 1> adc2en;\n      BitFieldModel<uint32_t,\
    \ 10, 1> adc3en;\n      BitFieldModel<uint32_t, 11, 1> sdioen;\n      BitFieldModel<uint32_t,\
    \ 12, 1> spi1en;\n      BitFieldModel<uint32_t, 13, 1> spi4enr;\n      BitFieldModel<uint32_t,\
    \ 14, 1> syscfgen;\n      BitFieldModel<uint32_t, 16, 1> tim9en;\n      BitFieldModel<uint32_t,\
    \ 17, 1> tim10en;\n      BitFieldModel<uint32_t, 18, 1> tim11en;\n      BitFieldModel<uint32_t,\
    \ 22, 1> sai1en;\n      BitFieldModel<uint32_t, 23, 1> sai2en;\n    };\n  };\n\
    \npublic:\n  using apb2enr = Apb2enrReg<BaseAddress + 0x0044>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Ahb1lpenrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using gpioalpen = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    using gpioblpen = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ gpioclpen = FieldModel<uint32_t, address, 2, 1>;\n    using gpiodlpen = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using gpioelpen = FieldModel<uint32_t, address, 4, 1>;\n\
    \    using gpioflpen = FieldModel<uint32_t, address, 5, 1>;\n    using gpioglpen\
    \ = FieldModel<uint32_t, address, 6, 1>;\n    using gpiohlpen = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using crclpen = FieldModel<uint32_t, address, 12, 1>;\n\
    \    using flitflpen = FieldModel<uint32_t, address, 15, 1>;\n    using sram1lpen\
    \ = FieldModel<uint32_t, address, 16, 1>;\n    using sram2lpen = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using bkpsramlpen = FieldModel<uint32_t, address, 18,\
    \ 1>;\n    using dma1lpen = FieldModel<uint32_t, address, 21, 1>;\n    using dma2lpen\
    \ = FieldModel<uint32_t, address, 22, 1>;\n    using otghslpen = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using otghsulpilpen = FieldModel<uint32_t, address, 30,\
    \ 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> gpioalpen;\n      BitFieldModel<uint32_t, 1, 1> gpioblpen;\n      BitFieldModel<uint32_t,\
    \ 2, 1> gpioclpen;\n      BitFieldModel<uint32_t, 3, 1> gpiodlpen;\n      BitFieldModel<uint32_t,\
    \ 4, 1> gpioelpen;\n      BitFieldModel<uint32_t, 5, 1> gpioflpen;\n      BitFieldModel<uint32_t,\
    \ 6, 1> gpioglpen;\n      BitFieldModel<uint32_t, 7, 1> gpiohlpen;\n      BitFieldModel<uint32_t,\
    \ 12, 1> crclpen;\n      BitFieldModel<uint32_t, 15, 1> flitflpen;\n      BitFieldModel<uint32_t,\
    \ 16, 1> sram1lpen;\n      BitFieldModel<uint32_t, 17, 1> sram2lpen;\n      BitFieldModel<uint32_t,\
    \ 18, 1> bkpsramlpen;\n      BitFieldModel<uint32_t, 21, 1> dma1lpen;\n      BitFieldModel<uint32_t,\
    \ 22, 1> dma2lpen;\n      BitFieldModel<uint32_t, 29, 1> otghslpen;\n      BitFieldModel<uint32_t,\
    \ 30, 1> otghsulpilpen;\n    };\n  };\n\npublic:\n  using ahb1lpenr = Ahb1lpenrReg<BaseAddress\
    \ + 0x0050>;\n\nprivate:\n  template<unsigned int address>\n  class Ahb2lpenrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using otgfslpen\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    using dcmilpen = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> otgfslpen;\n      BitFieldModel<uint32_t,\
    \ 0, 1> dcmilpen;\n    };\n  };\n\npublic:\n  using ahb2lpenr = Ahb2lpenrReg<BaseAddress\
    \ + 0x0054>;\n\nprivate:\n  template<unsigned int address>\n  class Ahb3lpenrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using fmclpen\
    \ = FieldModel<uint32_t, address, 0, 1>;\n    using qspilpen = FieldModel<uint32_t,\
    \ address, 1, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> fmclpen;\n      BitFieldModel<uint32_t, 1,\
    \ 1> qspilpen;\n    };\n  };\n\npublic:\n  using ahb3lpenr = Ahb3lpenrReg<BaseAddress\
    \ + 0x0058>;\n\nprivate:\n  template<unsigned int address>\n  class Apb1lpenrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using tim2lpen\
    \ = FieldModel<uint32_t, address, 0, 1>;\n    using tim3lpen = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using tim4lpen = FieldModel<uint32_t, address, 2, 1>;\n\
    \    using tim5lpen = FieldModel<uint32_t, address, 3, 1>;\n    using tim6lpen\
    \ = FieldModel<uint32_t, address, 4, 1>;\n    using tim7lpen = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using tim12lpen = FieldModel<uint32_t, address, 6, 1>;\n\
    \    using tim13lpen = FieldModel<uint32_t, address, 7, 1>;\n    using tim14lpen\
    \ = FieldModel<uint32_t, address, 8, 1>;\n    using wwdglpen = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using spi2lpen = FieldModel<uint32_t, address, 14, 1>;\n\
    \    using spi3lpen = FieldModel<uint32_t, address, 15, 1>;\n    using spdiflpen\
    \ = FieldModel<uint32_t, address, 16, 1>;\n    using usart2lpen = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using usart3lpen = FieldModel<uint32_t, address, 18, 1>;\n\
    \    using uart4lpen = FieldModel<uint32_t, address, 19, 1>;\n    using uart5lpen\
    \ = FieldModel<uint32_t, address, 20, 1>;\n    using i2c1lpen = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    using i2c2lpen = FieldModel<uint32_t, address, 22, 1>;\n\
    \    using i2c3lpen = FieldModel<uint32_t, address, 23, 1>;\n    using i2cfmp1lpen\
    \ = FieldModel<uint32_t, address, 24, 1>;\n    using can1lpen = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using can2lpen = FieldModel<uint32_t, address, 26, 1>;\n\
    \    using ceclpen = FieldModel<uint32_t, address, 27, 1>;\n    using pwrlpen\
    \ = FieldModel<uint32_t, address, 28, 1>;\n    using daclpen = FieldModel<uint32_t,\
    \ address, 29, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> tim2lpen;\n      BitFieldModel<uint32_t,\
    \ 1, 1> tim3lpen;\n      BitFieldModel<uint32_t, 2, 1> tim4lpen;\n      BitFieldModel<uint32_t,\
    \ 3, 1> tim5lpen;\n      BitFieldModel<uint32_t, 4, 1> tim6lpen;\n      BitFieldModel<uint32_t,\
    \ 5, 1> tim7lpen;\n      BitFieldModel<uint32_t, 6, 1> tim12lpen;\n      BitFieldModel<uint32_t,\
    \ 7, 1> tim13lpen;\n      BitFieldModel<uint32_t, 8, 1> tim14lpen;\n      BitFieldModel<uint32_t,\
    \ 11, 1> wwdglpen;\n      BitFieldModel<uint32_t, 14, 1> spi2lpen;\n      BitFieldModel<uint32_t,\
    \ 15, 1> spi3lpen;\n      BitFieldModel<uint32_t, 16, 1> spdiflpen;\n      BitFieldModel<uint32_t,\
    \ 17, 1> usart2lpen;\n      BitFieldModel<uint32_t, 18, 1> usart3lpen;\n     \
    \ BitFieldModel<uint32_t, 19, 1> uart4lpen;\n      BitFieldModel<uint32_t, 20,\
    \ 1> uart5lpen;\n      BitFieldModel<uint32_t, 21, 1> i2c1lpen;\n      BitFieldModel<uint32_t,\
    \ 22, 1> i2c2lpen;\n      BitFieldModel<uint32_t, 23, 1> i2c3lpen;\n      BitFieldModel<uint32_t,\
    \ 24, 1> i2cfmp1lpen;\n      BitFieldModel<uint32_t, 25, 1> can1lpen;\n      BitFieldModel<uint32_t,\
    \ 26, 1> can2lpen;\n      BitFieldModel<uint32_t, 27, 1> ceclpen;\n      BitFieldModel<uint32_t,\
    \ 28, 1> pwrlpen;\n      BitFieldModel<uint32_t, 29, 1> daclpen;\n    };\n  };\n\
    \npublic:\n  using apb1lpenr = Apb1lpenrReg<BaseAddress + 0x0060>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Apb2lpenrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using tim1lpen = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    using tim8lpen = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ usart1lpen = FieldModel<uint32_t, address, 4, 1>;\n    using usart6lpen = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using adc1lpen = FieldModel<uint32_t, address, 8, 1>;\n\
    \    using adc2lpen = FieldModel<uint32_t, address, 9, 1>;\n    using adc3lpen\
    \ = FieldModel<uint32_t, address, 10, 1>;\n    using sdiolpen = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using spi1lpen = FieldModel<uint32_t, address, 12, 1>;\n\
    \    using spi4lpen = FieldModel<uint32_t, address, 13, 1>;\n    using syscfglpen\
    \ = FieldModel<uint32_t, address, 14, 1>;\n    using tim9lpen = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using tim10lpen = FieldModel<uint32_t, address, 17, 1>;\n\
    \    using tim11lpen = FieldModel<uint32_t, address, 18, 1>;\n    using sai1lpen\
    \ = FieldModel<uint32_t, address, 22, 1>;\n    using sai2lpen = FieldModel<uint32_t,\
    \ address, 23, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> tim1lpen;\n      BitFieldModel<uint32_t,\
    \ 1, 1> tim8lpen;\n      BitFieldModel<uint32_t, 4, 1> usart1lpen;\n      BitFieldModel<uint32_t,\
    \ 5, 1> usart6lpen;\n      BitFieldModel<uint32_t, 8, 1> adc1lpen;\n      BitFieldModel<uint32_t,\
    \ 9, 1> adc2lpen;\n      BitFieldModel<uint32_t, 10, 1> adc3lpen;\n      BitFieldModel<uint32_t,\
    \ 11, 1> sdiolpen;\n      BitFieldModel<uint32_t, 12, 1> spi1lpen;\n      BitFieldModel<uint32_t,\
    \ 13, 1> spi4lpen;\n      BitFieldModel<uint32_t, 14, 1> syscfglpen;\n      BitFieldModel<uint32_t,\
    \ 16, 1> tim9lpen;\n      BitFieldModel<uint32_t, 17, 1> tim10lpen;\n      BitFieldModel<uint32_t,\
    \ 18, 1> tim11lpen;\n      BitFieldModel<uint32_t, 22, 1> sai1lpen;\n      BitFieldModel<uint32_t,\
    \ 23, 1> sai2lpen;\n    };\n  };\n\npublic:\n  using apb2lpenr = Apb2lpenrReg<BaseAddress\
    \ + 0x0064>;\n\nprivate:\n  template<unsigned int address>\n  class BdcrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using bdrst = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using rtcen = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using rtcsel = FieldModel<uint32_t, address, 8, 2>;\n    using lsemod = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using lsebyp = FieldModel<uint32_t, address, 2, 1>;\n \
    \   using lserdy = FieldModel<uint32_t, address, 1, 1>;\n    using lseon = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 16, 1> bdrst;\n      BitFieldModel<uint32_t, 15,\
    \ 1> rtcen;\n      BitFieldModel<uint32_t, 8, 2> rtcsel;\n      BitFieldModel<uint32_t,\
    \ 3, 1> lsemod;\n      BitFieldModel<uint32_t, 2, 1> lsebyp;\n      BitFieldModel<uint32_t,\
    \ 1, 1> lserdy;\n      BitFieldModel<uint32_t, 0, 1> lseon;\n    };\n  };\n\n\
    public:\n  using bdcr = BdcrReg<BaseAddress + 0x0070>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CsrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using lpwrrstf = FieldModel<uint32_t, address, 31, 1>;\n    using\
    \ wwdgrstf = FieldModel<uint32_t, address, 30, 1>;\n    using wdgrstf = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using sftrstf = FieldModel<uint32_t, address, 28, 1>;\n\
    \    using porrstf = FieldModel<uint32_t, address, 27, 1>;\n    using padrstf\
    \ = FieldModel<uint32_t, address, 26, 1>;\n    using borrstf = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using rmvf = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using lsirdy = FieldModel<uint32_t, address, 1, 1>;\n    using lsion = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 31, 1> lpwrrstf;\n      BitFieldModel<uint32_t,\
    \ 30, 1> wwdgrstf;\n      BitFieldModel<uint32_t, 29, 1> wdgrstf;\n      BitFieldModel<uint32_t,\
    \ 28, 1> sftrstf;\n      BitFieldModel<uint32_t, 27, 1> porrstf;\n      BitFieldModel<uint32_t,\
    \ 26, 1> padrstf;\n      BitFieldModel<uint32_t, 25, 1> borrstf;\n      BitFieldModel<uint32_t,\
    \ 24, 1> rmvf;\n      BitFieldModel<uint32_t, 1, 1> lsirdy;\n      BitFieldModel<uint32_t,\
    \ 0, 1> lsion;\n    };\n  };\n\npublic:\n  using csr = CsrReg<BaseAddress + 0x0074>;\n\
    \nprivate:\n  template<unsigned int address>\n  class SscgrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using sscgen = FieldModel<uint32_t, address, 31,\
    \ 1>;\n    using spreadsel = FieldModel<uint32_t, address, 30, 1>;\n    using\
    \ incstep = FieldModel<uint32_t, address, 13, 15>;\n    using modper = FieldModel<uint32_t,\
    \ address, 0, 13>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 31, 1> sscgen;\n      BitFieldModel<uint32_t, 30,\
    \ 1> spreadsel;\n      BitFieldModel<uint32_t, 13, 15> incstep;\n      BitFieldModel<uint32_t,\
    \ 0, 13> modper;\n    };\n  };\n\npublic:\n  using sscgr = SscgrReg<BaseAddress\
    \ + 0x0080>;\n\nprivate:\n  template<unsigned int address>\n  class Plli2scfgrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using plli2sm\
    \ = FieldModel<uint32_t, address, 0, 6>;\n    using plli2sn = FieldModel<uint32_t,\
    \ address, 6, 9>;\n    using plli2sp = FieldModel<uint32_t, address, 16, 2>;\n\
    \    using plli2sq = FieldModel<uint32_t, address, 24, 4>;\n    using plli2sr\
    \ = FieldModel<uint32_t, address, 28, 3>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 6> plli2sm;\n      BitFieldModel<uint32_t,\
    \ 6, 9> plli2sn;\n      BitFieldModel<uint32_t, 16, 2> plli2sp;\n      BitFieldModel<uint32_t,\
    \ 24, 4> plli2sq;\n      BitFieldModel<uint32_t, 28, 3> plli2sr;\n    };\n  };\n\
    \npublic:\n  using plli2scfgr = Plli2scfgrReg<BaseAddress + 0x0084>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class PllsaicfgrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using pllsaim = FieldModel<uint32_t, address,\
    \ 0, 6>;\n    using pllsain = FieldModel<uint32_t, address, 6, 9>;\n    using\
    \ pllsaip = FieldModel<uint32_t, address, 16, 2>;\n    using pllsaiq = FieldModel<uint32_t,\
    \ address, 24, 4>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 6> pllsaim;\n      BitFieldModel<uint32_t, 6,\
    \ 9> pllsain;\n      BitFieldModel<uint32_t, 16, 2> pllsaip;\n      BitFieldModel<uint32_t,\
    \ 24, 4> pllsaiq;\n    };\n  };\n\npublic:\n  using pllsaicfgr = PllsaicfgrReg<BaseAddress\
    \ + 0x0088>;\n\nprivate:\n  template<unsigned int address>\n  class DckcfgrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using plli2sdivq\
    \ = FieldModel<uint32_t, address, 0, 5>;\n    using pllsaidivq = FieldModel<uint32_t,\
    \ address, 8, 5>;\n    using sai1src = FieldModel<uint32_t, address, 20, 2>;\n\
    \    using sai2src = FieldModel<uint32_t, address, 22, 2>;\n    using timpre =\
    \ FieldModel<uint32_t, address, 24, 1>;\n    using i2s1src = FieldModel<uint32_t,\
    \ address, 25, 2>;\n    using i2s2src = FieldModel<uint32_t, address, 27, 2>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 5> plli2sdivq;\n      BitFieldModel<uint32_t, 8, 5> pllsaidivq;\n      BitFieldModel<uint32_t,\
    \ 20, 2> sai1src;\n      BitFieldModel<uint32_t, 22, 2> sai2src;\n      BitFieldModel<uint32_t,\
    \ 24, 1> timpre;\n      BitFieldModel<uint32_t, 25, 2> i2s1src;\n      BitFieldModel<uint32_t,\
    \ 27, 2> i2s2src;\n    };\n  };\n\npublic:\n  using dckcfgr = DckcfgrReg<BaseAddress\
    \ + 0x008C>;\n\nprivate:\n  template<unsigned int address>\n  class CkgatenrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ahb2apb1_cken\
    \ = FieldModel<uint32_t, address, 0, 1>;\n    using ahb2apb2_cken = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using cm4dbg_cken = FieldModel<uint32_t, address, 2, 1>;\n\
    \    using spare_cken = FieldModel<uint32_t, address, 3, 1>;\n    using sram_cken\
    \ = FieldModel<uint32_t, address, 4, 1>;\n    using flitf_cken = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using rcc_cken = FieldModel<uint32_t, address, 6, 1>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> ahb2apb1_cken;\n      BitFieldModel<uint32_t, 1, 1> ahb2apb2_cken;\n \
    \     BitFieldModel<uint32_t, 2, 1> cm4dbg_cken;\n      BitFieldModel<uint32_t,\
    \ 3, 1> spare_cken;\n      BitFieldModel<uint32_t, 4, 1> sram_cken;\n      BitFieldModel<uint32_t,\
    \ 5, 1> flitf_cken;\n      BitFieldModel<uint32_t, 6, 1> rcc_cken;\n    };\n \
    \ };\n\npublic:\n  using ckgatenr = CkgatenrReg<BaseAddress + 0x0090>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Dckcfgr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using fmpi2c1sel = FieldModel<uint32_t, address,\
    \ 22, 2>;\n    using cecsel = FieldModel<uint32_t, address, 26, 1>;\n    using\
    \ ck48msel = FieldModel<uint32_t, address, 27, 1>;\n    using sdiosel = FieldModel<uint32_t,\
    \ address, 28, 1>;\n    using spdifsel = FieldModel<uint32_t, address, 29, 1>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 22, 2> fmpi2c1sel;\n      BitFieldModel<uint32_t, 26, 1> cecsel;\n      BitFieldModel<uint32_t,\
    \ 27, 1> ck48msel;\n      BitFieldModel<uint32_t, 28, 1> sdiosel;\n      BitFieldModel<uint32_t,\
    \ 29, 1> spdifsel;\n    };\n  };\n\npublic:\n  using dckcfgr2 = Dckcfgr2Reg<BaseAddress\
    \ + 0x0094>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_RCC_H */\n"
  name: RCC
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_GPIOH_H\n#define DRAL_STM32F446_GPIOH_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass gpioh\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40021C00;\n\nprivate:\n\
    \  template<unsigned int address>\n  class ModerReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using moder15 = FieldModel<uint32_t, address,\
    \ 30, 2>;\n    using moder14 = FieldModel<uint32_t, address, 28, 2>;\n    using\
    \ moder13 = FieldModel<uint32_t, address, 26, 2>;\n    using moder12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    using moder11 = FieldModel<uint32_t, address, 22, 2>;\n\
    \    using moder10 = FieldModel<uint32_t, address, 20, 2>;\n    using moder9 =\
    \ FieldModel<uint32_t, address, 18, 2>;\n    using moder8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    using moder7 = FieldModel<uint32_t, address, 14, 2>;\n\
    \    using moder6 = FieldModel<uint32_t, address, 12, 2>;\n    using moder5 =\
    \ FieldModel<uint32_t, address, 10, 2>;\n    using moder4 = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    using moder3 = FieldModel<uint32_t, address, 6, 2>;\n \
    \   using moder2 = FieldModel<uint32_t, address, 4, 2>;\n    using moder1 = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    using moder0 = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 30, 2> moder15;\n      BitFieldModel<uint32_t, 28, 2> moder14;\n      BitFieldModel<uint32_t,\
    \ 26, 2> moder13;\n      BitFieldModel<uint32_t, 24, 2> moder12;\n      BitFieldModel<uint32_t,\
    \ 22, 2> moder11;\n      BitFieldModel<uint32_t, 20, 2> moder10;\n      BitFieldModel<uint32_t,\
    \ 18, 2> moder9;\n      BitFieldModel<uint32_t, 16, 2> moder8;\n      BitFieldModel<uint32_t,\
    \ 14, 2> moder7;\n      BitFieldModel<uint32_t, 12, 2> moder6;\n      BitFieldModel<uint32_t,\
    \ 10, 2> moder5;\n      BitFieldModel<uint32_t, 8, 2> moder4;\n      BitFieldModel<uint32_t,\
    \ 6, 2> moder3;\n      BitFieldModel<uint32_t, 4, 2> moder2;\n      BitFieldModel<uint32_t,\
    \ 2, 2> moder1;\n      BitFieldModel<uint32_t, 0, 2> moder0;\n    };\n  };\n\n\
    public:\n  using moder = ModerReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class OtyperReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ot15 = FieldModel<uint32_t, address, 15, 1>;\n    using\
    \ ot14 = FieldModel<uint32_t, address, 14, 1>;\n    using ot13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using ot12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using ot11 = FieldModel<uint32_t, address, 11, 1>;\n    using ot10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using ot9 = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using ot8 = FieldModel<uint32_t, address, 8, 1>;\n    using ot7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using ot6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ ot5 = FieldModel<uint32_t, address, 5, 1>;\n    using ot4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ot3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ ot2 = FieldModel<uint32_t, address, 2, 1>;\n    using ot1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ot0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 15,\
    \ 1> ot15;\n      BitFieldModel<uint32_t, 14, 1> ot14;\n      BitFieldModel<uint32_t,\
    \ 13, 1> ot13;\n      BitFieldModel<uint32_t, 12, 1> ot12;\n      BitFieldModel<uint32_t,\
    \ 11, 1> ot11;\n      BitFieldModel<uint32_t, 10, 1> ot10;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ot9;\n      BitFieldModel<uint32_t, 8, 1> ot8;\n      BitFieldModel<uint32_t,\
    \ 7, 1> ot7;\n      BitFieldModel<uint32_t, 6, 1> ot6;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ot5;\n      BitFieldModel<uint32_t, 4, 1> ot4;\n      BitFieldModel<uint32_t,\
    \ 3, 1> ot3;\n      BitFieldModel<uint32_t, 2, 1> ot2;\n      BitFieldModel<uint32_t,\
    \ 1, 1> ot1;\n      BitFieldModel<uint32_t, 0, 1> ot0;\n    };\n  };\n\npublic:\n\
    \  using otyper = OtyperReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class OspeedrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ospeedr15 = FieldModel<uint32_t, address, 30, 2>;\n\
    \    using ospeedr14 = FieldModel<uint32_t, address, 28, 2>;\n    using ospeedr13\
    \ = FieldModel<uint32_t, address, 26, 2>;\n    using ospeedr12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    using ospeedr11 = FieldModel<uint32_t, address, 22, 2>;\n\
    \    using ospeedr10 = FieldModel<uint32_t, address, 20, 2>;\n    using ospeedr9\
    \ = FieldModel<uint32_t, address, 18, 2>;\n    using ospeedr8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    using ospeedr7 = FieldModel<uint32_t, address, 14, 2>;\n\
    \    using ospeedr6 = FieldModel<uint32_t, address, 12, 2>;\n    using ospeedr5\
    \ = FieldModel<uint32_t, address, 10, 2>;\n    using ospeedr4 = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    using ospeedr3 = FieldModel<uint32_t, address, 6, 2>;\n\
    \    using ospeedr2 = FieldModel<uint32_t, address, 4, 2>;\n    using ospeedr1\
    \ = FieldModel<uint32_t, address, 2, 2>;\n    using ospeedr0 = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 30, 2> ospeedr15;\n      BitFieldModel<uint32_t,\
    \ 28, 2> ospeedr14;\n      BitFieldModel<uint32_t, 26, 2> ospeedr13;\n      BitFieldModel<uint32_t,\
    \ 24, 2> ospeedr12;\n      BitFieldModel<uint32_t, 22, 2> ospeedr11;\n      BitFieldModel<uint32_t,\
    \ 20, 2> ospeedr10;\n      BitFieldModel<uint32_t, 18, 2> ospeedr9;\n      BitFieldModel<uint32_t,\
    \ 16, 2> ospeedr8;\n      BitFieldModel<uint32_t, 14, 2> ospeedr7;\n      BitFieldModel<uint32_t,\
    \ 12, 2> ospeedr6;\n      BitFieldModel<uint32_t, 10, 2> ospeedr5;\n      BitFieldModel<uint32_t,\
    \ 8, 2> ospeedr4;\n      BitFieldModel<uint32_t, 6, 2> ospeedr3;\n      BitFieldModel<uint32_t,\
    \ 4, 2> ospeedr2;\n      BitFieldModel<uint32_t, 2, 2> ospeedr1;\n      BitFieldModel<uint32_t,\
    \ 0, 2> ospeedr0;\n    };\n  };\n\npublic:\n  using ospeedr = OspeedrReg<BaseAddress\
    \ + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class PupdrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using pupdr15 =\
    \ FieldModel<uint32_t, address, 30, 2>;\n    using pupdr14 = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    using pupdr13 = FieldModel<uint32_t, address, 26, 2>;\n\
    \    using pupdr12 = FieldModel<uint32_t, address, 24, 2>;\n    using pupdr11\
    \ = FieldModel<uint32_t, address, 22, 2>;\n    using pupdr10 = FieldModel<uint32_t,\
    \ address, 20, 2>;\n    using pupdr9 = FieldModel<uint32_t, address, 18, 2>;\n\
    \    using pupdr8 = FieldModel<uint32_t, address, 16, 2>;\n    using pupdr7 =\
    \ FieldModel<uint32_t, address, 14, 2>;\n    using pupdr6 = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    using pupdr5 = FieldModel<uint32_t, address, 10, 2>;\n\
    \    using pupdr4 = FieldModel<uint32_t, address, 8, 2>;\n    using pupdr3 = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pupdr2 = FieldModel<uint32_t, address, 4, 2>;\n \
    \   using pupdr1 = FieldModel<uint32_t, address, 2, 2>;\n    using pupdr0 = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 30, 2> pupdr15;\n      BitFieldModel<uint32_t,\
    \ 28, 2> pupdr14;\n      BitFieldModel<uint32_t, 26, 2> pupdr13;\n      BitFieldModel<uint32_t,\
    \ 24, 2> pupdr12;\n      BitFieldModel<uint32_t, 22, 2> pupdr11;\n      BitFieldModel<uint32_t,\
    \ 20, 2> pupdr10;\n      BitFieldModel<uint32_t, 18, 2> pupdr9;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pupdr8;\n      BitFieldModel<uint32_t, 14, 2> pupdr7;\n      BitFieldModel<uint32_t,\
    \ 12, 2> pupdr6;\n      BitFieldModel<uint32_t, 10, 2> pupdr5;\n      BitFieldModel<uint32_t,\
    \ 8, 2> pupdr4;\n      BitFieldModel<uint32_t, 6, 2> pupdr3;\n      BitFieldModel<uint32_t,\
    \ 4, 2> pupdr2;\n      BitFieldModel<uint32_t, 2, 2> pupdr1;\n      BitFieldModel<uint32_t,\
    \ 0, 2> pupdr0;\n    };\n  };\n\npublic:\n  using pupdr = PupdrReg<BaseAddress\
    \ + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class IdrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using idr15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using idr14 = FieldModel<uint32_t, address, 14, 1>;\n\
    \    using idr13 = FieldModel<uint32_t, address, 13, 1>;\n    using idr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using idr11 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using idr10 = FieldModel<uint32_t, address, 10, 1>;\n    using idr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using idr8 = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using idr7 = FieldModel<uint32_t, address, 7, 1>;\n    using idr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using idr5 = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using idr4 = FieldModel<uint32_t, address, 4, 1>;\n    using idr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using idr2 = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using idr1 = FieldModel<uint32_t, address, 1, 1>;\n    using idr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> idr15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> idr14;\n      BitFieldModel<uint32_t, 13, 1> idr13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> idr12;\n      BitFieldModel<uint32_t, 11, 1> idr11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> idr10;\n      BitFieldModel<uint32_t, 9, 1> idr9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> idr8;\n      BitFieldModel<uint32_t, 7, 1> idr7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> idr6;\n      BitFieldModel<uint32_t, 5, 1> idr5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> idr4;\n      BitFieldModel<uint32_t, 3, 1> idr3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> idr2;\n      BitFieldModel<uint32_t, 1, 1> idr1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> idr0;\n    };\n  };\n\npublic:\n  using idr = IdrReg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class OdrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using odr15 = FieldModel<uint32_t, address, 15,\
    \ 1>;\n    using odr14 = FieldModel<uint32_t, address, 14, 1>;\n    using odr13\
    \ = FieldModel<uint32_t, address, 13, 1>;\n    using odr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using odr11 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using odr10 = FieldModel<uint32_t, address, 10, 1>;\n    using odr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using odr8 = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using odr7 = FieldModel<uint32_t, address, 7, 1>;\n    using odr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using odr5 = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using odr4 = FieldModel<uint32_t, address, 4, 1>;\n    using odr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using odr2 = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using odr1 = FieldModel<uint32_t, address, 1, 1>;\n    using odr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> odr15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> odr14;\n      BitFieldModel<uint32_t, 13, 1> odr13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> odr12;\n      BitFieldModel<uint32_t, 11, 1> odr11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> odr10;\n      BitFieldModel<uint32_t, 9, 1> odr9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> odr8;\n      BitFieldModel<uint32_t, 7, 1> odr7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> odr6;\n      BitFieldModel<uint32_t, 5, 1> odr5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> odr4;\n      BitFieldModel<uint32_t, 3, 1> odr3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> odr2;\n      BitFieldModel<uint32_t, 1, 1> odr1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> odr0;\n    };\n  };\n\npublic:\n  using odr = OdrReg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class BsrrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using br15 = FieldModel<uint32_t, address, 31,\
    \ 1>;\n    using br14 = FieldModel<uint32_t, address, 30, 1>;\n    using br13\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using br12 = FieldModel<uint32_t,\
    \ address, 28, 1>;\n    using br11 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using br10 = FieldModel<uint32_t, address, 26, 1>;\n    using br9 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using br8 = FieldModel<uint32_t, address, 24, 1>;\n  \
    \  using br7 = FieldModel<uint32_t, address, 23, 1>;\n    using br6 = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    using br5 = FieldModel<uint32_t, address, 21, 1>;\n  \
    \  using br4 = FieldModel<uint32_t, address, 20, 1>;\n    using br3 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using br2 = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using br1 = FieldModel<uint32_t, address, 17, 1>;\n    using br0 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using bs15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using bs14 = FieldModel<uint32_t, address, 14, 1>;\n    using bs13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using bs12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using bs11 = FieldModel<uint32_t, address, 11, 1>;\n    using bs10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using bs9 = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using bs8 = FieldModel<uint32_t, address, 8, 1>;\n    using bs7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bs6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ bs5 = FieldModel<uint32_t, address, 5, 1>;\n    using bs4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using bs3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ bs2 = FieldModel<uint32_t, address, 2, 1>;\n    using bs1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using bs0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 31,\
    \ 1> br15;\n      BitFieldModel<uint32_t, 30, 1> br14;\n      BitFieldModel<uint32_t,\
    \ 29, 1> br13;\n      BitFieldModel<uint32_t, 28, 1> br12;\n      BitFieldModel<uint32_t,\
    \ 27, 1> br11;\n      BitFieldModel<uint32_t, 26, 1> br10;\n      BitFieldModel<uint32_t,\
    \ 25, 1> br9;\n      BitFieldModel<uint32_t, 24, 1> br8;\n      BitFieldModel<uint32_t,\
    \ 23, 1> br7;\n      BitFieldModel<uint32_t, 22, 1> br6;\n      BitFieldModel<uint32_t,\
    \ 21, 1> br5;\n      BitFieldModel<uint32_t, 20, 1> br4;\n      BitFieldModel<uint32_t,\
    \ 19, 1> br3;\n      BitFieldModel<uint32_t, 18, 1> br2;\n      BitFieldModel<uint32_t,\
    \ 17, 1> br1;\n      BitFieldModel<uint32_t, 16, 1> br0;\n      BitFieldModel<uint32_t,\
    \ 15, 1> bs15;\n      BitFieldModel<uint32_t, 14, 1> bs14;\n      BitFieldModel<uint32_t,\
    \ 13, 1> bs13;\n      BitFieldModel<uint32_t, 12, 1> bs12;\n      BitFieldModel<uint32_t,\
    \ 11, 1> bs11;\n      BitFieldModel<uint32_t, 10, 1> bs10;\n      BitFieldModel<uint32_t,\
    \ 9, 1> bs9;\n      BitFieldModel<uint32_t, 8, 1> bs8;\n      BitFieldModel<uint32_t,\
    \ 7, 1> bs7;\n      BitFieldModel<uint32_t, 6, 1> bs6;\n      BitFieldModel<uint32_t,\
    \ 5, 1> bs5;\n      BitFieldModel<uint32_t, 4, 1> bs4;\n      BitFieldModel<uint32_t,\
    \ 3, 1> bs3;\n      BitFieldModel<uint32_t, 2, 1> bs2;\n      BitFieldModel<uint32_t,\
    \ 1, 1> bs1;\n      BitFieldModel<uint32_t, 0, 1> bs0;\n    };\n  };\n\npublic:\n\
    \  using bsrr = BsrrReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class LckrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using lckk = FieldModel<uint32_t, address, 16, 1>;\n    using\
    \ lck15 = FieldModel<uint32_t, address, 15, 1>;\n    using lck14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using lck13 = FieldModel<uint32_t, address, 13, 1>;\n\
    \    using lck12 = FieldModel<uint32_t, address, 12, 1>;\n    using lck11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using lck10 = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using lck9 = FieldModel<uint32_t, address, 9, 1>;\n    using lck8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using lck7 = FieldModel<uint32_t, address, 7, 1>;\n   \
    \ using lck6 = FieldModel<uint32_t, address, 6, 1>;\n    using lck5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using lck4 = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ using lck3 = FieldModel<uint32_t, address, 3, 1>;\n    using lck2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using lck1 = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using lck0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16, 1> lckk;\n  \
    \    BitFieldModel<uint32_t, 15, 1> lck15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> lck14;\n      BitFieldModel<uint32_t, 13, 1> lck13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> lck12;\n      BitFieldModel<uint32_t, 11, 1> lck11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> lck10;\n      BitFieldModel<uint32_t, 9, 1> lck9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> lck8;\n      BitFieldModel<uint32_t, 7, 1> lck7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> lck6;\n      BitFieldModel<uint32_t, 5, 1> lck5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> lck4;\n      BitFieldModel<uint32_t, 3, 1> lck3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> lck2;\n      BitFieldModel<uint32_t, 1, 1> lck1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> lck0;\n    };\n  };\n\npublic:\n  using lckr = LckrReg<BaseAddress + 0x001C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class AfrlReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using afrl7 = FieldModel<uint32_t, address, 28,\
    \ 4>;\n    using afrl6 = FieldModel<uint32_t, address, 24, 4>;\n    using afrl5\
    \ = FieldModel<uint32_t, address, 20, 4>;\n    using afrl4 = FieldModel<uint32_t,\
    \ address, 16, 4>;\n    using afrl3 = FieldModel<uint32_t, address, 12, 4>;\n\
    \    using afrl2 = FieldModel<uint32_t, address, 8, 4>;\n    using afrl1 = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using afrl0 = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 28, 4> afrl7;\n      BitFieldModel<uint32_t, 24, 4> afrl6;\n      BitFieldModel<uint32_t,\
    \ 20, 4> afrl5;\n      BitFieldModel<uint32_t, 16, 4> afrl4;\n      BitFieldModel<uint32_t,\
    \ 12, 4> afrl3;\n      BitFieldModel<uint32_t, 8, 4> afrl2;\n      BitFieldModel<uint32_t,\
    \ 4, 4> afrl1;\n      BitFieldModel<uint32_t, 0, 4> afrl0;\n    };\n  };\n\npublic:\n\
    \  using afrl = AfrlReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class AfrhReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using afrh15 = FieldModel<uint32_t, address, 28, 4>;\n    using\
    \ afrh14 = FieldModel<uint32_t, address, 24, 4>;\n    using afrh13 = FieldModel<uint32_t,\
    \ address, 20, 4>;\n    using afrh12 = FieldModel<uint32_t, address, 16, 4>;\n\
    \    using afrh11 = FieldModel<uint32_t, address, 12, 4>;\n    using afrh10 =\
    \ FieldModel<uint32_t, address, 8, 4>;\n    using afrh9 = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using afrh8 = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 28, 4> afrh15;\n      BitFieldModel<uint32_t, 24, 4> afrh14;\n      BitFieldModel<uint32_t,\
    \ 20, 4> afrh13;\n      BitFieldModel<uint32_t, 16, 4> afrh12;\n      BitFieldModel<uint32_t,\
    \ 12, 4> afrh11;\n      BitFieldModel<uint32_t, 8, 4> afrh10;\n      BitFieldModel<uint32_t,\
    \ 4, 4> afrh9;\n      BitFieldModel<uint32_t, 0, 4> afrh8;\n    };\n  };\n\npublic:\n\
    \  using afrh = AfrhReg<BaseAddress + 0x0024>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_GPIOH_H\
    \ */\n"
  name: GPIOH
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_GPIOG_H\n#define DRAL_STM32F446_GPIOG_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass gpiog\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40021800;\n\nprivate:\n\
    \  template<unsigned int address>\n  class ModerReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using moder15 = FieldModel<uint32_t, address,\
    \ 30, 2>;\n    using moder14 = FieldModel<uint32_t, address, 28, 2>;\n    using\
    \ moder13 = FieldModel<uint32_t, address, 26, 2>;\n    using moder12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    using moder11 = FieldModel<uint32_t, address, 22, 2>;\n\
    \    using moder10 = FieldModel<uint32_t, address, 20, 2>;\n    using moder9 =\
    \ FieldModel<uint32_t, address, 18, 2>;\n    using moder8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    using moder7 = FieldModel<uint32_t, address, 14, 2>;\n\
    \    using moder6 = FieldModel<uint32_t, address, 12, 2>;\n    using moder5 =\
    \ FieldModel<uint32_t, address, 10, 2>;\n    using moder4 = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    using moder3 = FieldModel<uint32_t, address, 6, 2>;\n \
    \   using moder2 = FieldModel<uint32_t, address, 4, 2>;\n    using moder1 = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    using moder0 = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 30, 2> moder15;\n      BitFieldModel<uint32_t, 28, 2> moder14;\n      BitFieldModel<uint32_t,\
    \ 26, 2> moder13;\n      BitFieldModel<uint32_t, 24, 2> moder12;\n      BitFieldModel<uint32_t,\
    \ 22, 2> moder11;\n      BitFieldModel<uint32_t, 20, 2> moder10;\n      BitFieldModel<uint32_t,\
    \ 18, 2> moder9;\n      BitFieldModel<uint32_t, 16, 2> moder8;\n      BitFieldModel<uint32_t,\
    \ 14, 2> moder7;\n      BitFieldModel<uint32_t, 12, 2> moder6;\n      BitFieldModel<uint32_t,\
    \ 10, 2> moder5;\n      BitFieldModel<uint32_t, 8, 2> moder4;\n      BitFieldModel<uint32_t,\
    \ 6, 2> moder3;\n      BitFieldModel<uint32_t, 4, 2> moder2;\n      BitFieldModel<uint32_t,\
    \ 2, 2> moder1;\n      BitFieldModel<uint32_t, 0, 2> moder0;\n    };\n  };\n\n\
    public:\n  using moder = ModerReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class OtyperReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ot15 = FieldModel<uint32_t, address, 15, 1>;\n    using\
    \ ot14 = FieldModel<uint32_t, address, 14, 1>;\n    using ot13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using ot12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using ot11 = FieldModel<uint32_t, address, 11, 1>;\n    using ot10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using ot9 = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using ot8 = FieldModel<uint32_t, address, 8, 1>;\n    using ot7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using ot6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ ot5 = FieldModel<uint32_t, address, 5, 1>;\n    using ot4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ot3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ ot2 = FieldModel<uint32_t, address, 2, 1>;\n    using ot1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ot0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 15,\
    \ 1> ot15;\n      BitFieldModel<uint32_t, 14, 1> ot14;\n      BitFieldModel<uint32_t,\
    \ 13, 1> ot13;\n      BitFieldModel<uint32_t, 12, 1> ot12;\n      BitFieldModel<uint32_t,\
    \ 11, 1> ot11;\n      BitFieldModel<uint32_t, 10, 1> ot10;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ot9;\n      BitFieldModel<uint32_t, 8, 1> ot8;\n      BitFieldModel<uint32_t,\
    \ 7, 1> ot7;\n      BitFieldModel<uint32_t, 6, 1> ot6;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ot5;\n      BitFieldModel<uint32_t, 4, 1> ot4;\n      BitFieldModel<uint32_t,\
    \ 3, 1> ot3;\n      BitFieldModel<uint32_t, 2, 1> ot2;\n      BitFieldModel<uint32_t,\
    \ 1, 1> ot1;\n      BitFieldModel<uint32_t, 0, 1> ot0;\n    };\n  };\n\npublic:\n\
    \  using otyper = OtyperReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class OspeedrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ospeedr15 = FieldModel<uint32_t, address, 30, 2>;\n\
    \    using ospeedr14 = FieldModel<uint32_t, address, 28, 2>;\n    using ospeedr13\
    \ = FieldModel<uint32_t, address, 26, 2>;\n    using ospeedr12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    using ospeedr11 = FieldModel<uint32_t, address, 22, 2>;\n\
    \    using ospeedr10 = FieldModel<uint32_t, address, 20, 2>;\n    using ospeedr9\
    \ = FieldModel<uint32_t, address, 18, 2>;\n    using ospeedr8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    using ospeedr7 = FieldModel<uint32_t, address, 14, 2>;\n\
    \    using ospeedr6 = FieldModel<uint32_t, address, 12, 2>;\n    using ospeedr5\
    \ = FieldModel<uint32_t, address, 10, 2>;\n    using ospeedr4 = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    using ospeedr3 = FieldModel<uint32_t, address, 6, 2>;\n\
    \    using ospeedr2 = FieldModel<uint32_t, address, 4, 2>;\n    using ospeedr1\
    \ = FieldModel<uint32_t, address, 2, 2>;\n    using ospeedr0 = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 30, 2> ospeedr15;\n      BitFieldModel<uint32_t,\
    \ 28, 2> ospeedr14;\n      BitFieldModel<uint32_t, 26, 2> ospeedr13;\n      BitFieldModel<uint32_t,\
    \ 24, 2> ospeedr12;\n      BitFieldModel<uint32_t, 22, 2> ospeedr11;\n      BitFieldModel<uint32_t,\
    \ 20, 2> ospeedr10;\n      BitFieldModel<uint32_t, 18, 2> ospeedr9;\n      BitFieldModel<uint32_t,\
    \ 16, 2> ospeedr8;\n      BitFieldModel<uint32_t, 14, 2> ospeedr7;\n      BitFieldModel<uint32_t,\
    \ 12, 2> ospeedr6;\n      BitFieldModel<uint32_t, 10, 2> ospeedr5;\n      BitFieldModel<uint32_t,\
    \ 8, 2> ospeedr4;\n      BitFieldModel<uint32_t, 6, 2> ospeedr3;\n      BitFieldModel<uint32_t,\
    \ 4, 2> ospeedr2;\n      BitFieldModel<uint32_t, 2, 2> ospeedr1;\n      BitFieldModel<uint32_t,\
    \ 0, 2> ospeedr0;\n    };\n  };\n\npublic:\n  using ospeedr = OspeedrReg<BaseAddress\
    \ + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class PupdrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using pupdr15 =\
    \ FieldModel<uint32_t, address, 30, 2>;\n    using pupdr14 = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    using pupdr13 = FieldModel<uint32_t, address, 26, 2>;\n\
    \    using pupdr12 = FieldModel<uint32_t, address, 24, 2>;\n    using pupdr11\
    \ = FieldModel<uint32_t, address, 22, 2>;\n    using pupdr10 = FieldModel<uint32_t,\
    \ address, 20, 2>;\n    using pupdr9 = FieldModel<uint32_t, address, 18, 2>;\n\
    \    using pupdr8 = FieldModel<uint32_t, address, 16, 2>;\n    using pupdr7 =\
    \ FieldModel<uint32_t, address, 14, 2>;\n    using pupdr6 = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    using pupdr5 = FieldModel<uint32_t, address, 10, 2>;\n\
    \    using pupdr4 = FieldModel<uint32_t, address, 8, 2>;\n    using pupdr3 = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pupdr2 = FieldModel<uint32_t, address, 4, 2>;\n \
    \   using pupdr1 = FieldModel<uint32_t, address, 2, 2>;\n    using pupdr0 = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 30, 2> pupdr15;\n      BitFieldModel<uint32_t,\
    \ 28, 2> pupdr14;\n      BitFieldModel<uint32_t, 26, 2> pupdr13;\n      BitFieldModel<uint32_t,\
    \ 24, 2> pupdr12;\n      BitFieldModel<uint32_t, 22, 2> pupdr11;\n      BitFieldModel<uint32_t,\
    \ 20, 2> pupdr10;\n      BitFieldModel<uint32_t, 18, 2> pupdr9;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pupdr8;\n      BitFieldModel<uint32_t, 14, 2> pupdr7;\n      BitFieldModel<uint32_t,\
    \ 12, 2> pupdr6;\n      BitFieldModel<uint32_t, 10, 2> pupdr5;\n      BitFieldModel<uint32_t,\
    \ 8, 2> pupdr4;\n      BitFieldModel<uint32_t, 6, 2> pupdr3;\n      BitFieldModel<uint32_t,\
    \ 4, 2> pupdr2;\n      BitFieldModel<uint32_t, 2, 2> pupdr1;\n      BitFieldModel<uint32_t,\
    \ 0, 2> pupdr0;\n    };\n  };\n\npublic:\n  using pupdr = PupdrReg<BaseAddress\
    \ + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class IdrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using idr15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using idr14 = FieldModel<uint32_t, address, 14, 1>;\n\
    \    using idr13 = FieldModel<uint32_t, address, 13, 1>;\n    using idr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using idr11 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using idr10 = FieldModel<uint32_t, address, 10, 1>;\n    using idr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using idr8 = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using idr7 = FieldModel<uint32_t, address, 7, 1>;\n    using idr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using idr5 = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using idr4 = FieldModel<uint32_t, address, 4, 1>;\n    using idr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using idr2 = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using idr1 = FieldModel<uint32_t, address, 1, 1>;\n    using idr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> idr15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> idr14;\n      BitFieldModel<uint32_t, 13, 1> idr13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> idr12;\n      BitFieldModel<uint32_t, 11, 1> idr11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> idr10;\n      BitFieldModel<uint32_t, 9, 1> idr9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> idr8;\n      BitFieldModel<uint32_t, 7, 1> idr7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> idr6;\n      BitFieldModel<uint32_t, 5, 1> idr5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> idr4;\n      BitFieldModel<uint32_t, 3, 1> idr3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> idr2;\n      BitFieldModel<uint32_t, 1, 1> idr1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> idr0;\n    };\n  };\n\npublic:\n  using idr = IdrReg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class OdrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using odr15 = FieldModel<uint32_t, address, 15,\
    \ 1>;\n    using odr14 = FieldModel<uint32_t, address, 14, 1>;\n    using odr13\
    \ = FieldModel<uint32_t, address, 13, 1>;\n    using odr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using odr11 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using odr10 = FieldModel<uint32_t, address, 10, 1>;\n    using odr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using odr8 = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using odr7 = FieldModel<uint32_t, address, 7, 1>;\n    using odr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using odr5 = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using odr4 = FieldModel<uint32_t, address, 4, 1>;\n    using odr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using odr2 = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using odr1 = FieldModel<uint32_t, address, 1, 1>;\n    using odr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> odr15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> odr14;\n      BitFieldModel<uint32_t, 13, 1> odr13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> odr12;\n      BitFieldModel<uint32_t, 11, 1> odr11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> odr10;\n      BitFieldModel<uint32_t, 9, 1> odr9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> odr8;\n      BitFieldModel<uint32_t, 7, 1> odr7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> odr6;\n      BitFieldModel<uint32_t, 5, 1> odr5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> odr4;\n      BitFieldModel<uint32_t, 3, 1> odr3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> odr2;\n      BitFieldModel<uint32_t, 1, 1> odr1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> odr0;\n    };\n  };\n\npublic:\n  using odr = OdrReg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class BsrrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using br15 = FieldModel<uint32_t, address, 31,\
    \ 1>;\n    using br14 = FieldModel<uint32_t, address, 30, 1>;\n    using br13\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using br12 = FieldModel<uint32_t,\
    \ address, 28, 1>;\n    using br11 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using br10 = FieldModel<uint32_t, address, 26, 1>;\n    using br9 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using br8 = FieldModel<uint32_t, address, 24, 1>;\n  \
    \  using br7 = FieldModel<uint32_t, address, 23, 1>;\n    using br6 = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    using br5 = FieldModel<uint32_t, address, 21, 1>;\n  \
    \  using br4 = FieldModel<uint32_t, address, 20, 1>;\n    using br3 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using br2 = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using br1 = FieldModel<uint32_t, address, 17, 1>;\n    using br0 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using bs15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using bs14 = FieldModel<uint32_t, address, 14, 1>;\n    using bs13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using bs12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using bs11 = FieldModel<uint32_t, address, 11, 1>;\n    using bs10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using bs9 = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using bs8 = FieldModel<uint32_t, address, 8, 1>;\n    using bs7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bs6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ bs5 = FieldModel<uint32_t, address, 5, 1>;\n    using bs4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using bs3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ bs2 = FieldModel<uint32_t, address, 2, 1>;\n    using bs1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using bs0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 31,\
    \ 1> br15;\n      BitFieldModel<uint32_t, 30, 1> br14;\n      BitFieldModel<uint32_t,\
    \ 29, 1> br13;\n      BitFieldModel<uint32_t, 28, 1> br12;\n      BitFieldModel<uint32_t,\
    \ 27, 1> br11;\n      BitFieldModel<uint32_t, 26, 1> br10;\n      BitFieldModel<uint32_t,\
    \ 25, 1> br9;\n      BitFieldModel<uint32_t, 24, 1> br8;\n      BitFieldModel<uint32_t,\
    \ 23, 1> br7;\n      BitFieldModel<uint32_t, 22, 1> br6;\n      BitFieldModel<uint32_t,\
    \ 21, 1> br5;\n      BitFieldModel<uint32_t, 20, 1> br4;\n      BitFieldModel<uint32_t,\
    \ 19, 1> br3;\n      BitFieldModel<uint32_t, 18, 1> br2;\n      BitFieldModel<uint32_t,\
    \ 17, 1> br1;\n      BitFieldModel<uint32_t, 16, 1> br0;\n      BitFieldModel<uint32_t,\
    \ 15, 1> bs15;\n      BitFieldModel<uint32_t, 14, 1> bs14;\n      BitFieldModel<uint32_t,\
    \ 13, 1> bs13;\n      BitFieldModel<uint32_t, 12, 1> bs12;\n      BitFieldModel<uint32_t,\
    \ 11, 1> bs11;\n      BitFieldModel<uint32_t, 10, 1> bs10;\n      BitFieldModel<uint32_t,\
    \ 9, 1> bs9;\n      BitFieldModel<uint32_t, 8, 1> bs8;\n      BitFieldModel<uint32_t,\
    \ 7, 1> bs7;\n      BitFieldModel<uint32_t, 6, 1> bs6;\n      BitFieldModel<uint32_t,\
    \ 5, 1> bs5;\n      BitFieldModel<uint32_t, 4, 1> bs4;\n      BitFieldModel<uint32_t,\
    \ 3, 1> bs3;\n      BitFieldModel<uint32_t, 2, 1> bs2;\n      BitFieldModel<uint32_t,\
    \ 1, 1> bs1;\n      BitFieldModel<uint32_t, 0, 1> bs0;\n    };\n  };\n\npublic:\n\
    \  using bsrr = BsrrReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class LckrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using lckk = FieldModel<uint32_t, address, 16, 1>;\n    using\
    \ lck15 = FieldModel<uint32_t, address, 15, 1>;\n    using lck14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using lck13 = FieldModel<uint32_t, address, 13, 1>;\n\
    \    using lck12 = FieldModel<uint32_t, address, 12, 1>;\n    using lck11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using lck10 = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using lck9 = FieldModel<uint32_t, address, 9, 1>;\n    using lck8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using lck7 = FieldModel<uint32_t, address, 7, 1>;\n   \
    \ using lck6 = FieldModel<uint32_t, address, 6, 1>;\n    using lck5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using lck4 = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ using lck3 = FieldModel<uint32_t, address, 3, 1>;\n    using lck2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using lck1 = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using lck0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16, 1> lckk;\n  \
    \    BitFieldModel<uint32_t, 15, 1> lck15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> lck14;\n      BitFieldModel<uint32_t, 13, 1> lck13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> lck12;\n      BitFieldModel<uint32_t, 11, 1> lck11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> lck10;\n      BitFieldModel<uint32_t, 9, 1> lck9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> lck8;\n      BitFieldModel<uint32_t, 7, 1> lck7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> lck6;\n      BitFieldModel<uint32_t, 5, 1> lck5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> lck4;\n      BitFieldModel<uint32_t, 3, 1> lck3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> lck2;\n      BitFieldModel<uint32_t, 1, 1> lck1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> lck0;\n    };\n  };\n\npublic:\n  using lckr = LckrReg<BaseAddress + 0x001C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class AfrlReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using afrl7 = FieldModel<uint32_t, address, 28,\
    \ 4>;\n    using afrl6 = FieldModel<uint32_t, address, 24, 4>;\n    using afrl5\
    \ = FieldModel<uint32_t, address, 20, 4>;\n    using afrl4 = FieldModel<uint32_t,\
    \ address, 16, 4>;\n    using afrl3 = FieldModel<uint32_t, address, 12, 4>;\n\
    \    using afrl2 = FieldModel<uint32_t, address, 8, 4>;\n    using afrl1 = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using afrl0 = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 28, 4> afrl7;\n      BitFieldModel<uint32_t, 24, 4> afrl6;\n      BitFieldModel<uint32_t,\
    \ 20, 4> afrl5;\n      BitFieldModel<uint32_t, 16, 4> afrl4;\n      BitFieldModel<uint32_t,\
    \ 12, 4> afrl3;\n      BitFieldModel<uint32_t, 8, 4> afrl2;\n      BitFieldModel<uint32_t,\
    \ 4, 4> afrl1;\n      BitFieldModel<uint32_t, 0, 4> afrl0;\n    };\n  };\n\npublic:\n\
    \  using afrl = AfrlReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class AfrhReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using afrh15 = FieldModel<uint32_t, address, 28, 4>;\n    using\
    \ afrh14 = FieldModel<uint32_t, address, 24, 4>;\n    using afrh13 = FieldModel<uint32_t,\
    \ address, 20, 4>;\n    using afrh12 = FieldModel<uint32_t, address, 16, 4>;\n\
    \    using afrh11 = FieldModel<uint32_t, address, 12, 4>;\n    using afrh10 =\
    \ FieldModel<uint32_t, address, 8, 4>;\n    using afrh9 = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using afrh8 = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 28, 4> afrh15;\n      BitFieldModel<uint32_t, 24, 4> afrh14;\n      BitFieldModel<uint32_t,\
    \ 20, 4> afrh13;\n      BitFieldModel<uint32_t, 16, 4> afrh12;\n      BitFieldModel<uint32_t,\
    \ 12, 4> afrh11;\n      BitFieldModel<uint32_t, 8, 4> afrh10;\n      BitFieldModel<uint32_t,\
    \ 4, 4> afrh9;\n      BitFieldModel<uint32_t, 0, 4> afrh8;\n    };\n  };\n\npublic:\n\
    \  using afrh = AfrhReg<BaseAddress + 0x0024>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_GPIOG_H\
    \ */\n"
  name: GPIOG
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_GPIOF_H\n#define DRAL_STM32F446_GPIOF_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass gpiof\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40021400;\n\nprivate:\n\
    \  template<unsigned int address>\n  class ModerReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using moder15 = FieldModel<uint32_t, address,\
    \ 30, 2>;\n    using moder14 = FieldModel<uint32_t, address, 28, 2>;\n    using\
    \ moder13 = FieldModel<uint32_t, address, 26, 2>;\n    using moder12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    using moder11 = FieldModel<uint32_t, address, 22, 2>;\n\
    \    using moder10 = FieldModel<uint32_t, address, 20, 2>;\n    using moder9 =\
    \ FieldModel<uint32_t, address, 18, 2>;\n    using moder8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    using moder7 = FieldModel<uint32_t, address, 14, 2>;\n\
    \    using moder6 = FieldModel<uint32_t, address, 12, 2>;\n    using moder5 =\
    \ FieldModel<uint32_t, address, 10, 2>;\n    using moder4 = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    using moder3 = FieldModel<uint32_t, address, 6, 2>;\n \
    \   using moder2 = FieldModel<uint32_t, address, 4, 2>;\n    using moder1 = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    using moder0 = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 30, 2> moder15;\n      BitFieldModel<uint32_t, 28, 2> moder14;\n      BitFieldModel<uint32_t,\
    \ 26, 2> moder13;\n      BitFieldModel<uint32_t, 24, 2> moder12;\n      BitFieldModel<uint32_t,\
    \ 22, 2> moder11;\n      BitFieldModel<uint32_t, 20, 2> moder10;\n      BitFieldModel<uint32_t,\
    \ 18, 2> moder9;\n      BitFieldModel<uint32_t, 16, 2> moder8;\n      BitFieldModel<uint32_t,\
    \ 14, 2> moder7;\n      BitFieldModel<uint32_t, 12, 2> moder6;\n      BitFieldModel<uint32_t,\
    \ 10, 2> moder5;\n      BitFieldModel<uint32_t, 8, 2> moder4;\n      BitFieldModel<uint32_t,\
    \ 6, 2> moder3;\n      BitFieldModel<uint32_t, 4, 2> moder2;\n      BitFieldModel<uint32_t,\
    \ 2, 2> moder1;\n      BitFieldModel<uint32_t, 0, 2> moder0;\n    };\n  };\n\n\
    public:\n  using moder = ModerReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class OtyperReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ot15 = FieldModel<uint32_t, address, 15, 1>;\n    using\
    \ ot14 = FieldModel<uint32_t, address, 14, 1>;\n    using ot13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using ot12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using ot11 = FieldModel<uint32_t, address, 11, 1>;\n    using ot10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using ot9 = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using ot8 = FieldModel<uint32_t, address, 8, 1>;\n    using ot7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using ot6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ ot5 = FieldModel<uint32_t, address, 5, 1>;\n    using ot4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ot3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ ot2 = FieldModel<uint32_t, address, 2, 1>;\n    using ot1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ot0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 15,\
    \ 1> ot15;\n      BitFieldModel<uint32_t, 14, 1> ot14;\n      BitFieldModel<uint32_t,\
    \ 13, 1> ot13;\n      BitFieldModel<uint32_t, 12, 1> ot12;\n      BitFieldModel<uint32_t,\
    \ 11, 1> ot11;\n      BitFieldModel<uint32_t, 10, 1> ot10;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ot9;\n      BitFieldModel<uint32_t, 8, 1> ot8;\n      BitFieldModel<uint32_t,\
    \ 7, 1> ot7;\n      BitFieldModel<uint32_t, 6, 1> ot6;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ot5;\n      BitFieldModel<uint32_t, 4, 1> ot4;\n      BitFieldModel<uint32_t,\
    \ 3, 1> ot3;\n      BitFieldModel<uint32_t, 2, 1> ot2;\n      BitFieldModel<uint32_t,\
    \ 1, 1> ot1;\n      BitFieldModel<uint32_t, 0, 1> ot0;\n    };\n  };\n\npublic:\n\
    \  using otyper = OtyperReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class OspeedrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ospeedr15 = FieldModel<uint32_t, address, 30, 2>;\n\
    \    using ospeedr14 = FieldModel<uint32_t, address, 28, 2>;\n    using ospeedr13\
    \ = FieldModel<uint32_t, address, 26, 2>;\n    using ospeedr12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    using ospeedr11 = FieldModel<uint32_t, address, 22, 2>;\n\
    \    using ospeedr10 = FieldModel<uint32_t, address, 20, 2>;\n    using ospeedr9\
    \ = FieldModel<uint32_t, address, 18, 2>;\n    using ospeedr8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    using ospeedr7 = FieldModel<uint32_t, address, 14, 2>;\n\
    \    using ospeedr6 = FieldModel<uint32_t, address, 12, 2>;\n    using ospeedr5\
    \ = FieldModel<uint32_t, address, 10, 2>;\n    using ospeedr4 = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    using ospeedr3 = FieldModel<uint32_t, address, 6, 2>;\n\
    \    using ospeedr2 = FieldModel<uint32_t, address, 4, 2>;\n    using ospeedr1\
    \ = FieldModel<uint32_t, address, 2, 2>;\n    using ospeedr0 = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 30, 2> ospeedr15;\n      BitFieldModel<uint32_t,\
    \ 28, 2> ospeedr14;\n      BitFieldModel<uint32_t, 26, 2> ospeedr13;\n      BitFieldModel<uint32_t,\
    \ 24, 2> ospeedr12;\n      BitFieldModel<uint32_t, 22, 2> ospeedr11;\n      BitFieldModel<uint32_t,\
    \ 20, 2> ospeedr10;\n      BitFieldModel<uint32_t, 18, 2> ospeedr9;\n      BitFieldModel<uint32_t,\
    \ 16, 2> ospeedr8;\n      BitFieldModel<uint32_t, 14, 2> ospeedr7;\n      BitFieldModel<uint32_t,\
    \ 12, 2> ospeedr6;\n      BitFieldModel<uint32_t, 10, 2> ospeedr5;\n      BitFieldModel<uint32_t,\
    \ 8, 2> ospeedr4;\n      BitFieldModel<uint32_t, 6, 2> ospeedr3;\n      BitFieldModel<uint32_t,\
    \ 4, 2> ospeedr2;\n      BitFieldModel<uint32_t, 2, 2> ospeedr1;\n      BitFieldModel<uint32_t,\
    \ 0, 2> ospeedr0;\n    };\n  };\n\npublic:\n  using ospeedr = OspeedrReg<BaseAddress\
    \ + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class PupdrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using pupdr15 =\
    \ FieldModel<uint32_t, address, 30, 2>;\n    using pupdr14 = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    using pupdr13 = FieldModel<uint32_t, address, 26, 2>;\n\
    \    using pupdr12 = FieldModel<uint32_t, address, 24, 2>;\n    using pupdr11\
    \ = FieldModel<uint32_t, address, 22, 2>;\n    using pupdr10 = FieldModel<uint32_t,\
    \ address, 20, 2>;\n    using pupdr9 = FieldModel<uint32_t, address, 18, 2>;\n\
    \    using pupdr8 = FieldModel<uint32_t, address, 16, 2>;\n    using pupdr7 =\
    \ FieldModel<uint32_t, address, 14, 2>;\n    using pupdr6 = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    using pupdr5 = FieldModel<uint32_t, address, 10, 2>;\n\
    \    using pupdr4 = FieldModel<uint32_t, address, 8, 2>;\n    using pupdr3 = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pupdr2 = FieldModel<uint32_t, address, 4, 2>;\n \
    \   using pupdr1 = FieldModel<uint32_t, address, 2, 2>;\n    using pupdr0 = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 30, 2> pupdr15;\n      BitFieldModel<uint32_t,\
    \ 28, 2> pupdr14;\n      BitFieldModel<uint32_t, 26, 2> pupdr13;\n      BitFieldModel<uint32_t,\
    \ 24, 2> pupdr12;\n      BitFieldModel<uint32_t, 22, 2> pupdr11;\n      BitFieldModel<uint32_t,\
    \ 20, 2> pupdr10;\n      BitFieldModel<uint32_t, 18, 2> pupdr9;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pupdr8;\n      BitFieldModel<uint32_t, 14, 2> pupdr7;\n      BitFieldModel<uint32_t,\
    \ 12, 2> pupdr6;\n      BitFieldModel<uint32_t, 10, 2> pupdr5;\n      BitFieldModel<uint32_t,\
    \ 8, 2> pupdr4;\n      BitFieldModel<uint32_t, 6, 2> pupdr3;\n      BitFieldModel<uint32_t,\
    \ 4, 2> pupdr2;\n      BitFieldModel<uint32_t, 2, 2> pupdr1;\n      BitFieldModel<uint32_t,\
    \ 0, 2> pupdr0;\n    };\n  };\n\npublic:\n  using pupdr = PupdrReg<BaseAddress\
    \ + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class IdrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using idr15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using idr14 = FieldModel<uint32_t, address, 14, 1>;\n\
    \    using idr13 = FieldModel<uint32_t, address, 13, 1>;\n    using idr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using idr11 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using idr10 = FieldModel<uint32_t, address, 10, 1>;\n    using idr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using idr8 = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using idr7 = FieldModel<uint32_t, address, 7, 1>;\n    using idr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using idr5 = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using idr4 = FieldModel<uint32_t, address, 4, 1>;\n    using idr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using idr2 = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using idr1 = FieldModel<uint32_t, address, 1, 1>;\n    using idr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> idr15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> idr14;\n      BitFieldModel<uint32_t, 13, 1> idr13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> idr12;\n      BitFieldModel<uint32_t, 11, 1> idr11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> idr10;\n      BitFieldModel<uint32_t, 9, 1> idr9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> idr8;\n      BitFieldModel<uint32_t, 7, 1> idr7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> idr6;\n      BitFieldModel<uint32_t, 5, 1> idr5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> idr4;\n      BitFieldModel<uint32_t, 3, 1> idr3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> idr2;\n      BitFieldModel<uint32_t, 1, 1> idr1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> idr0;\n    };\n  };\n\npublic:\n  using idr = IdrReg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class OdrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using odr15 = FieldModel<uint32_t, address, 15,\
    \ 1>;\n    using odr14 = FieldModel<uint32_t, address, 14, 1>;\n    using odr13\
    \ = FieldModel<uint32_t, address, 13, 1>;\n    using odr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using odr11 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using odr10 = FieldModel<uint32_t, address, 10, 1>;\n    using odr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using odr8 = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using odr7 = FieldModel<uint32_t, address, 7, 1>;\n    using odr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using odr5 = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using odr4 = FieldModel<uint32_t, address, 4, 1>;\n    using odr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using odr2 = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using odr1 = FieldModel<uint32_t, address, 1, 1>;\n    using odr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> odr15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> odr14;\n      BitFieldModel<uint32_t, 13, 1> odr13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> odr12;\n      BitFieldModel<uint32_t, 11, 1> odr11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> odr10;\n      BitFieldModel<uint32_t, 9, 1> odr9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> odr8;\n      BitFieldModel<uint32_t, 7, 1> odr7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> odr6;\n      BitFieldModel<uint32_t, 5, 1> odr5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> odr4;\n      BitFieldModel<uint32_t, 3, 1> odr3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> odr2;\n      BitFieldModel<uint32_t, 1, 1> odr1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> odr0;\n    };\n  };\n\npublic:\n  using odr = OdrReg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class BsrrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using br15 = FieldModel<uint32_t, address, 31,\
    \ 1>;\n    using br14 = FieldModel<uint32_t, address, 30, 1>;\n    using br13\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using br12 = FieldModel<uint32_t,\
    \ address, 28, 1>;\n    using br11 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using br10 = FieldModel<uint32_t, address, 26, 1>;\n    using br9 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using br8 = FieldModel<uint32_t, address, 24, 1>;\n  \
    \  using br7 = FieldModel<uint32_t, address, 23, 1>;\n    using br6 = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    using br5 = FieldModel<uint32_t, address, 21, 1>;\n  \
    \  using br4 = FieldModel<uint32_t, address, 20, 1>;\n    using br3 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using br2 = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using br1 = FieldModel<uint32_t, address, 17, 1>;\n    using br0 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using bs15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using bs14 = FieldModel<uint32_t, address, 14, 1>;\n    using bs13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using bs12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using bs11 = FieldModel<uint32_t, address, 11, 1>;\n    using bs10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using bs9 = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using bs8 = FieldModel<uint32_t, address, 8, 1>;\n    using bs7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bs6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ bs5 = FieldModel<uint32_t, address, 5, 1>;\n    using bs4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using bs3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ bs2 = FieldModel<uint32_t, address, 2, 1>;\n    using bs1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using bs0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 31,\
    \ 1> br15;\n      BitFieldModel<uint32_t, 30, 1> br14;\n      BitFieldModel<uint32_t,\
    \ 29, 1> br13;\n      BitFieldModel<uint32_t, 28, 1> br12;\n      BitFieldModel<uint32_t,\
    \ 27, 1> br11;\n      BitFieldModel<uint32_t, 26, 1> br10;\n      BitFieldModel<uint32_t,\
    \ 25, 1> br9;\n      BitFieldModel<uint32_t, 24, 1> br8;\n      BitFieldModel<uint32_t,\
    \ 23, 1> br7;\n      BitFieldModel<uint32_t, 22, 1> br6;\n      BitFieldModel<uint32_t,\
    \ 21, 1> br5;\n      BitFieldModel<uint32_t, 20, 1> br4;\n      BitFieldModel<uint32_t,\
    \ 19, 1> br3;\n      BitFieldModel<uint32_t, 18, 1> br2;\n      BitFieldModel<uint32_t,\
    \ 17, 1> br1;\n      BitFieldModel<uint32_t, 16, 1> br0;\n      BitFieldModel<uint32_t,\
    \ 15, 1> bs15;\n      BitFieldModel<uint32_t, 14, 1> bs14;\n      BitFieldModel<uint32_t,\
    \ 13, 1> bs13;\n      BitFieldModel<uint32_t, 12, 1> bs12;\n      BitFieldModel<uint32_t,\
    \ 11, 1> bs11;\n      BitFieldModel<uint32_t, 10, 1> bs10;\n      BitFieldModel<uint32_t,\
    \ 9, 1> bs9;\n      BitFieldModel<uint32_t, 8, 1> bs8;\n      BitFieldModel<uint32_t,\
    \ 7, 1> bs7;\n      BitFieldModel<uint32_t, 6, 1> bs6;\n      BitFieldModel<uint32_t,\
    \ 5, 1> bs5;\n      BitFieldModel<uint32_t, 4, 1> bs4;\n      BitFieldModel<uint32_t,\
    \ 3, 1> bs3;\n      BitFieldModel<uint32_t, 2, 1> bs2;\n      BitFieldModel<uint32_t,\
    \ 1, 1> bs1;\n      BitFieldModel<uint32_t, 0, 1> bs0;\n    };\n  };\n\npublic:\n\
    \  using bsrr = BsrrReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class LckrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using lckk = FieldModel<uint32_t, address, 16, 1>;\n    using\
    \ lck15 = FieldModel<uint32_t, address, 15, 1>;\n    using lck14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using lck13 = FieldModel<uint32_t, address, 13, 1>;\n\
    \    using lck12 = FieldModel<uint32_t, address, 12, 1>;\n    using lck11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using lck10 = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using lck9 = FieldModel<uint32_t, address, 9, 1>;\n    using lck8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using lck7 = FieldModel<uint32_t, address, 7, 1>;\n   \
    \ using lck6 = FieldModel<uint32_t, address, 6, 1>;\n    using lck5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using lck4 = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ using lck3 = FieldModel<uint32_t, address, 3, 1>;\n    using lck2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using lck1 = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using lck0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16, 1> lckk;\n  \
    \    BitFieldModel<uint32_t, 15, 1> lck15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> lck14;\n      BitFieldModel<uint32_t, 13, 1> lck13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> lck12;\n      BitFieldModel<uint32_t, 11, 1> lck11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> lck10;\n      BitFieldModel<uint32_t, 9, 1> lck9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> lck8;\n      BitFieldModel<uint32_t, 7, 1> lck7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> lck6;\n      BitFieldModel<uint32_t, 5, 1> lck5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> lck4;\n      BitFieldModel<uint32_t, 3, 1> lck3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> lck2;\n      BitFieldModel<uint32_t, 1, 1> lck1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> lck0;\n    };\n  };\n\npublic:\n  using lckr = LckrReg<BaseAddress + 0x001C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class AfrlReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using afrl7 = FieldModel<uint32_t, address, 28,\
    \ 4>;\n    using afrl6 = FieldModel<uint32_t, address, 24, 4>;\n    using afrl5\
    \ = FieldModel<uint32_t, address, 20, 4>;\n    using afrl4 = FieldModel<uint32_t,\
    \ address, 16, 4>;\n    using afrl3 = FieldModel<uint32_t, address, 12, 4>;\n\
    \    using afrl2 = FieldModel<uint32_t, address, 8, 4>;\n    using afrl1 = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using afrl0 = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 28, 4> afrl7;\n      BitFieldModel<uint32_t, 24, 4> afrl6;\n      BitFieldModel<uint32_t,\
    \ 20, 4> afrl5;\n      BitFieldModel<uint32_t, 16, 4> afrl4;\n      BitFieldModel<uint32_t,\
    \ 12, 4> afrl3;\n      BitFieldModel<uint32_t, 8, 4> afrl2;\n      BitFieldModel<uint32_t,\
    \ 4, 4> afrl1;\n      BitFieldModel<uint32_t, 0, 4> afrl0;\n    };\n  };\n\npublic:\n\
    \  using afrl = AfrlReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class AfrhReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using afrh15 = FieldModel<uint32_t, address, 28, 4>;\n    using\
    \ afrh14 = FieldModel<uint32_t, address, 24, 4>;\n    using afrh13 = FieldModel<uint32_t,\
    \ address, 20, 4>;\n    using afrh12 = FieldModel<uint32_t, address, 16, 4>;\n\
    \    using afrh11 = FieldModel<uint32_t, address, 12, 4>;\n    using afrh10 =\
    \ FieldModel<uint32_t, address, 8, 4>;\n    using afrh9 = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using afrh8 = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 28, 4> afrh15;\n      BitFieldModel<uint32_t, 24, 4> afrh14;\n      BitFieldModel<uint32_t,\
    \ 20, 4> afrh13;\n      BitFieldModel<uint32_t, 16, 4> afrh12;\n      BitFieldModel<uint32_t,\
    \ 12, 4> afrh11;\n      BitFieldModel<uint32_t, 8, 4> afrh10;\n      BitFieldModel<uint32_t,\
    \ 4, 4> afrh9;\n      BitFieldModel<uint32_t, 0, 4> afrh8;\n    };\n  };\n\npublic:\n\
    \  using afrh = AfrhReg<BaseAddress + 0x0024>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_GPIOF_H\
    \ */\n"
  name: GPIOF
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_GPIOE_H\n#define DRAL_STM32F446_GPIOE_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass gpioe\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40021000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class ModerReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using moder15 = FieldModel<uint32_t, address,\
    \ 30, 2>;\n    using moder14 = FieldModel<uint32_t, address, 28, 2>;\n    using\
    \ moder13 = FieldModel<uint32_t, address, 26, 2>;\n    using moder12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    using moder11 = FieldModel<uint32_t, address, 22, 2>;\n\
    \    using moder10 = FieldModel<uint32_t, address, 20, 2>;\n    using moder9 =\
    \ FieldModel<uint32_t, address, 18, 2>;\n    using moder8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    using moder7 = FieldModel<uint32_t, address, 14, 2>;\n\
    \    using moder6 = FieldModel<uint32_t, address, 12, 2>;\n    using moder5 =\
    \ FieldModel<uint32_t, address, 10, 2>;\n    using moder4 = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    using moder3 = FieldModel<uint32_t, address, 6, 2>;\n \
    \   using moder2 = FieldModel<uint32_t, address, 4, 2>;\n    using moder1 = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    using moder0 = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 30, 2> moder15;\n      BitFieldModel<uint32_t, 28, 2> moder14;\n      BitFieldModel<uint32_t,\
    \ 26, 2> moder13;\n      BitFieldModel<uint32_t, 24, 2> moder12;\n      BitFieldModel<uint32_t,\
    \ 22, 2> moder11;\n      BitFieldModel<uint32_t, 20, 2> moder10;\n      BitFieldModel<uint32_t,\
    \ 18, 2> moder9;\n      BitFieldModel<uint32_t, 16, 2> moder8;\n      BitFieldModel<uint32_t,\
    \ 14, 2> moder7;\n      BitFieldModel<uint32_t, 12, 2> moder6;\n      BitFieldModel<uint32_t,\
    \ 10, 2> moder5;\n      BitFieldModel<uint32_t, 8, 2> moder4;\n      BitFieldModel<uint32_t,\
    \ 6, 2> moder3;\n      BitFieldModel<uint32_t, 4, 2> moder2;\n      BitFieldModel<uint32_t,\
    \ 2, 2> moder1;\n      BitFieldModel<uint32_t, 0, 2> moder0;\n    };\n  };\n\n\
    public:\n  using moder = ModerReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class OtyperReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ot15 = FieldModel<uint32_t, address, 15, 1>;\n    using\
    \ ot14 = FieldModel<uint32_t, address, 14, 1>;\n    using ot13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using ot12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using ot11 = FieldModel<uint32_t, address, 11, 1>;\n    using ot10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using ot9 = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using ot8 = FieldModel<uint32_t, address, 8, 1>;\n    using ot7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using ot6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ ot5 = FieldModel<uint32_t, address, 5, 1>;\n    using ot4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ot3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ ot2 = FieldModel<uint32_t, address, 2, 1>;\n    using ot1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ot0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 15,\
    \ 1> ot15;\n      BitFieldModel<uint32_t, 14, 1> ot14;\n      BitFieldModel<uint32_t,\
    \ 13, 1> ot13;\n      BitFieldModel<uint32_t, 12, 1> ot12;\n      BitFieldModel<uint32_t,\
    \ 11, 1> ot11;\n      BitFieldModel<uint32_t, 10, 1> ot10;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ot9;\n      BitFieldModel<uint32_t, 8, 1> ot8;\n      BitFieldModel<uint32_t,\
    \ 7, 1> ot7;\n      BitFieldModel<uint32_t, 6, 1> ot6;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ot5;\n      BitFieldModel<uint32_t, 4, 1> ot4;\n      BitFieldModel<uint32_t,\
    \ 3, 1> ot3;\n      BitFieldModel<uint32_t, 2, 1> ot2;\n      BitFieldModel<uint32_t,\
    \ 1, 1> ot1;\n      BitFieldModel<uint32_t, 0, 1> ot0;\n    };\n  };\n\npublic:\n\
    \  using otyper = OtyperReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class OspeedrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ospeedr15 = FieldModel<uint32_t, address, 30, 2>;\n\
    \    using ospeedr14 = FieldModel<uint32_t, address, 28, 2>;\n    using ospeedr13\
    \ = FieldModel<uint32_t, address, 26, 2>;\n    using ospeedr12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    using ospeedr11 = FieldModel<uint32_t, address, 22, 2>;\n\
    \    using ospeedr10 = FieldModel<uint32_t, address, 20, 2>;\n    using ospeedr9\
    \ = FieldModel<uint32_t, address, 18, 2>;\n    using ospeedr8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    using ospeedr7 = FieldModel<uint32_t, address, 14, 2>;\n\
    \    using ospeedr6 = FieldModel<uint32_t, address, 12, 2>;\n    using ospeedr5\
    \ = FieldModel<uint32_t, address, 10, 2>;\n    using ospeedr4 = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    using ospeedr3 = FieldModel<uint32_t, address, 6, 2>;\n\
    \    using ospeedr2 = FieldModel<uint32_t, address, 4, 2>;\n    using ospeedr1\
    \ = FieldModel<uint32_t, address, 2, 2>;\n    using ospeedr0 = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 30, 2> ospeedr15;\n      BitFieldModel<uint32_t,\
    \ 28, 2> ospeedr14;\n      BitFieldModel<uint32_t, 26, 2> ospeedr13;\n      BitFieldModel<uint32_t,\
    \ 24, 2> ospeedr12;\n      BitFieldModel<uint32_t, 22, 2> ospeedr11;\n      BitFieldModel<uint32_t,\
    \ 20, 2> ospeedr10;\n      BitFieldModel<uint32_t, 18, 2> ospeedr9;\n      BitFieldModel<uint32_t,\
    \ 16, 2> ospeedr8;\n      BitFieldModel<uint32_t, 14, 2> ospeedr7;\n      BitFieldModel<uint32_t,\
    \ 12, 2> ospeedr6;\n      BitFieldModel<uint32_t, 10, 2> ospeedr5;\n      BitFieldModel<uint32_t,\
    \ 8, 2> ospeedr4;\n      BitFieldModel<uint32_t, 6, 2> ospeedr3;\n      BitFieldModel<uint32_t,\
    \ 4, 2> ospeedr2;\n      BitFieldModel<uint32_t, 2, 2> ospeedr1;\n      BitFieldModel<uint32_t,\
    \ 0, 2> ospeedr0;\n    };\n  };\n\npublic:\n  using ospeedr = OspeedrReg<BaseAddress\
    \ + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class PupdrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using pupdr15 =\
    \ FieldModel<uint32_t, address, 30, 2>;\n    using pupdr14 = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    using pupdr13 = FieldModel<uint32_t, address, 26, 2>;\n\
    \    using pupdr12 = FieldModel<uint32_t, address, 24, 2>;\n    using pupdr11\
    \ = FieldModel<uint32_t, address, 22, 2>;\n    using pupdr10 = FieldModel<uint32_t,\
    \ address, 20, 2>;\n    using pupdr9 = FieldModel<uint32_t, address, 18, 2>;\n\
    \    using pupdr8 = FieldModel<uint32_t, address, 16, 2>;\n    using pupdr7 =\
    \ FieldModel<uint32_t, address, 14, 2>;\n    using pupdr6 = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    using pupdr5 = FieldModel<uint32_t, address, 10, 2>;\n\
    \    using pupdr4 = FieldModel<uint32_t, address, 8, 2>;\n    using pupdr3 = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pupdr2 = FieldModel<uint32_t, address, 4, 2>;\n \
    \   using pupdr1 = FieldModel<uint32_t, address, 2, 2>;\n    using pupdr0 = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 30, 2> pupdr15;\n      BitFieldModel<uint32_t,\
    \ 28, 2> pupdr14;\n      BitFieldModel<uint32_t, 26, 2> pupdr13;\n      BitFieldModel<uint32_t,\
    \ 24, 2> pupdr12;\n      BitFieldModel<uint32_t, 22, 2> pupdr11;\n      BitFieldModel<uint32_t,\
    \ 20, 2> pupdr10;\n      BitFieldModel<uint32_t, 18, 2> pupdr9;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pupdr8;\n      BitFieldModel<uint32_t, 14, 2> pupdr7;\n      BitFieldModel<uint32_t,\
    \ 12, 2> pupdr6;\n      BitFieldModel<uint32_t, 10, 2> pupdr5;\n      BitFieldModel<uint32_t,\
    \ 8, 2> pupdr4;\n      BitFieldModel<uint32_t, 6, 2> pupdr3;\n      BitFieldModel<uint32_t,\
    \ 4, 2> pupdr2;\n      BitFieldModel<uint32_t, 2, 2> pupdr1;\n      BitFieldModel<uint32_t,\
    \ 0, 2> pupdr0;\n    };\n  };\n\npublic:\n  using pupdr = PupdrReg<BaseAddress\
    \ + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class IdrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using idr15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using idr14 = FieldModel<uint32_t, address, 14, 1>;\n\
    \    using idr13 = FieldModel<uint32_t, address, 13, 1>;\n    using idr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using idr11 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using idr10 = FieldModel<uint32_t, address, 10, 1>;\n    using idr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using idr8 = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using idr7 = FieldModel<uint32_t, address, 7, 1>;\n    using idr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using idr5 = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using idr4 = FieldModel<uint32_t, address, 4, 1>;\n    using idr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using idr2 = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using idr1 = FieldModel<uint32_t, address, 1, 1>;\n    using idr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> idr15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> idr14;\n      BitFieldModel<uint32_t, 13, 1> idr13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> idr12;\n      BitFieldModel<uint32_t, 11, 1> idr11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> idr10;\n      BitFieldModel<uint32_t, 9, 1> idr9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> idr8;\n      BitFieldModel<uint32_t, 7, 1> idr7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> idr6;\n      BitFieldModel<uint32_t, 5, 1> idr5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> idr4;\n      BitFieldModel<uint32_t, 3, 1> idr3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> idr2;\n      BitFieldModel<uint32_t, 1, 1> idr1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> idr0;\n    };\n  };\n\npublic:\n  using idr = IdrReg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class OdrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using odr15 = FieldModel<uint32_t, address, 15,\
    \ 1>;\n    using odr14 = FieldModel<uint32_t, address, 14, 1>;\n    using odr13\
    \ = FieldModel<uint32_t, address, 13, 1>;\n    using odr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using odr11 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using odr10 = FieldModel<uint32_t, address, 10, 1>;\n    using odr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using odr8 = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using odr7 = FieldModel<uint32_t, address, 7, 1>;\n    using odr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using odr5 = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using odr4 = FieldModel<uint32_t, address, 4, 1>;\n    using odr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using odr2 = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using odr1 = FieldModel<uint32_t, address, 1, 1>;\n    using odr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> odr15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> odr14;\n      BitFieldModel<uint32_t, 13, 1> odr13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> odr12;\n      BitFieldModel<uint32_t, 11, 1> odr11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> odr10;\n      BitFieldModel<uint32_t, 9, 1> odr9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> odr8;\n      BitFieldModel<uint32_t, 7, 1> odr7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> odr6;\n      BitFieldModel<uint32_t, 5, 1> odr5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> odr4;\n      BitFieldModel<uint32_t, 3, 1> odr3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> odr2;\n      BitFieldModel<uint32_t, 1, 1> odr1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> odr0;\n    };\n  };\n\npublic:\n  using odr = OdrReg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class BsrrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using br15 = FieldModel<uint32_t, address, 31,\
    \ 1>;\n    using br14 = FieldModel<uint32_t, address, 30, 1>;\n    using br13\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using br12 = FieldModel<uint32_t,\
    \ address, 28, 1>;\n    using br11 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using br10 = FieldModel<uint32_t, address, 26, 1>;\n    using br9 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using br8 = FieldModel<uint32_t, address, 24, 1>;\n  \
    \  using br7 = FieldModel<uint32_t, address, 23, 1>;\n    using br6 = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    using br5 = FieldModel<uint32_t, address, 21, 1>;\n  \
    \  using br4 = FieldModel<uint32_t, address, 20, 1>;\n    using br3 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using br2 = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using br1 = FieldModel<uint32_t, address, 17, 1>;\n    using br0 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using bs15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using bs14 = FieldModel<uint32_t, address, 14, 1>;\n    using bs13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using bs12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using bs11 = FieldModel<uint32_t, address, 11, 1>;\n    using bs10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using bs9 = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using bs8 = FieldModel<uint32_t, address, 8, 1>;\n    using bs7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bs6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ bs5 = FieldModel<uint32_t, address, 5, 1>;\n    using bs4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using bs3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ bs2 = FieldModel<uint32_t, address, 2, 1>;\n    using bs1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using bs0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 31,\
    \ 1> br15;\n      BitFieldModel<uint32_t, 30, 1> br14;\n      BitFieldModel<uint32_t,\
    \ 29, 1> br13;\n      BitFieldModel<uint32_t, 28, 1> br12;\n      BitFieldModel<uint32_t,\
    \ 27, 1> br11;\n      BitFieldModel<uint32_t, 26, 1> br10;\n      BitFieldModel<uint32_t,\
    \ 25, 1> br9;\n      BitFieldModel<uint32_t, 24, 1> br8;\n      BitFieldModel<uint32_t,\
    \ 23, 1> br7;\n      BitFieldModel<uint32_t, 22, 1> br6;\n      BitFieldModel<uint32_t,\
    \ 21, 1> br5;\n      BitFieldModel<uint32_t, 20, 1> br4;\n      BitFieldModel<uint32_t,\
    \ 19, 1> br3;\n      BitFieldModel<uint32_t, 18, 1> br2;\n      BitFieldModel<uint32_t,\
    \ 17, 1> br1;\n      BitFieldModel<uint32_t, 16, 1> br0;\n      BitFieldModel<uint32_t,\
    \ 15, 1> bs15;\n      BitFieldModel<uint32_t, 14, 1> bs14;\n      BitFieldModel<uint32_t,\
    \ 13, 1> bs13;\n      BitFieldModel<uint32_t, 12, 1> bs12;\n      BitFieldModel<uint32_t,\
    \ 11, 1> bs11;\n      BitFieldModel<uint32_t, 10, 1> bs10;\n      BitFieldModel<uint32_t,\
    \ 9, 1> bs9;\n      BitFieldModel<uint32_t, 8, 1> bs8;\n      BitFieldModel<uint32_t,\
    \ 7, 1> bs7;\n      BitFieldModel<uint32_t, 6, 1> bs6;\n      BitFieldModel<uint32_t,\
    \ 5, 1> bs5;\n      BitFieldModel<uint32_t, 4, 1> bs4;\n      BitFieldModel<uint32_t,\
    \ 3, 1> bs3;\n      BitFieldModel<uint32_t, 2, 1> bs2;\n      BitFieldModel<uint32_t,\
    \ 1, 1> bs1;\n      BitFieldModel<uint32_t, 0, 1> bs0;\n    };\n  };\n\npublic:\n\
    \  using bsrr = BsrrReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class LckrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using lckk = FieldModel<uint32_t, address, 16, 1>;\n    using\
    \ lck15 = FieldModel<uint32_t, address, 15, 1>;\n    using lck14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using lck13 = FieldModel<uint32_t, address, 13, 1>;\n\
    \    using lck12 = FieldModel<uint32_t, address, 12, 1>;\n    using lck11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using lck10 = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using lck9 = FieldModel<uint32_t, address, 9, 1>;\n    using lck8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using lck7 = FieldModel<uint32_t, address, 7, 1>;\n   \
    \ using lck6 = FieldModel<uint32_t, address, 6, 1>;\n    using lck5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using lck4 = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ using lck3 = FieldModel<uint32_t, address, 3, 1>;\n    using lck2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using lck1 = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using lck0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16, 1> lckk;\n  \
    \    BitFieldModel<uint32_t, 15, 1> lck15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> lck14;\n      BitFieldModel<uint32_t, 13, 1> lck13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> lck12;\n      BitFieldModel<uint32_t, 11, 1> lck11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> lck10;\n      BitFieldModel<uint32_t, 9, 1> lck9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> lck8;\n      BitFieldModel<uint32_t, 7, 1> lck7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> lck6;\n      BitFieldModel<uint32_t, 5, 1> lck5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> lck4;\n      BitFieldModel<uint32_t, 3, 1> lck3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> lck2;\n      BitFieldModel<uint32_t, 1, 1> lck1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> lck0;\n    };\n  };\n\npublic:\n  using lckr = LckrReg<BaseAddress + 0x001C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class AfrlReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using afrl7 = FieldModel<uint32_t, address, 28,\
    \ 4>;\n    using afrl6 = FieldModel<uint32_t, address, 24, 4>;\n    using afrl5\
    \ = FieldModel<uint32_t, address, 20, 4>;\n    using afrl4 = FieldModel<uint32_t,\
    \ address, 16, 4>;\n    using afrl3 = FieldModel<uint32_t, address, 12, 4>;\n\
    \    using afrl2 = FieldModel<uint32_t, address, 8, 4>;\n    using afrl1 = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using afrl0 = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 28, 4> afrl7;\n      BitFieldModel<uint32_t, 24, 4> afrl6;\n      BitFieldModel<uint32_t,\
    \ 20, 4> afrl5;\n      BitFieldModel<uint32_t, 16, 4> afrl4;\n      BitFieldModel<uint32_t,\
    \ 12, 4> afrl3;\n      BitFieldModel<uint32_t, 8, 4> afrl2;\n      BitFieldModel<uint32_t,\
    \ 4, 4> afrl1;\n      BitFieldModel<uint32_t, 0, 4> afrl0;\n    };\n  };\n\npublic:\n\
    \  using afrl = AfrlReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class AfrhReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using afrh15 = FieldModel<uint32_t, address, 28, 4>;\n    using\
    \ afrh14 = FieldModel<uint32_t, address, 24, 4>;\n    using afrh13 = FieldModel<uint32_t,\
    \ address, 20, 4>;\n    using afrh12 = FieldModel<uint32_t, address, 16, 4>;\n\
    \    using afrh11 = FieldModel<uint32_t, address, 12, 4>;\n    using afrh10 =\
    \ FieldModel<uint32_t, address, 8, 4>;\n    using afrh9 = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using afrh8 = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 28, 4> afrh15;\n      BitFieldModel<uint32_t, 24, 4> afrh14;\n      BitFieldModel<uint32_t,\
    \ 20, 4> afrh13;\n      BitFieldModel<uint32_t, 16, 4> afrh12;\n      BitFieldModel<uint32_t,\
    \ 12, 4> afrh11;\n      BitFieldModel<uint32_t, 8, 4> afrh10;\n      BitFieldModel<uint32_t,\
    \ 4, 4> afrh9;\n      BitFieldModel<uint32_t, 0, 4> afrh8;\n    };\n  };\n\npublic:\n\
    \  using afrh = AfrhReg<BaseAddress + 0x0024>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_GPIOE_H\
    \ */\n"
  name: GPIOE
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_GPIOD_H\n#define DRAL_STM32F446_GPIOD_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass gpiod\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40020C00;\n\nprivate:\n\
    \  template<unsigned int address>\n  class ModerReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using moder15 = FieldModel<uint32_t, address,\
    \ 30, 2>;\n    using moder14 = FieldModel<uint32_t, address, 28, 2>;\n    using\
    \ moder13 = FieldModel<uint32_t, address, 26, 2>;\n    using moder12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    using moder11 = FieldModel<uint32_t, address, 22, 2>;\n\
    \    using moder10 = FieldModel<uint32_t, address, 20, 2>;\n    using moder9 =\
    \ FieldModel<uint32_t, address, 18, 2>;\n    using moder8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    using moder7 = FieldModel<uint32_t, address, 14, 2>;\n\
    \    using moder6 = FieldModel<uint32_t, address, 12, 2>;\n    using moder5 =\
    \ FieldModel<uint32_t, address, 10, 2>;\n    using moder4 = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    using moder3 = FieldModel<uint32_t, address, 6, 2>;\n \
    \   using moder2 = FieldModel<uint32_t, address, 4, 2>;\n    using moder1 = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    using moder0 = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 30, 2> moder15;\n      BitFieldModel<uint32_t, 28, 2> moder14;\n      BitFieldModel<uint32_t,\
    \ 26, 2> moder13;\n      BitFieldModel<uint32_t, 24, 2> moder12;\n      BitFieldModel<uint32_t,\
    \ 22, 2> moder11;\n      BitFieldModel<uint32_t, 20, 2> moder10;\n      BitFieldModel<uint32_t,\
    \ 18, 2> moder9;\n      BitFieldModel<uint32_t, 16, 2> moder8;\n      BitFieldModel<uint32_t,\
    \ 14, 2> moder7;\n      BitFieldModel<uint32_t, 12, 2> moder6;\n      BitFieldModel<uint32_t,\
    \ 10, 2> moder5;\n      BitFieldModel<uint32_t, 8, 2> moder4;\n      BitFieldModel<uint32_t,\
    \ 6, 2> moder3;\n      BitFieldModel<uint32_t, 4, 2> moder2;\n      BitFieldModel<uint32_t,\
    \ 2, 2> moder1;\n      BitFieldModel<uint32_t, 0, 2> moder0;\n    };\n  };\n\n\
    public:\n  using moder = ModerReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class OtyperReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ot15 = FieldModel<uint32_t, address, 15, 1>;\n    using\
    \ ot14 = FieldModel<uint32_t, address, 14, 1>;\n    using ot13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using ot12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using ot11 = FieldModel<uint32_t, address, 11, 1>;\n    using ot10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using ot9 = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using ot8 = FieldModel<uint32_t, address, 8, 1>;\n    using ot7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using ot6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ ot5 = FieldModel<uint32_t, address, 5, 1>;\n    using ot4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ot3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ ot2 = FieldModel<uint32_t, address, 2, 1>;\n    using ot1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ot0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 15,\
    \ 1> ot15;\n      BitFieldModel<uint32_t, 14, 1> ot14;\n      BitFieldModel<uint32_t,\
    \ 13, 1> ot13;\n      BitFieldModel<uint32_t, 12, 1> ot12;\n      BitFieldModel<uint32_t,\
    \ 11, 1> ot11;\n      BitFieldModel<uint32_t, 10, 1> ot10;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ot9;\n      BitFieldModel<uint32_t, 8, 1> ot8;\n      BitFieldModel<uint32_t,\
    \ 7, 1> ot7;\n      BitFieldModel<uint32_t, 6, 1> ot6;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ot5;\n      BitFieldModel<uint32_t, 4, 1> ot4;\n      BitFieldModel<uint32_t,\
    \ 3, 1> ot3;\n      BitFieldModel<uint32_t, 2, 1> ot2;\n      BitFieldModel<uint32_t,\
    \ 1, 1> ot1;\n      BitFieldModel<uint32_t, 0, 1> ot0;\n    };\n  };\n\npublic:\n\
    \  using otyper = OtyperReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class OspeedrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ospeedr15 = FieldModel<uint32_t, address, 30, 2>;\n\
    \    using ospeedr14 = FieldModel<uint32_t, address, 28, 2>;\n    using ospeedr13\
    \ = FieldModel<uint32_t, address, 26, 2>;\n    using ospeedr12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    using ospeedr11 = FieldModel<uint32_t, address, 22, 2>;\n\
    \    using ospeedr10 = FieldModel<uint32_t, address, 20, 2>;\n    using ospeedr9\
    \ = FieldModel<uint32_t, address, 18, 2>;\n    using ospeedr8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    using ospeedr7 = FieldModel<uint32_t, address, 14, 2>;\n\
    \    using ospeedr6 = FieldModel<uint32_t, address, 12, 2>;\n    using ospeedr5\
    \ = FieldModel<uint32_t, address, 10, 2>;\n    using ospeedr4 = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    using ospeedr3 = FieldModel<uint32_t, address, 6, 2>;\n\
    \    using ospeedr2 = FieldModel<uint32_t, address, 4, 2>;\n    using ospeedr1\
    \ = FieldModel<uint32_t, address, 2, 2>;\n    using ospeedr0 = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 30, 2> ospeedr15;\n      BitFieldModel<uint32_t,\
    \ 28, 2> ospeedr14;\n      BitFieldModel<uint32_t, 26, 2> ospeedr13;\n      BitFieldModel<uint32_t,\
    \ 24, 2> ospeedr12;\n      BitFieldModel<uint32_t, 22, 2> ospeedr11;\n      BitFieldModel<uint32_t,\
    \ 20, 2> ospeedr10;\n      BitFieldModel<uint32_t, 18, 2> ospeedr9;\n      BitFieldModel<uint32_t,\
    \ 16, 2> ospeedr8;\n      BitFieldModel<uint32_t, 14, 2> ospeedr7;\n      BitFieldModel<uint32_t,\
    \ 12, 2> ospeedr6;\n      BitFieldModel<uint32_t, 10, 2> ospeedr5;\n      BitFieldModel<uint32_t,\
    \ 8, 2> ospeedr4;\n      BitFieldModel<uint32_t, 6, 2> ospeedr3;\n      BitFieldModel<uint32_t,\
    \ 4, 2> ospeedr2;\n      BitFieldModel<uint32_t, 2, 2> ospeedr1;\n      BitFieldModel<uint32_t,\
    \ 0, 2> ospeedr0;\n    };\n  };\n\npublic:\n  using ospeedr = OspeedrReg<BaseAddress\
    \ + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class PupdrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using pupdr15 =\
    \ FieldModel<uint32_t, address, 30, 2>;\n    using pupdr14 = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    using pupdr13 = FieldModel<uint32_t, address, 26, 2>;\n\
    \    using pupdr12 = FieldModel<uint32_t, address, 24, 2>;\n    using pupdr11\
    \ = FieldModel<uint32_t, address, 22, 2>;\n    using pupdr10 = FieldModel<uint32_t,\
    \ address, 20, 2>;\n    using pupdr9 = FieldModel<uint32_t, address, 18, 2>;\n\
    \    using pupdr8 = FieldModel<uint32_t, address, 16, 2>;\n    using pupdr7 =\
    \ FieldModel<uint32_t, address, 14, 2>;\n    using pupdr6 = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    using pupdr5 = FieldModel<uint32_t, address, 10, 2>;\n\
    \    using pupdr4 = FieldModel<uint32_t, address, 8, 2>;\n    using pupdr3 = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pupdr2 = FieldModel<uint32_t, address, 4, 2>;\n \
    \   using pupdr1 = FieldModel<uint32_t, address, 2, 2>;\n    using pupdr0 = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 30, 2> pupdr15;\n      BitFieldModel<uint32_t,\
    \ 28, 2> pupdr14;\n      BitFieldModel<uint32_t, 26, 2> pupdr13;\n      BitFieldModel<uint32_t,\
    \ 24, 2> pupdr12;\n      BitFieldModel<uint32_t, 22, 2> pupdr11;\n      BitFieldModel<uint32_t,\
    \ 20, 2> pupdr10;\n      BitFieldModel<uint32_t, 18, 2> pupdr9;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pupdr8;\n      BitFieldModel<uint32_t, 14, 2> pupdr7;\n      BitFieldModel<uint32_t,\
    \ 12, 2> pupdr6;\n      BitFieldModel<uint32_t, 10, 2> pupdr5;\n      BitFieldModel<uint32_t,\
    \ 8, 2> pupdr4;\n      BitFieldModel<uint32_t, 6, 2> pupdr3;\n      BitFieldModel<uint32_t,\
    \ 4, 2> pupdr2;\n      BitFieldModel<uint32_t, 2, 2> pupdr1;\n      BitFieldModel<uint32_t,\
    \ 0, 2> pupdr0;\n    };\n  };\n\npublic:\n  using pupdr = PupdrReg<BaseAddress\
    \ + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class IdrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using idr15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using idr14 = FieldModel<uint32_t, address, 14, 1>;\n\
    \    using idr13 = FieldModel<uint32_t, address, 13, 1>;\n    using idr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using idr11 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using idr10 = FieldModel<uint32_t, address, 10, 1>;\n    using idr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using idr8 = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using idr7 = FieldModel<uint32_t, address, 7, 1>;\n    using idr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using idr5 = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using idr4 = FieldModel<uint32_t, address, 4, 1>;\n    using idr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using idr2 = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using idr1 = FieldModel<uint32_t, address, 1, 1>;\n    using idr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> idr15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> idr14;\n      BitFieldModel<uint32_t, 13, 1> idr13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> idr12;\n      BitFieldModel<uint32_t, 11, 1> idr11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> idr10;\n      BitFieldModel<uint32_t, 9, 1> idr9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> idr8;\n      BitFieldModel<uint32_t, 7, 1> idr7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> idr6;\n      BitFieldModel<uint32_t, 5, 1> idr5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> idr4;\n      BitFieldModel<uint32_t, 3, 1> idr3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> idr2;\n      BitFieldModel<uint32_t, 1, 1> idr1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> idr0;\n    };\n  };\n\npublic:\n  using idr = IdrReg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class OdrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using odr15 = FieldModel<uint32_t, address, 15,\
    \ 1>;\n    using odr14 = FieldModel<uint32_t, address, 14, 1>;\n    using odr13\
    \ = FieldModel<uint32_t, address, 13, 1>;\n    using odr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using odr11 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using odr10 = FieldModel<uint32_t, address, 10, 1>;\n    using odr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using odr8 = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using odr7 = FieldModel<uint32_t, address, 7, 1>;\n    using odr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using odr5 = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using odr4 = FieldModel<uint32_t, address, 4, 1>;\n    using odr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using odr2 = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using odr1 = FieldModel<uint32_t, address, 1, 1>;\n    using odr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> odr15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> odr14;\n      BitFieldModel<uint32_t, 13, 1> odr13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> odr12;\n      BitFieldModel<uint32_t, 11, 1> odr11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> odr10;\n      BitFieldModel<uint32_t, 9, 1> odr9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> odr8;\n      BitFieldModel<uint32_t, 7, 1> odr7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> odr6;\n      BitFieldModel<uint32_t, 5, 1> odr5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> odr4;\n      BitFieldModel<uint32_t, 3, 1> odr3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> odr2;\n      BitFieldModel<uint32_t, 1, 1> odr1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> odr0;\n    };\n  };\n\npublic:\n  using odr = OdrReg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class BsrrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using br15 = FieldModel<uint32_t, address, 31,\
    \ 1>;\n    using br14 = FieldModel<uint32_t, address, 30, 1>;\n    using br13\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using br12 = FieldModel<uint32_t,\
    \ address, 28, 1>;\n    using br11 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using br10 = FieldModel<uint32_t, address, 26, 1>;\n    using br9 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using br8 = FieldModel<uint32_t, address, 24, 1>;\n  \
    \  using br7 = FieldModel<uint32_t, address, 23, 1>;\n    using br6 = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    using br5 = FieldModel<uint32_t, address, 21, 1>;\n  \
    \  using br4 = FieldModel<uint32_t, address, 20, 1>;\n    using br3 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using br2 = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using br1 = FieldModel<uint32_t, address, 17, 1>;\n    using br0 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using bs15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using bs14 = FieldModel<uint32_t, address, 14, 1>;\n    using bs13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using bs12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using bs11 = FieldModel<uint32_t, address, 11, 1>;\n    using bs10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using bs9 = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using bs8 = FieldModel<uint32_t, address, 8, 1>;\n    using bs7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bs6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ bs5 = FieldModel<uint32_t, address, 5, 1>;\n    using bs4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using bs3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ bs2 = FieldModel<uint32_t, address, 2, 1>;\n    using bs1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using bs0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 31,\
    \ 1> br15;\n      BitFieldModel<uint32_t, 30, 1> br14;\n      BitFieldModel<uint32_t,\
    \ 29, 1> br13;\n      BitFieldModel<uint32_t, 28, 1> br12;\n      BitFieldModel<uint32_t,\
    \ 27, 1> br11;\n      BitFieldModel<uint32_t, 26, 1> br10;\n      BitFieldModel<uint32_t,\
    \ 25, 1> br9;\n      BitFieldModel<uint32_t, 24, 1> br8;\n      BitFieldModel<uint32_t,\
    \ 23, 1> br7;\n      BitFieldModel<uint32_t, 22, 1> br6;\n      BitFieldModel<uint32_t,\
    \ 21, 1> br5;\n      BitFieldModel<uint32_t, 20, 1> br4;\n      BitFieldModel<uint32_t,\
    \ 19, 1> br3;\n      BitFieldModel<uint32_t, 18, 1> br2;\n      BitFieldModel<uint32_t,\
    \ 17, 1> br1;\n      BitFieldModel<uint32_t, 16, 1> br0;\n      BitFieldModel<uint32_t,\
    \ 15, 1> bs15;\n      BitFieldModel<uint32_t, 14, 1> bs14;\n      BitFieldModel<uint32_t,\
    \ 13, 1> bs13;\n      BitFieldModel<uint32_t, 12, 1> bs12;\n      BitFieldModel<uint32_t,\
    \ 11, 1> bs11;\n      BitFieldModel<uint32_t, 10, 1> bs10;\n      BitFieldModel<uint32_t,\
    \ 9, 1> bs9;\n      BitFieldModel<uint32_t, 8, 1> bs8;\n      BitFieldModel<uint32_t,\
    \ 7, 1> bs7;\n      BitFieldModel<uint32_t, 6, 1> bs6;\n      BitFieldModel<uint32_t,\
    \ 5, 1> bs5;\n      BitFieldModel<uint32_t, 4, 1> bs4;\n      BitFieldModel<uint32_t,\
    \ 3, 1> bs3;\n      BitFieldModel<uint32_t, 2, 1> bs2;\n      BitFieldModel<uint32_t,\
    \ 1, 1> bs1;\n      BitFieldModel<uint32_t, 0, 1> bs0;\n    };\n  };\n\npublic:\n\
    \  using bsrr = BsrrReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class LckrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using lckk = FieldModel<uint32_t, address, 16, 1>;\n    using\
    \ lck15 = FieldModel<uint32_t, address, 15, 1>;\n    using lck14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using lck13 = FieldModel<uint32_t, address, 13, 1>;\n\
    \    using lck12 = FieldModel<uint32_t, address, 12, 1>;\n    using lck11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using lck10 = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using lck9 = FieldModel<uint32_t, address, 9, 1>;\n    using lck8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using lck7 = FieldModel<uint32_t, address, 7, 1>;\n   \
    \ using lck6 = FieldModel<uint32_t, address, 6, 1>;\n    using lck5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using lck4 = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ using lck3 = FieldModel<uint32_t, address, 3, 1>;\n    using lck2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using lck1 = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using lck0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16, 1> lckk;\n  \
    \    BitFieldModel<uint32_t, 15, 1> lck15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> lck14;\n      BitFieldModel<uint32_t, 13, 1> lck13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> lck12;\n      BitFieldModel<uint32_t, 11, 1> lck11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> lck10;\n      BitFieldModel<uint32_t, 9, 1> lck9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> lck8;\n      BitFieldModel<uint32_t, 7, 1> lck7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> lck6;\n      BitFieldModel<uint32_t, 5, 1> lck5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> lck4;\n      BitFieldModel<uint32_t, 3, 1> lck3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> lck2;\n      BitFieldModel<uint32_t, 1, 1> lck1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> lck0;\n    };\n  };\n\npublic:\n  using lckr = LckrReg<BaseAddress + 0x001C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class AfrlReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using afrl7 = FieldModel<uint32_t, address, 28,\
    \ 4>;\n    using afrl6 = FieldModel<uint32_t, address, 24, 4>;\n    using afrl5\
    \ = FieldModel<uint32_t, address, 20, 4>;\n    using afrl4 = FieldModel<uint32_t,\
    \ address, 16, 4>;\n    using afrl3 = FieldModel<uint32_t, address, 12, 4>;\n\
    \    using afrl2 = FieldModel<uint32_t, address, 8, 4>;\n    using afrl1 = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using afrl0 = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 28, 4> afrl7;\n      BitFieldModel<uint32_t, 24, 4> afrl6;\n      BitFieldModel<uint32_t,\
    \ 20, 4> afrl5;\n      BitFieldModel<uint32_t, 16, 4> afrl4;\n      BitFieldModel<uint32_t,\
    \ 12, 4> afrl3;\n      BitFieldModel<uint32_t, 8, 4> afrl2;\n      BitFieldModel<uint32_t,\
    \ 4, 4> afrl1;\n      BitFieldModel<uint32_t, 0, 4> afrl0;\n    };\n  };\n\npublic:\n\
    \  using afrl = AfrlReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class AfrhReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using afrh15 = FieldModel<uint32_t, address, 28, 4>;\n    using\
    \ afrh14 = FieldModel<uint32_t, address, 24, 4>;\n    using afrh13 = FieldModel<uint32_t,\
    \ address, 20, 4>;\n    using afrh12 = FieldModel<uint32_t, address, 16, 4>;\n\
    \    using afrh11 = FieldModel<uint32_t, address, 12, 4>;\n    using afrh10 =\
    \ FieldModel<uint32_t, address, 8, 4>;\n    using afrh9 = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using afrh8 = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 28, 4> afrh15;\n      BitFieldModel<uint32_t, 24, 4> afrh14;\n      BitFieldModel<uint32_t,\
    \ 20, 4> afrh13;\n      BitFieldModel<uint32_t, 16, 4> afrh12;\n      BitFieldModel<uint32_t,\
    \ 12, 4> afrh11;\n      BitFieldModel<uint32_t, 8, 4> afrh10;\n      BitFieldModel<uint32_t,\
    \ 4, 4> afrh9;\n      BitFieldModel<uint32_t, 0, 4> afrh8;\n    };\n  };\n\npublic:\n\
    \  using afrh = AfrhReg<BaseAddress + 0x0024>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_GPIOD_H\
    \ */\n"
  name: GPIOD
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_GPIOC_H\n#define DRAL_STM32F446_GPIOC_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass gpioc\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40020800;\n\nprivate:\n\
    \  template<unsigned int address>\n  class ModerReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using moder15 = FieldModel<uint32_t, address,\
    \ 30, 2>;\n    using moder14 = FieldModel<uint32_t, address, 28, 2>;\n    using\
    \ moder13 = FieldModel<uint32_t, address, 26, 2>;\n    using moder12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    using moder11 = FieldModel<uint32_t, address, 22, 2>;\n\
    \    using moder10 = FieldModel<uint32_t, address, 20, 2>;\n    using moder9 =\
    \ FieldModel<uint32_t, address, 18, 2>;\n    using moder8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    using moder7 = FieldModel<uint32_t, address, 14, 2>;\n\
    \    using moder6 = FieldModel<uint32_t, address, 12, 2>;\n    using moder5 =\
    \ FieldModel<uint32_t, address, 10, 2>;\n    using moder4 = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    using moder3 = FieldModel<uint32_t, address, 6, 2>;\n \
    \   using moder2 = FieldModel<uint32_t, address, 4, 2>;\n    using moder1 = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    using moder0 = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 30, 2> moder15;\n      BitFieldModel<uint32_t, 28, 2> moder14;\n      BitFieldModel<uint32_t,\
    \ 26, 2> moder13;\n      BitFieldModel<uint32_t, 24, 2> moder12;\n      BitFieldModel<uint32_t,\
    \ 22, 2> moder11;\n      BitFieldModel<uint32_t, 20, 2> moder10;\n      BitFieldModel<uint32_t,\
    \ 18, 2> moder9;\n      BitFieldModel<uint32_t, 16, 2> moder8;\n      BitFieldModel<uint32_t,\
    \ 14, 2> moder7;\n      BitFieldModel<uint32_t, 12, 2> moder6;\n      BitFieldModel<uint32_t,\
    \ 10, 2> moder5;\n      BitFieldModel<uint32_t, 8, 2> moder4;\n      BitFieldModel<uint32_t,\
    \ 6, 2> moder3;\n      BitFieldModel<uint32_t, 4, 2> moder2;\n      BitFieldModel<uint32_t,\
    \ 2, 2> moder1;\n      BitFieldModel<uint32_t, 0, 2> moder0;\n    };\n  };\n\n\
    public:\n  using moder = ModerReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class OtyperReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ot15 = FieldModel<uint32_t, address, 15, 1>;\n    using\
    \ ot14 = FieldModel<uint32_t, address, 14, 1>;\n    using ot13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using ot12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using ot11 = FieldModel<uint32_t, address, 11, 1>;\n    using ot10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using ot9 = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using ot8 = FieldModel<uint32_t, address, 8, 1>;\n    using ot7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using ot6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ ot5 = FieldModel<uint32_t, address, 5, 1>;\n    using ot4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ot3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ ot2 = FieldModel<uint32_t, address, 2, 1>;\n    using ot1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ot0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 15,\
    \ 1> ot15;\n      BitFieldModel<uint32_t, 14, 1> ot14;\n      BitFieldModel<uint32_t,\
    \ 13, 1> ot13;\n      BitFieldModel<uint32_t, 12, 1> ot12;\n      BitFieldModel<uint32_t,\
    \ 11, 1> ot11;\n      BitFieldModel<uint32_t, 10, 1> ot10;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ot9;\n      BitFieldModel<uint32_t, 8, 1> ot8;\n      BitFieldModel<uint32_t,\
    \ 7, 1> ot7;\n      BitFieldModel<uint32_t, 6, 1> ot6;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ot5;\n      BitFieldModel<uint32_t, 4, 1> ot4;\n      BitFieldModel<uint32_t,\
    \ 3, 1> ot3;\n      BitFieldModel<uint32_t, 2, 1> ot2;\n      BitFieldModel<uint32_t,\
    \ 1, 1> ot1;\n      BitFieldModel<uint32_t, 0, 1> ot0;\n    };\n  };\n\npublic:\n\
    \  using otyper = OtyperReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class OspeedrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ospeedr15 = FieldModel<uint32_t, address, 30, 2>;\n\
    \    using ospeedr14 = FieldModel<uint32_t, address, 28, 2>;\n    using ospeedr13\
    \ = FieldModel<uint32_t, address, 26, 2>;\n    using ospeedr12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    using ospeedr11 = FieldModel<uint32_t, address, 22, 2>;\n\
    \    using ospeedr10 = FieldModel<uint32_t, address, 20, 2>;\n    using ospeedr9\
    \ = FieldModel<uint32_t, address, 18, 2>;\n    using ospeedr8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    using ospeedr7 = FieldModel<uint32_t, address, 14, 2>;\n\
    \    using ospeedr6 = FieldModel<uint32_t, address, 12, 2>;\n    using ospeedr5\
    \ = FieldModel<uint32_t, address, 10, 2>;\n    using ospeedr4 = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    using ospeedr3 = FieldModel<uint32_t, address, 6, 2>;\n\
    \    using ospeedr2 = FieldModel<uint32_t, address, 4, 2>;\n    using ospeedr1\
    \ = FieldModel<uint32_t, address, 2, 2>;\n    using ospeedr0 = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 30, 2> ospeedr15;\n      BitFieldModel<uint32_t,\
    \ 28, 2> ospeedr14;\n      BitFieldModel<uint32_t, 26, 2> ospeedr13;\n      BitFieldModel<uint32_t,\
    \ 24, 2> ospeedr12;\n      BitFieldModel<uint32_t, 22, 2> ospeedr11;\n      BitFieldModel<uint32_t,\
    \ 20, 2> ospeedr10;\n      BitFieldModel<uint32_t, 18, 2> ospeedr9;\n      BitFieldModel<uint32_t,\
    \ 16, 2> ospeedr8;\n      BitFieldModel<uint32_t, 14, 2> ospeedr7;\n      BitFieldModel<uint32_t,\
    \ 12, 2> ospeedr6;\n      BitFieldModel<uint32_t, 10, 2> ospeedr5;\n      BitFieldModel<uint32_t,\
    \ 8, 2> ospeedr4;\n      BitFieldModel<uint32_t, 6, 2> ospeedr3;\n      BitFieldModel<uint32_t,\
    \ 4, 2> ospeedr2;\n      BitFieldModel<uint32_t, 2, 2> ospeedr1;\n      BitFieldModel<uint32_t,\
    \ 0, 2> ospeedr0;\n    };\n  };\n\npublic:\n  using ospeedr = OspeedrReg<BaseAddress\
    \ + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class PupdrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using pupdr15 =\
    \ FieldModel<uint32_t, address, 30, 2>;\n    using pupdr14 = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    using pupdr13 = FieldModel<uint32_t, address, 26, 2>;\n\
    \    using pupdr12 = FieldModel<uint32_t, address, 24, 2>;\n    using pupdr11\
    \ = FieldModel<uint32_t, address, 22, 2>;\n    using pupdr10 = FieldModel<uint32_t,\
    \ address, 20, 2>;\n    using pupdr9 = FieldModel<uint32_t, address, 18, 2>;\n\
    \    using pupdr8 = FieldModel<uint32_t, address, 16, 2>;\n    using pupdr7 =\
    \ FieldModel<uint32_t, address, 14, 2>;\n    using pupdr6 = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    using pupdr5 = FieldModel<uint32_t, address, 10, 2>;\n\
    \    using pupdr4 = FieldModel<uint32_t, address, 8, 2>;\n    using pupdr3 = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pupdr2 = FieldModel<uint32_t, address, 4, 2>;\n \
    \   using pupdr1 = FieldModel<uint32_t, address, 2, 2>;\n    using pupdr0 = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 30, 2> pupdr15;\n      BitFieldModel<uint32_t,\
    \ 28, 2> pupdr14;\n      BitFieldModel<uint32_t, 26, 2> pupdr13;\n      BitFieldModel<uint32_t,\
    \ 24, 2> pupdr12;\n      BitFieldModel<uint32_t, 22, 2> pupdr11;\n      BitFieldModel<uint32_t,\
    \ 20, 2> pupdr10;\n      BitFieldModel<uint32_t, 18, 2> pupdr9;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pupdr8;\n      BitFieldModel<uint32_t, 14, 2> pupdr7;\n      BitFieldModel<uint32_t,\
    \ 12, 2> pupdr6;\n      BitFieldModel<uint32_t, 10, 2> pupdr5;\n      BitFieldModel<uint32_t,\
    \ 8, 2> pupdr4;\n      BitFieldModel<uint32_t, 6, 2> pupdr3;\n      BitFieldModel<uint32_t,\
    \ 4, 2> pupdr2;\n      BitFieldModel<uint32_t, 2, 2> pupdr1;\n      BitFieldModel<uint32_t,\
    \ 0, 2> pupdr0;\n    };\n  };\n\npublic:\n  using pupdr = PupdrReg<BaseAddress\
    \ + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class IdrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using idr15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using idr14 = FieldModel<uint32_t, address, 14, 1>;\n\
    \    using idr13 = FieldModel<uint32_t, address, 13, 1>;\n    using idr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using idr11 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using idr10 = FieldModel<uint32_t, address, 10, 1>;\n    using idr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using idr8 = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using idr7 = FieldModel<uint32_t, address, 7, 1>;\n    using idr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using idr5 = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using idr4 = FieldModel<uint32_t, address, 4, 1>;\n    using idr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using idr2 = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using idr1 = FieldModel<uint32_t, address, 1, 1>;\n    using idr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> idr15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> idr14;\n      BitFieldModel<uint32_t, 13, 1> idr13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> idr12;\n      BitFieldModel<uint32_t, 11, 1> idr11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> idr10;\n      BitFieldModel<uint32_t, 9, 1> idr9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> idr8;\n      BitFieldModel<uint32_t, 7, 1> idr7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> idr6;\n      BitFieldModel<uint32_t, 5, 1> idr5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> idr4;\n      BitFieldModel<uint32_t, 3, 1> idr3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> idr2;\n      BitFieldModel<uint32_t, 1, 1> idr1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> idr0;\n    };\n  };\n\npublic:\n  using idr = IdrReg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class OdrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using odr15 = FieldModel<uint32_t, address, 15,\
    \ 1>;\n    using odr14 = FieldModel<uint32_t, address, 14, 1>;\n    using odr13\
    \ = FieldModel<uint32_t, address, 13, 1>;\n    using odr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using odr11 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using odr10 = FieldModel<uint32_t, address, 10, 1>;\n    using odr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using odr8 = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using odr7 = FieldModel<uint32_t, address, 7, 1>;\n    using odr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using odr5 = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using odr4 = FieldModel<uint32_t, address, 4, 1>;\n    using odr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using odr2 = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using odr1 = FieldModel<uint32_t, address, 1, 1>;\n    using odr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> odr15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> odr14;\n      BitFieldModel<uint32_t, 13, 1> odr13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> odr12;\n      BitFieldModel<uint32_t, 11, 1> odr11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> odr10;\n      BitFieldModel<uint32_t, 9, 1> odr9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> odr8;\n      BitFieldModel<uint32_t, 7, 1> odr7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> odr6;\n      BitFieldModel<uint32_t, 5, 1> odr5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> odr4;\n      BitFieldModel<uint32_t, 3, 1> odr3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> odr2;\n      BitFieldModel<uint32_t, 1, 1> odr1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> odr0;\n    };\n  };\n\npublic:\n  using odr = OdrReg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class BsrrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using br15 = FieldModel<uint32_t, address, 31,\
    \ 1>;\n    using br14 = FieldModel<uint32_t, address, 30, 1>;\n    using br13\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using br12 = FieldModel<uint32_t,\
    \ address, 28, 1>;\n    using br11 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using br10 = FieldModel<uint32_t, address, 26, 1>;\n    using br9 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using br8 = FieldModel<uint32_t, address, 24, 1>;\n  \
    \  using br7 = FieldModel<uint32_t, address, 23, 1>;\n    using br6 = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    using br5 = FieldModel<uint32_t, address, 21, 1>;\n  \
    \  using br4 = FieldModel<uint32_t, address, 20, 1>;\n    using br3 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using br2 = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using br1 = FieldModel<uint32_t, address, 17, 1>;\n    using br0 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using bs15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using bs14 = FieldModel<uint32_t, address, 14, 1>;\n    using bs13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using bs12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using bs11 = FieldModel<uint32_t, address, 11, 1>;\n    using bs10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using bs9 = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using bs8 = FieldModel<uint32_t, address, 8, 1>;\n    using bs7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bs6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ bs5 = FieldModel<uint32_t, address, 5, 1>;\n    using bs4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using bs3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ bs2 = FieldModel<uint32_t, address, 2, 1>;\n    using bs1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using bs0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 31,\
    \ 1> br15;\n      BitFieldModel<uint32_t, 30, 1> br14;\n      BitFieldModel<uint32_t,\
    \ 29, 1> br13;\n      BitFieldModel<uint32_t, 28, 1> br12;\n      BitFieldModel<uint32_t,\
    \ 27, 1> br11;\n      BitFieldModel<uint32_t, 26, 1> br10;\n      BitFieldModel<uint32_t,\
    \ 25, 1> br9;\n      BitFieldModel<uint32_t, 24, 1> br8;\n      BitFieldModel<uint32_t,\
    \ 23, 1> br7;\n      BitFieldModel<uint32_t, 22, 1> br6;\n      BitFieldModel<uint32_t,\
    \ 21, 1> br5;\n      BitFieldModel<uint32_t, 20, 1> br4;\n      BitFieldModel<uint32_t,\
    \ 19, 1> br3;\n      BitFieldModel<uint32_t, 18, 1> br2;\n      BitFieldModel<uint32_t,\
    \ 17, 1> br1;\n      BitFieldModel<uint32_t, 16, 1> br0;\n      BitFieldModel<uint32_t,\
    \ 15, 1> bs15;\n      BitFieldModel<uint32_t, 14, 1> bs14;\n      BitFieldModel<uint32_t,\
    \ 13, 1> bs13;\n      BitFieldModel<uint32_t, 12, 1> bs12;\n      BitFieldModel<uint32_t,\
    \ 11, 1> bs11;\n      BitFieldModel<uint32_t, 10, 1> bs10;\n      BitFieldModel<uint32_t,\
    \ 9, 1> bs9;\n      BitFieldModel<uint32_t, 8, 1> bs8;\n      BitFieldModel<uint32_t,\
    \ 7, 1> bs7;\n      BitFieldModel<uint32_t, 6, 1> bs6;\n      BitFieldModel<uint32_t,\
    \ 5, 1> bs5;\n      BitFieldModel<uint32_t, 4, 1> bs4;\n      BitFieldModel<uint32_t,\
    \ 3, 1> bs3;\n      BitFieldModel<uint32_t, 2, 1> bs2;\n      BitFieldModel<uint32_t,\
    \ 1, 1> bs1;\n      BitFieldModel<uint32_t, 0, 1> bs0;\n    };\n  };\n\npublic:\n\
    \  using bsrr = BsrrReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class LckrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using lckk = FieldModel<uint32_t, address, 16, 1>;\n    using\
    \ lck15 = FieldModel<uint32_t, address, 15, 1>;\n    using lck14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using lck13 = FieldModel<uint32_t, address, 13, 1>;\n\
    \    using lck12 = FieldModel<uint32_t, address, 12, 1>;\n    using lck11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using lck10 = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using lck9 = FieldModel<uint32_t, address, 9, 1>;\n    using lck8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using lck7 = FieldModel<uint32_t, address, 7, 1>;\n   \
    \ using lck6 = FieldModel<uint32_t, address, 6, 1>;\n    using lck5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using lck4 = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ using lck3 = FieldModel<uint32_t, address, 3, 1>;\n    using lck2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using lck1 = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using lck0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16, 1> lckk;\n  \
    \    BitFieldModel<uint32_t, 15, 1> lck15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> lck14;\n      BitFieldModel<uint32_t, 13, 1> lck13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> lck12;\n      BitFieldModel<uint32_t, 11, 1> lck11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> lck10;\n      BitFieldModel<uint32_t, 9, 1> lck9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> lck8;\n      BitFieldModel<uint32_t, 7, 1> lck7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> lck6;\n      BitFieldModel<uint32_t, 5, 1> lck5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> lck4;\n      BitFieldModel<uint32_t, 3, 1> lck3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> lck2;\n      BitFieldModel<uint32_t, 1, 1> lck1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> lck0;\n    };\n  };\n\npublic:\n  using lckr = LckrReg<BaseAddress + 0x001C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class AfrlReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using afrl7 = FieldModel<uint32_t, address, 28,\
    \ 4>;\n    using afrl6 = FieldModel<uint32_t, address, 24, 4>;\n    using afrl5\
    \ = FieldModel<uint32_t, address, 20, 4>;\n    using afrl4 = FieldModel<uint32_t,\
    \ address, 16, 4>;\n    using afrl3 = FieldModel<uint32_t, address, 12, 4>;\n\
    \    using afrl2 = FieldModel<uint32_t, address, 8, 4>;\n    using afrl1 = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using afrl0 = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 28, 4> afrl7;\n      BitFieldModel<uint32_t, 24, 4> afrl6;\n      BitFieldModel<uint32_t,\
    \ 20, 4> afrl5;\n      BitFieldModel<uint32_t, 16, 4> afrl4;\n      BitFieldModel<uint32_t,\
    \ 12, 4> afrl3;\n      BitFieldModel<uint32_t, 8, 4> afrl2;\n      BitFieldModel<uint32_t,\
    \ 4, 4> afrl1;\n      BitFieldModel<uint32_t, 0, 4> afrl0;\n    };\n  };\n\npublic:\n\
    \  using afrl = AfrlReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class AfrhReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using afrh15 = FieldModel<uint32_t, address, 28, 4>;\n    using\
    \ afrh14 = FieldModel<uint32_t, address, 24, 4>;\n    using afrh13 = FieldModel<uint32_t,\
    \ address, 20, 4>;\n    using afrh12 = FieldModel<uint32_t, address, 16, 4>;\n\
    \    using afrh11 = FieldModel<uint32_t, address, 12, 4>;\n    using afrh10 =\
    \ FieldModel<uint32_t, address, 8, 4>;\n    using afrh9 = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using afrh8 = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 28, 4> afrh15;\n      BitFieldModel<uint32_t, 24, 4> afrh14;\n      BitFieldModel<uint32_t,\
    \ 20, 4> afrh13;\n      BitFieldModel<uint32_t, 16, 4> afrh12;\n      BitFieldModel<uint32_t,\
    \ 12, 4> afrh11;\n      BitFieldModel<uint32_t, 8, 4> afrh10;\n      BitFieldModel<uint32_t,\
    \ 4, 4> afrh9;\n      BitFieldModel<uint32_t, 0, 4> afrh8;\n    };\n  };\n\npublic:\n\
    \  using afrh = AfrhReg<BaseAddress + 0x0024>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_GPIOC_H\
    \ */\n"
  name: GPIOC
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_GPIOB_H\n#define DRAL_STM32F446_GPIOB_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass gpiob\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40020400;\n\nprivate:\n\
    \  template<unsigned int address>\n  class ModerReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using moder15 = FieldModel<uint32_t, address,\
    \ 30, 2>;\n    using moder14 = FieldModel<uint32_t, address, 28, 2>;\n    using\
    \ moder13 = FieldModel<uint32_t, address, 26, 2>;\n    using moder12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    using moder11 = FieldModel<uint32_t, address, 22, 2>;\n\
    \    using moder10 = FieldModel<uint32_t, address, 20, 2>;\n    using moder9 =\
    \ FieldModel<uint32_t, address, 18, 2>;\n    using moder8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    using moder7 = FieldModel<uint32_t, address, 14, 2>;\n\
    \    using moder6 = FieldModel<uint32_t, address, 12, 2>;\n    using moder5 =\
    \ FieldModel<uint32_t, address, 10, 2>;\n    using moder4 = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    using moder3 = FieldModel<uint32_t, address, 6, 2>;\n \
    \   using moder2 = FieldModel<uint32_t, address, 4, 2>;\n    using moder1 = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    using moder0 = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 30, 2> moder15;\n      BitFieldModel<uint32_t, 28, 2> moder14;\n      BitFieldModel<uint32_t,\
    \ 26, 2> moder13;\n      BitFieldModel<uint32_t, 24, 2> moder12;\n      BitFieldModel<uint32_t,\
    \ 22, 2> moder11;\n      BitFieldModel<uint32_t, 20, 2> moder10;\n      BitFieldModel<uint32_t,\
    \ 18, 2> moder9;\n      BitFieldModel<uint32_t, 16, 2> moder8;\n      BitFieldModel<uint32_t,\
    \ 14, 2> moder7;\n      BitFieldModel<uint32_t, 12, 2> moder6;\n      BitFieldModel<uint32_t,\
    \ 10, 2> moder5;\n      BitFieldModel<uint32_t, 8, 2> moder4;\n      BitFieldModel<uint32_t,\
    \ 6, 2> moder3;\n      BitFieldModel<uint32_t, 4, 2> moder2;\n      BitFieldModel<uint32_t,\
    \ 2, 2> moder1;\n      BitFieldModel<uint32_t, 0, 2> moder0;\n    };\n  };\n\n\
    public:\n  using moder = ModerReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class OtyperReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ot15 = FieldModel<uint32_t, address, 15, 1>;\n    using\
    \ ot14 = FieldModel<uint32_t, address, 14, 1>;\n    using ot13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using ot12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using ot11 = FieldModel<uint32_t, address, 11, 1>;\n    using ot10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using ot9 = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using ot8 = FieldModel<uint32_t, address, 8, 1>;\n    using ot7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using ot6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ ot5 = FieldModel<uint32_t, address, 5, 1>;\n    using ot4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ot3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ ot2 = FieldModel<uint32_t, address, 2, 1>;\n    using ot1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ot0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 15,\
    \ 1> ot15;\n      BitFieldModel<uint32_t, 14, 1> ot14;\n      BitFieldModel<uint32_t,\
    \ 13, 1> ot13;\n      BitFieldModel<uint32_t, 12, 1> ot12;\n      BitFieldModel<uint32_t,\
    \ 11, 1> ot11;\n      BitFieldModel<uint32_t, 10, 1> ot10;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ot9;\n      BitFieldModel<uint32_t, 8, 1> ot8;\n      BitFieldModel<uint32_t,\
    \ 7, 1> ot7;\n      BitFieldModel<uint32_t, 6, 1> ot6;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ot5;\n      BitFieldModel<uint32_t, 4, 1> ot4;\n      BitFieldModel<uint32_t,\
    \ 3, 1> ot3;\n      BitFieldModel<uint32_t, 2, 1> ot2;\n      BitFieldModel<uint32_t,\
    \ 1, 1> ot1;\n      BitFieldModel<uint32_t, 0, 1> ot0;\n    };\n  };\n\npublic:\n\
    \  using otyper = OtyperReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class OspeedrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ospeedr15 = FieldModel<uint32_t, address, 30, 2>;\n\
    \    using ospeedr14 = FieldModel<uint32_t, address, 28, 2>;\n    using ospeedr13\
    \ = FieldModel<uint32_t, address, 26, 2>;\n    using ospeedr12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    using ospeedr11 = FieldModel<uint32_t, address, 22, 2>;\n\
    \    using ospeedr10 = FieldModel<uint32_t, address, 20, 2>;\n    using ospeedr9\
    \ = FieldModel<uint32_t, address, 18, 2>;\n    using ospeedr8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    using ospeedr7 = FieldModel<uint32_t, address, 14, 2>;\n\
    \    using ospeedr6 = FieldModel<uint32_t, address, 12, 2>;\n    using ospeedr5\
    \ = FieldModel<uint32_t, address, 10, 2>;\n    using ospeedr4 = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    using ospeedr3 = FieldModel<uint32_t, address, 6, 2>;\n\
    \    using ospeedr2 = FieldModel<uint32_t, address, 4, 2>;\n    using ospeedr1\
    \ = FieldModel<uint32_t, address, 2, 2>;\n    using ospeedr0 = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 30, 2> ospeedr15;\n      BitFieldModel<uint32_t,\
    \ 28, 2> ospeedr14;\n      BitFieldModel<uint32_t, 26, 2> ospeedr13;\n      BitFieldModel<uint32_t,\
    \ 24, 2> ospeedr12;\n      BitFieldModel<uint32_t, 22, 2> ospeedr11;\n      BitFieldModel<uint32_t,\
    \ 20, 2> ospeedr10;\n      BitFieldModel<uint32_t, 18, 2> ospeedr9;\n      BitFieldModel<uint32_t,\
    \ 16, 2> ospeedr8;\n      BitFieldModel<uint32_t, 14, 2> ospeedr7;\n      BitFieldModel<uint32_t,\
    \ 12, 2> ospeedr6;\n      BitFieldModel<uint32_t, 10, 2> ospeedr5;\n      BitFieldModel<uint32_t,\
    \ 8, 2> ospeedr4;\n      BitFieldModel<uint32_t, 6, 2> ospeedr3;\n      BitFieldModel<uint32_t,\
    \ 4, 2> ospeedr2;\n      BitFieldModel<uint32_t, 2, 2> ospeedr1;\n      BitFieldModel<uint32_t,\
    \ 0, 2> ospeedr0;\n    };\n  };\n\npublic:\n  using ospeedr = OspeedrReg<BaseAddress\
    \ + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class PupdrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using pupdr15 =\
    \ FieldModel<uint32_t, address, 30, 2>;\n    using pupdr14 = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    using pupdr13 = FieldModel<uint32_t, address, 26, 2>;\n\
    \    using pupdr12 = FieldModel<uint32_t, address, 24, 2>;\n    using pupdr11\
    \ = FieldModel<uint32_t, address, 22, 2>;\n    using pupdr10 = FieldModel<uint32_t,\
    \ address, 20, 2>;\n    using pupdr9 = FieldModel<uint32_t, address, 18, 2>;\n\
    \    using pupdr8 = FieldModel<uint32_t, address, 16, 2>;\n    using pupdr7 =\
    \ FieldModel<uint32_t, address, 14, 2>;\n    using pupdr6 = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    using pupdr5 = FieldModel<uint32_t, address, 10, 2>;\n\
    \    using pupdr4 = FieldModel<uint32_t, address, 8, 2>;\n    using pupdr3 = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pupdr2 = FieldModel<uint32_t, address, 4, 2>;\n \
    \   using pupdr1 = FieldModel<uint32_t, address, 2, 2>;\n    using pupdr0 = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 30, 2> pupdr15;\n      BitFieldModel<uint32_t,\
    \ 28, 2> pupdr14;\n      BitFieldModel<uint32_t, 26, 2> pupdr13;\n      BitFieldModel<uint32_t,\
    \ 24, 2> pupdr12;\n      BitFieldModel<uint32_t, 22, 2> pupdr11;\n      BitFieldModel<uint32_t,\
    \ 20, 2> pupdr10;\n      BitFieldModel<uint32_t, 18, 2> pupdr9;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pupdr8;\n      BitFieldModel<uint32_t, 14, 2> pupdr7;\n      BitFieldModel<uint32_t,\
    \ 12, 2> pupdr6;\n      BitFieldModel<uint32_t, 10, 2> pupdr5;\n      BitFieldModel<uint32_t,\
    \ 8, 2> pupdr4;\n      BitFieldModel<uint32_t, 6, 2> pupdr3;\n      BitFieldModel<uint32_t,\
    \ 4, 2> pupdr2;\n      BitFieldModel<uint32_t, 2, 2> pupdr1;\n      BitFieldModel<uint32_t,\
    \ 0, 2> pupdr0;\n    };\n  };\n\npublic:\n  using pupdr = PupdrReg<BaseAddress\
    \ + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class IdrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using idr15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using idr14 = FieldModel<uint32_t, address, 14, 1>;\n\
    \    using idr13 = FieldModel<uint32_t, address, 13, 1>;\n    using idr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using idr11 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using idr10 = FieldModel<uint32_t, address, 10, 1>;\n    using idr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using idr8 = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using idr7 = FieldModel<uint32_t, address, 7, 1>;\n    using idr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using idr5 = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using idr4 = FieldModel<uint32_t, address, 4, 1>;\n    using idr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using idr2 = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using idr1 = FieldModel<uint32_t, address, 1, 1>;\n    using idr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> idr15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> idr14;\n      BitFieldModel<uint32_t, 13, 1> idr13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> idr12;\n      BitFieldModel<uint32_t, 11, 1> idr11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> idr10;\n      BitFieldModel<uint32_t, 9, 1> idr9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> idr8;\n      BitFieldModel<uint32_t, 7, 1> idr7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> idr6;\n      BitFieldModel<uint32_t, 5, 1> idr5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> idr4;\n      BitFieldModel<uint32_t, 3, 1> idr3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> idr2;\n      BitFieldModel<uint32_t, 1, 1> idr1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> idr0;\n    };\n  };\n\npublic:\n  using idr = IdrReg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class OdrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using odr15 = FieldModel<uint32_t, address, 15,\
    \ 1>;\n    using odr14 = FieldModel<uint32_t, address, 14, 1>;\n    using odr13\
    \ = FieldModel<uint32_t, address, 13, 1>;\n    using odr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using odr11 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using odr10 = FieldModel<uint32_t, address, 10, 1>;\n    using odr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using odr8 = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using odr7 = FieldModel<uint32_t, address, 7, 1>;\n    using odr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using odr5 = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using odr4 = FieldModel<uint32_t, address, 4, 1>;\n    using odr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using odr2 = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using odr1 = FieldModel<uint32_t, address, 1, 1>;\n    using odr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> odr15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> odr14;\n      BitFieldModel<uint32_t, 13, 1> odr13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> odr12;\n      BitFieldModel<uint32_t, 11, 1> odr11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> odr10;\n      BitFieldModel<uint32_t, 9, 1> odr9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> odr8;\n      BitFieldModel<uint32_t, 7, 1> odr7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> odr6;\n      BitFieldModel<uint32_t, 5, 1> odr5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> odr4;\n      BitFieldModel<uint32_t, 3, 1> odr3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> odr2;\n      BitFieldModel<uint32_t, 1, 1> odr1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> odr0;\n    };\n  };\n\npublic:\n  using odr = OdrReg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class BsrrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using br15 = FieldModel<uint32_t, address, 31,\
    \ 1>;\n    using br14 = FieldModel<uint32_t, address, 30, 1>;\n    using br13\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using br12 = FieldModel<uint32_t,\
    \ address, 28, 1>;\n    using br11 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using br10 = FieldModel<uint32_t, address, 26, 1>;\n    using br9 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using br8 = FieldModel<uint32_t, address, 24, 1>;\n  \
    \  using br7 = FieldModel<uint32_t, address, 23, 1>;\n    using br6 = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    using br5 = FieldModel<uint32_t, address, 21, 1>;\n  \
    \  using br4 = FieldModel<uint32_t, address, 20, 1>;\n    using br3 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using br2 = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using br1 = FieldModel<uint32_t, address, 17, 1>;\n    using br0 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using bs15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using bs14 = FieldModel<uint32_t, address, 14, 1>;\n    using bs13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using bs12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using bs11 = FieldModel<uint32_t, address, 11, 1>;\n    using bs10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using bs9 = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using bs8 = FieldModel<uint32_t, address, 8, 1>;\n    using bs7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bs6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ bs5 = FieldModel<uint32_t, address, 5, 1>;\n    using bs4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using bs3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ bs2 = FieldModel<uint32_t, address, 2, 1>;\n    using bs1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using bs0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 31,\
    \ 1> br15;\n      BitFieldModel<uint32_t, 30, 1> br14;\n      BitFieldModel<uint32_t,\
    \ 29, 1> br13;\n      BitFieldModel<uint32_t, 28, 1> br12;\n      BitFieldModel<uint32_t,\
    \ 27, 1> br11;\n      BitFieldModel<uint32_t, 26, 1> br10;\n      BitFieldModel<uint32_t,\
    \ 25, 1> br9;\n      BitFieldModel<uint32_t, 24, 1> br8;\n      BitFieldModel<uint32_t,\
    \ 23, 1> br7;\n      BitFieldModel<uint32_t, 22, 1> br6;\n      BitFieldModel<uint32_t,\
    \ 21, 1> br5;\n      BitFieldModel<uint32_t, 20, 1> br4;\n      BitFieldModel<uint32_t,\
    \ 19, 1> br3;\n      BitFieldModel<uint32_t, 18, 1> br2;\n      BitFieldModel<uint32_t,\
    \ 17, 1> br1;\n      BitFieldModel<uint32_t, 16, 1> br0;\n      BitFieldModel<uint32_t,\
    \ 15, 1> bs15;\n      BitFieldModel<uint32_t, 14, 1> bs14;\n      BitFieldModel<uint32_t,\
    \ 13, 1> bs13;\n      BitFieldModel<uint32_t, 12, 1> bs12;\n      BitFieldModel<uint32_t,\
    \ 11, 1> bs11;\n      BitFieldModel<uint32_t, 10, 1> bs10;\n      BitFieldModel<uint32_t,\
    \ 9, 1> bs9;\n      BitFieldModel<uint32_t, 8, 1> bs8;\n      BitFieldModel<uint32_t,\
    \ 7, 1> bs7;\n      BitFieldModel<uint32_t, 6, 1> bs6;\n      BitFieldModel<uint32_t,\
    \ 5, 1> bs5;\n      BitFieldModel<uint32_t, 4, 1> bs4;\n      BitFieldModel<uint32_t,\
    \ 3, 1> bs3;\n      BitFieldModel<uint32_t, 2, 1> bs2;\n      BitFieldModel<uint32_t,\
    \ 1, 1> bs1;\n      BitFieldModel<uint32_t, 0, 1> bs0;\n    };\n  };\n\npublic:\n\
    \  using bsrr = BsrrReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class LckrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using lckk = FieldModel<uint32_t, address, 16, 1>;\n    using\
    \ lck15 = FieldModel<uint32_t, address, 15, 1>;\n    using lck14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using lck13 = FieldModel<uint32_t, address, 13, 1>;\n\
    \    using lck12 = FieldModel<uint32_t, address, 12, 1>;\n    using lck11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using lck10 = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using lck9 = FieldModel<uint32_t, address, 9, 1>;\n    using lck8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using lck7 = FieldModel<uint32_t, address, 7, 1>;\n   \
    \ using lck6 = FieldModel<uint32_t, address, 6, 1>;\n    using lck5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using lck4 = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ using lck3 = FieldModel<uint32_t, address, 3, 1>;\n    using lck2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using lck1 = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using lck0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16, 1> lckk;\n  \
    \    BitFieldModel<uint32_t, 15, 1> lck15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> lck14;\n      BitFieldModel<uint32_t, 13, 1> lck13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> lck12;\n      BitFieldModel<uint32_t, 11, 1> lck11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> lck10;\n      BitFieldModel<uint32_t, 9, 1> lck9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> lck8;\n      BitFieldModel<uint32_t, 7, 1> lck7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> lck6;\n      BitFieldModel<uint32_t, 5, 1> lck5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> lck4;\n      BitFieldModel<uint32_t, 3, 1> lck3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> lck2;\n      BitFieldModel<uint32_t, 1, 1> lck1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> lck0;\n    };\n  };\n\npublic:\n  using lckr = LckrReg<BaseAddress + 0x001C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class AfrlReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using afrl7 = FieldModel<uint32_t, address, 28,\
    \ 4>;\n    using afrl6 = FieldModel<uint32_t, address, 24, 4>;\n    using afrl5\
    \ = FieldModel<uint32_t, address, 20, 4>;\n    using afrl4 = FieldModel<uint32_t,\
    \ address, 16, 4>;\n    using afrl3 = FieldModel<uint32_t, address, 12, 4>;\n\
    \    using afrl2 = FieldModel<uint32_t, address, 8, 4>;\n    using afrl1 = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using afrl0 = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 28, 4> afrl7;\n      BitFieldModel<uint32_t, 24, 4> afrl6;\n      BitFieldModel<uint32_t,\
    \ 20, 4> afrl5;\n      BitFieldModel<uint32_t, 16, 4> afrl4;\n      BitFieldModel<uint32_t,\
    \ 12, 4> afrl3;\n      BitFieldModel<uint32_t, 8, 4> afrl2;\n      BitFieldModel<uint32_t,\
    \ 4, 4> afrl1;\n      BitFieldModel<uint32_t, 0, 4> afrl0;\n    };\n  };\n\npublic:\n\
    \  using afrl = AfrlReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class AfrhReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using afrh15 = FieldModel<uint32_t, address, 28, 4>;\n    using\
    \ afrh14 = FieldModel<uint32_t, address, 24, 4>;\n    using afrh13 = FieldModel<uint32_t,\
    \ address, 20, 4>;\n    using afrh12 = FieldModel<uint32_t, address, 16, 4>;\n\
    \    using afrh11 = FieldModel<uint32_t, address, 12, 4>;\n    using afrh10 =\
    \ FieldModel<uint32_t, address, 8, 4>;\n    using afrh9 = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using afrh8 = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 28, 4> afrh15;\n      BitFieldModel<uint32_t, 24, 4> afrh14;\n      BitFieldModel<uint32_t,\
    \ 20, 4> afrh13;\n      BitFieldModel<uint32_t, 16, 4> afrh12;\n      BitFieldModel<uint32_t,\
    \ 12, 4> afrh11;\n      BitFieldModel<uint32_t, 8, 4> afrh10;\n      BitFieldModel<uint32_t,\
    \ 4, 4> afrh9;\n      BitFieldModel<uint32_t, 0, 4> afrh8;\n    };\n  };\n\npublic:\n\
    \  using afrh = AfrhReg<BaseAddress + 0x0024>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_GPIOB_H\
    \ */\n"
  name: GPIOB
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_GPIOA_H\n#define DRAL_STM32F446_GPIOA_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass gpioa\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40020000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class ModerReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using moder15 = FieldModel<uint32_t, address,\
    \ 30, 2>;\n    using moder14 = FieldModel<uint32_t, address, 28, 2>;\n    using\
    \ moder13 = FieldModel<uint32_t, address, 26, 2>;\n    using moder12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    using moder11 = FieldModel<uint32_t, address, 22, 2>;\n\
    \    using moder10 = FieldModel<uint32_t, address, 20, 2>;\n    using moder9 =\
    \ FieldModel<uint32_t, address, 18, 2>;\n    using moder8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    using moder7 = FieldModel<uint32_t, address, 14, 2>;\n\
    \    using moder6 = FieldModel<uint32_t, address, 12, 2>;\n    using moder5 =\
    \ FieldModel<uint32_t, address, 10, 2>;\n    using moder4 = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    using moder3 = FieldModel<uint32_t, address, 6, 2>;\n \
    \   using moder2 = FieldModel<uint32_t, address, 4, 2>;\n    using moder1 = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    using moder0 = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 30, 2> moder15;\n      BitFieldModel<uint32_t, 28, 2> moder14;\n      BitFieldModel<uint32_t,\
    \ 26, 2> moder13;\n      BitFieldModel<uint32_t, 24, 2> moder12;\n      BitFieldModel<uint32_t,\
    \ 22, 2> moder11;\n      BitFieldModel<uint32_t, 20, 2> moder10;\n      BitFieldModel<uint32_t,\
    \ 18, 2> moder9;\n      BitFieldModel<uint32_t, 16, 2> moder8;\n      BitFieldModel<uint32_t,\
    \ 14, 2> moder7;\n      BitFieldModel<uint32_t, 12, 2> moder6;\n      BitFieldModel<uint32_t,\
    \ 10, 2> moder5;\n      BitFieldModel<uint32_t, 8, 2> moder4;\n      BitFieldModel<uint32_t,\
    \ 6, 2> moder3;\n      BitFieldModel<uint32_t, 4, 2> moder2;\n      BitFieldModel<uint32_t,\
    \ 2, 2> moder1;\n      BitFieldModel<uint32_t, 0, 2> moder0;\n    };\n  };\n\n\
    public:\n  using moder = ModerReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class OtyperReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ot15 = FieldModel<uint32_t, address, 15, 1>;\n    using\
    \ ot14 = FieldModel<uint32_t, address, 14, 1>;\n    using ot13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using ot12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using ot11 = FieldModel<uint32_t, address, 11, 1>;\n    using ot10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using ot9 = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using ot8 = FieldModel<uint32_t, address, 8, 1>;\n    using ot7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using ot6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ ot5 = FieldModel<uint32_t, address, 5, 1>;\n    using ot4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ot3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ ot2 = FieldModel<uint32_t, address, 2, 1>;\n    using ot1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ot0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 15,\
    \ 1> ot15;\n      BitFieldModel<uint32_t, 14, 1> ot14;\n      BitFieldModel<uint32_t,\
    \ 13, 1> ot13;\n      BitFieldModel<uint32_t, 12, 1> ot12;\n      BitFieldModel<uint32_t,\
    \ 11, 1> ot11;\n      BitFieldModel<uint32_t, 10, 1> ot10;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ot9;\n      BitFieldModel<uint32_t, 8, 1> ot8;\n      BitFieldModel<uint32_t,\
    \ 7, 1> ot7;\n      BitFieldModel<uint32_t, 6, 1> ot6;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ot5;\n      BitFieldModel<uint32_t, 4, 1> ot4;\n      BitFieldModel<uint32_t,\
    \ 3, 1> ot3;\n      BitFieldModel<uint32_t, 2, 1> ot2;\n      BitFieldModel<uint32_t,\
    \ 1, 1> ot1;\n      BitFieldModel<uint32_t, 0, 1> ot0;\n    };\n  };\n\npublic:\n\
    \  using otyper = OtyperReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class OspeedrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ospeedr15 = FieldModel<uint32_t, address, 30, 2>;\n\
    \    using ospeedr14 = FieldModel<uint32_t, address, 28, 2>;\n    using ospeedr13\
    \ = FieldModel<uint32_t, address, 26, 2>;\n    using ospeedr12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    using ospeedr11 = FieldModel<uint32_t, address, 22, 2>;\n\
    \    using ospeedr10 = FieldModel<uint32_t, address, 20, 2>;\n    using ospeedr9\
    \ = FieldModel<uint32_t, address, 18, 2>;\n    using ospeedr8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    using ospeedr7 = FieldModel<uint32_t, address, 14, 2>;\n\
    \    using ospeedr6 = FieldModel<uint32_t, address, 12, 2>;\n    using ospeedr5\
    \ = FieldModel<uint32_t, address, 10, 2>;\n    using ospeedr4 = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    using ospeedr3 = FieldModel<uint32_t, address, 6, 2>;\n\
    \    using ospeedr2 = FieldModel<uint32_t, address, 4, 2>;\n    using ospeedr1\
    \ = FieldModel<uint32_t, address, 2, 2>;\n    using ospeedr0 = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 30, 2> ospeedr15;\n      BitFieldModel<uint32_t,\
    \ 28, 2> ospeedr14;\n      BitFieldModel<uint32_t, 26, 2> ospeedr13;\n      BitFieldModel<uint32_t,\
    \ 24, 2> ospeedr12;\n      BitFieldModel<uint32_t, 22, 2> ospeedr11;\n      BitFieldModel<uint32_t,\
    \ 20, 2> ospeedr10;\n      BitFieldModel<uint32_t, 18, 2> ospeedr9;\n      BitFieldModel<uint32_t,\
    \ 16, 2> ospeedr8;\n      BitFieldModel<uint32_t, 14, 2> ospeedr7;\n      BitFieldModel<uint32_t,\
    \ 12, 2> ospeedr6;\n      BitFieldModel<uint32_t, 10, 2> ospeedr5;\n      BitFieldModel<uint32_t,\
    \ 8, 2> ospeedr4;\n      BitFieldModel<uint32_t, 6, 2> ospeedr3;\n      BitFieldModel<uint32_t,\
    \ 4, 2> ospeedr2;\n      BitFieldModel<uint32_t, 2, 2> ospeedr1;\n      BitFieldModel<uint32_t,\
    \ 0, 2> ospeedr0;\n    };\n  };\n\npublic:\n  using ospeedr = OspeedrReg<BaseAddress\
    \ + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class PupdrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using pupdr15 =\
    \ FieldModel<uint32_t, address, 30, 2>;\n    using pupdr14 = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    using pupdr13 = FieldModel<uint32_t, address, 26, 2>;\n\
    \    using pupdr12 = FieldModel<uint32_t, address, 24, 2>;\n    using pupdr11\
    \ = FieldModel<uint32_t, address, 22, 2>;\n    using pupdr10 = FieldModel<uint32_t,\
    \ address, 20, 2>;\n    using pupdr9 = FieldModel<uint32_t, address, 18, 2>;\n\
    \    using pupdr8 = FieldModel<uint32_t, address, 16, 2>;\n    using pupdr7 =\
    \ FieldModel<uint32_t, address, 14, 2>;\n    using pupdr6 = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    using pupdr5 = FieldModel<uint32_t, address, 10, 2>;\n\
    \    using pupdr4 = FieldModel<uint32_t, address, 8, 2>;\n    using pupdr3 = FieldModel<uint32_t,\
    \ address, 6, 2>;\n    using pupdr2 = FieldModel<uint32_t, address, 4, 2>;\n \
    \   using pupdr1 = FieldModel<uint32_t, address, 2, 2>;\n    using pupdr0 = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 30, 2> pupdr15;\n      BitFieldModel<uint32_t,\
    \ 28, 2> pupdr14;\n      BitFieldModel<uint32_t, 26, 2> pupdr13;\n      BitFieldModel<uint32_t,\
    \ 24, 2> pupdr12;\n      BitFieldModel<uint32_t, 22, 2> pupdr11;\n      BitFieldModel<uint32_t,\
    \ 20, 2> pupdr10;\n      BitFieldModel<uint32_t, 18, 2> pupdr9;\n      BitFieldModel<uint32_t,\
    \ 16, 2> pupdr8;\n      BitFieldModel<uint32_t, 14, 2> pupdr7;\n      BitFieldModel<uint32_t,\
    \ 12, 2> pupdr6;\n      BitFieldModel<uint32_t, 10, 2> pupdr5;\n      BitFieldModel<uint32_t,\
    \ 8, 2> pupdr4;\n      BitFieldModel<uint32_t, 6, 2> pupdr3;\n      BitFieldModel<uint32_t,\
    \ 4, 2> pupdr2;\n      BitFieldModel<uint32_t, 2, 2> pupdr1;\n      BitFieldModel<uint32_t,\
    \ 0, 2> pupdr0;\n    };\n  };\n\npublic:\n  using pupdr = PupdrReg<BaseAddress\
    \ + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class IdrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using idr15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using idr14 = FieldModel<uint32_t, address, 14, 1>;\n\
    \    using idr13 = FieldModel<uint32_t, address, 13, 1>;\n    using idr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using idr11 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using idr10 = FieldModel<uint32_t, address, 10, 1>;\n    using idr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using idr8 = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using idr7 = FieldModel<uint32_t, address, 7, 1>;\n    using idr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using idr5 = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using idr4 = FieldModel<uint32_t, address, 4, 1>;\n    using idr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using idr2 = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using idr1 = FieldModel<uint32_t, address, 1, 1>;\n    using idr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> idr15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> idr14;\n      BitFieldModel<uint32_t, 13, 1> idr13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> idr12;\n      BitFieldModel<uint32_t, 11, 1> idr11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> idr10;\n      BitFieldModel<uint32_t, 9, 1> idr9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> idr8;\n      BitFieldModel<uint32_t, 7, 1> idr7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> idr6;\n      BitFieldModel<uint32_t, 5, 1> idr5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> idr4;\n      BitFieldModel<uint32_t, 3, 1> idr3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> idr2;\n      BitFieldModel<uint32_t, 1, 1> idr1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> idr0;\n    };\n  };\n\npublic:\n  using idr = IdrReg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class OdrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using odr15 = FieldModel<uint32_t, address, 15,\
    \ 1>;\n    using odr14 = FieldModel<uint32_t, address, 14, 1>;\n    using odr13\
    \ = FieldModel<uint32_t, address, 13, 1>;\n    using odr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using odr11 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using odr10 = FieldModel<uint32_t, address, 10, 1>;\n    using odr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using odr8 = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using odr7 = FieldModel<uint32_t, address, 7, 1>;\n    using odr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using odr5 = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using odr4 = FieldModel<uint32_t, address, 4, 1>;\n    using odr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using odr2 = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using odr1 = FieldModel<uint32_t, address, 1, 1>;\n    using odr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> odr15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> odr14;\n      BitFieldModel<uint32_t, 13, 1> odr13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> odr12;\n      BitFieldModel<uint32_t, 11, 1> odr11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> odr10;\n      BitFieldModel<uint32_t, 9, 1> odr9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> odr8;\n      BitFieldModel<uint32_t, 7, 1> odr7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> odr6;\n      BitFieldModel<uint32_t, 5, 1> odr5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> odr4;\n      BitFieldModel<uint32_t, 3, 1> odr3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> odr2;\n      BitFieldModel<uint32_t, 1, 1> odr1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> odr0;\n    };\n  };\n\npublic:\n  using odr = OdrReg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class BsrrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using br15 = FieldModel<uint32_t, address, 31,\
    \ 1>;\n    using br14 = FieldModel<uint32_t, address, 30, 1>;\n    using br13\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using br12 = FieldModel<uint32_t,\
    \ address, 28, 1>;\n    using br11 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using br10 = FieldModel<uint32_t, address, 26, 1>;\n    using br9 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using br8 = FieldModel<uint32_t, address, 24, 1>;\n  \
    \  using br7 = FieldModel<uint32_t, address, 23, 1>;\n    using br6 = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    using br5 = FieldModel<uint32_t, address, 21, 1>;\n  \
    \  using br4 = FieldModel<uint32_t, address, 20, 1>;\n    using br3 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using br2 = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  using br1 = FieldModel<uint32_t, address, 17, 1>;\n    using br0 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using bs15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using bs14 = FieldModel<uint32_t, address, 14, 1>;\n    using bs13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using bs12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using bs11 = FieldModel<uint32_t, address, 11, 1>;\n    using bs10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using bs9 = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using bs8 = FieldModel<uint32_t, address, 8, 1>;\n    using bs7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bs6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ bs5 = FieldModel<uint32_t, address, 5, 1>;\n    using bs4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using bs3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ bs2 = FieldModel<uint32_t, address, 2, 1>;\n    using bs1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using bs0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 31,\
    \ 1> br15;\n      BitFieldModel<uint32_t, 30, 1> br14;\n      BitFieldModel<uint32_t,\
    \ 29, 1> br13;\n      BitFieldModel<uint32_t, 28, 1> br12;\n      BitFieldModel<uint32_t,\
    \ 27, 1> br11;\n      BitFieldModel<uint32_t, 26, 1> br10;\n      BitFieldModel<uint32_t,\
    \ 25, 1> br9;\n      BitFieldModel<uint32_t, 24, 1> br8;\n      BitFieldModel<uint32_t,\
    \ 23, 1> br7;\n      BitFieldModel<uint32_t, 22, 1> br6;\n      BitFieldModel<uint32_t,\
    \ 21, 1> br5;\n      BitFieldModel<uint32_t, 20, 1> br4;\n      BitFieldModel<uint32_t,\
    \ 19, 1> br3;\n      BitFieldModel<uint32_t, 18, 1> br2;\n      BitFieldModel<uint32_t,\
    \ 17, 1> br1;\n      BitFieldModel<uint32_t, 16, 1> br0;\n      BitFieldModel<uint32_t,\
    \ 15, 1> bs15;\n      BitFieldModel<uint32_t, 14, 1> bs14;\n      BitFieldModel<uint32_t,\
    \ 13, 1> bs13;\n      BitFieldModel<uint32_t, 12, 1> bs12;\n      BitFieldModel<uint32_t,\
    \ 11, 1> bs11;\n      BitFieldModel<uint32_t, 10, 1> bs10;\n      BitFieldModel<uint32_t,\
    \ 9, 1> bs9;\n      BitFieldModel<uint32_t, 8, 1> bs8;\n      BitFieldModel<uint32_t,\
    \ 7, 1> bs7;\n      BitFieldModel<uint32_t, 6, 1> bs6;\n      BitFieldModel<uint32_t,\
    \ 5, 1> bs5;\n      BitFieldModel<uint32_t, 4, 1> bs4;\n      BitFieldModel<uint32_t,\
    \ 3, 1> bs3;\n      BitFieldModel<uint32_t, 2, 1> bs2;\n      BitFieldModel<uint32_t,\
    \ 1, 1> bs1;\n      BitFieldModel<uint32_t, 0, 1> bs0;\n    };\n  };\n\npublic:\n\
    \  using bsrr = BsrrReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class LckrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using lckk = FieldModel<uint32_t, address, 16, 1>;\n    using\
    \ lck15 = FieldModel<uint32_t, address, 15, 1>;\n    using lck14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using lck13 = FieldModel<uint32_t, address, 13, 1>;\n\
    \    using lck12 = FieldModel<uint32_t, address, 12, 1>;\n    using lck11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using lck10 = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using lck9 = FieldModel<uint32_t, address, 9, 1>;\n    using lck8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using lck7 = FieldModel<uint32_t, address, 7, 1>;\n   \
    \ using lck6 = FieldModel<uint32_t, address, 6, 1>;\n    using lck5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using lck4 = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ using lck3 = FieldModel<uint32_t, address, 3, 1>;\n    using lck2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using lck1 = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using lck0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16, 1> lckk;\n  \
    \    BitFieldModel<uint32_t, 15, 1> lck15;\n      BitFieldModel<uint32_t, 14,\
    \ 1> lck14;\n      BitFieldModel<uint32_t, 13, 1> lck13;\n      BitFieldModel<uint32_t,\
    \ 12, 1> lck12;\n      BitFieldModel<uint32_t, 11, 1> lck11;\n      BitFieldModel<uint32_t,\
    \ 10, 1> lck10;\n      BitFieldModel<uint32_t, 9, 1> lck9;\n      BitFieldModel<uint32_t,\
    \ 8, 1> lck8;\n      BitFieldModel<uint32_t, 7, 1> lck7;\n      BitFieldModel<uint32_t,\
    \ 6, 1> lck6;\n      BitFieldModel<uint32_t, 5, 1> lck5;\n      BitFieldModel<uint32_t,\
    \ 4, 1> lck4;\n      BitFieldModel<uint32_t, 3, 1> lck3;\n      BitFieldModel<uint32_t,\
    \ 2, 1> lck2;\n      BitFieldModel<uint32_t, 1, 1> lck1;\n      BitFieldModel<uint32_t,\
    \ 0, 1> lck0;\n    };\n  };\n\npublic:\n  using lckr = LckrReg<BaseAddress + 0x001C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class AfrlReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using afrl7 = FieldModel<uint32_t, address, 28,\
    \ 4>;\n    using afrl6 = FieldModel<uint32_t, address, 24, 4>;\n    using afrl5\
    \ = FieldModel<uint32_t, address, 20, 4>;\n    using afrl4 = FieldModel<uint32_t,\
    \ address, 16, 4>;\n    using afrl3 = FieldModel<uint32_t, address, 12, 4>;\n\
    \    using afrl2 = FieldModel<uint32_t, address, 8, 4>;\n    using afrl1 = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using afrl0 = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 28, 4> afrl7;\n      BitFieldModel<uint32_t, 24, 4> afrl6;\n      BitFieldModel<uint32_t,\
    \ 20, 4> afrl5;\n      BitFieldModel<uint32_t, 16, 4> afrl4;\n      BitFieldModel<uint32_t,\
    \ 12, 4> afrl3;\n      BitFieldModel<uint32_t, 8, 4> afrl2;\n      BitFieldModel<uint32_t,\
    \ 4, 4> afrl1;\n      BitFieldModel<uint32_t, 0, 4> afrl0;\n    };\n  };\n\npublic:\n\
    \  using afrl = AfrlReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class AfrhReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using afrh15 = FieldModel<uint32_t, address, 28, 4>;\n    using\
    \ afrh14 = FieldModel<uint32_t, address, 24, 4>;\n    using afrh13 = FieldModel<uint32_t,\
    \ address, 20, 4>;\n    using afrh12 = FieldModel<uint32_t, address, 16, 4>;\n\
    \    using afrh11 = FieldModel<uint32_t, address, 12, 4>;\n    using afrh10 =\
    \ FieldModel<uint32_t, address, 8, 4>;\n    using afrh9 = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using afrh8 = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 28, 4> afrh15;\n      BitFieldModel<uint32_t, 24, 4> afrh14;\n      BitFieldModel<uint32_t,\
    \ 20, 4> afrh13;\n      BitFieldModel<uint32_t, 16, 4> afrh12;\n      BitFieldModel<uint32_t,\
    \ 12, 4> afrh11;\n      BitFieldModel<uint32_t, 8, 4> afrh10;\n      BitFieldModel<uint32_t,\
    \ 4, 4> afrh9;\n      BitFieldModel<uint32_t, 0, 4> afrh8;\n    };\n  };\n\npublic:\n\
    \  using afrh = AfrhReg<BaseAddress + 0x0024>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_GPIOA_H\
    \ */\n"
  name: GPIOA
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_SYSCFG_H\n#define DRAL_STM32F446_SYSCFG_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass syscfg\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40013800;\n\nprivate:\n\
    \  template<unsigned int address>\n  class MemrmReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using mem_mode = FieldModel<uint32_t, address,\
    \ 0, 3>;\n    using fb_mode = FieldModel<uint32_t, address, 8, 1>;\n    using\
    \ swp_fmc = FieldModel<uint32_t, address, 10, 2>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 3> mem_mode;\n\
    \      BitFieldModel<uint32_t, 8, 1> fb_mode;\n      BitFieldModel<uint32_t, 10,\
    \ 2> swp_fmc;\n    };\n  };\n\npublic:\n  using memrm = MemrmReg<BaseAddress +\
    \ 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class PmcReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using mii_rmii_sel = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using adc1dc2 = FieldModel<uint32_t, address, 16, 1>;\n\
    \    using adc2dc2 = FieldModel<uint32_t, address, 17, 1>;\n    using adc3dc2\
    \ = FieldModel<uint32_t, address, 18, 1>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 23, 1> mii_rmii_sel;\n \
    \     BitFieldModel<uint32_t, 16, 1> adc1dc2;\n      BitFieldModel<uint32_t, 17,\
    \ 1> adc2dc2;\n      BitFieldModel<uint32_t, 18, 1> adc3dc2;\n    };\n  };\n\n\
    public:\n  using pmc = PmcReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Exticr1Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using exti3 = FieldModel<uint32_t, address, 12, 4>;\n   \
    \ using exti2 = FieldModel<uint32_t, address, 8, 4>;\n    using exti1 = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using exti0 = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 12, 4> exti3;\n      BitFieldModel<uint32_t, 8, 4> exti2;\n      BitFieldModel<uint32_t,\
    \ 4, 4> exti1;\n      BitFieldModel<uint32_t, 0, 4> exti0;\n    };\n  };\n\npublic:\n\
    \  using exticr1 = Exticr1Reg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Exticr2Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using exti7 = FieldModel<uint32_t, address, 12, 4>;\n   \
    \ using exti6 = FieldModel<uint32_t, address, 8, 4>;\n    using exti5 = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using exti4 = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 12, 4> exti7;\n      BitFieldModel<uint32_t, 8, 4> exti6;\n      BitFieldModel<uint32_t,\
    \ 4, 4> exti5;\n      BitFieldModel<uint32_t, 0, 4> exti4;\n    };\n  };\n\npublic:\n\
    \  using exticr2 = Exticr2Reg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Exticr3Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using exti11 = FieldModel<uint32_t, address, 12, 4>;\n  \
    \  using exti10 = FieldModel<uint32_t, address, 8, 4>;\n    using exti9 = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using exti8 = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 12, 4> exti11;\n      BitFieldModel<uint32_t, 8, 4> exti10;\n      BitFieldModel<uint32_t,\
    \ 4, 4> exti9;\n      BitFieldModel<uint32_t, 0, 4> exti8;\n    };\n  };\n\npublic:\n\
    \  using exticr3 = Exticr3Reg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Exticr4Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using exti15 = FieldModel<uint32_t, address, 12, 4>;\n  \
    \  using exti14 = FieldModel<uint32_t, address, 8, 4>;\n    using exti13 = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using exti12 = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 12, 4> exti15;\n      BitFieldModel<uint32_t, 8, 4> exti14;\n      BitFieldModel<uint32_t,\
    \ 4, 4> exti13;\n      BitFieldModel<uint32_t, 0, 4> exti12;\n    };\n  };\n\n\
    public:\n  using exticr4 = Exticr4Reg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CmpcrReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using ready = FieldModel<uint32_t, address, 8, 1>;\n    using\
    \ cmp_pd = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 1> ready;\n  \
    \    BitFieldModel<uint32_t, 0, 1> cmp_pd;\n    };\n  };\n\npublic:\n  using cmpcr\
    \ = CmpcrReg<BaseAddress + 0x0020>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_SYSCFG_H\
    \ */\n"
  name: SYSCFG
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_SPI1_H\n#define DRAL_STM32F446_SPI1_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass spi1\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40013000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using bidimode = FieldModel<uint32_t, address,\
    \ 15, 1>;\n    using bidioe = FieldModel<uint32_t, address, 14, 1>;\n    using\
    \ crcen = FieldModel<uint32_t, address, 13, 1>;\n    using crcnext = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using dff = FieldModel<uint32_t, address, 11, 1>;\n  \
    \  using rxonly = FieldModel<uint32_t, address, 10, 1>;\n    using ssm = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using ssi = FieldModel<uint32_t, address, 8, 1>;\n    using\
    \ lsbfirst = FieldModel<uint32_t, address, 7, 1>;\n    using spe = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using br = FieldModel<uint32_t, address, 3, 3>;\n    using\
    \ mstr = FieldModel<uint32_t, address, 2, 1>;\n    using cpol = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using cpha = FieldModel<uint32_t, address, 0, 1>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 15, 1> bidimode;\n      BitFieldModel<uint32_t, 14, 1> bidioe;\n      BitFieldModel<uint32_t,\
    \ 13, 1> crcen;\n      BitFieldModel<uint32_t, 12, 1> crcnext;\n      BitFieldModel<uint32_t,\
    \ 11, 1> dff;\n      BitFieldModel<uint32_t, 10, 1> rxonly;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ssm;\n      BitFieldModel<uint32_t, 8, 1> ssi;\n      BitFieldModel<uint32_t,\
    \ 7, 1> lsbfirst;\n      BitFieldModel<uint32_t, 6, 1> spe;\n      BitFieldModel<uint32_t,\
    \ 3, 3> br;\n      BitFieldModel<uint32_t, 2, 1> mstr;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cpol;\n      BitFieldModel<uint32_t, 0, 1> cpha;\n    };\n  };\n\npublic:\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using txeie = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ rxneie = FieldModel<uint32_t, address, 6, 1>;\n    using errie = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using frf = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ ssoe = FieldModel<uint32_t, address, 2, 1>;\n    using txdmaen = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using rxdmaen = FieldModel<uint32_t, address, 0, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txeie;\n      BitFieldModel<uint32_t, 6, 1> rxneie;\n      BitFieldModel<uint32_t,\
    \ 5, 1> errie;\n      BitFieldModel<uint32_t, 4, 1> frf;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ssoe;\n      BitFieldModel<uint32_t, 1, 1> txdmaen;\n      BitFieldModel<uint32_t,\
    \ 0, 1> rxdmaen;\n    };\n  };\n\npublic:\n  using cr2 = Cr2Reg<BaseAddress +\
    \ 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class SrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using tifrfe = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using bsy = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ ovr = FieldModel<uint32_t, address, 6, 1>;\n    using modf = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using crcerr = FieldModel<uint32_t, address, 4, 1>;\n \
    \   using udr = FieldModel<uint32_t, address, 3, 1>;\n    using chside = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using txe = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ rxne = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n  \
    \  {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 1> tifrfe;\n   \
    \   BitFieldModel<uint32_t, 7, 1> bsy;\n      BitFieldModel<uint32_t, 6, 1> ovr;\n\
    \      BitFieldModel<uint32_t, 5, 1> modf;\n      BitFieldModel<uint32_t, 4, 1>\
    \ crcerr;\n      BitFieldModel<uint32_t, 3, 1> udr;\n      BitFieldModel<uint32_t,\
    \ 2, 1> chside;\n      BitFieldModel<uint32_t, 1, 1> txe;\n      BitFieldModel<uint32_t,\
    \ 0, 1> rxne;\n    };\n  };\n\npublic:\n  using sr = SrReg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dr = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> dr;\n    };\n  };\n\npublic:\n  using dr = DrReg<BaseAddress + 0x000C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CrcprReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using crcpoly = FieldModel<uint32_t, address,\
    \ 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> crcpoly;\n    };\n  };\n\npublic:\n  using crcpr = CrcprReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class RxcrcrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using rxcrc =\
    \ FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 0, 16> rxcrc;\n    };\n \
    \ };\n\npublic:\n  using rxcrcr = RxcrcrReg<BaseAddress + 0x0014>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class TxcrcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using txcrc = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> txcrc;\n    };\n  };\n\npublic:\n  using txcrcr = TxcrcrReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class I2scfgrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using i2smod\
    \ = FieldModel<uint32_t, address, 11, 1>;\n    using i2se = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using i2scfg = FieldModel<uint32_t, address, 8, 2>;\n\
    \    using pcmsync = FieldModel<uint32_t, address, 7, 1>;\n    using i2sstd =\
    \ FieldModel<uint32_t, address, 4, 2>;\n    using ckpol = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using datlen = FieldModel<uint32_t, address, 1, 2>;\n \
    \   using chlen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 11, 1> i2smod;\n\
    \      BitFieldModel<uint32_t, 10, 1> i2se;\n      BitFieldModel<uint32_t, 8,\
    \ 2> i2scfg;\n      BitFieldModel<uint32_t, 7, 1> pcmsync;\n      BitFieldModel<uint32_t,\
    \ 4, 2> i2sstd;\n      BitFieldModel<uint32_t, 3, 1> ckpol;\n      BitFieldModel<uint32_t,\
    \ 1, 2> datlen;\n      BitFieldModel<uint32_t, 0, 1> chlen;\n    };\n  };\n\n\
    public:\n  using i2scfgr = I2scfgrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class I2sprReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using mckoe = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ odd = FieldModel<uint32_t, address, 8, 1>;\n    using i2sdiv = FieldModel<uint32_t,\
    \ address, 0, 8>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 9, 1> mckoe;\n      BitFieldModel<uint32_t, 8,\
    \ 1> odd;\n      BitFieldModel<uint32_t, 0, 8> i2sdiv;\n    };\n  };\n\npublic:\n\
    \  using i2spr = I2sprReg<BaseAddress + 0x0020>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_SPI1_H\
    \ */\n"
  name: SPI1
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_SPI2_H\n#define DRAL_STM32F446_SPI2_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass spi2\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40003800;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using bidimode = FieldModel<uint32_t, address,\
    \ 15, 1>;\n    using bidioe = FieldModel<uint32_t, address, 14, 1>;\n    using\
    \ crcen = FieldModel<uint32_t, address, 13, 1>;\n    using crcnext = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using dff = FieldModel<uint32_t, address, 11, 1>;\n  \
    \  using rxonly = FieldModel<uint32_t, address, 10, 1>;\n    using ssm = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using ssi = FieldModel<uint32_t, address, 8, 1>;\n    using\
    \ lsbfirst = FieldModel<uint32_t, address, 7, 1>;\n    using spe = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using br = FieldModel<uint32_t, address, 3, 3>;\n    using\
    \ mstr = FieldModel<uint32_t, address, 2, 1>;\n    using cpol = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using cpha = FieldModel<uint32_t, address, 0, 1>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 15, 1> bidimode;\n      BitFieldModel<uint32_t, 14, 1> bidioe;\n      BitFieldModel<uint32_t,\
    \ 13, 1> crcen;\n      BitFieldModel<uint32_t, 12, 1> crcnext;\n      BitFieldModel<uint32_t,\
    \ 11, 1> dff;\n      BitFieldModel<uint32_t, 10, 1> rxonly;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ssm;\n      BitFieldModel<uint32_t, 8, 1> ssi;\n      BitFieldModel<uint32_t,\
    \ 7, 1> lsbfirst;\n      BitFieldModel<uint32_t, 6, 1> spe;\n      BitFieldModel<uint32_t,\
    \ 3, 3> br;\n      BitFieldModel<uint32_t, 2, 1> mstr;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cpol;\n      BitFieldModel<uint32_t, 0, 1> cpha;\n    };\n  };\n\npublic:\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using txeie = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ rxneie = FieldModel<uint32_t, address, 6, 1>;\n    using errie = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using frf = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ ssoe = FieldModel<uint32_t, address, 2, 1>;\n    using txdmaen = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using rxdmaen = FieldModel<uint32_t, address, 0, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txeie;\n      BitFieldModel<uint32_t, 6, 1> rxneie;\n      BitFieldModel<uint32_t,\
    \ 5, 1> errie;\n      BitFieldModel<uint32_t, 4, 1> frf;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ssoe;\n      BitFieldModel<uint32_t, 1, 1> txdmaen;\n      BitFieldModel<uint32_t,\
    \ 0, 1> rxdmaen;\n    };\n  };\n\npublic:\n  using cr2 = Cr2Reg<BaseAddress +\
    \ 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class SrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using tifrfe = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using bsy = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ ovr = FieldModel<uint32_t, address, 6, 1>;\n    using modf = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using crcerr = FieldModel<uint32_t, address, 4, 1>;\n \
    \   using udr = FieldModel<uint32_t, address, 3, 1>;\n    using chside = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using txe = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ rxne = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n  \
    \  {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 1> tifrfe;\n   \
    \   BitFieldModel<uint32_t, 7, 1> bsy;\n      BitFieldModel<uint32_t, 6, 1> ovr;\n\
    \      BitFieldModel<uint32_t, 5, 1> modf;\n      BitFieldModel<uint32_t, 4, 1>\
    \ crcerr;\n      BitFieldModel<uint32_t, 3, 1> udr;\n      BitFieldModel<uint32_t,\
    \ 2, 1> chside;\n      BitFieldModel<uint32_t, 1, 1> txe;\n      BitFieldModel<uint32_t,\
    \ 0, 1> rxne;\n    };\n  };\n\npublic:\n  using sr = SrReg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dr = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> dr;\n    };\n  };\n\npublic:\n  using dr = DrReg<BaseAddress + 0x000C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CrcprReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using crcpoly = FieldModel<uint32_t, address,\
    \ 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> crcpoly;\n    };\n  };\n\npublic:\n  using crcpr = CrcprReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class RxcrcrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using rxcrc =\
    \ FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 0, 16> rxcrc;\n    };\n \
    \ };\n\npublic:\n  using rxcrcr = RxcrcrReg<BaseAddress + 0x0014>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class TxcrcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using txcrc = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> txcrc;\n    };\n  };\n\npublic:\n  using txcrcr = TxcrcrReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class I2scfgrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using i2smod\
    \ = FieldModel<uint32_t, address, 11, 1>;\n    using i2se = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using i2scfg = FieldModel<uint32_t, address, 8, 2>;\n\
    \    using pcmsync = FieldModel<uint32_t, address, 7, 1>;\n    using i2sstd =\
    \ FieldModel<uint32_t, address, 4, 2>;\n    using ckpol = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using datlen = FieldModel<uint32_t, address, 1, 2>;\n \
    \   using chlen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 11, 1> i2smod;\n\
    \      BitFieldModel<uint32_t, 10, 1> i2se;\n      BitFieldModel<uint32_t, 8,\
    \ 2> i2scfg;\n      BitFieldModel<uint32_t, 7, 1> pcmsync;\n      BitFieldModel<uint32_t,\
    \ 4, 2> i2sstd;\n      BitFieldModel<uint32_t, 3, 1> ckpol;\n      BitFieldModel<uint32_t,\
    \ 1, 2> datlen;\n      BitFieldModel<uint32_t, 0, 1> chlen;\n    };\n  };\n\n\
    public:\n  using i2scfgr = I2scfgrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class I2sprReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using mckoe = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ odd = FieldModel<uint32_t, address, 8, 1>;\n    using i2sdiv = FieldModel<uint32_t,\
    \ address, 0, 8>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 9, 1> mckoe;\n      BitFieldModel<uint32_t, 8,\
    \ 1> odd;\n      BitFieldModel<uint32_t, 0, 8> i2sdiv;\n    };\n  };\n\npublic:\n\
    \  using i2spr = I2sprReg<BaseAddress + 0x0020>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_SPI2_H\
    \ */\n"
  name: SPI2
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_SPI3_H\n#define DRAL_STM32F446_SPI3_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass spi3\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40003C00;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using bidimode = FieldModel<uint32_t, address,\
    \ 15, 1>;\n    using bidioe = FieldModel<uint32_t, address, 14, 1>;\n    using\
    \ crcen = FieldModel<uint32_t, address, 13, 1>;\n    using crcnext = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using dff = FieldModel<uint32_t, address, 11, 1>;\n  \
    \  using rxonly = FieldModel<uint32_t, address, 10, 1>;\n    using ssm = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using ssi = FieldModel<uint32_t, address, 8, 1>;\n    using\
    \ lsbfirst = FieldModel<uint32_t, address, 7, 1>;\n    using spe = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using br = FieldModel<uint32_t, address, 3, 3>;\n    using\
    \ mstr = FieldModel<uint32_t, address, 2, 1>;\n    using cpol = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using cpha = FieldModel<uint32_t, address, 0, 1>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 15, 1> bidimode;\n      BitFieldModel<uint32_t, 14, 1> bidioe;\n      BitFieldModel<uint32_t,\
    \ 13, 1> crcen;\n      BitFieldModel<uint32_t, 12, 1> crcnext;\n      BitFieldModel<uint32_t,\
    \ 11, 1> dff;\n      BitFieldModel<uint32_t, 10, 1> rxonly;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ssm;\n      BitFieldModel<uint32_t, 8, 1> ssi;\n      BitFieldModel<uint32_t,\
    \ 7, 1> lsbfirst;\n      BitFieldModel<uint32_t, 6, 1> spe;\n      BitFieldModel<uint32_t,\
    \ 3, 3> br;\n      BitFieldModel<uint32_t, 2, 1> mstr;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cpol;\n      BitFieldModel<uint32_t, 0, 1> cpha;\n    };\n  };\n\npublic:\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using txeie = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ rxneie = FieldModel<uint32_t, address, 6, 1>;\n    using errie = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using frf = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ ssoe = FieldModel<uint32_t, address, 2, 1>;\n    using txdmaen = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using rxdmaen = FieldModel<uint32_t, address, 0, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txeie;\n      BitFieldModel<uint32_t, 6, 1> rxneie;\n      BitFieldModel<uint32_t,\
    \ 5, 1> errie;\n      BitFieldModel<uint32_t, 4, 1> frf;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ssoe;\n      BitFieldModel<uint32_t, 1, 1> txdmaen;\n      BitFieldModel<uint32_t,\
    \ 0, 1> rxdmaen;\n    };\n  };\n\npublic:\n  using cr2 = Cr2Reg<BaseAddress +\
    \ 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class SrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using tifrfe = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using bsy = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ ovr = FieldModel<uint32_t, address, 6, 1>;\n    using modf = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using crcerr = FieldModel<uint32_t, address, 4, 1>;\n \
    \   using udr = FieldModel<uint32_t, address, 3, 1>;\n    using chside = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using txe = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ rxne = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n  \
    \  {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 1> tifrfe;\n   \
    \   BitFieldModel<uint32_t, 7, 1> bsy;\n      BitFieldModel<uint32_t, 6, 1> ovr;\n\
    \      BitFieldModel<uint32_t, 5, 1> modf;\n      BitFieldModel<uint32_t, 4, 1>\
    \ crcerr;\n      BitFieldModel<uint32_t, 3, 1> udr;\n      BitFieldModel<uint32_t,\
    \ 2, 1> chside;\n      BitFieldModel<uint32_t, 1, 1> txe;\n      BitFieldModel<uint32_t,\
    \ 0, 1> rxne;\n    };\n  };\n\npublic:\n  using sr = SrReg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dr = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> dr;\n    };\n  };\n\npublic:\n  using dr = DrReg<BaseAddress + 0x000C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CrcprReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using crcpoly = FieldModel<uint32_t, address,\
    \ 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> crcpoly;\n    };\n  };\n\npublic:\n  using crcpr = CrcprReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class RxcrcrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using rxcrc =\
    \ FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 0, 16> rxcrc;\n    };\n \
    \ };\n\npublic:\n  using rxcrcr = RxcrcrReg<BaseAddress + 0x0014>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class TxcrcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using txcrc = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> txcrc;\n    };\n  };\n\npublic:\n  using txcrcr = TxcrcrReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class I2scfgrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using i2smod\
    \ = FieldModel<uint32_t, address, 11, 1>;\n    using i2se = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using i2scfg = FieldModel<uint32_t, address, 8, 2>;\n\
    \    using pcmsync = FieldModel<uint32_t, address, 7, 1>;\n    using i2sstd =\
    \ FieldModel<uint32_t, address, 4, 2>;\n    using ckpol = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using datlen = FieldModel<uint32_t, address, 1, 2>;\n \
    \   using chlen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 11, 1> i2smod;\n\
    \      BitFieldModel<uint32_t, 10, 1> i2se;\n      BitFieldModel<uint32_t, 8,\
    \ 2> i2scfg;\n      BitFieldModel<uint32_t, 7, 1> pcmsync;\n      BitFieldModel<uint32_t,\
    \ 4, 2> i2sstd;\n      BitFieldModel<uint32_t, 3, 1> ckpol;\n      BitFieldModel<uint32_t,\
    \ 1, 2> datlen;\n      BitFieldModel<uint32_t, 0, 1> chlen;\n    };\n  };\n\n\
    public:\n  using i2scfgr = I2scfgrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class I2sprReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using mckoe = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ odd = FieldModel<uint32_t, address, 8, 1>;\n    using i2sdiv = FieldModel<uint32_t,\
    \ address, 0, 8>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 9, 1> mckoe;\n      BitFieldModel<uint32_t, 8,\
    \ 1> odd;\n      BitFieldModel<uint32_t, 0, 8> i2sdiv;\n    };\n  };\n\npublic:\n\
    \  using i2spr = I2sprReg<BaseAddress + 0x0020>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_SPI3_H\
    \ */\n"
  name: SPI3
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_SPI4_H\n#define DRAL_STM32F446_SPI4_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass spi4\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40013400;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using bidimode = FieldModel<uint32_t, address,\
    \ 15, 1>;\n    using bidioe = FieldModel<uint32_t, address, 14, 1>;\n    using\
    \ crcen = FieldModel<uint32_t, address, 13, 1>;\n    using crcnext = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using dff = FieldModel<uint32_t, address, 11, 1>;\n  \
    \  using rxonly = FieldModel<uint32_t, address, 10, 1>;\n    using ssm = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using ssi = FieldModel<uint32_t, address, 8, 1>;\n    using\
    \ lsbfirst = FieldModel<uint32_t, address, 7, 1>;\n    using spe = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using br = FieldModel<uint32_t, address, 3, 3>;\n    using\
    \ mstr = FieldModel<uint32_t, address, 2, 1>;\n    using cpol = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using cpha = FieldModel<uint32_t, address, 0, 1>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 15, 1> bidimode;\n      BitFieldModel<uint32_t, 14, 1> bidioe;\n      BitFieldModel<uint32_t,\
    \ 13, 1> crcen;\n      BitFieldModel<uint32_t, 12, 1> crcnext;\n      BitFieldModel<uint32_t,\
    \ 11, 1> dff;\n      BitFieldModel<uint32_t, 10, 1> rxonly;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ssm;\n      BitFieldModel<uint32_t, 8, 1> ssi;\n      BitFieldModel<uint32_t,\
    \ 7, 1> lsbfirst;\n      BitFieldModel<uint32_t, 6, 1> spe;\n      BitFieldModel<uint32_t,\
    \ 3, 3> br;\n      BitFieldModel<uint32_t, 2, 1> mstr;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cpol;\n      BitFieldModel<uint32_t, 0, 1> cpha;\n    };\n  };\n\npublic:\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using txeie = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ rxneie = FieldModel<uint32_t, address, 6, 1>;\n    using errie = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using frf = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ ssoe = FieldModel<uint32_t, address, 2, 1>;\n    using txdmaen = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using rxdmaen = FieldModel<uint32_t, address, 0, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txeie;\n      BitFieldModel<uint32_t, 6, 1> rxneie;\n      BitFieldModel<uint32_t,\
    \ 5, 1> errie;\n      BitFieldModel<uint32_t, 4, 1> frf;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ssoe;\n      BitFieldModel<uint32_t, 1, 1> txdmaen;\n      BitFieldModel<uint32_t,\
    \ 0, 1> rxdmaen;\n    };\n  };\n\npublic:\n  using cr2 = Cr2Reg<BaseAddress +\
    \ 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class SrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using tifrfe = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using bsy = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ ovr = FieldModel<uint32_t, address, 6, 1>;\n    using modf = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using crcerr = FieldModel<uint32_t, address, 4, 1>;\n \
    \   using udr = FieldModel<uint32_t, address, 3, 1>;\n    using chside = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using txe = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ rxne = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n  \
    \  {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 1> tifrfe;\n   \
    \   BitFieldModel<uint32_t, 7, 1> bsy;\n      BitFieldModel<uint32_t, 6, 1> ovr;\n\
    \      BitFieldModel<uint32_t, 5, 1> modf;\n      BitFieldModel<uint32_t, 4, 1>\
    \ crcerr;\n      BitFieldModel<uint32_t, 3, 1> udr;\n      BitFieldModel<uint32_t,\
    \ 2, 1> chside;\n      BitFieldModel<uint32_t, 1, 1> txe;\n      BitFieldModel<uint32_t,\
    \ 0, 1> rxne;\n    };\n  };\n\npublic:\n  using sr = SrReg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dr = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> dr;\n    };\n  };\n\npublic:\n  using dr = DrReg<BaseAddress + 0x000C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CrcprReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using crcpoly = FieldModel<uint32_t, address,\
    \ 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> crcpoly;\n    };\n  };\n\npublic:\n  using crcpr = CrcprReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class RxcrcrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using rxcrc =\
    \ FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 0, 16> rxcrc;\n    };\n \
    \ };\n\npublic:\n  using rxcrcr = RxcrcrReg<BaseAddress + 0x0014>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class TxcrcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using txcrc = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> txcrc;\n    };\n  };\n\npublic:\n  using txcrcr = TxcrcrReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class I2scfgrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using i2smod\
    \ = FieldModel<uint32_t, address, 11, 1>;\n    using i2se = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using i2scfg = FieldModel<uint32_t, address, 8, 2>;\n\
    \    using pcmsync = FieldModel<uint32_t, address, 7, 1>;\n    using i2sstd =\
    \ FieldModel<uint32_t, address, 4, 2>;\n    using ckpol = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using datlen = FieldModel<uint32_t, address, 1, 2>;\n \
    \   using chlen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 11, 1> i2smod;\n\
    \      BitFieldModel<uint32_t, 10, 1> i2se;\n      BitFieldModel<uint32_t, 8,\
    \ 2> i2scfg;\n      BitFieldModel<uint32_t, 7, 1> pcmsync;\n      BitFieldModel<uint32_t,\
    \ 4, 2> i2sstd;\n      BitFieldModel<uint32_t, 3, 1> ckpol;\n      BitFieldModel<uint32_t,\
    \ 1, 2> datlen;\n      BitFieldModel<uint32_t, 0, 1> chlen;\n    };\n  };\n\n\
    public:\n  using i2scfgr = I2scfgrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class I2sprReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using mckoe = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ odd = FieldModel<uint32_t, address, 8, 1>;\n    using i2sdiv = FieldModel<uint32_t,\
    \ address, 0, 8>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 9, 1> mckoe;\n      BitFieldModel<uint32_t, 8,\
    \ 1> odd;\n      BitFieldModel<uint32_t, 0, 8> i2sdiv;\n    };\n  };\n\npublic:\n\
    \  using i2spr = I2sprReg<BaseAddress + 0x0020>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_SPI4_H\
    \ */\n"
  name: SPI4
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_ADC1_H\n#define DRAL_STM32F446_ADC1_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass adc1\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40012000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ovr = FieldModel<uint32_t, address, 5, 1>;\n\
    \    using strt = FieldModel<uint32_t, address, 4, 1>;\n    using jstrt = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using jeoc = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using eoc = FieldModel<uint32_t, address, 1, 1>;\n    using awd = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 5, 1> ovr;\n      BitFieldModel<uint32_t, 4, 1>\
    \ strt;\n      BitFieldModel<uint32_t, 3, 1> jstrt;\n      BitFieldModel<uint32_t,\
    \ 2, 1> jeoc;\n      BitFieldModel<uint32_t, 1, 1> eoc;\n      BitFieldModel<uint32_t,\
    \ 0, 1> awd;\n    };\n  };\n\npublic:\n  using sr = SrReg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ovrie = FieldModel<uint32_t, address, 26,\
    \ 1>;\n    using res = FieldModel<uint32_t, address, 24, 2>;\n    using awden\
    \ = FieldModel<uint32_t, address, 23, 1>;\n    using jawden = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    using discnum = FieldModel<uint32_t, address, 13, 3>;\n\
    \    using jdiscen = FieldModel<uint32_t, address, 12, 1>;\n    using discen =\
    \ FieldModel<uint32_t, address, 11, 1>;\n    using jauto = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using awdsgl = FieldModel<uint32_t, address, 9, 1>;\n\
    \    using scan = FieldModel<uint32_t, address, 8, 1>;\n    using jeocie = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using awdie = FieldModel<uint32_t, address, 6, 1>;\n  \
    \  using eocie = FieldModel<uint32_t, address, 5, 1>;\n    using awdch = FieldModel<uint32_t,\
    \ address, 0, 5>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 26, 1> ovrie;\n      BitFieldModel<uint32_t, 24,\
    \ 2> res;\n      BitFieldModel<uint32_t, 23, 1> awden;\n      BitFieldModel<uint32_t,\
    \ 22, 1> jawden;\n      BitFieldModel<uint32_t, 13, 3> discnum;\n      BitFieldModel<uint32_t,\
    \ 12, 1> jdiscen;\n      BitFieldModel<uint32_t, 11, 1> discen;\n      BitFieldModel<uint32_t,\
    \ 10, 1> jauto;\n      BitFieldModel<uint32_t, 9, 1> awdsgl;\n      BitFieldModel<uint32_t,\
    \ 8, 1> scan;\n      BitFieldModel<uint32_t, 7, 1> jeocie;\n      BitFieldModel<uint32_t,\
    \ 6, 1> awdie;\n      BitFieldModel<uint32_t, 5, 1> eocie;\n      BitFieldModel<uint32_t,\
    \ 0, 5> awdch;\n    };\n  };\n\npublic:\n  using cr1 = Cr1Reg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Cr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using swstart = FieldModel<uint32_t, address,\
    \ 30, 1>;\n    using exten = FieldModel<uint32_t, address, 28, 2>;\n    using\
    \ extsel = FieldModel<uint32_t, address, 24, 4>;\n    using jswstart = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    using jexten = FieldModel<uint32_t, address, 20, 2>;\n\
    \    using jextsel = FieldModel<uint32_t, address, 16, 4>;\n    using align =\
    \ FieldModel<uint32_t, address, 11, 1>;\n    using eocs = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using dds = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using dma = FieldModel<uint32_t, address, 8, 1>;\n    using cont = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using adon = FieldModel<uint32_t, address, 0, 1>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 30, 1> swstart;\n      BitFieldModel<uint32_t, 28, 2> exten;\n      BitFieldModel<uint32_t,\
    \ 24, 4> extsel;\n      BitFieldModel<uint32_t, 22, 1> jswstart;\n      BitFieldModel<uint32_t,\
    \ 20, 2> jexten;\n      BitFieldModel<uint32_t, 16, 4> jextsel;\n      BitFieldModel<uint32_t,\
    \ 11, 1> align;\n      BitFieldModel<uint32_t, 10, 1> eocs;\n      BitFieldModel<uint32_t,\
    \ 9, 1> dds;\n      BitFieldModel<uint32_t, 8, 1> dma;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cont;\n      BitFieldModel<uint32_t, 0, 1> adon;\n    };\n  };\n\npublic:\n\
    \  using cr2 = Cr2Reg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Smpr1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using smpx_x = FieldModel<uint32_t, address, 0, 32>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> smpx_x;\n    };\n  };\n\npublic:\n  using smpr1 = Smpr1Reg<BaseAddress\
    \ + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class Smpr2Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using smpx_x =\
    \ FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> smpx_x;\n    };\n\
    \  };\n\npublic:\n  using smpr2 = Smpr2Reg<BaseAddress + 0x0010>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Jofr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using joffset1 = FieldModel<uint32_t, address,\
    \ 0, 12>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 12> joffset1;\n    };\n  };\n\npublic:\n  using jofr1 = Jofr1Reg<BaseAddress\
    \ + 0x0014>;\n\nprivate:\n  template<unsigned int address>\n  class Jofr2Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using joffset2\
    \ = FieldModel<uint32_t, address, 0, 12>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 12> joffset2;\n    };\n\
    \  };\n\npublic:\n  using jofr2 = Jofr2Reg<BaseAddress + 0x0018>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Jofr3Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using joffset3 = FieldModel<uint32_t, address,\
    \ 0, 12>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 12> joffset3;\n    };\n  };\n\npublic:\n  using jofr3 = Jofr3Reg<BaseAddress\
    \ + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class Jofr4Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using joffset4\
    \ = FieldModel<uint32_t, address, 0, 12>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 12> joffset4;\n    };\n\
    \  };\n\npublic:\n  using jofr4 = Jofr4Reg<BaseAddress + 0x0020>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class HtrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ht = FieldModel<uint32_t, address, 0, 12>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 12> ht;\n    };\n  };\n\npublic:\n  using htr = HtrReg<BaseAddress + 0x0024>;\n\
    \nprivate:\n  template<unsigned int address>\n  class LtrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using lt = FieldModel<uint32_t, address, 0, 12>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 12> lt;\n    };\n  };\n\npublic:\n  using ltr = LtrReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Sqr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using l = FieldModel<uint32_t, address, 20, 4>;\n\
    \    using sq16 = FieldModel<uint32_t, address, 15, 5>;\n    using sq15 = FieldModel<uint32_t,\
    \ address, 10, 5>;\n    using sq14 = FieldModel<uint32_t, address, 5, 5>;\n  \
    \  using sq13 = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 20, 4> l;\n     \
    \ BitFieldModel<uint32_t, 15, 5> sq16;\n      BitFieldModel<uint32_t, 10, 5> sq15;\n\
    \      BitFieldModel<uint32_t, 5, 5> sq14;\n      BitFieldModel<uint32_t, 0, 5>\
    \ sq13;\n    };\n  };\n\npublic:\n  using sqr1 = Sqr1Reg<BaseAddress + 0x002C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Sqr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using sq12 = FieldModel<uint32_t, address, 25,\
    \ 5>;\n    using sq11 = FieldModel<uint32_t, address, 20, 5>;\n    using sq10\
    \ = FieldModel<uint32_t, address, 15, 5>;\n    using sq9 = FieldModel<uint32_t,\
    \ address, 10, 5>;\n    using sq8 = FieldModel<uint32_t, address, 5, 5>;\n   \
    \ using sq7 = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 25, 5> sq12;\n  \
    \    BitFieldModel<uint32_t, 20, 5> sq11;\n      BitFieldModel<uint32_t, 15, 5>\
    \ sq10;\n      BitFieldModel<uint32_t, 10, 5> sq9;\n      BitFieldModel<uint32_t,\
    \ 5, 5> sq8;\n      BitFieldModel<uint32_t, 0, 5> sq7;\n    };\n  };\n\npublic:\n\
    \  using sqr2 = Sqr2Reg<BaseAddress + 0x0030>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Sqr3Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using sq6 = FieldModel<uint32_t, address, 25, 5>;\n    using sq5\
    \ = FieldModel<uint32_t, address, 20, 5>;\n    using sq4 = FieldModel<uint32_t,\
    \ address, 15, 5>;\n    using sq3 = FieldModel<uint32_t, address, 10, 5>;\n  \
    \  using sq2 = FieldModel<uint32_t, address, 5, 5>;\n    using sq1 = FieldModel<uint32_t,\
    \ address, 0, 5>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 25, 5> sq6;\n      BitFieldModel<uint32_t, 20,\
    \ 5> sq5;\n      BitFieldModel<uint32_t, 15, 5> sq4;\n      BitFieldModel<uint32_t,\
    \ 10, 5> sq3;\n      BitFieldModel<uint32_t, 5, 5> sq2;\n      BitFieldModel<uint32_t,\
    \ 0, 5> sq1;\n    };\n  };\n\npublic:\n  using sqr3 = Sqr3Reg<BaseAddress + 0x0034>;\n\
    \nprivate:\n  template<unsigned int address>\n  class JsqrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using jl = FieldModel<uint32_t, address, 20, 2>;\n\
    \    using jsq4 = FieldModel<uint32_t, address, 15, 5>;\n    using jsq3 = FieldModel<uint32_t,\
    \ address, 10, 5>;\n    using jsq2 = FieldModel<uint32_t, address, 5, 5>;\n  \
    \  using jsq1 = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 20, 2> jl;\n    \
    \  BitFieldModel<uint32_t, 15, 5> jsq4;\n      BitFieldModel<uint32_t, 10, 5>\
    \ jsq3;\n      BitFieldModel<uint32_t, 5, 5> jsq2;\n      BitFieldModel<uint32_t,\
    \ 0, 5> jsq1;\n    };\n  };\n\npublic:\n  using jsqr = JsqrReg<BaseAddress + 0x0038>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Jdr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using jdata = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> jdata;\n    };\n  };\n\npublic:\n  using jdr1 = Jdr1Reg<BaseAddress +\
    \ 0x003C>;\n\nprivate:\n  template<unsigned int address>\n  class Jdr2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using jdata = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> jdata;\n    };\n  };\n\npublic:\n  using\
    \ jdr2 = Jdr2Reg<BaseAddress + 0x0040>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Jdr3Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   using jdata = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 16> jdata;\n\
    \    };\n  };\n\npublic:\n  using jdr3 = Jdr3Reg<BaseAddress + 0x0044>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Jdr4Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using jdata = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> jdata;\n    };\n  };\n\npublic:\n  using jdr4 = Jdr4Reg<BaseAddress +\
    \ 0x0048>;\n\nprivate:\n  template<unsigned int address>\n  class DrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using data = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> data;\n    };\n  };\n\npublic:\n  using\
    \ dr = DrReg<BaseAddress + 0x004C>;\n\nprivate:\n  template<unsigned int address,\
    \ unsigned int bankOffset>\n  class SmprxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using smpx_x = FieldModel<uint32_t,\
    \ address, 0, 32, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      BitFieldModel<uint32_t, 0, 32> smpx_x;\n    };\n  };\n\npublic:\n\
    \  using smprx = SmprxBankReg<BaseAddress + 0x000C, 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class JdrxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using jdata = FieldModel<uint32_t,\
    \ address, 0, 16, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      BitFieldModel<uint32_t, 0, 16> jdata;\n    };\n  };\n\npublic:\n\
    \  using jdrx = JdrxBankReg<BaseAddress + 0x003C, 0x0004>;\n};\n\n}\n\n#endif\
    \ /* DRAL_STM32F446_ADC1_H */\n"
  name: ADC1
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_ADC2_H\n#define DRAL_STM32F446_ADC2_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass adc2\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40012100;\n\nprivate:\n\
    \  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ovr = FieldModel<uint32_t, address, 5, 1>;\n\
    \    using strt = FieldModel<uint32_t, address, 4, 1>;\n    using jstrt = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using jeoc = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using eoc = FieldModel<uint32_t, address, 1, 1>;\n    using awd = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 5, 1> ovr;\n      BitFieldModel<uint32_t, 4, 1>\
    \ strt;\n      BitFieldModel<uint32_t, 3, 1> jstrt;\n      BitFieldModel<uint32_t,\
    \ 2, 1> jeoc;\n      BitFieldModel<uint32_t, 1, 1> eoc;\n      BitFieldModel<uint32_t,\
    \ 0, 1> awd;\n    };\n  };\n\npublic:\n  using sr = SrReg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ovrie = FieldModel<uint32_t, address, 26,\
    \ 1>;\n    using res = FieldModel<uint32_t, address, 24, 2>;\n    using awden\
    \ = FieldModel<uint32_t, address, 23, 1>;\n    using jawden = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    using discnum = FieldModel<uint32_t, address, 13, 3>;\n\
    \    using jdiscen = FieldModel<uint32_t, address, 12, 1>;\n    using discen =\
    \ FieldModel<uint32_t, address, 11, 1>;\n    using jauto = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using awdsgl = FieldModel<uint32_t, address, 9, 1>;\n\
    \    using scan = FieldModel<uint32_t, address, 8, 1>;\n    using jeocie = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using awdie = FieldModel<uint32_t, address, 6, 1>;\n  \
    \  using eocie = FieldModel<uint32_t, address, 5, 1>;\n    using awdch = FieldModel<uint32_t,\
    \ address, 0, 5>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 26, 1> ovrie;\n      BitFieldModel<uint32_t, 24,\
    \ 2> res;\n      BitFieldModel<uint32_t, 23, 1> awden;\n      BitFieldModel<uint32_t,\
    \ 22, 1> jawden;\n      BitFieldModel<uint32_t, 13, 3> discnum;\n      BitFieldModel<uint32_t,\
    \ 12, 1> jdiscen;\n      BitFieldModel<uint32_t, 11, 1> discen;\n      BitFieldModel<uint32_t,\
    \ 10, 1> jauto;\n      BitFieldModel<uint32_t, 9, 1> awdsgl;\n      BitFieldModel<uint32_t,\
    \ 8, 1> scan;\n      BitFieldModel<uint32_t, 7, 1> jeocie;\n      BitFieldModel<uint32_t,\
    \ 6, 1> awdie;\n      BitFieldModel<uint32_t, 5, 1> eocie;\n      BitFieldModel<uint32_t,\
    \ 0, 5> awdch;\n    };\n  };\n\npublic:\n  using cr1 = Cr1Reg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Cr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using swstart = FieldModel<uint32_t, address,\
    \ 30, 1>;\n    using exten = FieldModel<uint32_t, address, 28, 2>;\n    using\
    \ extsel = FieldModel<uint32_t, address, 24, 4>;\n    using jswstart = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    using jexten = FieldModel<uint32_t, address, 20, 2>;\n\
    \    using jextsel = FieldModel<uint32_t, address, 16, 4>;\n    using align =\
    \ FieldModel<uint32_t, address, 11, 1>;\n    using eocs = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using dds = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using dma = FieldModel<uint32_t, address, 8, 1>;\n    using cont = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using adon = FieldModel<uint32_t, address, 0, 1>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 30, 1> swstart;\n      BitFieldModel<uint32_t, 28, 2> exten;\n      BitFieldModel<uint32_t,\
    \ 24, 4> extsel;\n      BitFieldModel<uint32_t, 22, 1> jswstart;\n      BitFieldModel<uint32_t,\
    \ 20, 2> jexten;\n      BitFieldModel<uint32_t, 16, 4> jextsel;\n      BitFieldModel<uint32_t,\
    \ 11, 1> align;\n      BitFieldModel<uint32_t, 10, 1> eocs;\n      BitFieldModel<uint32_t,\
    \ 9, 1> dds;\n      BitFieldModel<uint32_t, 8, 1> dma;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cont;\n      BitFieldModel<uint32_t, 0, 1> adon;\n    };\n  };\n\npublic:\n\
    \  using cr2 = Cr2Reg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Smpr1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using smpx_x = FieldModel<uint32_t, address, 0, 32>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> smpx_x;\n    };\n  };\n\npublic:\n  using smpr1 = Smpr1Reg<BaseAddress\
    \ + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class Smpr2Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using smpx_x =\
    \ FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> smpx_x;\n    };\n\
    \  };\n\npublic:\n  using smpr2 = Smpr2Reg<BaseAddress + 0x0010>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Jofr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using joffset1 = FieldModel<uint32_t, address,\
    \ 0, 12>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 12> joffset1;\n    };\n  };\n\npublic:\n  using jofr1 = Jofr1Reg<BaseAddress\
    \ + 0x0014>;\n\nprivate:\n  template<unsigned int address>\n  class Jofr2Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using joffset2\
    \ = FieldModel<uint32_t, address, 0, 12>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 12> joffset2;\n    };\n\
    \  };\n\npublic:\n  using jofr2 = Jofr2Reg<BaseAddress + 0x0018>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Jofr3Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using joffset3 = FieldModel<uint32_t, address,\
    \ 0, 12>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 12> joffset3;\n    };\n  };\n\npublic:\n  using jofr3 = Jofr3Reg<BaseAddress\
    \ + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class Jofr4Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using joffset4\
    \ = FieldModel<uint32_t, address, 0, 12>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 12> joffset4;\n    };\n\
    \  };\n\npublic:\n  using jofr4 = Jofr4Reg<BaseAddress + 0x0020>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class HtrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ht = FieldModel<uint32_t, address, 0, 12>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 12> ht;\n    };\n  };\n\npublic:\n  using htr = HtrReg<BaseAddress + 0x0024>;\n\
    \nprivate:\n  template<unsigned int address>\n  class LtrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using lt = FieldModel<uint32_t, address, 0, 12>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 12> lt;\n    };\n  };\n\npublic:\n  using ltr = LtrReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Sqr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using l = FieldModel<uint32_t, address, 20, 4>;\n\
    \    using sq16 = FieldModel<uint32_t, address, 15, 5>;\n    using sq15 = FieldModel<uint32_t,\
    \ address, 10, 5>;\n    using sq14 = FieldModel<uint32_t, address, 5, 5>;\n  \
    \  using sq13 = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 20, 4> l;\n     \
    \ BitFieldModel<uint32_t, 15, 5> sq16;\n      BitFieldModel<uint32_t, 10, 5> sq15;\n\
    \      BitFieldModel<uint32_t, 5, 5> sq14;\n      BitFieldModel<uint32_t, 0, 5>\
    \ sq13;\n    };\n  };\n\npublic:\n  using sqr1 = Sqr1Reg<BaseAddress + 0x002C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Sqr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using sq12 = FieldModel<uint32_t, address, 25,\
    \ 5>;\n    using sq11 = FieldModel<uint32_t, address, 20, 5>;\n    using sq10\
    \ = FieldModel<uint32_t, address, 15, 5>;\n    using sq9 = FieldModel<uint32_t,\
    \ address, 10, 5>;\n    using sq8 = FieldModel<uint32_t, address, 5, 5>;\n   \
    \ using sq7 = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 25, 5> sq12;\n  \
    \    BitFieldModel<uint32_t, 20, 5> sq11;\n      BitFieldModel<uint32_t, 15, 5>\
    \ sq10;\n      BitFieldModel<uint32_t, 10, 5> sq9;\n      BitFieldModel<uint32_t,\
    \ 5, 5> sq8;\n      BitFieldModel<uint32_t, 0, 5> sq7;\n    };\n  };\n\npublic:\n\
    \  using sqr2 = Sqr2Reg<BaseAddress + 0x0030>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Sqr3Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using sq6 = FieldModel<uint32_t, address, 25, 5>;\n    using sq5\
    \ = FieldModel<uint32_t, address, 20, 5>;\n    using sq4 = FieldModel<uint32_t,\
    \ address, 15, 5>;\n    using sq3 = FieldModel<uint32_t, address, 10, 5>;\n  \
    \  using sq2 = FieldModel<uint32_t, address, 5, 5>;\n    using sq1 = FieldModel<uint32_t,\
    \ address, 0, 5>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 25, 5> sq6;\n      BitFieldModel<uint32_t, 20,\
    \ 5> sq5;\n      BitFieldModel<uint32_t, 15, 5> sq4;\n      BitFieldModel<uint32_t,\
    \ 10, 5> sq3;\n      BitFieldModel<uint32_t, 5, 5> sq2;\n      BitFieldModel<uint32_t,\
    \ 0, 5> sq1;\n    };\n  };\n\npublic:\n  using sqr3 = Sqr3Reg<BaseAddress + 0x0034>;\n\
    \nprivate:\n  template<unsigned int address>\n  class JsqrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using jl = FieldModel<uint32_t, address, 20, 2>;\n\
    \    using jsq4 = FieldModel<uint32_t, address, 15, 5>;\n    using jsq3 = FieldModel<uint32_t,\
    \ address, 10, 5>;\n    using jsq2 = FieldModel<uint32_t, address, 5, 5>;\n  \
    \  using jsq1 = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 20, 2> jl;\n    \
    \  BitFieldModel<uint32_t, 15, 5> jsq4;\n      BitFieldModel<uint32_t, 10, 5>\
    \ jsq3;\n      BitFieldModel<uint32_t, 5, 5> jsq2;\n      BitFieldModel<uint32_t,\
    \ 0, 5> jsq1;\n    };\n  };\n\npublic:\n  using jsqr = JsqrReg<BaseAddress + 0x0038>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Jdr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using jdata = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> jdata;\n    };\n  };\n\npublic:\n  using jdr1 = Jdr1Reg<BaseAddress +\
    \ 0x003C>;\n\nprivate:\n  template<unsigned int address>\n  class Jdr2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using jdata = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> jdata;\n    };\n  };\n\npublic:\n  using\
    \ jdr2 = Jdr2Reg<BaseAddress + 0x0040>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Jdr3Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   using jdata = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 16> jdata;\n\
    \    };\n  };\n\npublic:\n  using jdr3 = Jdr3Reg<BaseAddress + 0x0044>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Jdr4Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using jdata = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> jdata;\n    };\n  };\n\npublic:\n  using jdr4 = Jdr4Reg<BaseAddress +\
    \ 0x0048>;\n\nprivate:\n  template<unsigned int address>\n  class DrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using data = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> data;\n    };\n  };\n\npublic:\n  using\
    \ dr = DrReg<BaseAddress + 0x004C>;\n\nprivate:\n  template<unsigned int address,\
    \ unsigned int bankOffset>\n  class SmprxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using smpx_x = FieldModel<uint32_t,\
    \ address, 0, 32, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      BitFieldModel<uint32_t, 0, 32> smpx_x;\n    };\n  };\n\npublic:\n\
    \  using smprx = SmprxBankReg<BaseAddress + 0x000C, 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class JdrxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using jdata = FieldModel<uint32_t,\
    \ address, 0, 16, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      BitFieldModel<uint32_t, 0, 16> jdata;\n    };\n  };\n\npublic:\n\
    \  using jdrx = JdrxBankReg<BaseAddress + 0x003C, 0x0004>;\n};\n\n}\n\n#endif\
    \ /* DRAL_STM32F446_ADC2_H */\n"
  name: ADC2
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_ADC3_H\n#define DRAL_STM32F446_ADC3_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass adc3\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40012200;\n\nprivate:\n\
    \  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ovr = FieldModel<uint32_t, address, 5, 1>;\n\
    \    using strt = FieldModel<uint32_t, address, 4, 1>;\n    using jstrt = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using jeoc = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using eoc = FieldModel<uint32_t, address, 1, 1>;\n    using awd = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 5, 1> ovr;\n      BitFieldModel<uint32_t, 4, 1>\
    \ strt;\n      BitFieldModel<uint32_t, 3, 1> jstrt;\n      BitFieldModel<uint32_t,\
    \ 2, 1> jeoc;\n      BitFieldModel<uint32_t, 1, 1> eoc;\n      BitFieldModel<uint32_t,\
    \ 0, 1> awd;\n    };\n  };\n\npublic:\n  using sr = SrReg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ovrie = FieldModel<uint32_t, address, 26,\
    \ 1>;\n    using res = FieldModel<uint32_t, address, 24, 2>;\n    using awden\
    \ = FieldModel<uint32_t, address, 23, 1>;\n    using jawden = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    using discnum = FieldModel<uint32_t, address, 13, 3>;\n\
    \    using jdiscen = FieldModel<uint32_t, address, 12, 1>;\n    using discen =\
    \ FieldModel<uint32_t, address, 11, 1>;\n    using jauto = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using awdsgl = FieldModel<uint32_t, address, 9, 1>;\n\
    \    using scan = FieldModel<uint32_t, address, 8, 1>;\n    using jeocie = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using awdie = FieldModel<uint32_t, address, 6, 1>;\n  \
    \  using eocie = FieldModel<uint32_t, address, 5, 1>;\n    using awdch = FieldModel<uint32_t,\
    \ address, 0, 5>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 26, 1> ovrie;\n      BitFieldModel<uint32_t, 24,\
    \ 2> res;\n      BitFieldModel<uint32_t, 23, 1> awden;\n      BitFieldModel<uint32_t,\
    \ 22, 1> jawden;\n      BitFieldModel<uint32_t, 13, 3> discnum;\n      BitFieldModel<uint32_t,\
    \ 12, 1> jdiscen;\n      BitFieldModel<uint32_t, 11, 1> discen;\n      BitFieldModel<uint32_t,\
    \ 10, 1> jauto;\n      BitFieldModel<uint32_t, 9, 1> awdsgl;\n      BitFieldModel<uint32_t,\
    \ 8, 1> scan;\n      BitFieldModel<uint32_t, 7, 1> jeocie;\n      BitFieldModel<uint32_t,\
    \ 6, 1> awdie;\n      BitFieldModel<uint32_t, 5, 1> eocie;\n      BitFieldModel<uint32_t,\
    \ 0, 5> awdch;\n    };\n  };\n\npublic:\n  using cr1 = Cr1Reg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Cr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using swstart = FieldModel<uint32_t, address,\
    \ 30, 1>;\n    using exten = FieldModel<uint32_t, address, 28, 2>;\n    using\
    \ extsel = FieldModel<uint32_t, address, 24, 4>;\n    using jswstart = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    using jexten = FieldModel<uint32_t, address, 20, 2>;\n\
    \    using jextsel = FieldModel<uint32_t, address, 16, 4>;\n    using align =\
    \ FieldModel<uint32_t, address, 11, 1>;\n    using eocs = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using dds = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using dma = FieldModel<uint32_t, address, 8, 1>;\n    using cont = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using adon = FieldModel<uint32_t, address, 0, 1>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 30, 1> swstart;\n      BitFieldModel<uint32_t, 28, 2> exten;\n      BitFieldModel<uint32_t,\
    \ 24, 4> extsel;\n      BitFieldModel<uint32_t, 22, 1> jswstart;\n      BitFieldModel<uint32_t,\
    \ 20, 2> jexten;\n      BitFieldModel<uint32_t, 16, 4> jextsel;\n      BitFieldModel<uint32_t,\
    \ 11, 1> align;\n      BitFieldModel<uint32_t, 10, 1> eocs;\n      BitFieldModel<uint32_t,\
    \ 9, 1> dds;\n      BitFieldModel<uint32_t, 8, 1> dma;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cont;\n      BitFieldModel<uint32_t, 0, 1> adon;\n    };\n  };\n\npublic:\n\
    \  using cr2 = Cr2Reg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Smpr1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using smpx_x = FieldModel<uint32_t, address, 0, 32>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> smpx_x;\n    };\n  };\n\npublic:\n  using smpr1 = Smpr1Reg<BaseAddress\
    \ + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class Smpr2Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using smpx_x =\
    \ FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> smpx_x;\n    };\n\
    \  };\n\npublic:\n  using smpr2 = Smpr2Reg<BaseAddress + 0x0010>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Jofr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using joffset1 = FieldModel<uint32_t, address,\
    \ 0, 12>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 12> joffset1;\n    };\n  };\n\npublic:\n  using jofr1 = Jofr1Reg<BaseAddress\
    \ + 0x0014>;\n\nprivate:\n  template<unsigned int address>\n  class Jofr2Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using joffset2\
    \ = FieldModel<uint32_t, address, 0, 12>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 12> joffset2;\n    };\n\
    \  };\n\npublic:\n  using jofr2 = Jofr2Reg<BaseAddress + 0x0018>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Jofr3Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using joffset3 = FieldModel<uint32_t, address,\
    \ 0, 12>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 12> joffset3;\n    };\n  };\n\npublic:\n  using jofr3 = Jofr3Reg<BaseAddress\
    \ + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class Jofr4Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using joffset4\
    \ = FieldModel<uint32_t, address, 0, 12>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 12> joffset4;\n    };\n\
    \  };\n\npublic:\n  using jofr4 = Jofr4Reg<BaseAddress + 0x0020>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class HtrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ht = FieldModel<uint32_t, address, 0, 12>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 12> ht;\n    };\n  };\n\npublic:\n  using htr = HtrReg<BaseAddress + 0x0024>;\n\
    \nprivate:\n  template<unsigned int address>\n  class LtrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using lt = FieldModel<uint32_t, address, 0, 12>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 12> lt;\n    };\n  };\n\npublic:\n  using ltr = LtrReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Sqr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using l = FieldModel<uint32_t, address, 20, 4>;\n\
    \    using sq16 = FieldModel<uint32_t, address, 15, 5>;\n    using sq15 = FieldModel<uint32_t,\
    \ address, 10, 5>;\n    using sq14 = FieldModel<uint32_t, address, 5, 5>;\n  \
    \  using sq13 = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 20, 4> l;\n     \
    \ BitFieldModel<uint32_t, 15, 5> sq16;\n      BitFieldModel<uint32_t, 10, 5> sq15;\n\
    \      BitFieldModel<uint32_t, 5, 5> sq14;\n      BitFieldModel<uint32_t, 0, 5>\
    \ sq13;\n    };\n  };\n\npublic:\n  using sqr1 = Sqr1Reg<BaseAddress + 0x002C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Sqr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using sq12 = FieldModel<uint32_t, address, 25,\
    \ 5>;\n    using sq11 = FieldModel<uint32_t, address, 20, 5>;\n    using sq10\
    \ = FieldModel<uint32_t, address, 15, 5>;\n    using sq9 = FieldModel<uint32_t,\
    \ address, 10, 5>;\n    using sq8 = FieldModel<uint32_t, address, 5, 5>;\n   \
    \ using sq7 = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 25, 5> sq12;\n  \
    \    BitFieldModel<uint32_t, 20, 5> sq11;\n      BitFieldModel<uint32_t, 15, 5>\
    \ sq10;\n      BitFieldModel<uint32_t, 10, 5> sq9;\n      BitFieldModel<uint32_t,\
    \ 5, 5> sq8;\n      BitFieldModel<uint32_t, 0, 5> sq7;\n    };\n  };\n\npublic:\n\
    \  using sqr2 = Sqr2Reg<BaseAddress + 0x0030>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Sqr3Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using sq6 = FieldModel<uint32_t, address, 25, 5>;\n    using sq5\
    \ = FieldModel<uint32_t, address, 20, 5>;\n    using sq4 = FieldModel<uint32_t,\
    \ address, 15, 5>;\n    using sq3 = FieldModel<uint32_t, address, 10, 5>;\n  \
    \  using sq2 = FieldModel<uint32_t, address, 5, 5>;\n    using sq1 = FieldModel<uint32_t,\
    \ address, 0, 5>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 25, 5> sq6;\n      BitFieldModel<uint32_t, 20,\
    \ 5> sq5;\n      BitFieldModel<uint32_t, 15, 5> sq4;\n      BitFieldModel<uint32_t,\
    \ 10, 5> sq3;\n      BitFieldModel<uint32_t, 5, 5> sq2;\n      BitFieldModel<uint32_t,\
    \ 0, 5> sq1;\n    };\n  };\n\npublic:\n  using sqr3 = Sqr3Reg<BaseAddress + 0x0034>;\n\
    \nprivate:\n  template<unsigned int address>\n  class JsqrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using jl = FieldModel<uint32_t, address, 20, 2>;\n\
    \    using jsq4 = FieldModel<uint32_t, address, 15, 5>;\n    using jsq3 = FieldModel<uint32_t,\
    \ address, 10, 5>;\n    using jsq2 = FieldModel<uint32_t, address, 5, 5>;\n  \
    \  using jsq1 = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 20, 2> jl;\n    \
    \  BitFieldModel<uint32_t, 15, 5> jsq4;\n      BitFieldModel<uint32_t, 10, 5>\
    \ jsq3;\n      BitFieldModel<uint32_t, 5, 5> jsq2;\n      BitFieldModel<uint32_t,\
    \ 0, 5> jsq1;\n    };\n  };\n\npublic:\n  using jsqr = JsqrReg<BaseAddress + 0x0038>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Jdr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using jdata = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> jdata;\n    };\n  };\n\npublic:\n  using jdr1 = Jdr1Reg<BaseAddress +\
    \ 0x003C>;\n\nprivate:\n  template<unsigned int address>\n  class Jdr2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using jdata = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> jdata;\n    };\n  };\n\npublic:\n  using\
    \ jdr2 = Jdr2Reg<BaseAddress + 0x0040>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Jdr3Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   using jdata = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 16> jdata;\n\
    \    };\n  };\n\npublic:\n  using jdr3 = Jdr3Reg<BaseAddress + 0x0044>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Jdr4Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using jdata = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> jdata;\n    };\n  };\n\npublic:\n  using jdr4 = Jdr4Reg<BaseAddress +\
    \ 0x0048>;\n\nprivate:\n  template<unsigned int address>\n  class DrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using data = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> data;\n    };\n  };\n\npublic:\n  using\
    \ dr = DrReg<BaseAddress + 0x004C>;\n\nprivate:\n  template<unsigned int address,\
    \ unsigned int bankOffset>\n  class SmprxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using smpx_x = FieldModel<uint32_t,\
    \ address, 0, 32, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      BitFieldModel<uint32_t, 0, 32> smpx_x;\n    };\n  };\n\npublic:\n\
    \  using smprx = SmprxBankReg<BaseAddress + 0x000C, 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class JdrxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using jdata = FieldModel<uint32_t,\
    \ address, 0, 16, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      BitFieldModel<uint32_t, 0, 16> jdata;\n    };\n  };\n\npublic:\n\
    \  using jdrx = JdrxBankReg<BaseAddress + 0x003C, 0x0004>;\n};\n\n}\n\n#endif\
    \ /* DRAL_STM32F446_ADC3_H */\n"
  name: ADC3
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_USART6_H\n#define DRAL_STM32F446_USART6_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass usart6\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40011400;\n\nprivate:\n\
    \  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cts = FieldModel<uint32_t, address, 9, 1>;\n\
    \    using lbd = FieldModel<uint32_t, address, 8, 1>;\n    using txe = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using tc = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ rxne = FieldModel<uint32_t, address, 5, 1>;\n    using idle = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ore = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ nf = FieldModel<uint32_t, address, 2, 1>;\n    using fe = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using pe = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 9,\
    \ 1> cts;\n      BitFieldModel<uint32_t, 8, 1> lbd;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txe;\n      BitFieldModel<uint32_t, 6, 1> tc;\n      BitFieldModel<uint32_t,\
    \ 5, 1> rxne;\n      BitFieldModel<uint32_t, 4, 1> idle;\n      BitFieldModel<uint32_t,\
    \ 3, 1> ore;\n      BitFieldModel<uint32_t, 2, 1> nf;\n      BitFieldModel<uint32_t,\
    \ 1, 1> fe;\n      BitFieldModel<uint32_t, 0, 1> pe;\n    };\n  };\n\npublic:\n\
    \  using sr = SrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class DrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using dr = FieldModel<uint32_t, address, 0, 9>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 9> dr;\n    };\n\
    \  };\n\npublic:\n  using dr = DrReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class BrrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using div_mantissa = FieldModel<uint32_t, address, 4, 12>;\n \
    \   using div_fraction = FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n \
    \   union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 4,\
    \ 12> div_mantissa;\n      BitFieldModel<uint32_t, 0, 4> div_fraction;\n    };\n\
    \  };\n\npublic:\n  using brr = BrrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using over8 = FieldModel<uint32_t, address, 15, 1>;\n    using\
    \ ue = FieldModel<uint32_t, address, 13, 1>;\n    using m = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using wake = FieldModel<uint32_t, address, 11, 1>;\n \
    \   using pce = FieldModel<uint32_t, address, 10, 1>;\n    using ps = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using peie = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using txeie = FieldModel<uint32_t, address, 7, 1>;\n    using tcie = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using rxneie = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using idleie = FieldModel<uint32_t, address, 4, 1>;\n    using te = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using re = FieldModel<uint32_t, address, 2, 1>;\n    using\
    \ rwu = FieldModel<uint32_t, address, 1, 1>;\n    using sbk = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> over8;\n      BitFieldModel<uint32_t, 13,\
    \ 1> ue;\n      BitFieldModel<uint32_t, 12, 1> m;\n      BitFieldModel<uint32_t,\
    \ 11, 1> wake;\n      BitFieldModel<uint32_t, 10, 1> pce;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ps;\n      BitFieldModel<uint32_t, 8, 1> peie;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txeie;\n      BitFieldModel<uint32_t, 6, 1> tcie;\n      BitFieldModel<uint32_t,\
    \ 5, 1> rxneie;\n      BitFieldModel<uint32_t, 4, 1> idleie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> te;\n      BitFieldModel<uint32_t, 2, 1> re;\n      BitFieldModel<uint32_t,\
    \ 1, 1> rwu;\n      BitFieldModel<uint32_t, 0, 1> sbk;\n    };\n  };\n\npublic:\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using linen = FieldModel<uint32_t, address, 14, 1>;\n    using\
    \ stop = FieldModel<uint32_t, address, 12, 2>;\n    using clken = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using cpol = FieldModel<uint32_t, address, 10, 1>;\n \
    \   using cpha = FieldModel<uint32_t, address, 9, 1>;\n    using lbcl = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using lbdie = FieldModel<uint32_t, address, 6, 1>;\n  \
    \  using lbdl = FieldModel<uint32_t, address, 5, 1>;\n    using add = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 14, 1> linen;\n      BitFieldModel<uint32_t, 12,\
    \ 2> stop;\n      BitFieldModel<uint32_t, 11, 1> clken;\n      BitFieldModel<uint32_t,\
    \ 10, 1> cpol;\n      BitFieldModel<uint32_t, 9, 1> cpha;\n      BitFieldModel<uint32_t,\
    \ 8, 1> lbcl;\n      BitFieldModel<uint32_t, 6, 1> lbdie;\n      BitFieldModel<uint32_t,\
    \ 5, 1> lbdl;\n      BitFieldModel<uint32_t, 0, 4> add;\n    };\n  };\n\npublic:\n\
    \  using cr2 = Cr2Reg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr3Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using onebit = FieldModel<uint32_t, address, 11, 1>;\n    using\
    \ ctsie = FieldModel<uint32_t, address, 10, 1>;\n    using ctse = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using rtse = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using dmat = FieldModel<uint32_t, address, 7, 1>;\n    using dmar = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using scen = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using nack = FieldModel<uint32_t, address, 4, 1>;\n    using hdsel = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using irlp = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using iren = FieldModel<uint32_t, address, 1, 1>;\n    using eie = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 11, 1> onebit;\n      BitFieldModel<uint32_t, 10,\
    \ 1> ctsie;\n      BitFieldModel<uint32_t, 9, 1> ctse;\n      BitFieldModel<uint32_t,\
    \ 8, 1> rtse;\n      BitFieldModel<uint32_t, 7, 1> dmat;\n      BitFieldModel<uint32_t,\
    \ 6, 1> dmar;\n      BitFieldModel<uint32_t, 5, 1> scen;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nack;\n      BitFieldModel<uint32_t, 3, 1> hdsel;\n      BitFieldModel<uint32_t,\
    \ 2, 1> irlp;\n      BitFieldModel<uint32_t, 1, 1> iren;\n      BitFieldModel<uint32_t,\
    \ 0, 1> eie;\n    };\n  };\n\npublic:\n  using cr3 = Cr3Reg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class GtprReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using gt = FieldModel<uint32_t, address, 8, 8>;\n\
    \    using psc = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 8> gt;\n\
    \      BitFieldModel<uint32_t, 0, 8> psc;\n    };\n  };\n\npublic:\n  using gtpr\
    \ = GtprReg<BaseAddress + 0x0018>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_USART6_H\
    \ */\n"
  name: USART6
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_USART1_H\n#define DRAL_STM32F446_USART1_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass usart1\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40011000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cts = FieldModel<uint32_t, address, 9, 1>;\n\
    \    using lbd = FieldModel<uint32_t, address, 8, 1>;\n    using txe = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using tc = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ rxne = FieldModel<uint32_t, address, 5, 1>;\n    using idle = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ore = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ nf = FieldModel<uint32_t, address, 2, 1>;\n    using fe = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using pe = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 9,\
    \ 1> cts;\n      BitFieldModel<uint32_t, 8, 1> lbd;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txe;\n      BitFieldModel<uint32_t, 6, 1> tc;\n      BitFieldModel<uint32_t,\
    \ 5, 1> rxne;\n      BitFieldModel<uint32_t, 4, 1> idle;\n      BitFieldModel<uint32_t,\
    \ 3, 1> ore;\n      BitFieldModel<uint32_t, 2, 1> nf;\n      BitFieldModel<uint32_t,\
    \ 1, 1> fe;\n      BitFieldModel<uint32_t, 0, 1> pe;\n    };\n  };\n\npublic:\n\
    \  using sr = SrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class DrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using dr = FieldModel<uint32_t, address, 0, 9>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 9> dr;\n    };\n\
    \  };\n\npublic:\n  using dr = DrReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class BrrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using div_mantissa = FieldModel<uint32_t, address, 4, 12>;\n \
    \   using div_fraction = FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n \
    \   union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 4,\
    \ 12> div_mantissa;\n      BitFieldModel<uint32_t, 0, 4> div_fraction;\n    };\n\
    \  };\n\npublic:\n  using brr = BrrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using over8 = FieldModel<uint32_t, address, 15, 1>;\n    using\
    \ ue = FieldModel<uint32_t, address, 13, 1>;\n    using m = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using wake = FieldModel<uint32_t, address, 11, 1>;\n \
    \   using pce = FieldModel<uint32_t, address, 10, 1>;\n    using ps = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using peie = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using txeie = FieldModel<uint32_t, address, 7, 1>;\n    using tcie = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using rxneie = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using idleie = FieldModel<uint32_t, address, 4, 1>;\n    using te = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using re = FieldModel<uint32_t, address, 2, 1>;\n    using\
    \ rwu = FieldModel<uint32_t, address, 1, 1>;\n    using sbk = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> over8;\n      BitFieldModel<uint32_t, 13,\
    \ 1> ue;\n      BitFieldModel<uint32_t, 12, 1> m;\n      BitFieldModel<uint32_t,\
    \ 11, 1> wake;\n      BitFieldModel<uint32_t, 10, 1> pce;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ps;\n      BitFieldModel<uint32_t, 8, 1> peie;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txeie;\n      BitFieldModel<uint32_t, 6, 1> tcie;\n      BitFieldModel<uint32_t,\
    \ 5, 1> rxneie;\n      BitFieldModel<uint32_t, 4, 1> idleie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> te;\n      BitFieldModel<uint32_t, 2, 1> re;\n      BitFieldModel<uint32_t,\
    \ 1, 1> rwu;\n      BitFieldModel<uint32_t, 0, 1> sbk;\n    };\n  };\n\npublic:\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using linen = FieldModel<uint32_t, address, 14, 1>;\n    using\
    \ stop = FieldModel<uint32_t, address, 12, 2>;\n    using clken = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using cpol = FieldModel<uint32_t, address, 10, 1>;\n \
    \   using cpha = FieldModel<uint32_t, address, 9, 1>;\n    using lbcl = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using lbdie = FieldModel<uint32_t, address, 6, 1>;\n  \
    \  using lbdl = FieldModel<uint32_t, address, 5, 1>;\n    using add = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 14, 1> linen;\n      BitFieldModel<uint32_t, 12,\
    \ 2> stop;\n      BitFieldModel<uint32_t, 11, 1> clken;\n      BitFieldModel<uint32_t,\
    \ 10, 1> cpol;\n      BitFieldModel<uint32_t, 9, 1> cpha;\n      BitFieldModel<uint32_t,\
    \ 8, 1> lbcl;\n      BitFieldModel<uint32_t, 6, 1> lbdie;\n      BitFieldModel<uint32_t,\
    \ 5, 1> lbdl;\n      BitFieldModel<uint32_t, 0, 4> add;\n    };\n  };\n\npublic:\n\
    \  using cr2 = Cr2Reg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr3Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using onebit = FieldModel<uint32_t, address, 11, 1>;\n    using\
    \ ctsie = FieldModel<uint32_t, address, 10, 1>;\n    using ctse = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using rtse = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using dmat = FieldModel<uint32_t, address, 7, 1>;\n    using dmar = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using scen = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using nack = FieldModel<uint32_t, address, 4, 1>;\n    using hdsel = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using irlp = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using iren = FieldModel<uint32_t, address, 1, 1>;\n    using eie = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 11, 1> onebit;\n      BitFieldModel<uint32_t, 10,\
    \ 1> ctsie;\n      BitFieldModel<uint32_t, 9, 1> ctse;\n      BitFieldModel<uint32_t,\
    \ 8, 1> rtse;\n      BitFieldModel<uint32_t, 7, 1> dmat;\n      BitFieldModel<uint32_t,\
    \ 6, 1> dmar;\n      BitFieldModel<uint32_t, 5, 1> scen;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nack;\n      BitFieldModel<uint32_t, 3, 1> hdsel;\n      BitFieldModel<uint32_t,\
    \ 2, 1> irlp;\n      BitFieldModel<uint32_t, 1, 1> iren;\n      BitFieldModel<uint32_t,\
    \ 0, 1> eie;\n    };\n  };\n\npublic:\n  using cr3 = Cr3Reg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class GtprReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using gt = FieldModel<uint32_t, address, 8, 8>;\n\
    \    using psc = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 8> gt;\n\
    \      BitFieldModel<uint32_t, 0, 8> psc;\n    };\n  };\n\npublic:\n  using gtpr\
    \ = GtprReg<BaseAddress + 0x0018>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_USART1_H\
    \ */\n"
  name: USART1
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_USART2_H\n#define DRAL_STM32F446_USART2_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass usart2\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40004400;\n\nprivate:\n\
    \  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cts = FieldModel<uint32_t, address, 9, 1>;\n\
    \    using lbd = FieldModel<uint32_t, address, 8, 1>;\n    using txe = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using tc = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ rxne = FieldModel<uint32_t, address, 5, 1>;\n    using idle = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ore = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ nf = FieldModel<uint32_t, address, 2, 1>;\n    using fe = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using pe = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 9,\
    \ 1> cts;\n      BitFieldModel<uint32_t, 8, 1> lbd;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txe;\n      BitFieldModel<uint32_t, 6, 1> tc;\n      BitFieldModel<uint32_t,\
    \ 5, 1> rxne;\n      BitFieldModel<uint32_t, 4, 1> idle;\n      BitFieldModel<uint32_t,\
    \ 3, 1> ore;\n      BitFieldModel<uint32_t, 2, 1> nf;\n      BitFieldModel<uint32_t,\
    \ 1, 1> fe;\n      BitFieldModel<uint32_t, 0, 1> pe;\n    };\n  };\n\npublic:\n\
    \  using sr = SrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class DrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using dr = FieldModel<uint32_t, address, 0, 9>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 9> dr;\n    };\n\
    \  };\n\npublic:\n  using dr = DrReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class BrrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using div_mantissa = FieldModel<uint32_t, address, 4, 12>;\n \
    \   using div_fraction = FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n \
    \   union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 4,\
    \ 12> div_mantissa;\n      BitFieldModel<uint32_t, 0, 4> div_fraction;\n    };\n\
    \  };\n\npublic:\n  using brr = BrrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using over8 = FieldModel<uint32_t, address, 15, 1>;\n    using\
    \ ue = FieldModel<uint32_t, address, 13, 1>;\n    using m = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using wake = FieldModel<uint32_t, address, 11, 1>;\n \
    \   using pce = FieldModel<uint32_t, address, 10, 1>;\n    using ps = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using peie = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using txeie = FieldModel<uint32_t, address, 7, 1>;\n    using tcie = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using rxneie = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using idleie = FieldModel<uint32_t, address, 4, 1>;\n    using te = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using re = FieldModel<uint32_t, address, 2, 1>;\n    using\
    \ rwu = FieldModel<uint32_t, address, 1, 1>;\n    using sbk = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> over8;\n      BitFieldModel<uint32_t, 13,\
    \ 1> ue;\n      BitFieldModel<uint32_t, 12, 1> m;\n      BitFieldModel<uint32_t,\
    \ 11, 1> wake;\n      BitFieldModel<uint32_t, 10, 1> pce;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ps;\n      BitFieldModel<uint32_t, 8, 1> peie;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txeie;\n      BitFieldModel<uint32_t, 6, 1> tcie;\n      BitFieldModel<uint32_t,\
    \ 5, 1> rxneie;\n      BitFieldModel<uint32_t, 4, 1> idleie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> te;\n      BitFieldModel<uint32_t, 2, 1> re;\n      BitFieldModel<uint32_t,\
    \ 1, 1> rwu;\n      BitFieldModel<uint32_t, 0, 1> sbk;\n    };\n  };\n\npublic:\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using linen = FieldModel<uint32_t, address, 14, 1>;\n    using\
    \ stop = FieldModel<uint32_t, address, 12, 2>;\n    using clken = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using cpol = FieldModel<uint32_t, address, 10, 1>;\n \
    \   using cpha = FieldModel<uint32_t, address, 9, 1>;\n    using lbcl = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using lbdie = FieldModel<uint32_t, address, 6, 1>;\n  \
    \  using lbdl = FieldModel<uint32_t, address, 5, 1>;\n    using add = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 14, 1> linen;\n      BitFieldModel<uint32_t, 12,\
    \ 2> stop;\n      BitFieldModel<uint32_t, 11, 1> clken;\n      BitFieldModel<uint32_t,\
    \ 10, 1> cpol;\n      BitFieldModel<uint32_t, 9, 1> cpha;\n      BitFieldModel<uint32_t,\
    \ 8, 1> lbcl;\n      BitFieldModel<uint32_t, 6, 1> lbdie;\n      BitFieldModel<uint32_t,\
    \ 5, 1> lbdl;\n      BitFieldModel<uint32_t, 0, 4> add;\n    };\n  };\n\npublic:\n\
    \  using cr2 = Cr2Reg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr3Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using onebit = FieldModel<uint32_t, address, 11, 1>;\n    using\
    \ ctsie = FieldModel<uint32_t, address, 10, 1>;\n    using ctse = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using rtse = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using dmat = FieldModel<uint32_t, address, 7, 1>;\n    using dmar = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using scen = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using nack = FieldModel<uint32_t, address, 4, 1>;\n    using hdsel = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using irlp = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using iren = FieldModel<uint32_t, address, 1, 1>;\n    using eie = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 11, 1> onebit;\n      BitFieldModel<uint32_t, 10,\
    \ 1> ctsie;\n      BitFieldModel<uint32_t, 9, 1> ctse;\n      BitFieldModel<uint32_t,\
    \ 8, 1> rtse;\n      BitFieldModel<uint32_t, 7, 1> dmat;\n      BitFieldModel<uint32_t,\
    \ 6, 1> dmar;\n      BitFieldModel<uint32_t, 5, 1> scen;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nack;\n      BitFieldModel<uint32_t, 3, 1> hdsel;\n      BitFieldModel<uint32_t,\
    \ 2, 1> irlp;\n      BitFieldModel<uint32_t, 1, 1> iren;\n      BitFieldModel<uint32_t,\
    \ 0, 1> eie;\n    };\n  };\n\npublic:\n  using cr3 = Cr3Reg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class GtprReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using gt = FieldModel<uint32_t, address, 8, 8>;\n\
    \    using psc = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 8> gt;\n\
    \      BitFieldModel<uint32_t, 0, 8> psc;\n    };\n  };\n\npublic:\n  using gtpr\
    \ = GtprReg<BaseAddress + 0x0018>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_USART2_H\
    \ */\n"
  name: USART2
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_USART3_H\n#define DRAL_STM32F446_USART3_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass usart3\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40004800;\n\nprivate:\n\
    \  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cts = FieldModel<uint32_t, address, 9, 1>;\n\
    \    using lbd = FieldModel<uint32_t, address, 8, 1>;\n    using txe = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using tc = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ rxne = FieldModel<uint32_t, address, 5, 1>;\n    using idle = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ore = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ nf = FieldModel<uint32_t, address, 2, 1>;\n    using fe = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using pe = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 9,\
    \ 1> cts;\n      BitFieldModel<uint32_t, 8, 1> lbd;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txe;\n      BitFieldModel<uint32_t, 6, 1> tc;\n      BitFieldModel<uint32_t,\
    \ 5, 1> rxne;\n      BitFieldModel<uint32_t, 4, 1> idle;\n      BitFieldModel<uint32_t,\
    \ 3, 1> ore;\n      BitFieldModel<uint32_t, 2, 1> nf;\n      BitFieldModel<uint32_t,\
    \ 1, 1> fe;\n      BitFieldModel<uint32_t, 0, 1> pe;\n    };\n  };\n\npublic:\n\
    \  using sr = SrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class DrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using dr = FieldModel<uint32_t, address, 0, 9>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 9> dr;\n    };\n\
    \  };\n\npublic:\n  using dr = DrReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class BrrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using div_mantissa = FieldModel<uint32_t, address, 4, 12>;\n \
    \   using div_fraction = FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n \
    \   union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 4,\
    \ 12> div_mantissa;\n      BitFieldModel<uint32_t, 0, 4> div_fraction;\n    };\n\
    \  };\n\npublic:\n  using brr = BrrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using over8 = FieldModel<uint32_t, address, 15, 1>;\n    using\
    \ ue = FieldModel<uint32_t, address, 13, 1>;\n    using m = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using wake = FieldModel<uint32_t, address, 11, 1>;\n \
    \   using pce = FieldModel<uint32_t, address, 10, 1>;\n    using ps = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using peie = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using txeie = FieldModel<uint32_t, address, 7, 1>;\n    using tcie = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using rxneie = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using idleie = FieldModel<uint32_t, address, 4, 1>;\n    using te = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using re = FieldModel<uint32_t, address, 2, 1>;\n    using\
    \ rwu = FieldModel<uint32_t, address, 1, 1>;\n    using sbk = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> over8;\n      BitFieldModel<uint32_t, 13,\
    \ 1> ue;\n      BitFieldModel<uint32_t, 12, 1> m;\n      BitFieldModel<uint32_t,\
    \ 11, 1> wake;\n      BitFieldModel<uint32_t, 10, 1> pce;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ps;\n      BitFieldModel<uint32_t, 8, 1> peie;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txeie;\n      BitFieldModel<uint32_t, 6, 1> tcie;\n      BitFieldModel<uint32_t,\
    \ 5, 1> rxneie;\n      BitFieldModel<uint32_t, 4, 1> idleie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> te;\n      BitFieldModel<uint32_t, 2, 1> re;\n      BitFieldModel<uint32_t,\
    \ 1, 1> rwu;\n      BitFieldModel<uint32_t, 0, 1> sbk;\n    };\n  };\n\npublic:\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using linen = FieldModel<uint32_t, address, 14, 1>;\n    using\
    \ stop = FieldModel<uint32_t, address, 12, 2>;\n    using clken = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using cpol = FieldModel<uint32_t, address, 10, 1>;\n \
    \   using cpha = FieldModel<uint32_t, address, 9, 1>;\n    using lbcl = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using lbdie = FieldModel<uint32_t, address, 6, 1>;\n  \
    \  using lbdl = FieldModel<uint32_t, address, 5, 1>;\n    using add = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 14, 1> linen;\n      BitFieldModel<uint32_t, 12,\
    \ 2> stop;\n      BitFieldModel<uint32_t, 11, 1> clken;\n      BitFieldModel<uint32_t,\
    \ 10, 1> cpol;\n      BitFieldModel<uint32_t, 9, 1> cpha;\n      BitFieldModel<uint32_t,\
    \ 8, 1> lbcl;\n      BitFieldModel<uint32_t, 6, 1> lbdie;\n      BitFieldModel<uint32_t,\
    \ 5, 1> lbdl;\n      BitFieldModel<uint32_t, 0, 4> add;\n    };\n  };\n\npublic:\n\
    \  using cr2 = Cr2Reg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr3Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using onebit = FieldModel<uint32_t, address, 11, 1>;\n    using\
    \ ctsie = FieldModel<uint32_t, address, 10, 1>;\n    using ctse = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using rtse = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using dmat = FieldModel<uint32_t, address, 7, 1>;\n    using dmar = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using scen = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using nack = FieldModel<uint32_t, address, 4, 1>;\n    using hdsel = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using irlp = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using iren = FieldModel<uint32_t, address, 1, 1>;\n    using eie = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 11, 1> onebit;\n      BitFieldModel<uint32_t, 10,\
    \ 1> ctsie;\n      BitFieldModel<uint32_t, 9, 1> ctse;\n      BitFieldModel<uint32_t,\
    \ 8, 1> rtse;\n      BitFieldModel<uint32_t, 7, 1> dmat;\n      BitFieldModel<uint32_t,\
    \ 6, 1> dmar;\n      BitFieldModel<uint32_t, 5, 1> scen;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nack;\n      BitFieldModel<uint32_t, 3, 1> hdsel;\n      BitFieldModel<uint32_t,\
    \ 2, 1> irlp;\n      BitFieldModel<uint32_t, 1, 1> iren;\n      BitFieldModel<uint32_t,\
    \ 0, 1> eie;\n    };\n  };\n\npublic:\n  using cr3 = Cr3Reg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class GtprReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using gt = FieldModel<uint32_t, address, 8, 8>;\n\
    \    using psc = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 8> gt;\n\
    \      BitFieldModel<uint32_t, 0, 8> psc;\n    };\n  };\n\npublic:\n  using gtpr\
    \ = GtprReg<BaseAddress + 0x0018>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_USART3_H\
    \ */\n"
  name: USART3
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_DAC_H\n#define DRAL_STM32F446_DAC_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass dac\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40007400;\n\nprivate:\n\
    \  template<unsigned int address>\n  class CrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dmaudrie2 = FieldModel<uint32_t, address,\
    \ 29, 1>;\n    using dmaen2 = FieldModel<uint32_t, address, 28, 1>;\n    using\
    \ mamp2 = FieldModel<uint32_t, address, 24, 4>;\n    using wave2 = FieldModel<uint32_t,\
    \ address, 22, 2>;\n    using tsel2 = FieldModel<uint32_t, address, 19, 3>;\n\
    \    using ten2 = FieldModel<uint32_t, address, 18, 1>;\n    using boff2 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using en2 = FieldModel<uint32_t, address, 16, 1>;\n  \
    \  using dmaudrie1 = FieldModel<uint32_t, address, 13, 1>;\n    using dmaen1 =\
    \ FieldModel<uint32_t, address, 12, 1>;\n    using mamp1 = FieldModel<uint32_t,\
    \ address, 8, 4>;\n    using wave1 = FieldModel<uint32_t, address, 6, 2>;\n  \
    \  using tsel1 = FieldModel<uint32_t, address, 3, 3>;\n    using ten1 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using boff1 = FieldModel<uint32_t, address, 1, 1>;\n  \
    \  using en1 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 29, 1> dmaudrie2;\n\
    \      BitFieldModel<uint32_t, 28, 1> dmaen2;\n      BitFieldModel<uint32_t, 24,\
    \ 4> mamp2;\n      BitFieldModel<uint32_t, 22, 2> wave2;\n      BitFieldModel<uint32_t,\
    \ 19, 3> tsel2;\n      BitFieldModel<uint32_t, 18, 1> ten2;\n      BitFieldModel<uint32_t,\
    \ 17, 1> boff2;\n      BitFieldModel<uint32_t, 16, 1> en2;\n      BitFieldModel<uint32_t,\
    \ 13, 1> dmaudrie1;\n      BitFieldModel<uint32_t, 12, 1> dmaen1;\n      BitFieldModel<uint32_t,\
    \ 8, 4> mamp1;\n      BitFieldModel<uint32_t, 6, 2> wave1;\n      BitFieldModel<uint32_t,\
    \ 3, 3> tsel1;\n      BitFieldModel<uint32_t, 2, 1> ten1;\n      BitFieldModel<uint32_t,\
    \ 1, 1> boff1;\n      BitFieldModel<uint32_t, 0, 1> en1;\n    };\n  };\n\npublic:\n\
    \  using cr = CrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class SwtrigrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using swtrig2 = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ swtrig1 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 1, 1> swtrig2;\n\
    \      BitFieldModel<uint32_t, 0, 1> swtrig1;\n    };\n  };\n\npublic:\n  using\
    \ swtrigr = SwtrigrReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Dhr12r1Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using dacc1dhr = FieldModel<uint32_t, address, 0, 12>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 12> dacc1dhr;\n    };\n  };\n\npublic:\n  using dhr12r1 = Dhr12r1Reg<BaseAddress\
    \ + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class Dhr12l1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using dacc1dhr\
    \ = FieldModel<uint32_t, address, 4, 12>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 4, 12> dacc1dhr;\n    };\n\
    \  };\n\npublic:\n  using dhr12l1 = Dhr12l1Reg<BaseAddress + 0x000C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Dhr8r1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dacc1dhr = FieldModel<uint32_t, address,\
    \ 0, 8>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> dacc1dhr;\n    };\n  };\n\npublic:\n  using dhr8r1 = Dhr8r1Reg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class Dhr12r2Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using dacc2dhr\
    \ = FieldModel<uint32_t, address, 0, 12>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 12> dacc2dhr;\n    };\n\
    \  };\n\npublic:\n  using dhr12r2 = Dhr12r2Reg<BaseAddress + 0x0014>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Dhr12l2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dacc2dhr = FieldModel<uint32_t, address,\
    \ 4, 12>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 4, 12> dacc2dhr;\n    };\n  };\n\npublic:\n  using dhr12l2 = Dhr12l2Reg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class Dhr8r2Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using dacc2dhr\
    \ = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 8> dacc2dhr;\n    };\n\
    \  };\n\npublic:\n  using dhr8r2 = Dhr8r2Reg<BaseAddress + 0x001C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Dhr12rdReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dacc2dhr = FieldModel<uint32_t, address,\
    \ 16, 12>;\n    using dacc1dhr = FieldModel<uint32_t, address, 0, 12>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16,\
    \ 12> dacc2dhr;\n      BitFieldModel<uint32_t, 0, 12> dacc1dhr;\n    };\n  };\n\
    \npublic:\n  using dhr12rd = Dhr12rdReg<BaseAddress + 0x0020>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Dhr12ldReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dacc2dhr = FieldModel<uint32_t, address,\
    \ 20, 12>;\n    using dacc1dhr = FieldModel<uint32_t, address, 4, 12>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 20,\
    \ 12> dacc2dhr;\n      BitFieldModel<uint32_t, 4, 12> dacc1dhr;\n    };\n  };\n\
    \npublic:\n  using dhr12ld = Dhr12ldReg<BaseAddress + 0x0024>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Dhr8rdReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dacc2dhr = FieldModel<uint32_t, address,\
    \ 8, 8>;\n    using dacc1dhr = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8,\
    \ 8> dacc2dhr;\n      BitFieldModel<uint32_t, 0, 8> dacc1dhr;\n    };\n  };\n\n\
    public:\n  using dhr8rd = Dhr8rdReg<BaseAddress + 0x0028>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Dor1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using dacc1dor = FieldModel<uint32_t, address, 0, 12>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 12> dacc1dor;\n    };\n  };\n\npublic:\n  using dor1 = Dor1Reg<BaseAddress +\
    \ 0x002C>;\n\nprivate:\n  template<unsigned int address>\n  class Dor2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using dacc2dor = FieldModel<uint32_t,\
    \ address, 0, 12>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 12> dacc2dor;\n    };\n  };\n\npublic:\n  using\
    \ dor2 = Dor2Reg<BaseAddress + 0x0030>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class SrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ using dmaudr2 = FieldModel<uint32_t, address, 29, 1>;\n    using dmaudr1 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 29, 1> dmaudr2;\n      BitFieldModel<uint32_t,\
    \ 13, 1> dmaudr1;\n    };\n  };\n\npublic:\n  using sr = SrReg<BaseAddress + 0x0034>;\n\
    \n\n};\n\n}\n\n#endif /* DRAL_STM32F446_DAC_H */\n"
  name: DAC
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_FMPI2C_H\n#define DRAL_STM32F446_FMPI2C_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass fmpi2c\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40006000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using pecen = FieldModel<uint32_t, address, 23,\
    \ 1>;\n    using alerten = FieldModel<uint32_t, address, 22, 1>;\n    using smbden\
    \ = FieldModel<uint32_t, address, 21, 1>;\n    using smbhen = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using gcen = FieldModel<uint32_t, address, 19, 1>;\n \
    \   using nostretch = FieldModel<uint32_t, address, 17, 1>;\n    using sbc = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using rxdmaen = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using txdmaen = FieldModel<uint32_t, address, 14, 1>;\n    using anfoff =\
    \ FieldModel<uint32_t, address, 12, 1>;\n    using dnf = FieldModel<uint32_t,\
    \ address, 8, 4>;\n    using errie = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using tcie = FieldModel<uint32_t, address, 6, 1>;\n    using stopie = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using nackie = FieldModel<uint32_t, address, 4, 1>;\n \
    \   using addrie = FieldModel<uint32_t, address, 3, 1>;\n    using rxie = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using txie = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using pe = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 23, 1> pecen;\n \
    \     BitFieldModel<uint32_t, 22, 1> alerten;\n      BitFieldModel<uint32_t, 21,\
    \ 1> smbden;\n      BitFieldModel<uint32_t, 20, 1> smbhen;\n      BitFieldModel<uint32_t,\
    \ 19, 1> gcen;\n      BitFieldModel<uint32_t, 17, 1> nostretch;\n      BitFieldModel<uint32_t,\
    \ 16, 1> sbc;\n      BitFieldModel<uint32_t, 15, 1> rxdmaen;\n      BitFieldModel<uint32_t,\
    \ 14, 1> txdmaen;\n      BitFieldModel<uint32_t, 12, 1> anfoff;\n      BitFieldModel<uint32_t,\
    \ 8, 4> dnf;\n      BitFieldModel<uint32_t, 7, 1> errie;\n      BitFieldModel<uint32_t,\
    \ 6, 1> tcie;\n      BitFieldModel<uint32_t, 5, 1> stopie;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nackie;\n      BitFieldModel<uint32_t, 3, 1> addrie;\n      BitFieldModel<uint32_t,\
    \ 2, 1> rxie;\n      BitFieldModel<uint32_t, 1, 1> txie;\n      BitFieldModel<uint32_t,\
    \ 0, 1> pe;\n    };\n  };\n\npublic:\n  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Cr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using sadd0 = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using sadd7_1 = FieldModel<uint32_t, address, 1, 7>;\n    using sadd9_8\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    using rd_wrn = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using add10 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using head10r = FieldModel<uint32_t, address, 12, 1>;\n    using start =\
    \ FieldModel<uint32_t, address, 13, 1>;\n    using stop = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using nack = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using nbytes = FieldModel<uint32_t, address, 16, 8>;\n    using reload = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    using autoend = FieldModel<uint32_t, address, 25, 1>;\n\
    \    using pecbyte = FieldModel<uint32_t, address, 26, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> sadd0;\n\
    \      BitFieldModel<uint32_t, 1, 7> sadd7_1;\n      BitFieldModel<uint32_t, 8,\
    \ 2> sadd9_8;\n      BitFieldModel<uint32_t, 10, 1> rd_wrn;\n      BitFieldModel<uint32_t,\
    \ 11, 1> add10;\n      BitFieldModel<uint32_t, 12, 1> head10r;\n      BitFieldModel<uint32_t,\
    \ 13, 1> start;\n      BitFieldModel<uint32_t, 14, 1> stop;\n      BitFieldModel<uint32_t,\
    \ 15, 1> nack;\n      BitFieldModel<uint32_t, 16, 8> nbytes;\n      BitFieldModel<uint32_t,\
    \ 24, 1> reload;\n      BitFieldModel<uint32_t, 25, 1> autoend;\n      BitFieldModel<uint32_t,\
    \ 26, 1> pecbyte;\n    };\n  };\n\npublic:\n  using cr2 = Cr2Reg<BaseAddress +\
    \ 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class Oar1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using oa1_0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using oa1_7_1 = FieldModel<uint32_t, address, 1, 7>;\n\
    \    using oa1_9_8 = FieldModel<uint32_t, address, 8, 2>;\n    using oa1mode =\
    \ FieldModel<uint32_t, address, 10, 1>;\n    using oa1en = FieldModel<uint32_t,\
    \ address, 15, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> oa1_0;\n      BitFieldModel<uint32_t, 1,\
    \ 7> oa1_7_1;\n      BitFieldModel<uint32_t, 8, 2> oa1_9_8;\n      BitFieldModel<uint32_t,\
    \ 10, 1> oa1mode;\n      BitFieldModel<uint32_t, 15, 1> oa1en;\n    };\n  };\n\
    \npublic:\n  using oar1 = Oar1Reg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Oar2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using oa2 = FieldModel<uint32_t, address, 1, 7>;\n    using oa2msk\
    \ = FieldModel<uint32_t, address, 8, 3>;\n    using oa2en = FieldModel<uint32_t,\
    \ address, 15, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 1, 7> oa2;\n      BitFieldModel<uint32_t, 8, 3>\
    \ oa2msk;\n      BitFieldModel<uint32_t, 15, 1> oa2en;\n    };\n  };\n\npublic:\n\
    \  using oar2 = Oar2Reg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class TimingrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using scll = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ sclh = FieldModel<uint32_t, address, 8, 8>;\n    using sdadel = FieldModel<uint32_t,\
    \ address, 16, 4>;\n    using scldel = FieldModel<uint32_t, address, 20, 4>;\n\
    \    using presc = FieldModel<uint32_t, address, 28, 4>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 8> scll;\n\
    \      BitFieldModel<uint32_t, 8, 8> sclh;\n      BitFieldModel<uint32_t, 16,\
    \ 4> sdadel;\n      BitFieldModel<uint32_t, 20, 4> scldel;\n      BitFieldModel<uint32_t,\
    \ 28, 4> presc;\n    };\n  };\n\npublic:\n  using timingr = TimingrReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class TimeoutrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using timeouta\
    \ = FieldModel<uint32_t, address, 0, 12>;\n    using tidle = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using timouten = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using timeoutb = FieldModel<uint32_t, address, 16, 12>;\n    using texten\
    \ = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 12> timeouta;\n     \
    \ BitFieldModel<uint32_t, 12, 1> tidle;\n      BitFieldModel<uint32_t, 15, 1>\
    \ timouten;\n      BitFieldModel<uint32_t, 16, 12> timeoutb;\n      BitFieldModel<uint32_t,\
    \ 31, 1> texten;\n    };\n  };\n\npublic:\n  using timeoutr = TimeoutrReg<BaseAddress\
    \ + 0x0014>;\n\nprivate:\n  template<unsigned int address>\n  class IsrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using txe = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using txis = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using rxne = FieldModel<uint32_t, address, 2, 1>;\n    using addr = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using nackf = FieldModel<uint32_t, address, 4, 1>;\n  \
    \  using stopf = FieldModel<uint32_t, address, 5, 1>;\n    using tc = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using tcr = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ berr = FieldModel<uint32_t, address, 8, 1>;\n    using arlo = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using ovr = FieldModel<uint32_t, address, 10, 1>;\n   \
    \ using pecerr = FieldModel<uint32_t, address, 11, 1>;\n    using timeout = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using alert = FieldModel<uint32_t, address, 13, 1>;\n\
    \    using busy = FieldModel<uint32_t, address, 15, 1>;\n    using dir = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using addcode = FieldModel<uint32_t, address, 17, 7>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> txe;\n      BitFieldModel<uint32_t, 1, 1> txis;\n      BitFieldModel<uint32_t,\
    \ 2, 1> rxne;\n      BitFieldModel<uint32_t, 3, 1> addr;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nackf;\n      BitFieldModel<uint32_t, 5, 1> stopf;\n      BitFieldModel<uint32_t,\
    \ 6, 1> tc;\n      BitFieldModel<uint32_t, 7, 1> tcr;\n      BitFieldModel<uint32_t,\
    \ 8, 1> berr;\n      BitFieldModel<uint32_t, 9, 1> arlo;\n      BitFieldModel<uint32_t,\
    \ 10, 1> ovr;\n      BitFieldModel<uint32_t, 11, 1> pecerr;\n      BitFieldModel<uint32_t,\
    \ 12, 1> timeout;\n      BitFieldModel<uint32_t, 13, 1> alert;\n      BitFieldModel<uint32_t,\
    \ 15, 1> busy;\n      BitFieldModel<uint32_t, 16, 1> dir;\n      BitFieldModel<uint32_t,\
    \ 17, 7> addcode;\n    };\n  };\n\npublic:\n  using isr = IsrReg<BaseAddress +\
    \ 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class IcrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using addrcf = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using nackcf = FieldModel<uint32_t, address, 4, 1>;\n \
    \   using stopcf = FieldModel<uint32_t, address, 5, 1>;\n    using berrcf = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using arlocf = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using ovrcf = FieldModel<uint32_t, address, 10, 1>;\n    using peccf = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using timoutcf = FieldModel<uint32_t, address, 12, 1>;\n\
    \    using alertcf = FieldModel<uint32_t, address, 13, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 3, 1> addrcf;\n\
    \      BitFieldModel<uint32_t, 4, 1> nackcf;\n      BitFieldModel<uint32_t, 5,\
    \ 1> stopcf;\n      BitFieldModel<uint32_t, 8, 1> berrcf;\n      BitFieldModel<uint32_t,\
    \ 9, 1> arlocf;\n      BitFieldModel<uint32_t, 10, 1> ovrcf;\n      BitFieldModel<uint32_t,\
    \ 11, 1> peccf;\n      BitFieldModel<uint32_t, 12, 1> timoutcf;\n      BitFieldModel<uint32_t,\
    \ 13, 1> alertcf;\n    };\n  };\n\npublic:\n  using icr = IcrReg<BaseAddress +\
    \ 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class PecrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using pec = FieldModel<uint32_t,\
    \ address, 0, 8>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 8> pec;\n    };\n  };\n\npublic:\n  using pecr\
    \ = PecrReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class RxdrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   using rxdata = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 8> rxdata;\n\
    \    };\n  };\n\npublic:\n  using rxdr = RxdrReg<BaseAddress + 0x0024>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class TxdrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using txdata = FieldModel<uint32_t, address, 0,\
    \ 8>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> txdata;\n    };\n  };\n\npublic:\n  using txdr = TxdrReg<BaseAddress +\
    \ 0x0028>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_FMPI2C_H */\n"
  name: FMPI2C
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_I2C3_H\n#define DRAL_STM32F446_I2C3_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass i2c3\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40005C00;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using swrst = FieldModel<uint32_t, address, 15,\
    \ 1>;\n    using alert = FieldModel<uint32_t, address, 13, 1>;\n    using pec\
    \ = FieldModel<uint32_t, address, 12, 1>;\n    using pos = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using ack = FieldModel<uint32_t, address, 10, 1>;\n  \
    \  using stop = FieldModel<uint32_t, address, 9, 1>;\n    using start = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using nostretch = FieldModel<uint32_t, address, 7, 1>;\n\
    \    using engc = FieldModel<uint32_t, address, 6, 1>;\n    using enpec = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using enarp = FieldModel<uint32_t, address, 4, 1>;\n  \
    \  using smbtype = FieldModel<uint32_t, address, 3, 1>;\n    using smbus = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using pe = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 15,\
    \ 1> swrst;\n      BitFieldModel<uint32_t, 13, 1> alert;\n      BitFieldModel<uint32_t,\
    \ 12, 1> pec;\n      BitFieldModel<uint32_t, 11, 1> pos;\n      BitFieldModel<uint32_t,\
    \ 10, 1> ack;\n      BitFieldModel<uint32_t, 9, 1> stop;\n      BitFieldModel<uint32_t,\
    \ 8, 1> start;\n      BitFieldModel<uint32_t, 7, 1> nostretch;\n      BitFieldModel<uint32_t,\
    \ 6, 1> engc;\n      BitFieldModel<uint32_t, 5, 1> enpec;\n      BitFieldModel<uint32_t,\
    \ 4, 1> enarp;\n      BitFieldModel<uint32_t, 3, 1> smbtype;\n      BitFieldModel<uint32_t,\
    \ 1, 1> smbus;\n      BitFieldModel<uint32_t, 0, 1> pe;\n    };\n  };\n\npublic:\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using last = FieldModel<uint32_t, address, 12, 1>;\n    using\
    \ dmaen = FieldModel<uint32_t, address, 11, 1>;\n    using itbufen = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using itevten = FieldModel<uint32_t, address, 9, 1>;\n\
    \    using iterren = FieldModel<uint32_t, address, 8, 1>;\n    using freq = FieldModel<uint32_t,\
    \ address, 0, 6>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 12, 1> last;\n      BitFieldModel<uint32_t, 11,\
    \ 1> dmaen;\n      BitFieldModel<uint32_t, 10, 1> itbufen;\n      BitFieldModel<uint32_t,\
    \ 9, 1> itevten;\n      BitFieldModel<uint32_t, 8, 1> iterren;\n      BitFieldModel<uint32_t,\
    \ 0, 6> freq;\n    };\n  };\n\npublic:\n  using cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Oar1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using addmode = FieldModel<uint32_t, address,\
    \ 15, 1>;\n    using add10 = FieldModel<uint32_t, address, 8, 2>;\n    using add7\
    \ = FieldModel<uint32_t, address, 1, 7>;\n    using add0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> addmode;\n      BitFieldModel<uint32_t,\
    \ 8, 2> add10;\n      BitFieldModel<uint32_t, 1, 7> add7;\n      BitFieldModel<uint32_t,\
    \ 0, 1> add0;\n    };\n  };\n\npublic:\n  using oar1 = Oar1Reg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Oar2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using add2 = FieldModel<uint32_t, address, 1,\
    \ 7>;\n    using endual = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 1,\
    \ 7> add2;\n      BitFieldModel<uint32_t, 0, 1> endual;\n    };\n  };\n\npublic:\n\
    \  using oar2 = Oar2Reg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using dr = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 8> dr;\n    };\n  };\n\npublic:\n  using dr = DrReg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Sr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using smbalert = FieldModel<uint32_t, address,\
    \ 15, 1>;\n    using timeout = FieldModel<uint32_t, address, 14, 1>;\n    using\
    \ pecerr = FieldModel<uint32_t, address, 12, 1>;\n    using ovr = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using af = FieldModel<uint32_t, address, 10, 1>;\n   \
    \ using arlo = FieldModel<uint32_t, address, 9, 1>;\n    using berr = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using txe = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ rxne = FieldModel<uint32_t, address, 6, 1>;\n    using stopf = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using add10 = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using btf = FieldModel<uint32_t, address, 2, 1>;\n    using addr = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using sb = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 15,\
    \ 1> smbalert;\n      BitFieldModel<uint32_t, 14, 1> timeout;\n      BitFieldModel<uint32_t,\
    \ 12, 1> pecerr;\n      BitFieldModel<uint32_t, 11, 1> ovr;\n      BitFieldModel<uint32_t,\
    \ 10, 1> af;\n      BitFieldModel<uint32_t, 9, 1> arlo;\n      BitFieldModel<uint32_t,\
    \ 8, 1> berr;\n      BitFieldModel<uint32_t, 7, 1> txe;\n      BitFieldModel<uint32_t,\
    \ 6, 1> rxne;\n      BitFieldModel<uint32_t, 4, 1> stopf;\n      BitFieldModel<uint32_t,\
    \ 3, 1> add10;\n      BitFieldModel<uint32_t, 2, 1> btf;\n      BitFieldModel<uint32_t,\
    \ 1, 1> addr;\n      BitFieldModel<uint32_t, 0, 1> sb;\n    };\n  };\n\npublic:\n\
    \  using sr1 = Sr1Reg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Sr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using pec = FieldModel<uint32_t, address, 8, 8>;\n    using dualf\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    using smbhost = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using smbdefault = FieldModel<uint32_t, address, 5, 1>;\n\
    \    using gencall = FieldModel<uint32_t, address, 4, 1>;\n    using tra = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using busy = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using msl = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 8> pec;\n    \
    \  BitFieldModel<uint32_t, 7, 1> dualf;\n      BitFieldModel<uint32_t, 6, 1> smbhost;\n\
    \      BitFieldModel<uint32_t, 5, 1> smbdefault;\n      BitFieldModel<uint32_t,\
    \ 4, 1> gencall;\n      BitFieldModel<uint32_t, 2, 1> tra;\n      BitFieldModel<uint32_t,\
    \ 1, 1> busy;\n      BitFieldModel<uint32_t, 0, 1> msl;\n    };\n  };\n\npublic:\n\
    \  using sr2 = Sr2Reg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CcrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using f_s = FieldModel<uint32_t, address, 15, 1>;\n    using duty\
    \ = FieldModel<uint32_t, address, 14, 1>;\n    using ccr = FieldModel<uint32_t,\
    \ address, 0, 12>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> f_s;\n      BitFieldModel<uint32_t, 14,\
    \ 1> duty;\n      BitFieldModel<uint32_t, 0, 12> ccr;\n    };\n  };\n\npublic:\n\
    \  using ccr = CcrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class TriseReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using trise = FieldModel<uint32_t, address, 0, 6>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 6> trise;\n    };\n  };\n\npublic:\n  using trise = TriseReg<BaseAddress + 0x0020>;\n\
    \nprivate:\n  template<unsigned int address>\n  class FltrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dnf = FieldModel<uint32_t, address, 0, 4>;\n\
    \    using anoff = FieldModel<uint32_t, address, 4, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 4> dnf;\n\
    \      BitFieldModel<uint32_t, 4, 1> anoff;\n    };\n  };\n\npublic:\n  using\
    \ fltr = FltrReg<BaseAddress + 0x0024>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_I2C3_H\
    \ */\n"
  name: I2C3
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_I2C2_H\n#define DRAL_STM32F446_I2C2_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass i2c2\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40005800;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using swrst = FieldModel<uint32_t, address, 15,\
    \ 1>;\n    using alert = FieldModel<uint32_t, address, 13, 1>;\n    using pec\
    \ = FieldModel<uint32_t, address, 12, 1>;\n    using pos = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using ack = FieldModel<uint32_t, address, 10, 1>;\n  \
    \  using stop = FieldModel<uint32_t, address, 9, 1>;\n    using start = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using nostretch = FieldModel<uint32_t, address, 7, 1>;\n\
    \    using engc = FieldModel<uint32_t, address, 6, 1>;\n    using enpec = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using enarp = FieldModel<uint32_t, address, 4, 1>;\n  \
    \  using smbtype = FieldModel<uint32_t, address, 3, 1>;\n    using smbus = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using pe = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 15,\
    \ 1> swrst;\n      BitFieldModel<uint32_t, 13, 1> alert;\n      BitFieldModel<uint32_t,\
    \ 12, 1> pec;\n      BitFieldModel<uint32_t, 11, 1> pos;\n      BitFieldModel<uint32_t,\
    \ 10, 1> ack;\n      BitFieldModel<uint32_t, 9, 1> stop;\n      BitFieldModel<uint32_t,\
    \ 8, 1> start;\n      BitFieldModel<uint32_t, 7, 1> nostretch;\n      BitFieldModel<uint32_t,\
    \ 6, 1> engc;\n      BitFieldModel<uint32_t, 5, 1> enpec;\n      BitFieldModel<uint32_t,\
    \ 4, 1> enarp;\n      BitFieldModel<uint32_t, 3, 1> smbtype;\n      BitFieldModel<uint32_t,\
    \ 1, 1> smbus;\n      BitFieldModel<uint32_t, 0, 1> pe;\n    };\n  };\n\npublic:\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using last = FieldModel<uint32_t, address, 12, 1>;\n    using\
    \ dmaen = FieldModel<uint32_t, address, 11, 1>;\n    using itbufen = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using itevten = FieldModel<uint32_t, address, 9, 1>;\n\
    \    using iterren = FieldModel<uint32_t, address, 8, 1>;\n    using freq = FieldModel<uint32_t,\
    \ address, 0, 6>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 12, 1> last;\n      BitFieldModel<uint32_t, 11,\
    \ 1> dmaen;\n      BitFieldModel<uint32_t, 10, 1> itbufen;\n      BitFieldModel<uint32_t,\
    \ 9, 1> itevten;\n      BitFieldModel<uint32_t, 8, 1> iterren;\n      BitFieldModel<uint32_t,\
    \ 0, 6> freq;\n    };\n  };\n\npublic:\n  using cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Oar1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using addmode = FieldModel<uint32_t, address,\
    \ 15, 1>;\n    using add10 = FieldModel<uint32_t, address, 8, 2>;\n    using add7\
    \ = FieldModel<uint32_t, address, 1, 7>;\n    using add0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> addmode;\n      BitFieldModel<uint32_t,\
    \ 8, 2> add10;\n      BitFieldModel<uint32_t, 1, 7> add7;\n      BitFieldModel<uint32_t,\
    \ 0, 1> add0;\n    };\n  };\n\npublic:\n  using oar1 = Oar1Reg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Oar2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using add2 = FieldModel<uint32_t, address, 1,\
    \ 7>;\n    using endual = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 1,\
    \ 7> add2;\n      BitFieldModel<uint32_t, 0, 1> endual;\n    };\n  };\n\npublic:\n\
    \  using oar2 = Oar2Reg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using dr = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 8> dr;\n    };\n  };\n\npublic:\n  using dr = DrReg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Sr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using smbalert = FieldModel<uint32_t, address,\
    \ 15, 1>;\n    using timeout = FieldModel<uint32_t, address, 14, 1>;\n    using\
    \ pecerr = FieldModel<uint32_t, address, 12, 1>;\n    using ovr = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using af = FieldModel<uint32_t, address, 10, 1>;\n   \
    \ using arlo = FieldModel<uint32_t, address, 9, 1>;\n    using berr = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using txe = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ rxne = FieldModel<uint32_t, address, 6, 1>;\n    using stopf = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using add10 = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using btf = FieldModel<uint32_t, address, 2, 1>;\n    using addr = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using sb = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 15,\
    \ 1> smbalert;\n      BitFieldModel<uint32_t, 14, 1> timeout;\n      BitFieldModel<uint32_t,\
    \ 12, 1> pecerr;\n      BitFieldModel<uint32_t, 11, 1> ovr;\n      BitFieldModel<uint32_t,\
    \ 10, 1> af;\n      BitFieldModel<uint32_t, 9, 1> arlo;\n      BitFieldModel<uint32_t,\
    \ 8, 1> berr;\n      BitFieldModel<uint32_t, 7, 1> txe;\n      BitFieldModel<uint32_t,\
    \ 6, 1> rxne;\n      BitFieldModel<uint32_t, 4, 1> stopf;\n      BitFieldModel<uint32_t,\
    \ 3, 1> add10;\n      BitFieldModel<uint32_t, 2, 1> btf;\n      BitFieldModel<uint32_t,\
    \ 1, 1> addr;\n      BitFieldModel<uint32_t, 0, 1> sb;\n    };\n  };\n\npublic:\n\
    \  using sr1 = Sr1Reg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Sr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using pec = FieldModel<uint32_t, address, 8, 8>;\n    using dualf\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    using smbhost = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using smbdefault = FieldModel<uint32_t, address, 5, 1>;\n\
    \    using gencall = FieldModel<uint32_t, address, 4, 1>;\n    using tra = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using busy = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using msl = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 8> pec;\n    \
    \  BitFieldModel<uint32_t, 7, 1> dualf;\n      BitFieldModel<uint32_t, 6, 1> smbhost;\n\
    \      BitFieldModel<uint32_t, 5, 1> smbdefault;\n      BitFieldModel<uint32_t,\
    \ 4, 1> gencall;\n      BitFieldModel<uint32_t, 2, 1> tra;\n      BitFieldModel<uint32_t,\
    \ 1, 1> busy;\n      BitFieldModel<uint32_t, 0, 1> msl;\n    };\n  };\n\npublic:\n\
    \  using sr2 = Sr2Reg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CcrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using f_s = FieldModel<uint32_t, address, 15, 1>;\n    using duty\
    \ = FieldModel<uint32_t, address, 14, 1>;\n    using ccr = FieldModel<uint32_t,\
    \ address, 0, 12>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> f_s;\n      BitFieldModel<uint32_t, 14,\
    \ 1> duty;\n      BitFieldModel<uint32_t, 0, 12> ccr;\n    };\n  };\n\npublic:\n\
    \  using ccr = CcrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class TriseReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using trise = FieldModel<uint32_t, address, 0, 6>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 6> trise;\n    };\n  };\n\npublic:\n  using trise = TriseReg<BaseAddress + 0x0020>;\n\
    \nprivate:\n  template<unsigned int address>\n  class FltrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dnf = FieldModel<uint32_t, address, 0, 4>;\n\
    \    using anoff = FieldModel<uint32_t, address, 4, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 4> dnf;\n\
    \      BitFieldModel<uint32_t, 4, 1> anoff;\n    };\n  };\n\npublic:\n  using\
    \ fltr = FltrReg<BaseAddress + 0x0024>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_I2C2_H\
    \ */\n"
  name: I2C2
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_I2C1_H\n#define DRAL_STM32F446_I2C1_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass i2c1\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40005400;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using swrst = FieldModel<uint32_t, address, 15,\
    \ 1>;\n    using alert = FieldModel<uint32_t, address, 13, 1>;\n    using pec\
    \ = FieldModel<uint32_t, address, 12, 1>;\n    using pos = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using ack = FieldModel<uint32_t, address, 10, 1>;\n  \
    \  using stop = FieldModel<uint32_t, address, 9, 1>;\n    using start = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using nostretch = FieldModel<uint32_t, address, 7, 1>;\n\
    \    using engc = FieldModel<uint32_t, address, 6, 1>;\n    using enpec = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using enarp = FieldModel<uint32_t, address, 4, 1>;\n  \
    \  using smbtype = FieldModel<uint32_t, address, 3, 1>;\n    using smbus = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using pe = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 15,\
    \ 1> swrst;\n      BitFieldModel<uint32_t, 13, 1> alert;\n      BitFieldModel<uint32_t,\
    \ 12, 1> pec;\n      BitFieldModel<uint32_t, 11, 1> pos;\n      BitFieldModel<uint32_t,\
    \ 10, 1> ack;\n      BitFieldModel<uint32_t, 9, 1> stop;\n      BitFieldModel<uint32_t,\
    \ 8, 1> start;\n      BitFieldModel<uint32_t, 7, 1> nostretch;\n      BitFieldModel<uint32_t,\
    \ 6, 1> engc;\n      BitFieldModel<uint32_t, 5, 1> enpec;\n      BitFieldModel<uint32_t,\
    \ 4, 1> enarp;\n      BitFieldModel<uint32_t, 3, 1> smbtype;\n      BitFieldModel<uint32_t,\
    \ 1, 1> smbus;\n      BitFieldModel<uint32_t, 0, 1> pe;\n    };\n  };\n\npublic:\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using last = FieldModel<uint32_t, address, 12, 1>;\n    using\
    \ dmaen = FieldModel<uint32_t, address, 11, 1>;\n    using itbufen = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using itevten = FieldModel<uint32_t, address, 9, 1>;\n\
    \    using iterren = FieldModel<uint32_t, address, 8, 1>;\n    using freq = FieldModel<uint32_t,\
    \ address, 0, 6>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 12, 1> last;\n      BitFieldModel<uint32_t, 11,\
    \ 1> dmaen;\n      BitFieldModel<uint32_t, 10, 1> itbufen;\n      BitFieldModel<uint32_t,\
    \ 9, 1> itevten;\n      BitFieldModel<uint32_t, 8, 1> iterren;\n      BitFieldModel<uint32_t,\
    \ 0, 6> freq;\n    };\n  };\n\npublic:\n  using cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Oar1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using addmode = FieldModel<uint32_t, address,\
    \ 15, 1>;\n    using add10 = FieldModel<uint32_t, address, 8, 2>;\n    using add7\
    \ = FieldModel<uint32_t, address, 1, 7>;\n    using add0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> addmode;\n      BitFieldModel<uint32_t,\
    \ 8, 2> add10;\n      BitFieldModel<uint32_t, 1, 7> add7;\n      BitFieldModel<uint32_t,\
    \ 0, 1> add0;\n    };\n  };\n\npublic:\n  using oar1 = Oar1Reg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Oar2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using add2 = FieldModel<uint32_t, address, 1,\
    \ 7>;\n    using endual = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 1,\
    \ 7> add2;\n      BitFieldModel<uint32_t, 0, 1> endual;\n    };\n  };\n\npublic:\n\
    \  using oar2 = Oar2Reg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using dr = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 8> dr;\n    };\n  };\n\npublic:\n  using dr = DrReg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Sr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using smbalert = FieldModel<uint32_t, address,\
    \ 15, 1>;\n    using timeout = FieldModel<uint32_t, address, 14, 1>;\n    using\
    \ pecerr = FieldModel<uint32_t, address, 12, 1>;\n    using ovr = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using af = FieldModel<uint32_t, address, 10, 1>;\n   \
    \ using arlo = FieldModel<uint32_t, address, 9, 1>;\n    using berr = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using txe = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ rxne = FieldModel<uint32_t, address, 6, 1>;\n    using stopf = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using add10 = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using btf = FieldModel<uint32_t, address, 2, 1>;\n    using addr = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using sb = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 15,\
    \ 1> smbalert;\n      BitFieldModel<uint32_t, 14, 1> timeout;\n      BitFieldModel<uint32_t,\
    \ 12, 1> pecerr;\n      BitFieldModel<uint32_t, 11, 1> ovr;\n      BitFieldModel<uint32_t,\
    \ 10, 1> af;\n      BitFieldModel<uint32_t, 9, 1> arlo;\n      BitFieldModel<uint32_t,\
    \ 8, 1> berr;\n      BitFieldModel<uint32_t, 7, 1> txe;\n      BitFieldModel<uint32_t,\
    \ 6, 1> rxne;\n      BitFieldModel<uint32_t, 4, 1> stopf;\n      BitFieldModel<uint32_t,\
    \ 3, 1> add10;\n      BitFieldModel<uint32_t, 2, 1> btf;\n      BitFieldModel<uint32_t,\
    \ 1, 1> addr;\n      BitFieldModel<uint32_t, 0, 1> sb;\n    };\n  };\n\npublic:\n\
    \  using sr1 = Sr1Reg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Sr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using pec = FieldModel<uint32_t, address, 8, 8>;\n    using dualf\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    using smbhost = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using smbdefault = FieldModel<uint32_t, address, 5, 1>;\n\
    \    using gencall = FieldModel<uint32_t, address, 4, 1>;\n    using tra = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using busy = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using msl = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 8> pec;\n    \
    \  BitFieldModel<uint32_t, 7, 1> dualf;\n      BitFieldModel<uint32_t, 6, 1> smbhost;\n\
    \      BitFieldModel<uint32_t, 5, 1> smbdefault;\n      BitFieldModel<uint32_t,\
    \ 4, 1> gencall;\n      BitFieldModel<uint32_t, 2, 1> tra;\n      BitFieldModel<uint32_t,\
    \ 1, 1> busy;\n      BitFieldModel<uint32_t, 0, 1> msl;\n    };\n  };\n\npublic:\n\
    \  using sr2 = Sr2Reg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CcrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using f_s = FieldModel<uint32_t, address, 15, 1>;\n    using duty\
    \ = FieldModel<uint32_t, address, 14, 1>;\n    using ccr = FieldModel<uint32_t,\
    \ address, 0, 12>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> f_s;\n      BitFieldModel<uint32_t, 14,\
    \ 1> duty;\n      BitFieldModel<uint32_t, 0, 12> ccr;\n    };\n  };\n\npublic:\n\
    \  using ccr = CcrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class TriseReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using trise = FieldModel<uint32_t, address, 0, 6>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 6> trise;\n    };\n  };\n\npublic:\n  using trise = TriseReg<BaseAddress + 0x0020>;\n\
    \nprivate:\n  template<unsigned int address>\n  class FltrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dnf = FieldModel<uint32_t, address, 0, 4>;\n\
    \    using anoff = FieldModel<uint32_t, address, 4, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 4> dnf;\n\
    \      BitFieldModel<uint32_t, 4, 1> anoff;\n    };\n  };\n\npublic:\n  using\
    \ fltr = FltrReg<BaseAddress + 0x0024>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_I2C1_H\
    \ */\n"
  name: I2C1
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_IWDG_H\n#define DRAL_STM32F446_IWDG_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass iwdg\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40003000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class KrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using key = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> key;\n    };\n  };\n\npublic:\n  using kr = KrReg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class PrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using pr = FieldModel<uint32_t, address, 0, 3>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 3> pr;\n    };\n  };\n\npublic:\n  using pr = PrReg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class RlrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using rl = FieldModel<uint32_t, address, 0, 12>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 12> rl;\n    };\n  };\n\npublic:\n  using rlr = RlrReg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using rvu = FieldModel<uint32_t, address, 1, 1>;\n\
    \    using pvu = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 1, 1> rvu;\n\
    \      BitFieldModel<uint32_t, 0, 1> pvu;\n    };\n  };\n\npublic:\n  using sr\
    \ = SrReg<BaseAddress + 0x000C>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_IWDG_H\
    \ */\n"
  name: IWDG
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_WWDG_H\n#define DRAL_STM32F446_WWDG_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass wwdg\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40002C00;\n\nprivate:\n\
    \  template<unsigned int address>\n  class CrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using wdga = FieldModel<uint32_t, address, 7,\
    \ 1>;\n    using t = FieldModel<uint32_t, address, 0, 7>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 7, 1> wdga;\n\
    \      BitFieldModel<uint32_t, 0, 7> t;\n    };\n  };\n\npublic:\n  using cr =\
    \ CrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class CfrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  using ewi = FieldModel<uint32_t, address, 9, 1>;\n    using wdgtb1 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using wdgtb0 = FieldModel<uint32_t, address, 7, 1>;\n \
    \   using w = FieldModel<uint32_t, address, 0, 7>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 9, 1> ewi;\n    \
    \  BitFieldModel<uint32_t, 8, 1> wdgtb1;\n      BitFieldModel<uint32_t, 7, 1>\
    \ wdgtb0;\n      BitFieldModel<uint32_t, 0, 7> w;\n    };\n  };\n\npublic:\n \
    \ using cfr = CfrReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class SrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using ewif = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> ewif;\n\
    \    };\n  };\n\npublic:\n  using sr = SrReg<BaseAddress + 0x0008>;\n\n\n};\n\n\
    }\n\n#endif /* DRAL_STM32F446_WWDG_H */\n"
  name: WWDG
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_RTC_H\n#define DRAL_STM32F446_RTC_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass rtc\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40002800;\n\nprivate:\n\
    \  template<unsigned int address>\n  class TrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using pm = FieldModel<uint32_t, address, 22, 1>;\n\
    \    using ht = FieldModel<uint32_t, address, 20, 2>;\n    using hu = FieldModel<uint32_t,\
    \ address, 16, 4>;\n    using mnt = FieldModel<uint32_t, address, 12, 3>;\n  \
    \  using mnu = FieldModel<uint32_t, address, 8, 4>;\n    using st = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    using su = FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 22,\
    \ 1> pm;\n      BitFieldModel<uint32_t, 20, 2> ht;\n      BitFieldModel<uint32_t,\
    \ 16, 4> hu;\n      BitFieldModel<uint32_t, 12, 3> mnt;\n      BitFieldModel<uint32_t,\
    \ 8, 4> mnu;\n      BitFieldModel<uint32_t, 4, 3> st;\n      BitFieldModel<uint32_t,\
    \ 0, 4> su;\n    };\n  };\n\npublic:\n  using tr = TrReg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using yt = FieldModel<uint32_t, address, 20, 4>;\n\
    \    using yu = FieldModel<uint32_t, address, 16, 4>;\n    using wdu = FieldModel<uint32_t,\
    \ address, 13, 3>;\n    using mt = FieldModel<uint32_t, address, 12, 1>;\n   \
    \ using mu = FieldModel<uint32_t, address, 8, 4>;\n    using dt = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    using du = FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 20,\
    \ 4> yt;\n      BitFieldModel<uint32_t, 16, 4> yu;\n      BitFieldModel<uint32_t,\
    \ 13, 3> wdu;\n      BitFieldModel<uint32_t, 12, 1> mt;\n      BitFieldModel<uint32_t,\
    \ 8, 4> mu;\n      BitFieldModel<uint32_t, 4, 2> dt;\n      BitFieldModel<uint32_t,\
    \ 0, 4> du;\n    };\n  };\n\npublic:\n  using dr = DrReg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using coe = FieldModel<uint32_t, address, 23,\
    \ 1>;\n    using osel = FieldModel<uint32_t, address, 21, 2>;\n    using pol =\
    \ FieldModel<uint32_t, address, 20, 1>;\n    using bkp = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    using sub1h = FieldModel<uint32_t, address, 17, 1>;\n\
    \    using add1h = FieldModel<uint32_t, address, 16, 1>;\n    using tsie = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using wutie = FieldModel<uint32_t, address, 14, 1>;\n\
    \    using alrbie = FieldModel<uint32_t, address, 13, 1>;\n    using alraie =\
    \ FieldModel<uint32_t, address, 12, 1>;\n    using tse = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using wute = FieldModel<uint32_t, address, 10, 1>;\n \
    \   using alrbe = FieldModel<uint32_t, address, 9, 1>;\n    using alrae = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using dce = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ fmt = FieldModel<uint32_t, address, 6, 1>;\n    using refckon = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using tsedge = FieldModel<uint32_t, address, 3, 1>;\n \
    \   using wcksel = FieldModel<uint32_t, address, 0, 3>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 23, 1> coe;\n\
    \      BitFieldModel<uint32_t, 21, 2> osel;\n      BitFieldModel<uint32_t, 20,\
    \ 1> pol;\n      BitFieldModel<uint32_t, 18, 1> bkp;\n      BitFieldModel<uint32_t,\
    \ 17, 1> sub1h;\n      BitFieldModel<uint32_t, 16, 1> add1h;\n      BitFieldModel<uint32_t,\
    \ 15, 1> tsie;\n      BitFieldModel<uint32_t, 14, 1> wutie;\n      BitFieldModel<uint32_t,\
    \ 13, 1> alrbie;\n      BitFieldModel<uint32_t, 12, 1> alraie;\n      BitFieldModel<uint32_t,\
    \ 11, 1> tse;\n      BitFieldModel<uint32_t, 10, 1> wute;\n      BitFieldModel<uint32_t,\
    \ 9, 1> alrbe;\n      BitFieldModel<uint32_t, 8, 1> alrae;\n      BitFieldModel<uint32_t,\
    \ 7, 1> dce;\n      BitFieldModel<uint32_t, 6, 1> fmt;\n      BitFieldModel<uint32_t,\
    \ 4, 1> refckon;\n      BitFieldModel<uint32_t, 3, 1> tsedge;\n      BitFieldModel<uint32_t,\
    \ 0, 3> wcksel;\n    };\n  };\n\npublic:\n  using cr = CrReg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class IsrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using alrawf = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using alrbwf = FieldModel<uint32_t, address, 1, 1>;\n    using wutwf\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    using shpf = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using inits = FieldModel<uint32_t, address, 4, 1>;\n  \
    \  using rsf = FieldModel<uint32_t, address, 5, 1>;\n    using initf = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using init = FieldModel<uint32_t, address, 7, 1>;\n   \
    \ using alraf = FieldModel<uint32_t, address, 8, 1>;\n    using alrbf = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using wutf = FieldModel<uint32_t, address, 10, 1>;\n  \
    \  using tsf = FieldModel<uint32_t, address, 11, 1>;\n    using tsovf = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using tamp1f = FieldModel<uint32_t, address, 13, 1>;\n\
    \    using tamp2f = FieldModel<uint32_t, address, 14, 1>;\n    using recalpf =\
    \ FieldModel<uint32_t, address, 16, 1>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> alrawf;\n      BitFieldModel<uint32_t,\
    \ 1, 1> alrbwf;\n      BitFieldModel<uint32_t, 2, 1> wutwf;\n      BitFieldModel<uint32_t,\
    \ 3, 1> shpf;\n      BitFieldModel<uint32_t, 4, 1> inits;\n      BitFieldModel<uint32_t,\
    \ 5, 1> rsf;\n      BitFieldModel<uint32_t, 6, 1> initf;\n      BitFieldModel<uint32_t,\
    \ 7, 1> init;\n      BitFieldModel<uint32_t, 8, 1> alraf;\n      BitFieldModel<uint32_t,\
    \ 9, 1> alrbf;\n      BitFieldModel<uint32_t, 10, 1> wutf;\n      BitFieldModel<uint32_t,\
    \ 11, 1> tsf;\n      BitFieldModel<uint32_t, 12, 1> tsovf;\n      BitFieldModel<uint32_t,\
    \ 13, 1> tamp1f;\n      BitFieldModel<uint32_t, 14, 1> tamp2f;\n      BitFieldModel<uint32_t,\
    \ 16, 1> recalpf;\n    };\n  };\n\npublic:\n  using isr = IsrReg<BaseAddress +\
    \ 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class PrerReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using prediv_a = FieldModel<uint32_t,\
    \ address, 16, 7>;\n    using prediv_s = FieldModel<uint32_t, address, 0, 15>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 16, 7> prediv_a;\n      BitFieldModel<uint32_t, 0, 15> prediv_s;\n    };\n \
    \ };\n\npublic:\n  using prer = PrerReg<BaseAddress + 0x0010>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class WutrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using wut = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> wut;\n    };\n  };\n\npublic:\n  using wutr = WutrReg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CalibrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dcs = FieldModel<uint32_t, address, 7, 1>;\n\
    \    using dc = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 7, 1> dcs;\n    \
    \  BitFieldModel<uint32_t, 0, 5> dc;\n    };\n  };\n\npublic:\n  using calibr\
    \ = CalibrReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class AlrmarReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using msk4 = FieldModel<uint32_t, address, 31, 1>;\n    using wdsel = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    using dt = FieldModel<uint32_t, address, 28, 2>;\n   \
    \ using du = FieldModel<uint32_t, address, 24, 4>;\n    using msk3 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using pm = FieldModel<uint32_t, address, 22, 1>;\n   \
    \ using ht = FieldModel<uint32_t, address, 20, 2>;\n    using hu = FieldModel<uint32_t,\
    \ address, 16, 4>;\n    using msk2 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using mnt = FieldModel<uint32_t, address, 12, 3>;\n    using mnu = FieldModel<uint32_t,\
    \ address, 8, 4>;\n    using msk1 = FieldModel<uint32_t, address, 7, 1>;\n   \
    \ using st = FieldModel<uint32_t, address, 4, 3>;\n    using su = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 31, 1> msk4;\n      BitFieldModel<uint32_t, 30,\
    \ 1> wdsel;\n      BitFieldModel<uint32_t, 28, 2> dt;\n      BitFieldModel<uint32_t,\
    \ 24, 4> du;\n      BitFieldModel<uint32_t, 23, 1> msk3;\n      BitFieldModel<uint32_t,\
    \ 22, 1> pm;\n      BitFieldModel<uint32_t, 20, 2> ht;\n      BitFieldModel<uint32_t,\
    \ 16, 4> hu;\n      BitFieldModel<uint32_t, 15, 1> msk2;\n      BitFieldModel<uint32_t,\
    \ 12, 3> mnt;\n      BitFieldModel<uint32_t, 8, 4> mnu;\n      BitFieldModel<uint32_t,\
    \ 7, 1> msk1;\n      BitFieldModel<uint32_t, 4, 3> st;\n      BitFieldModel<uint32_t,\
    \ 0, 4> su;\n    };\n  };\n\npublic:\n  using alrmar = AlrmarReg<BaseAddress +\
    \ 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class AlrmbrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using msk4 = FieldModel<uint32_t,\
    \ address, 31, 1>;\n    using wdsel = FieldModel<uint32_t, address, 30, 1>;\n\
    \    using dt = FieldModel<uint32_t, address, 28, 2>;\n    using du = FieldModel<uint32_t,\
    \ address, 24, 4>;\n    using msk3 = FieldModel<uint32_t, address, 23, 1>;\n \
    \   using pm = FieldModel<uint32_t, address, 22, 1>;\n    using ht = FieldModel<uint32_t,\
    \ address, 20, 2>;\n    using hu = FieldModel<uint32_t, address, 16, 4>;\n   \
    \ using msk2 = FieldModel<uint32_t, address, 15, 1>;\n    using mnt = FieldModel<uint32_t,\
    \ address, 12, 3>;\n    using mnu = FieldModel<uint32_t, address, 8, 4>;\n   \
    \ using msk1 = FieldModel<uint32_t, address, 7, 1>;\n    using st = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    using su = FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 31,\
    \ 1> msk4;\n      BitFieldModel<uint32_t, 30, 1> wdsel;\n      BitFieldModel<uint32_t,\
    \ 28, 2> dt;\n      BitFieldModel<uint32_t, 24, 4> du;\n      BitFieldModel<uint32_t,\
    \ 23, 1> msk3;\n      BitFieldModel<uint32_t, 22, 1> pm;\n      BitFieldModel<uint32_t,\
    \ 20, 2> ht;\n      BitFieldModel<uint32_t, 16, 4> hu;\n      BitFieldModel<uint32_t,\
    \ 15, 1> msk2;\n      BitFieldModel<uint32_t, 12, 3> mnt;\n      BitFieldModel<uint32_t,\
    \ 8, 4> mnu;\n      BitFieldModel<uint32_t, 7, 1> msk1;\n      BitFieldModel<uint32_t,\
    \ 4, 3> st;\n      BitFieldModel<uint32_t, 0, 4> su;\n    };\n  };\n\npublic:\n\
    \  using alrmbr = AlrmbrReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class WprReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using key = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 8> key;\n    };\n  };\n\npublic:\n  using wpr = WprReg<BaseAddress + 0x0024>;\n\
    \nprivate:\n  template<unsigned int address>\n  class SsrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ss = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ss;\n    };\n  };\n\npublic:\n  using ssr = SsrReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class ShiftrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using add1s = FieldModel<uint32_t, address, 31,\
    \ 1>;\n    using subfs = FieldModel<uint32_t, address, 0, 15>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 31,\
    \ 1> add1s;\n      BitFieldModel<uint32_t, 0, 15> subfs;\n    };\n  };\n\npublic:\n\
    \  using shiftr = ShiftrReg<BaseAddress + 0x002C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class TstrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using alarmouttype = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using tsinsel = FieldModel<uint32_t, address, 17, 1>;\n    using tamp1insel\
    \ = FieldModel<uint32_t, address, 16, 1>;\n    using tampie = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using tamp1trg = FieldModel<uint32_t, address, 1, 1>;\n\
    \    using tamp1e = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 18, 1> alarmouttype;\n\
    \      BitFieldModel<uint32_t, 17, 1> tsinsel;\n      BitFieldModel<uint32_t,\
    \ 16, 1> tamp1insel;\n      BitFieldModel<uint32_t, 2, 1> tampie;\n      BitFieldModel<uint32_t,\
    \ 1, 1> tamp1trg;\n      BitFieldModel<uint32_t, 0, 1> tamp1e;\n    };\n  };\n\
    \npublic:\n  using tstr = TstrReg<BaseAddress + 0x0030>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class TsdrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using wdu = FieldModel<uint32_t, address, 13, 3>;\n    using mt\
    \ = FieldModel<uint32_t, address, 12, 1>;\n    using mu = FieldModel<uint32_t,\
    \ address, 8, 4>;\n    using dt = FieldModel<uint32_t, address, 4, 2>;\n    using\
    \ du = FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 13, 3> wdu;\n      BitFieldModel<uint32_t,\
    \ 12, 1> mt;\n      BitFieldModel<uint32_t, 8, 4> mu;\n      BitFieldModel<uint32_t,\
    \ 4, 2> dt;\n      BitFieldModel<uint32_t, 0, 4> du;\n    };\n  };\n\npublic:\n\
    \  using tsdr = TsdrReg<BaseAddress + 0x0034>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class TsssrReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using ss = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> ss;\n    };\n  };\n\npublic:\n  using tsssr = TsssrReg<BaseAddress + 0x0038>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CalrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using calp = FieldModel<uint32_t, address, 15,\
    \ 1>;\n    using calw8 = FieldModel<uint32_t, address, 14, 1>;\n    using calw16\
    \ = FieldModel<uint32_t, address, 13, 1>;\n    using calm = FieldModel<uint32_t,\
    \ address, 0, 9>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> calp;\n      BitFieldModel<uint32_t, 14,\
    \ 1> calw8;\n      BitFieldModel<uint32_t, 13, 1> calw16;\n      BitFieldModel<uint32_t,\
    \ 0, 9> calm;\n    };\n  };\n\npublic:\n  using calr = CalrReg<BaseAddress + 0x003C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class TafcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using alarmouttype = FieldModel<uint32_t, address,\
    \ 18, 1>;\n    using tsinsel = FieldModel<uint32_t, address, 17, 1>;\n    using\
    \ tamp1insel = FieldModel<uint32_t, address, 16, 1>;\n    using tamppudis = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using tampprch = FieldModel<uint32_t, address, 13, 2>;\n\
    \    using tampflt = FieldModel<uint32_t, address, 11, 2>;\n    using tampfreq\
    \ = FieldModel<uint32_t, address, 8, 3>;\n    using tampts = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using tamp2trg = FieldModel<uint32_t, address, 4, 1>;\n\
    \    using tamp2e = FieldModel<uint32_t, address, 3, 1>;\n    using tampie = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using tamp1trg = FieldModel<uint32_t, address, 1, 1>;\n\
    \    using tamp1e = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 18, 1> alarmouttype;\n\
    \      BitFieldModel<uint32_t, 17, 1> tsinsel;\n      BitFieldModel<uint32_t,\
    \ 16, 1> tamp1insel;\n      BitFieldModel<uint32_t, 15, 1> tamppudis;\n      BitFieldModel<uint32_t,\
    \ 13, 2> tampprch;\n      BitFieldModel<uint32_t, 11, 2> tampflt;\n      BitFieldModel<uint32_t,\
    \ 8, 3> tampfreq;\n      BitFieldModel<uint32_t, 7, 1> tampts;\n      BitFieldModel<uint32_t,\
    \ 4, 1> tamp2trg;\n      BitFieldModel<uint32_t, 3, 1> tamp2e;\n      BitFieldModel<uint32_t,\
    \ 2, 1> tampie;\n      BitFieldModel<uint32_t, 1, 1> tamp1trg;\n      BitFieldModel<uint32_t,\
    \ 0, 1> tamp1e;\n    };\n  };\n\npublic:\n  using tafcr = TafcrReg<BaseAddress\
    \ + 0x0040>;\n\nprivate:\n  template<unsigned int address>\n  class AlrmassrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using maskss\
    \ = FieldModel<uint32_t, address, 24, 4>;\n    using ss = FieldModel<uint32_t,\
    \ address, 0, 15>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 24, 4> maskss;\n      BitFieldModel<uint32_t, 0,\
    \ 15> ss;\n    };\n  };\n\npublic:\n  using alrmassr = AlrmassrReg<BaseAddress\
    \ + 0x0044>;\n\nprivate:\n  template<unsigned int address>\n  class AlrmbssrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using maskss\
    \ = FieldModel<uint32_t, address, 24, 4>;\n    using ss = FieldModel<uint32_t,\
    \ address, 0, 15>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 24, 4> maskss;\n      BitFieldModel<uint32_t, 0,\
    \ 15> ss;\n    };\n  };\n\npublic:\n  using alrmbssr = AlrmbssrReg<BaseAddress\
    \ + 0x0048>;\n\nprivate:\n  template<unsigned int address>\n  class Bkp0rReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using bkp = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> bkp;\n    };\n  };\n\npublic:\n  using bkp0r\
    \ = Bkp0rReg<BaseAddress + 0x0050>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Bkp1rReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> bkp;\n\
    \    };\n  };\n\npublic:\n  using bkp1r = Bkp1rReg<BaseAddress + 0x0054>;\n\n\
    private:\n  template<unsigned int address>\n  class Bkp2rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  using bkp2r = Bkp2rReg<BaseAddress +\
    \ 0x0058>;\n\nprivate:\n  template<unsigned int address>\n  class Bkp3rReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using bkp = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> bkp;\n    };\n  };\n\npublic:\n  using bkp3r\
    \ = Bkp3rReg<BaseAddress + 0x005C>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Bkp4rReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> bkp;\n\
    \    };\n  };\n\npublic:\n  using bkp4r = Bkp4rReg<BaseAddress + 0x0060>;\n\n\
    private:\n  template<unsigned int address>\n  class Bkp5rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  using bkp5r = Bkp5rReg<BaseAddress +\
    \ 0x0064>;\n\nprivate:\n  template<unsigned int address>\n  class Bkp6rReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using bkp = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> bkp;\n    };\n  };\n\npublic:\n  using bkp6r\
    \ = Bkp6rReg<BaseAddress + 0x0068>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Bkp7rReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> bkp;\n\
    \    };\n  };\n\npublic:\n  using bkp7r = Bkp7rReg<BaseAddress + 0x006C>;\n\n\
    private:\n  template<unsigned int address>\n  class Bkp8rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  using bkp8r = Bkp8rReg<BaseAddress +\
    \ 0x0070>;\n\nprivate:\n  template<unsigned int address>\n  class Bkp9rReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using bkp = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> bkp;\n    };\n  };\n\npublic:\n  using bkp9r\
    \ = Bkp9rReg<BaseAddress + 0x0074>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Bkp10rReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> bkp;\n\
    \    };\n  };\n\npublic:\n  using bkp10r = Bkp10rReg<BaseAddress + 0x0078>;\n\n\
    private:\n  template<unsigned int address>\n  class Bkp11rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  using bkp11r = Bkp11rReg<BaseAddress\
    \ + 0x007C>;\n\nprivate:\n  template<unsigned int address>\n  class Bkp12rReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using bkp = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> bkp;\n    };\n  };\n\npublic:\n  using bkp12r\
    \ = Bkp12rReg<BaseAddress + 0x0080>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Bkp13rReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> bkp;\n\
    \    };\n  };\n\npublic:\n  using bkp13r = Bkp13rReg<BaseAddress + 0x0084>;\n\n\
    private:\n  template<unsigned int address>\n  class Bkp14rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  using bkp14r = Bkp14rReg<BaseAddress\
    \ + 0x0088>;\n\nprivate:\n  template<unsigned int address>\n  class Bkp15rReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using bkp = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> bkp;\n    };\n  };\n\npublic:\n  using bkp15r\
    \ = Bkp15rReg<BaseAddress + 0x008C>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Bkp16rReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> bkp;\n\
    \    };\n  };\n\npublic:\n  using bkp16r = Bkp16rReg<BaseAddress + 0x0090>;\n\n\
    private:\n  template<unsigned int address>\n  class Bkp17rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  using bkp17r = Bkp17rReg<BaseAddress\
    \ + 0x0094>;\n\nprivate:\n  template<unsigned int address>\n  class Bkp18rReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using bkp = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> bkp;\n    };\n  };\n\npublic:\n  using bkp18r\
    \ = Bkp18rReg<BaseAddress + 0x0098>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Bkp19rReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> bkp;\n\
    \    };\n  };\n\npublic:\n  using bkp19r = Bkp19rReg<BaseAddress + 0x009C>;\n\n\
    private:\n  template<unsigned int address, unsigned int bankOffset>\n  class AlrmxrBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    using msk4 = FieldModel<uint32_t, address, 31, 1, bankOffset>;\n    using\
    \ wdsel = FieldModel<uint32_t, address, 30, 1, bankOffset>;\n    using dt = FieldModel<uint32_t,\
    \ address, 28, 2, bankOffset>;\n    using du = FieldModel<uint32_t, address, 24,\
    \ 4, bankOffset>;\n    using msk3 = FieldModel<uint32_t, address, 23, 1, bankOffset>;\n\
    \    using pm = FieldModel<uint32_t, address, 22, 1, bankOffset>;\n    using ht\
    \ = FieldModel<uint32_t, address, 20, 2, bankOffset>;\n    using hu = FieldModel<uint32_t,\
    \ address, 16, 4, bankOffset>;\n    using msk2 = FieldModel<uint32_t, address,\
    \ 15, 1, bankOffset>;\n    using mnt = FieldModel<uint32_t, address, 12, 3, bankOffset>;\n\
    \    using mnu = FieldModel<uint32_t, address, 8, 4, bankOffset>;\n    using msk1\
    \ = FieldModel<uint32_t, address, 7, 1, bankOffset>;\n    using st = FieldModel<uint32_t,\
    \ address, 4, 3, bankOffset>;\n    using su = FieldModel<uint32_t, address, 0,\
    \ 4, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 31, 1> msk4;\n      BitFieldModel<uint32_t, 30,\
    \ 1> wdsel;\n      BitFieldModel<uint32_t, 28, 2> dt;\n      BitFieldModel<uint32_t,\
    \ 24, 4> du;\n      BitFieldModel<uint32_t, 23, 1> msk3;\n      BitFieldModel<uint32_t,\
    \ 22, 1> pm;\n      BitFieldModel<uint32_t, 20, 2> ht;\n      BitFieldModel<uint32_t,\
    \ 16, 4> hu;\n      BitFieldModel<uint32_t, 15, 1> msk2;\n      BitFieldModel<uint32_t,\
    \ 12, 3> mnt;\n      BitFieldModel<uint32_t, 8, 4> mnu;\n      BitFieldModel<uint32_t,\
    \ 7, 1> msk1;\n      BitFieldModel<uint32_t, 4, 3> st;\n      BitFieldModel<uint32_t,\
    \ 0, 4> su;\n    };\n  };\n\npublic:\n  using alrmxr = AlrmxrBankReg<BaseAddress\
    \ + 0x001C, 0x0004>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class AlrmxssrBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using maskss = FieldModel<uint32_t, address,\
    \ 24, 4, bankOffset>;\n    using ss = FieldModel<uint32_t, address, 0, 15, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 4> maskss;\n      BitFieldModel<uint32_t, 0, 15> ss;\n    };\n  };\n\npublic:\n\
    \  using alrmxssr = AlrmxssrBankReg<BaseAddress + 0x0044, 0x0004>;\n\nprivate:\n\
    \  template<unsigned int address, unsigned int bankOffset>\n  class BkpxrBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    using bkp = FieldModel<uint32_t, address, 0, 32, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 32> bkp;\n    };\n  };\n\npublic:\n  using bkpxr = BkpxrBankReg<BaseAddress\
    \ + 0x0050, 0x0004>;\n};\n\n}\n\n#endif /* DRAL_STM32F446_RTC_H */\n"
  name: RTC
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_UART4_H\n#define DRAL_STM32F446_UART4_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass uart4\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40004C00;\n\nprivate:\n\
    \  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using lbd = FieldModel<uint32_t, address, 8, 1>;\n\
    \    using txe = FieldModel<uint32_t, address, 7, 1>;\n    using tc = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using rxne = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using idle = FieldModel<uint32_t, address, 4, 1>;\n    using ore = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using nf = FieldModel<uint32_t, address, 2, 1>;\n    using\
    \ fe = FieldModel<uint32_t, address, 1, 1>;\n    using pe = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 8, 1> lbd;\n      BitFieldModel<uint32_t, 7, 1>\
    \ txe;\n      BitFieldModel<uint32_t, 6, 1> tc;\n      BitFieldModel<uint32_t,\
    \ 5, 1> rxne;\n      BitFieldModel<uint32_t, 4, 1> idle;\n      BitFieldModel<uint32_t,\
    \ 3, 1> ore;\n      BitFieldModel<uint32_t, 2, 1> nf;\n      BitFieldModel<uint32_t,\
    \ 1, 1> fe;\n      BitFieldModel<uint32_t, 0, 1> pe;\n    };\n  };\n\npublic:\n\
    \  using sr = SrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class DrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using dr = FieldModel<uint32_t, address, 0, 9>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 9> dr;\n    };\n\
    \  };\n\npublic:\n  using dr = DrReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class BrrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using div_mantissa = FieldModel<uint32_t, address, 4, 12>;\n \
    \   using div_fraction = FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n \
    \   union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 4,\
    \ 12> div_mantissa;\n      BitFieldModel<uint32_t, 0, 4> div_fraction;\n    };\n\
    \  };\n\npublic:\n  using brr = BrrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using over8 = FieldModel<uint32_t, address, 15, 1>;\n    using\
    \ ue = FieldModel<uint32_t, address, 13, 1>;\n    using m = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using wake = FieldModel<uint32_t, address, 11, 1>;\n \
    \   using pce = FieldModel<uint32_t, address, 10, 1>;\n    using ps = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using peie = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using txeie = FieldModel<uint32_t, address, 7, 1>;\n    using tcie = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using rxneie = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using idleie = FieldModel<uint32_t, address, 4, 1>;\n    using te = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using re = FieldModel<uint32_t, address, 2, 1>;\n    using\
    \ rwu = FieldModel<uint32_t, address, 1, 1>;\n    using sbk = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> over8;\n      BitFieldModel<uint32_t, 13,\
    \ 1> ue;\n      BitFieldModel<uint32_t, 12, 1> m;\n      BitFieldModel<uint32_t,\
    \ 11, 1> wake;\n      BitFieldModel<uint32_t, 10, 1> pce;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ps;\n      BitFieldModel<uint32_t, 8, 1> peie;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txeie;\n      BitFieldModel<uint32_t, 6, 1> tcie;\n      BitFieldModel<uint32_t,\
    \ 5, 1> rxneie;\n      BitFieldModel<uint32_t, 4, 1> idleie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> te;\n      BitFieldModel<uint32_t, 2, 1> re;\n      BitFieldModel<uint32_t,\
    \ 1, 1> rwu;\n      BitFieldModel<uint32_t, 0, 1> sbk;\n    };\n  };\n\npublic:\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using linen = FieldModel<uint32_t, address, 14, 1>;\n    using\
    \ stop = FieldModel<uint32_t, address, 12, 2>;\n    using lbdie = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using lbdl = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using add = FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 14, 1> linen;\n \
    \     BitFieldModel<uint32_t, 12, 2> stop;\n      BitFieldModel<uint32_t, 6, 1>\
    \ lbdie;\n      BitFieldModel<uint32_t, 5, 1> lbdl;\n      BitFieldModel<uint32_t,\
    \ 0, 4> add;\n    };\n  };\n\npublic:\n  using cr2 = Cr2Reg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Cr3Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using onebit = FieldModel<uint32_t, address, 11,\
    \ 1>;\n    using ctsie = FieldModel<uint32_t, address, 10, 1>;\n    using ctse\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    using rtse = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using dmat = FieldModel<uint32_t, address, 7, 1>;\n   \
    \ using dmar = FieldModel<uint32_t, address, 6, 1>;\n    using hdsel = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using irlp = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using iren = FieldModel<uint32_t, address, 1, 1>;\n    using eie = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 11, 1> onebit;\n      BitFieldModel<uint32_t, 10,\
    \ 1> ctsie;\n      BitFieldModel<uint32_t, 9, 1> ctse;\n      BitFieldModel<uint32_t,\
    \ 8, 1> rtse;\n      BitFieldModel<uint32_t, 7, 1> dmat;\n      BitFieldModel<uint32_t,\
    \ 6, 1> dmar;\n      BitFieldModel<uint32_t, 3, 1> hdsel;\n      BitFieldModel<uint32_t,\
    \ 2, 1> irlp;\n      BitFieldModel<uint32_t, 1, 1> iren;\n      BitFieldModel<uint32_t,\
    \ 0, 1> eie;\n    };\n  };\n\npublic:\n  using cr3 = Cr3Reg<BaseAddress + 0x0014>;\n\
    \n\n};\n\n}\n\n#endif /* DRAL_STM32F446_UART4_H */\n"
  name: UART4
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_UART5_H\n#define DRAL_STM32F446_UART5_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass uart5\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40005000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using lbd = FieldModel<uint32_t, address, 8, 1>;\n\
    \    using txe = FieldModel<uint32_t, address, 7, 1>;\n    using tc = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using rxne = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using idle = FieldModel<uint32_t, address, 4, 1>;\n    using ore = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using nf = FieldModel<uint32_t, address, 2, 1>;\n    using\
    \ fe = FieldModel<uint32_t, address, 1, 1>;\n    using pe = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 8, 1> lbd;\n      BitFieldModel<uint32_t, 7, 1>\
    \ txe;\n      BitFieldModel<uint32_t, 6, 1> tc;\n      BitFieldModel<uint32_t,\
    \ 5, 1> rxne;\n      BitFieldModel<uint32_t, 4, 1> idle;\n      BitFieldModel<uint32_t,\
    \ 3, 1> ore;\n      BitFieldModel<uint32_t, 2, 1> nf;\n      BitFieldModel<uint32_t,\
    \ 1, 1> fe;\n      BitFieldModel<uint32_t, 0, 1> pe;\n    };\n  };\n\npublic:\n\
    \  using sr = SrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class DrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using dr = FieldModel<uint32_t, address, 0, 9>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 9> dr;\n    };\n\
    \  };\n\npublic:\n  using dr = DrReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class BrrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using div_mantissa = FieldModel<uint32_t, address, 4, 12>;\n \
    \   using div_fraction = FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n \
    \   union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 4,\
    \ 12> div_mantissa;\n      BitFieldModel<uint32_t, 0, 4> div_fraction;\n    };\n\
    \  };\n\npublic:\n  using brr = BrrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using over8 = FieldModel<uint32_t, address, 15, 1>;\n    using\
    \ ue = FieldModel<uint32_t, address, 13, 1>;\n    using m = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using wake = FieldModel<uint32_t, address, 11, 1>;\n \
    \   using pce = FieldModel<uint32_t, address, 10, 1>;\n    using ps = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using peie = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using txeie = FieldModel<uint32_t, address, 7, 1>;\n    using tcie = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using rxneie = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using idleie = FieldModel<uint32_t, address, 4, 1>;\n    using te = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using re = FieldModel<uint32_t, address, 2, 1>;\n    using\
    \ rwu = FieldModel<uint32_t, address, 1, 1>;\n    using sbk = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> over8;\n      BitFieldModel<uint32_t, 13,\
    \ 1> ue;\n      BitFieldModel<uint32_t, 12, 1> m;\n      BitFieldModel<uint32_t,\
    \ 11, 1> wake;\n      BitFieldModel<uint32_t, 10, 1> pce;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ps;\n      BitFieldModel<uint32_t, 8, 1> peie;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txeie;\n      BitFieldModel<uint32_t, 6, 1> tcie;\n      BitFieldModel<uint32_t,\
    \ 5, 1> rxneie;\n      BitFieldModel<uint32_t, 4, 1> idleie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> te;\n      BitFieldModel<uint32_t, 2, 1> re;\n      BitFieldModel<uint32_t,\
    \ 1, 1> rwu;\n      BitFieldModel<uint32_t, 0, 1> sbk;\n    };\n  };\n\npublic:\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using linen = FieldModel<uint32_t, address, 14, 1>;\n    using\
    \ stop = FieldModel<uint32_t, address, 12, 2>;\n    using lbdie = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using lbdl = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using add = FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 14, 1> linen;\n \
    \     BitFieldModel<uint32_t, 12, 2> stop;\n      BitFieldModel<uint32_t, 6, 1>\
    \ lbdie;\n      BitFieldModel<uint32_t, 5, 1> lbdl;\n      BitFieldModel<uint32_t,\
    \ 0, 4> add;\n    };\n  };\n\npublic:\n  using cr2 = Cr2Reg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Cr3Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using onebit = FieldModel<uint32_t, address, 11,\
    \ 1>;\n    using ctsie = FieldModel<uint32_t, address, 10, 1>;\n    using ctse\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    using rtse = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using dmat = FieldModel<uint32_t, address, 7, 1>;\n   \
    \ using dmar = FieldModel<uint32_t, address, 6, 1>;\n    using hdsel = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using irlp = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using iren = FieldModel<uint32_t, address, 1, 1>;\n    using eie = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 11, 1> onebit;\n      BitFieldModel<uint32_t, 10,\
    \ 1> ctsie;\n      BitFieldModel<uint32_t, 9, 1> ctse;\n      BitFieldModel<uint32_t,\
    \ 8, 1> rtse;\n      BitFieldModel<uint32_t, 7, 1> dmat;\n      BitFieldModel<uint32_t,\
    \ 6, 1> dmar;\n      BitFieldModel<uint32_t, 3, 1> hdsel;\n      BitFieldModel<uint32_t,\
    \ 2, 1> irlp;\n      BitFieldModel<uint32_t, 1, 1> iren;\n      BitFieldModel<uint32_t,\
    \ 0, 1> eie;\n    };\n  };\n\npublic:\n  using cr3 = Cr3Reg<BaseAddress + 0x0014>;\n\
    \n\n};\n\n}\n\n#endif /* DRAL_STM32F446_UART5_H */\n"
  name: UART5
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_C_ADC_H\n#define DRAL_STM32F446_C_ADC_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass c_adc\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40012300;\n\nprivate:\n\
    \  template<unsigned int address>\n  class CsrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ovr3 = FieldModel<uint32_t, address, 21,\
    \ 1>;\n    using strt3 = FieldModel<uint32_t, address, 20, 1>;\n    using jstrt3\
    \ = FieldModel<uint32_t, address, 19, 1>;\n    using jeoc3 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    using eoc3 = FieldModel<uint32_t, address, 17, 1>;\n \
    \   using awd3 = FieldModel<uint32_t, address, 16, 1>;\n    using ovr2 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using strt2 = FieldModel<uint32_t, address, 12, 1>;\n\
    \    using jstrt2 = FieldModel<uint32_t, address, 11, 1>;\n    using jeoc2 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using eoc2 = FieldModel<uint32_t, address, 9, 1>;\n  \
    \  using awd2 = FieldModel<uint32_t, address, 8, 1>;\n    using ovr1 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using strt1 = FieldModel<uint32_t, address, 4, 1>;\n  \
    \  using jstrt1 = FieldModel<uint32_t, address, 3, 1>;\n    using jeoc1 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using eoc1 = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using awd1 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 21, 1> ovr3;\n  \
    \    BitFieldModel<uint32_t, 20, 1> strt3;\n      BitFieldModel<uint32_t, 19,\
    \ 1> jstrt3;\n      BitFieldModel<uint32_t, 18, 1> jeoc3;\n      BitFieldModel<uint32_t,\
    \ 17, 1> eoc3;\n      BitFieldModel<uint32_t, 16, 1> awd3;\n      BitFieldModel<uint32_t,\
    \ 13, 1> ovr2;\n      BitFieldModel<uint32_t, 12, 1> strt2;\n      BitFieldModel<uint32_t,\
    \ 11, 1> jstrt2;\n      BitFieldModel<uint32_t, 10, 1> jeoc2;\n      BitFieldModel<uint32_t,\
    \ 9, 1> eoc2;\n      BitFieldModel<uint32_t, 8, 1> awd2;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ovr1;\n      BitFieldModel<uint32_t, 4, 1> strt1;\n      BitFieldModel<uint32_t,\
    \ 3, 1> jstrt1;\n      BitFieldModel<uint32_t, 2, 1> jeoc1;\n      BitFieldModel<uint32_t,\
    \ 1, 1> eoc1;\n      BitFieldModel<uint32_t, 0, 1> awd1;\n    };\n  };\n\npublic:\n\
    \  using csr = CsrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CcrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using tsvrefe = FieldModel<uint32_t, address, 23, 1>;\n    using\
    \ vbate = FieldModel<uint32_t, address, 22, 1>;\n    using adcpre = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    using dma = FieldModel<uint32_t, address, 14, 2>;\n  \
    \  using dds = FieldModel<uint32_t, address, 13, 1>;\n    using delay = FieldModel<uint32_t,\
    \ address, 8, 4>;\n    using mult = FieldModel<uint32_t, address, 0, 5>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 23, 1> tsvrefe;\n      BitFieldModel<uint32_t, 22, 1> vbate;\n      BitFieldModel<uint32_t,\
    \ 16, 2> adcpre;\n      BitFieldModel<uint32_t, 14, 2> dma;\n      BitFieldModel<uint32_t,\
    \ 13, 1> dds;\n      BitFieldModel<uint32_t, 8, 4> delay;\n      BitFieldModel<uint32_t,\
    \ 0, 5> mult;\n    };\n  };\n\npublic:\n  using ccr = CcrReg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CdrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using data2 = FieldModel<uint32_t, address, 16,\
    \ 16>;\n    using data1 = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16,\
    \ 16> data2;\n      BitFieldModel<uint32_t, 0, 16> data1;\n    };\n  };\n\npublic:\n\
    \  using cdr = CdrReg<BaseAddress + 0x0008>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_C_ADC_H\
    \ */\n"
  name: C_ADC
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_TIM1_H\n#define DRAL_STM32F446_TIM1_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass tim1\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40010000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ckd = FieldModel<uint32_t, address, 8, 2>;\n\
    \    using arpe = FieldModel<uint32_t, address, 7, 1>;\n    using cms = FieldModel<uint32_t,\
    \ address, 5, 2>;\n    using dir = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ opm = FieldModel<uint32_t, address, 3, 1>;\n    using urs = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using udis = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using cen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 2> ckd;\n    \
    \  BitFieldModel<uint32_t, 7, 1> arpe;\n      BitFieldModel<uint32_t, 5, 2> cms;\n\
    \      BitFieldModel<uint32_t, 4, 1> dir;\n      BitFieldModel<uint32_t, 3, 1>\
    \ opm;\n      BitFieldModel<uint32_t, 2, 1> urs;\n      BitFieldModel<uint32_t,\
    \ 1, 1> udis;\n      BitFieldModel<uint32_t, 0, 1> cen;\n    };\n  };\n\npublic:\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ois4 = FieldModel<uint32_t, address, 14, 1>;\n    using\
    \ ois3n = FieldModel<uint32_t, address, 13, 1>;\n    using ois3 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using ois2n = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using ois2 = FieldModel<uint32_t, address, 10, 1>;\n    using ois1n = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using ois1 = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using ti1s = FieldModel<uint32_t, address, 7, 1>;\n    using mms = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    using ccds = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using ccus = FieldModel<uint32_t, address, 2, 1>;\n    using ccpc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 14, 1> ois4;\n      BitFieldModel<uint32_t, 13,\
    \ 1> ois3n;\n      BitFieldModel<uint32_t, 12, 1> ois3;\n      BitFieldModel<uint32_t,\
    \ 11, 1> ois2n;\n      BitFieldModel<uint32_t, 10, 1> ois2;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ois1n;\n      BitFieldModel<uint32_t, 8, 1> ois1;\n      BitFieldModel<uint32_t,\
    \ 7, 1> ti1s;\n      BitFieldModel<uint32_t, 4, 3> mms;\n      BitFieldModel<uint32_t,\
    \ 3, 1> ccds;\n      BitFieldModel<uint32_t, 2, 1> ccus;\n      BitFieldModel<uint32_t,\
    \ 0, 1> ccpc;\n    };\n  };\n\npublic:\n  using cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class SmcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using etp = FieldModel<uint32_t, address, 15,\
    \ 1>;\n    using ece = FieldModel<uint32_t, address, 14, 1>;\n    using etps =\
    \ FieldModel<uint32_t, address, 12, 2>;\n    using etf = FieldModel<uint32_t,\
    \ address, 8, 4>;\n    using msm = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ ts = FieldModel<uint32_t, address, 4, 3>;\n    using sms = FieldModel<uint32_t,\
    \ address, 0, 3>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> etp;\n      BitFieldModel<uint32_t, 14,\
    \ 1> ece;\n      BitFieldModel<uint32_t, 12, 2> etps;\n      BitFieldModel<uint32_t,\
    \ 8, 4> etf;\n      BitFieldModel<uint32_t, 7, 1> msm;\n      BitFieldModel<uint32_t,\
    \ 4, 3> ts;\n      BitFieldModel<uint32_t, 0, 3> sms;\n    };\n  };\n\npublic:\n\
    \  using smcr = SmcrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DierReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using tde = FieldModel<uint32_t, address, 14, 1>;\n    using comde\
    \ = FieldModel<uint32_t, address, 13, 1>;\n    using cc4de = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using cc3de = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using cc2de = FieldModel<uint32_t, address, 10, 1>;\n    using cc1de = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using ude = FieldModel<uint32_t, address, 8, 1>;\n    using\
    \ tie = FieldModel<uint32_t, address, 6, 1>;\n    using cc4ie = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using cc3ie = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using cc2ie = FieldModel<uint32_t, address, 2, 1>;\n    using cc1ie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using uie = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ bie = FieldModel<uint32_t, address, 7, 1>;\n    using comie = FieldModel<uint32_t,\
    \ address, 5, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 14, 1> tde;\n      BitFieldModel<uint32_t, 13,\
    \ 1> comde;\n      BitFieldModel<uint32_t, 12, 1> cc4de;\n      BitFieldModel<uint32_t,\
    \ 11, 1> cc3de;\n      BitFieldModel<uint32_t, 10, 1> cc2de;\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc1de;\n      BitFieldModel<uint32_t, 8, 1> ude;\n      BitFieldModel<uint32_t,\
    \ 6, 1> tie;\n      BitFieldModel<uint32_t, 4, 1> cc4ie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3ie;\n      BitFieldModel<uint32_t, 2, 1> cc2ie;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1ie;\n      BitFieldModel<uint32_t, 0, 1> uie;\n      BitFieldModel<uint32_t,\
    \ 7, 1> bie;\n      BitFieldModel<uint32_t, 5, 1> comie;\n    };\n  };\n\npublic:\n\
    \  using dier = DierReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class SrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using cc4of = FieldModel<uint32_t, address, 12, 1>;\n    using\
    \ cc3of = FieldModel<uint32_t, address, 11, 1>;\n    using cc2of = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using cc1of = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using bif = FieldModel<uint32_t, address, 7, 1>;\n    using tif = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using comif = FieldModel<uint32_t, address, 5, 1>;\n  \
    \  using cc4if = FieldModel<uint32_t, address, 4, 1>;\n    using cc3if = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using cc2if = FieldModel<uint32_t, address, 2, 1>;\n  \
    \  using cc1if = FieldModel<uint32_t, address, 1, 1>;\n    using uif = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 12, 1> cc4of;\n      BitFieldModel<uint32_t, 11,\
    \ 1> cc3of;\n      BitFieldModel<uint32_t, 10, 1> cc2of;\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc1of;\n      BitFieldModel<uint32_t, 7, 1> bif;\n      BitFieldModel<uint32_t,\
    \ 6, 1> tif;\n      BitFieldModel<uint32_t, 5, 1> comif;\n      BitFieldModel<uint32_t,\
    \ 4, 1> cc4if;\n      BitFieldModel<uint32_t, 3, 1> cc3if;\n      BitFieldModel<uint32_t,\
    \ 2, 1> cc2if;\n      BitFieldModel<uint32_t, 1, 1> cc1if;\n      BitFieldModel<uint32_t,\
    \ 0, 1> uif;\n    };\n  };\n\npublic:\n  using sr = SrReg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class EgrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using bg = FieldModel<uint32_t, address, 7, 1>;\n\
    \    using tg = FieldModel<uint32_t, address, 6, 1>;\n    using comg = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using cc4g = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ using cc3g = FieldModel<uint32_t, address, 3, 1>;\n    using cc2g = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc1g = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using ug = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 7, 1> bg;\n     \
    \ BitFieldModel<uint32_t, 6, 1> tg;\n      BitFieldModel<uint32_t, 5, 1> comg;\n\
    \      BitFieldModel<uint32_t, 4, 1> cc4g;\n      BitFieldModel<uint32_t, 3, 1>\
    \ cc3g;\n      BitFieldModel<uint32_t, 2, 1> cc2g;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1g;\n      BitFieldModel<uint32_t, 0, 1> ug;\n    };\n  };\n\npublic:\n\
    \  using egr = EgrReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr1_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using oc2ce = FieldModel<uint32_t, address, 15, 1>;\n   \
    \ using oc2m = FieldModel<uint32_t, address, 12, 3>;\n    using oc2pe = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using oc2fe = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using cc2s = FieldModel<uint32_t, address, 8, 2>;\n    using oc1ce = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using oc1m = FieldModel<uint32_t, address, 4, 3>;\n   \
    \ using oc1pe = FieldModel<uint32_t, address, 3, 1>;\n    using oc1fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 15, 1> oc2ce;\n      BitFieldModel<uint32_t, 12, 3> oc2m;\n      BitFieldModel<uint32_t,\
    \ 11, 1> oc2pe;\n      BitFieldModel<uint32_t, 10, 1> oc2fe;\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc2s;\n      BitFieldModel<uint32_t, 7, 1> oc1ce;\n      BitFieldModel<uint32_t,\
    \ 4, 3> oc1m;\n      BitFieldModel<uint32_t, 3, 1> oc1pe;\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc1fe;\n      BitFieldModel<uint32_t, 0, 2> cc1s;\n    };\n  };\n\npublic:\n\
    \  using ccmr1_output = Ccmr1_outputReg<BaseAddress + 0x0018>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Ccmr1_inputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ic2f = FieldModel<uint32_t, address, 12,\
    \ 4>;\n    using ic2pcs = FieldModel<uint32_t, address, 10, 2>;\n    using cc2s\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    using ic1f = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using icpcs = FieldModel<uint32_t, address, 2, 2>;\n  \
    \  using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 12, 4> ic2f;\n  \
    \    BitFieldModel<uint32_t, 10, 2> ic2pcs;\n      BitFieldModel<uint32_t, 8,\
    \ 2> cc2s;\n      BitFieldModel<uint32_t, 4, 4> ic1f;\n      BitFieldModel<uint32_t,\
    \ 2, 2> icpcs;\n      BitFieldModel<uint32_t, 0, 2> cc1s;\n    };\n  };\n\npublic:\n\
    \  using ccmr1_input = Ccmr1_inputReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr2_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using oc4ce = FieldModel<uint32_t, address, 15, 1>;\n   \
    \ using oc4m = FieldModel<uint32_t, address, 12, 3>;\n    using oc4pe = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using oc4fe = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using cc4s = FieldModel<uint32_t, address, 8, 2>;\n    using oc3ce = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using oc3m = FieldModel<uint32_t, address, 4, 3>;\n   \
    \ using oc3pe = FieldModel<uint32_t, address, 3, 1>;\n    using oc3fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc3s = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 15, 1> oc4ce;\n      BitFieldModel<uint32_t, 12, 3> oc4m;\n      BitFieldModel<uint32_t,\
    \ 11, 1> oc4pe;\n      BitFieldModel<uint32_t, 10, 1> oc4fe;\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc4s;\n      BitFieldModel<uint32_t, 7, 1> oc3ce;\n      BitFieldModel<uint32_t,\
    \ 4, 3> oc3m;\n      BitFieldModel<uint32_t, 3, 1> oc3pe;\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc3fe;\n      BitFieldModel<uint32_t, 0, 2> cc3s;\n    };\n  };\n\npublic:\n\
    \  using ccmr2_output = Ccmr2_outputReg<BaseAddress + 0x001C>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Ccmr2_inputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ic4f = FieldModel<uint32_t, address, 12,\
    \ 4>;\n    using ic4psc = FieldModel<uint32_t, address, 10, 2>;\n    using cc4s\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    using ic3f = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using ic3psc = FieldModel<uint32_t, address, 2, 2>;\n \
    \   using cc3s = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 12, 4> ic4f;\n\
    \      BitFieldModel<uint32_t, 10, 2> ic4psc;\n      BitFieldModel<uint32_t, 8,\
    \ 2> cc4s;\n      BitFieldModel<uint32_t, 4, 4> ic3f;\n      BitFieldModel<uint32_t,\
    \ 2, 2> ic3psc;\n      BitFieldModel<uint32_t, 0, 2> cc3s;\n    };\n  };\n\npublic:\n\
    \  using ccmr2_input = Ccmr2_inputReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CcerReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using cc4p = FieldModel<uint32_t, address, 13, 1>;\n    using\
    \ cc4e = FieldModel<uint32_t, address, 12, 1>;\n    using cc3np = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using cc3ne = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using cc3p = FieldModel<uint32_t, address, 9, 1>;\n    using cc3e = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using cc2np = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using cc2ne = FieldModel<uint32_t, address, 6, 1>;\n    using cc2p = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using cc2e = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ using cc1np = FieldModel<uint32_t, address, 3, 1>;\n    using cc1ne = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc1p = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using cc1e = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 13, 1> cc4p;\n  \
    \    BitFieldModel<uint32_t, 12, 1> cc4e;\n      BitFieldModel<uint32_t, 11, 1>\
    \ cc3np;\n      BitFieldModel<uint32_t, 10, 1> cc3ne;\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc3p;\n      BitFieldModel<uint32_t, 8, 1> cc3e;\n      BitFieldModel<uint32_t,\
    \ 7, 1> cc2np;\n      BitFieldModel<uint32_t, 6, 1> cc2ne;\n      BitFieldModel<uint32_t,\
    \ 5, 1> cc2p;\n      BitFieldModel<uint32_t, 4, 1> cc2e;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc1np;\n      BitFieldModel<uint32_t, 2, 1> cc1ne;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1p;\n      BitFieldModel<uint32_t, 0, 1> cc1e;\n    };\n  };\n\npublic:\n\
    \  using ccer = CcerReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CntReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using cnt = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> cnt;\n    };\n  };\n\npublic:\n  using cnt = CntReg<BaseAddress + 0x0024>;\n\
    \nprivate:\n  template<unsigned int address>\n  class PscReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using psc = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> psc;\n    };\n  };\n\npublic:\n  using psc = PscReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class ArrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using arr = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> arr;\n    };\n  };\n\npublic:\n  using arr = ArrReg<BaseAddress + 0x002C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Ccr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ccr1 = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr1;\n    };\n  };\n\npublic:\n  using ccr1 = Ccr1Reg<BaseAddress +\
    \ 0x0034>;\n\nprivate:\n  template<unsigned int address>\n  class Ccr2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using ccr2 = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> ccr2;\n    };\n  };\n\npublic:\n  using\
    \ ccr2 = Ccr2Reg<BaseAddress + 0x0038>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Ccr3Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   using ccr3 = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 16> ccr3;\n\
    \    };\n  };\n\npublic:\n  using ccr3 = Ccr3Reg<BaseAddress + 0x003C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Ccr4Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ccr4 = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr4;\n    };\n  };\n\npublic:\n  using ccr4 = Ccr4Reg<BaseAddress +\
    \ 0x0040>;\n\nprivate:\n  template<unsigned int address>\n  class DcrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using dbl = FieldModel<uint32_t,\
    \ address, 8, 5>;\n    using dba = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8,\
    \ 5> dbl;\n      BitFieldModel<uint32_t, 0, 5> dba;\n    };\n  };\n\npublic:\n\
    \  using dcr = DcrReg<BaseAddress + 0x0048>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DmarReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using dmab = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> dmab;\n    };\n  };\n\npublic:\n  using dmar = DmarReg<BaseAddress + 0x004C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class RcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using rep = FieldModel<uint32_t, address, 0, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> rep;\n    };\n  };\n\npublic:\n  using rcr = RcrReg<BaseAddress + 0x0030>;\n\
    \nprivate:\n  template<unsigned int address>\n  class BdtrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using moe = FieldModel<uint32_t, address, 15,\
    \ 1>;\n    using aoe = FieldModel<uint32_t, address, 14, 1>;\n    using bkp =\
    \ FieldModel<uint32_t, address, 13, 1>;\n    using bke = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using ossr = FieldModel<uint32_t, address, 11, 1>;\n \
    \   using ossi = FieldModel<uint32_t, address, 10, 1>;\n    using lock = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    using dtg = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 15,\
    \ 1> moe;\n      BitFieldModel<uint32_t, 14, 1> aoe;\n      BitFieldModel<uint32_t,\
    \ 13, 1> bkp;\n      BitFieldModel<uint32_t, 12, 1> bke;\n      BitFieldModel<uint32_t,\
    \ 11, 1> ossr;\n      BitFieldModel<uint32_t, 10, 1> ossi;\n      BitFieldModel<uint32_t,\
    \ 8, 2> lock;\n      BitFieldModel<uint32_t, 0, 8> dtg;\n    };\n  };\n\npublic:\n\
    \  using bdtr = BdtrReg<BaseAddress + 0x0044>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_TIM1_H\
    \ */\n"
  name: TIM1
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_TIM8_H\n#define DRAL_STM32F446_TIM8_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass tim8\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40010400;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ckd = FieldModel<uint32_t, address, 8, 2>;\n\
    \    using arpe = FieldModel<uint32_t, address, 7, 1>;\n    using cms = FieldModel<uint32_t,\
    \ address, 5, 2>;\n    using dir = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ opm = FieldModel<uint32_t, address, 3, 1>;\n    using urs = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using udis = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using cen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 2> ckd;\n    \
    \  BitFieldModel<uint32_t, 7, 1> arpe;\n      BitFieldModel<uint32_t, 5, 2> cms;\n\
    \      BitFieldModel<uint32_t, 4, 1> dir;\n      BitFieldModel<uint32_t, 3, 1>\
    \ opm;\n      BitFieldModel<uint32_t, 2, 1> urs;\n      BitFieldModel<uint32_t,\
    \ 1, 1> udis;\n      BitFieldModel<uint32_t, 0, 1> cen;\n    };\n  };\n\npublic:\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ois4 = FieldModel<uint32_t, address, 14, 1>;\n    using\
    \ ois3n = FieldModel<uint32_t, address, 13, 1>;\n    using ois3 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using ois2n = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using ois2 = FieldModel<uint32_t, address, 10, 1>;\n    using ois1n = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using ois1 = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using ti1s = FieldModel<uint32_t, address, 7, 1>;\n    using mms = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    using ccds = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using ccus = FieldModel<uint32_t, address, 2, 1>;\n    using ccpc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 14, 1> ois4;\n      BitFieldModel<uint32_t, 13,\
    \ 1> ois3n;\n      BitFieldModel<uint32_t, 12, 1> ois3;\n      BitFieldModel<uint32_t,\
    \ 11, 1> ois2n;\n      BitFieldModel<uint32_t, 10, 1> ois2;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ois1n;\n      BitFieldModel<uint32_t, 8, 1> ois1;\n      BitFieldModel<uint32_t,\
    \ 7, 1> ti1s;\n      BitFieldModel<uint32_t, 4, 3> mms;\n      BitFieldModel<uint32_t,\
    \ 3, 1> ccds;\n      BitFieldModel<uint32_t, 2, 1> ccus;\n      BitFieldModel<uint32_t,\
    \ 0, 1> ccpc;\n    };\n  };\n\npublic:\n  using cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class SmcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using etp = FieldModel<uint32_t, address, 15,\
    \ 1>;\n    using ece = FieldModel<uint32_t, address, 14, 1>;\n    using etps =\
    \ FieldModel<uint32_t, address, 12, 2>;\n    using etf = FieldModel<uint32_t,\
    \ address, 8, 4>;\n    using msm = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ ts = FieldModel<uint32_t, address, 4, 3>;\n    using sms = FieldModel<uint32_t,\
    \ address, 0, 3>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> etp;\n      BitFieldModel<uint32_t, 14,\
    \ 1> ece;\n      BitFieldModel<uint32_t, 12, 2> etps;\n      BitFieldModel<uint32_t,\
    \ 8, 4> etf;\n      BitFieldModel<uint32_t, 7, 1> msm;\n      BitFieldModel<uint32_t,\
    \ 4, 3> ts;\n      BitFieldModel<uint32_t, 0, 3> sms;\n    };\n  };\n\npublic:\n\
    \  using smcr = SmcrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DierReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using tde = FieldModel<uint32_t, address, 14, 1>;\n    using comde\
    \ = FieldModel<uint32_t, address, 13, 1>;\n    using cc4de = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using cc3de = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using cc2de = FieldModel<uint32_t, address, 10, 1>;\n    using cc1de = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using ude = FieldModel<uint32_t, address, 8, 1>;\n    using\
    \ tie = FieldModel<uint32_t, address, 6, 1>;\n    using cc4ie = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using cc3ie = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using cc2ie = FieldModel<uint32_t, address, 2, 1>;\n    using cc1ie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using uie = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ bie = FieldModel<uint32_t, address, 7, 1>;\n    using comie = FieldModel<uint32_t,\
    \ address, 5, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 14, 1> tde;\n      BitFieldModel<uint32_t, 13,\
    \ 1> comde;\n      BitFieldModel<uint32_t, 12, 1> cc4de;\n      BitFieldModel<uint32_t,\
    \ 11, 1> cc3de;\n      BitFieldModel<uint32_t, 10, 1> cc2de;\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc1de;\n      BitFieldModel<uint32_t, 8, 1> ude;\n      BitFieldModel<uint32_t,\
    \ 6, 1> tie;\n      BitFieldModel<uint32_t, 4, 1> cc4ie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3ie;\n      BitFieldModel<uint32_t, 2, 1> cc2ie;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1ie;\n      BitFieldModel<uint32_t, 0, 1> uie;\n      BitFieldModel<uint32_t,\
    \ 7, 1> bie;\n      BitFieldModel<uint32_t, 5, 1> comie;\n    };\n  };\n\npublic:\n\
    \  using dier = DierReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class SrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using cc4of = FieldModel<uint32_t, address, 12, 1>;\n    using\
    \ cc3of = FieldModel<uint32_t, address, 11, 1>;\n    using cc2of = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using cc1of = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using bif = FieldModel<uint32_t, address, 7, 1>;\n    using tif = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using comif = FieldModel<uint32_t, address, 5, 1>;\n  \
    \  using cc4if = FieldModel<uint32_t, address, 4, 1>;\n    using cc3if = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using cc2if = FieldModel<uint32_t, address, 2, 1>;\n  \
    \  using cc1if = FieldModel<uint32_t, address, 1, 1>;\n    using uif = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 12, 1> cc4of;\n      BitFieldModel<uint32_t, 11,\
    \ 1> cc3of;\n      BitFieldModel<uint32_t, 10, 1> cc2of;\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc1of;\n      BitFieldModel<uint32_t, 7, 1> bif;\n      BitFieldModel<uint32_t,\
    \ 6, 1> tif;\n      BitFieldModel<uint32_t, 5, 1> comif;\n      BitFieldModel<uint32_t,\
    \ 4, 1> cc4if;\n      BitFieldModel<uint32_t, 3, 1> cc3if;\n      BitFieldModel<uint32_t,\
    \ 2, 1> cc2if;\n      BitFieldModel<uint32_t, 1, 1> cc1if;\n      BitFieldModel<uint32_t,\
    \ 0, 1> uif;\n    };\n  };\n\npublic:\n  using sr = SrReg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class EgrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using bg = FieldModel<uint32_t, address, 7, 1>;\n\
    \    using tg = FieldModel<uint32_t, address, 6, 1>;\n    using comg = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using cc4g = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ using cc3g = FieldModel<uint32_t, address, 3, 1>;\n    using cc2g = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc1g = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using ug = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 7, 1> bg;\n     \
    \ BitFieldModel<uint32_t, 6, 1> tg;\n      BitFieldModel<uint32_t, 5, 1> comg;\n\
    \      BitFieldModel<uint32_t, 4, 1> cc4g;\n      BitFieldModel<uint32_t, 3, 1>\
    \ cc3g;\n      BitFieldModel<uint32_t, 2, 1> cc2g;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1g;\n      BitFieldModel<uint32_t, 0, 1> ug;\n    };\n  };\n\npublic:\n\
    \  using egr = EgrReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr1_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using oc2ce = FieldModel<uint32_t, address, 15, 1>;\n   \
    \ using oc2m = FieldModel<uint32_t, address, 12, 3>;\n    using oc2pe = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using oc2fe = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using cc2s = FieldModel<uint32_t, address, 8, 2>;\n    using oc1ce = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using oc1m = FieldModel<uint32_t, address, 4, 3>;\n   \
    \ using oc1pe = FieldModel<uint32_t, address, 3, 1>;\n    using oc1fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 15, 1> oc2ce;\n      BitFieldModel<uint32_t, 12, 3> oc2m;\n      BitFieldModel<uint32_t,\
    \ 11, 1> oc2pe;\n      BitFieldModel<uint32_t, 10, 1> oc2fe;\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc2s;\n      BitFieldModel<uint32_t, 7, 1> oc1ce;\n      BitFieldModel<uint32_t,\
    \ 4, 3> oc1m;\n      BitFieldModel<uint32_t, 3, 1> oc1pe;\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc1fe;\n      BitFieldModel<uint32_t, 0, 2> cc1s;\n    };\n  };\n\npublic:\n\
    \  using ccmr1_output = Ccmr1_outputReg<BaseAddress + 0x0018>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Ccmr1_inputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ic2f = FieldModel<uint32_t, address, 12,\
    \ 4>;\n    using ic2pcs = FieldModel<uint32_t, address, 10, 2>;\n    using cc2s\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    using ic1f = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using icpcs = FieldModel<uint32_t, address, 2, 2>;\n  \
    \  using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 12, 4> ic2f;\n  \
    \    BitFieldModel<uint32_t, 10, 2> ic2pcs;\n      BitFieldModel<uint32_t, 8,\
    \ 2> cc2s;\n      BitFieldModel<uint32_t, 4, 4> ic1f;\n      BitFieldModel<uint32_t,\
    \ 2, 2> icpcs;\n      BitFieldModel<uint32_t, 0, 2> cc1s;\n    };\n  };\n\npublic:\n\
    \  using ccmr1_input = Ccmr1_inputReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr2_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using oc4ce = FieldModel<uint32_t, address, 15, 1>;\n   \
    \ using oc4m = FieldModel<uint32_t, address, 12, 3>;\n    using oc4pe = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using oc4fe = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using cc4s = FieldModel<uint32_t, address, 8, 2>;\n    using oc3ce = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using oc3m = FieldModel<uint32_t, address, 4, 3>;\n   \
    \ using oc3pe = FieldModel<uint32_t, address, 3, 1>;\n    using oc3fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc3s = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 15, 1> oc4ce;\n      BitFieldModel<uint32_t, 12, 3> oc4m;\n      BitFieldModel<uint32_t,\
    \ 11, 1> oc4pe;\n      BitFieldModel<uint32_t, 10, 1> oc4fe;\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc4s;\n      BitFieldModel<uint32_t, 7, 1> oc3ce;\n      BitFieldModel<uint32_t,\
    \ 4, 3> oc3m;\n      BitFieldModel<uint32_t, 3, 1> oc3pe;\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc3fe;\n      BitFieldModel<uint32_t, 0, 2> cc3s;\n    };\n  };\n\npublic:\n\
    \  using ccmr2_output = Ccmr2_outputReg<BaseAddress + 0x001C>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Ccmr2_inputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ic4f = FieldModel<uint32_t, address, 12,\
    \ 4>;\n    using ic4psc = FieldModel<uint32_t, address, 10, 2>;\n    using cc4s\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    using ic3f = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using ic3psc = FieldModel<uint32_t, address, 2, 2>;\n \
    \   using cc3s = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 12, 4> ic4f;\n\
    \      BitFieldModel<uint32_t, 10, 2> ic4psc;\n      BitFieldModel<uint32_t, 8,\
    \ 2> cc4s;\n      BitFieldModel<uint32_t, 4, 4> ic3f;\n      BitFieldModel<uint32_t,\
    \ 2, 2> ic3psc;\n      BitFieldModel<uint32_t, 0, 2> cc3s;\n    };\n  };\n\npublic:\n\
    \  using ccmr2_input = Ccmr2_inputReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CcerReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using cc4p = FieldModel<uint32_t, address, 13, 1>;\n    using\
    \ cc4e = FieldModel<uint32_t, address, 12, 1>;\n    using cc3np = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using cc3ne = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using cc3p = FieldModel<uint32_t, address, 9, 1>;\n    using cc3e = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using cc2np = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using cc2ne = FieldModel<uint32_t, address, 6, 1>;\n    using cc2p = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using cc2e = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ using cc1np = FieldModel<uint32_t, address, 3, 1>;\n    using cc1ne = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc1p = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using cc1e = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 13, 1> cc4p;\n  \
    \    BitFieldModel<uint32_t, 12, 1> cc4e;\n      BitFieldModel<uint32_t, 11, 1>\
    \ cc3np;\n      BitFieldModel<uint32_t, 10, 1> cc3ne;\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc3p;\n      BitFieldModel<uint32_t, 8, 1> cc3e;\n      BitFieldModel<uint32_t,\
    \ 7, 1> cc2np;\n      BitFieldModel<uint32_t, 6, 1> cc2ne;\n      BitFieldModel<uint32_t,\
    \ 5, 1> cc2p;\n      BitFieldModel<uint32_t, 4, 1> cc2e;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc1np;\n      BitFieldModel<uint32_t, 2, 1> cc1ne;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1p;\n      BitFieldModel<uint32_t, 0, 1> cc1e;\n    };\n  };\n\npublic:\n\
    \  using ccer = CcerReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CntReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using cnt = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> cnt;\n    };\n  };\n\npublic:\n  using cnt = CntReg<BaseAddress + 0x0024>;\n\
    \nprivate:\n  template<unsigned int address>\n  class PscReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using psc = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> psc;\n    };\n  };\n\npublic:\n  using psc = PscReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class ArrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using arr = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> arr;\n    };\n  };\n\npublic:\n  using arr = ArrReg<BaseAddress + 0x002C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Ccr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ccr1 = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr1;\n    };\n  };\n\npublic:\n  using ccr1 = Ccr1Reg<BaseAddress +\
    \ 0x0034>;\n\nprivate:\n  template<unsigned int address>\n  class Ccr2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using ccr2 = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> ccr2;\n    };\n  };\n\npublic:\n  using\
    \ ccr2 = Ccr2Reg<BaseAddress + 0x0038>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Ccr3Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   using ccr3 = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 16> ccr3;\n\
    \    };\n  };\n\npublic:\n  using ccr3 = Ccr3Reg<BaseAddress + 0x003C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Ccr4Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ccr4 = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr4;\n    };\n  };\n\npublic:\n  using ccr4 = Ccr4Reg<BaseAddress +\
    \ 0x0040>;\n\nprivate:\n  template<unsigned int address>\n  class DcrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using dbl = FieldModel<uint32_t,\
    \ address, 8, 5>;\n    using dba = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8,\
    \ 5> dbl;\n      BitFieldModel<uint32_t, 0, 5> dba;\n    };\n  };\n\npublic:\n\
    \  using dcr = DcrReg<BaseAddress + 0x0048>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DmarReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using dmab = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> dmab;\n    };\n  };\n\npublic:\n  using dmar = DmarReg<BaseAddress + 0x004C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class RcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using rep = FieldModel<uint32_t, address, 0, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> rep;\n    };\n  };\n\npublic:\n  using rcr = RcrReg<BaseAddress + 0x0030>;\n\
    \nprivate:\n  template<unsigned int address>\n  class BdtrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using moe = FieldModel<uint32_t, address, 15,\
    \ 1>;\n    using aoe = FieldModel<uint32_t, address, 14, 1>;\n    using bkp =\
    \ FieldModel<uint32_t, address, 13, 1>;\n    using bke = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using ossr = FieldModel<uint32_t, address, 11, 1>;\n \
    \   using ossi = FieldModel<uint32_t, address, 10, 1>;\n    using lock = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    using dtg = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 15,\
    \ 1> moe;\n      BitFieldModel<uint32_t, 14, 1> aoe;\n      BitFieldModel<uint32_t,\
    \ 13, 1> bkp;\n      BitFieldModel<uint32_t, 12, 1> bke;\n      BitFieldModel<uint32_t,\
    \ 11, 1> ossr;\n      BitFieldModel<uint32_t, 10, 1> ossi;\n      BitFieldModel<uint32_t,\
    \ 8, 2> lock;\n      BitFieldModel<uint32_t, 0, 8> dtg;\n    };\n  };\n\npublic:\n\
    \  using bdtr = BdtrReg<BaseAddress + 0x0044>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_TIM8_H\
    \ */\n"
  name: TIM8
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_TIM2_H\n#define DRAL_STM32F446_TIM2_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass tim2\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40000000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ckd = FieldModel<uint32_t, address, 8, 2>;\n\
    \    using arpe = FieldModel<uint32_t, address, 7, 1>;\n    using cms = FieldModel<uint32_t,\
    \ address, 5, 2>;\n    using dir = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ opm = FieldModel<uint32_t, address, 3, 1>;\n    using urs = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using udis = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using cen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 2> ckd;\n    \
    \  BitFieldModel<uint32_t, 7, 1> arpe;\n      BitFieldModel<uint32_t, 5, 2> cms;\n\
    \      BitFieldModel<uint32_t, 4, 1> dir;\n      BitFieldModel<uint32_t, 3, 1>\
    \ opm;\n      BitFieldModel<uint32_t, 2, 1> urs;\n      BitFieldModel<uint32_t,\
    \ 1, 1> udis;\n      BitFieldModel<uint32_t, 0, 1> cen;\n    };\n  };\n\npublic:\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ti1s = FieldModel<uint32_t, address, 7, 1>;\n    using mms\
    \ = FieldModel<uint32_t, address, 4, 3>;\n    using ccds = FieldModel<uint32_t,\
    \ address, 3, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> ti1s;\n      BitFieldModel<uint32_t, 4, 3>\
    \ mms;\n      BitFieldModel<uint32_t, 3, 1> ccds;\n    };\n  };\n\npublic:\n \
    \ using cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class SmcrReg : public RegisterModel<uint32_t, address>\n  {\n \
    \ public:\n    using etp = FieldModel<uint32_t, address, 15, 1>;\n    using ece\
    \ = FieldModel<uint32_t, address, 14, 1>;\n    using etps = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    using etf = FieldModel<uint32_t, address, 8, 4>;\n   \
    \ using msm = FieldModel<uint32_t, address, 7, 1>;\n    using ts = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    using sms = FieldModel<uint32_t, address, 0, 3>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 15,\
    \ 1> etp;\n      BitFieldModel<uint32_t, 14, 1> ece;\n      BitFieldModel<uint32_t,\
    \ 12, 2> etps;\n      BitFieldModel<uint32_t, 8, 4> etf;\n      BitFieldModel<uint32_t,\
    \ 7, 1> msm;\n      BitFieldModel<uint32_t, 4, 3> ts;\n      BitFieldModel<uint32_t,\
    \ 0, 3> sms;\n    };\n  };\n\npublic:\n  using smcr = SmcrReg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DierReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using tde = FieldModel<uint32_t, address, 14,\
    \ 1>;\n    using cc4de = FieldModel<uint32_t, address, 12, 1>;\n    using cc3de\
    \ = FieldModel<uint32_t, address, 11, 1>;\n    using cc2de = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using cc1de = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using ude = FieldModel<uint32_t, address, 8, 1>;\n    using tie = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using cc4ie = FieldModel<uint32_t, address, 4, 1>;\n  \
    \  using cc3ie = FieldModel<uint32_t, address, 3, 1>;\n    using cc2ie = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc1ie = FieldModel<uint32_t, address, 1, 1>;\n  \
    \  using uie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 14, 1> tde;\n   \
    \   BitFieldModel<uint32_t, 12, 1> cc4de;\n      BitFieldModel<uint32_t, 11, 1>\
    \ cc3de;\n      BitFieldModel<uint32_t, 10, 1> cc2de;\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc1de;\n      BitFieldModel<uint32_t, 8, 1> ude;\n      BitFieldModel<uint32_t,\
    \ 6, 1> tie;\n      BitFieldModel<uint32_t, 4, 1> cc4ie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3ie;\n      BitFieldModel<uint32_t, 2, 1> cc2ie;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1ie;\n      BitFieldModel<uint32_t, 0, 1> uie;\n    };\n  };\n\npublic:\n\
    \  using dier = DierReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class SrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using cc4of = FieldModel<uint32_t, address, 12, 1>;\n    using\
    \ cc3of = FieldModel<uint32_t, address, 11, 1>;\n    using cc2of = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using cc1of = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using tif = FieldModel<uint32_t, address, 6, 1>;\n    using cc4if = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using cc3if = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using cc2if = FieldModel<uint32_t, address, 2, 1>;\n    using cc1if = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using uif = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 12,\
    \ 1> cc4of;\n      BitFieldModel<uint32_t, 11, 1> cc3of;\n      BitFieldModel<uint32_t,\
    \ 10, 1> cc2of;\n      BitFieldModel<uint32_t, 9, 1> cc1of;\n      BitFieldModel<uint32_t,\
    \ 6, 1> tif;\n      BitFieldModel<uint32_t, 4, 1> cc4if;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3if;\n      BitFieldModel<uint32_t, 2, 1> cc2if;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1if;\n      BitFieldModel<uint32_t, 0, 1> uif;\n    };\n  };\n\npublic:\n\
    \  using sr = SrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class EgrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using tg = FieldModel<uint32_t, address, 6, 1>;\n    using cc4g = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using cc3g = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using cc2g = FieldModel<uint32_t, address, 2, 1>;\n    using cc1g = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ug = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 6,\
    \ 1> tg;\n      BitFieldModel<uint32_t, 4, 1> cc4g;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3g;\n      BitFieldModel<uint32_t, 2, 1> cc2g;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1g;\n      BitFieldModel<uint32_t, 0, 1> ug;\n    };\n  };\n\npublic:\n\
    \  using egr = EgrReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr1_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using oc2ce = FieldModel<uint32_t, address, 15, 1>;\n   \
    \ using oc2m = FieldModel<uint32_t, address, 12, 3>;\n    using oc2pe = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using oc2fe = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using cc2s = FieldModel<uint32_t, address, 8, 2>;\n    using oc1ce = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using oc1m = FieldModel<uint32_t, address, 4, 3>;\n   \
    \ using oc1pe = FieldModel<uint32_t, address, 3, 1>;\n    using oc1fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 15, 1> oc2ce;\n      BitFieldModel<uint32_t, 12, 3> oc2m;\n      BitFieldModel<uint32_t,\
    \ 11, 1> oc2pe;\n      BitFieldModel<uint32_t, 10, 1> oc2fe;\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc2s;\n      BitFieldModel<uint32_t, 7, 1> oc1ce;\n      BitFieldModel<uint32_t,\
    \ 4, 3> oc1m;\n      BitFieldModel<uint32_t, 3, 1> oc1pe;\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc1fe;\n      BitFieldModel<uint32_t, 0, 2> cc1s;\n    };\n  };\n\npublic:\n\
    \  using ccmr1_output = Ccmr1_outputReg<BaseAddress + 0x0018>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Ccmr1_inputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ic2f = FieldModel<uint32_t, address, 12,\
    \ 4>;\n    using ic2pcs = FieldModel<uint32_t, address, 10, 2>;\n    using cc2s\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    using ic1f = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using icpcs = FieldModel<uint32_t, address, 2, 2>;\n  \
    \  using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 12, 4> ic2f;\n  \
    \    BitFieldModel<uint32_t, 10, 2> ic2pcs;\n      BitFieldModel<uint32_t, 8,\
    \ 2> cc2s;\n      BitFieldModel<uint32_t, 4, 4> ic1f;\n      BitFieldModel<uint32_t,\
    \ 2, 2> icpcs;\n      BitFieldModel<uint32_t, 0, 2> cc1s;\n    };\n  };\n\npublic:\n\
    \  using ccmr1_input = Ccmr1_inputReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr2_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using oc4ce = FieldModel<uint32_t, address, 15, 1>;\n   \
    \ using oc4m = FieldModel<uint32_t, address, 12, 3>;\n    using oc4pe = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using oc4fe = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using cc4s = FieldModel<uint32_t, address, 8, 2>;\n    using oc3ce = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using oc3m = FieldModel<uint32_t, address, 4, 3>;\n   \
    \ using oc3pe = FieldModel<uint32_t, address, 3, 1>;\n    using oc3fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc3s = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 15, 1> oc4ce;\n      BitFieldModel<uint32_t, 12, 3> oc4m;\n      BitFieldModel<uint32_t,\
    \ 11, 1> oc4pe;\n      BitFieldModel<uint32_t, 10, 1> oc4fe;\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc4s;\n      BitFieldModel<uint32_t, 7, 1> oc3ce;\n      BitFieldModel<uint32_t,\
    \ 4, 3> oc3m;\n      BitFieldModel<uint32_t, 3, 1> oc3pe;\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc3fe;\n      BitFieldModel<uint32_t, 0, 2> cc3s;\n    };\n  };\n\npublic:\n\
    \  using ccmr2_output = Ccmr2_outputReg<BaseAddress + 0x001C>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Ccmr2_inputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ic4f = FieldModel<uint32_t, address, 12,\
    \ 4>;\n    using ic4psc = FieldModel<uint32_t, address, 10, 2>;\n    using cc4s\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    using ic3f = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using ic3psc = FieldModel<uint32_t, address, 2, 2>;\n \
    \   using cc3s = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 12, 4> ic4f;\n\
    \      BitFieldModel<uint32_t, 10, 2> ic4psc;\n      BitFieldModel<uint32_t, 8,\
    \ 2> cc4s;\n      BitFieldModel<uint32_t, 4, 4> ic3f;\n      BitFieldModel<uint32_t,\
    \ 2, 2> ic3psc;\n      BitFieldModel<uint32_t, 0, 2> cc3s;\n    };\n  };\n\npublic:\n\
    \  using ccmr2_input = Ccmr2_inputReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CcerReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using cc4np = FieldModel<uint32_t, address, 15, 1>;\n    using\
    \ cc4p = FieldModel<uint32_t, address, 13, 1>;\n    using cc4e = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using cc3np = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using cc3p = FieldModel<uint32_t, address, 9, 1>;\n    using cc3e = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using cc2np = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using cc2p = FieldModel<uint32_t, address, 5, 1>;\n    using cc2e = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using cc1np = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using cc1p = FieldModel<uint32_t, address, 1, 1>;\n    using cc1e = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> cc4np;\n      BitFieldModel<uint32_t, 13,\
    \ 1> cc4p;\n      BitFieldModel<uint32_t, 12, 1> cc4e;\n      BitFieldModel<uint32_t,\
    \ 11, 1> cc3np;\n      BitFieldModel<uint32_t, 9, 1> cc3p;\n      BitFieldModel<uint32_t,\
    \ 8, 1> cc3e;\n      BitFieldModel<uint32_t, 7, 1> cc2np;\n      BitFieldModel<uint32_t,\
    \ 5, 1> cc2p;\n      BitFieldModel<uint32_t, 4, 1> cc2e;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc1np;\n      BitFieldModel<uint32_t, 1, 1> cc1p;\n      BitFieldModel<uint32_t,\
    \ 0, 1> cc1e;\n    };\n  };\n\npublic:\n  using ccer = CcerReg<BaseAddress + 0x0020>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CntReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cnt_h = FieldModel<uint32_t, address, 16,\
    \ 16>;\n    using cnt_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16,\
    \ 16> cnt_h;\n      BitFieldModel<uint32_t, 0, 16> cnt_l;\n    };\n  };\n\npublic:\n\
    \  using cnt = CntReg<BaseAddress + 0x0024>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class PscReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using psc = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> psc;\n    };\n  };\n\npublic:\n  using psc = PscReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class ArrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using arr_h = FieldModel<uint32_t, address, 16,\
    \ 16>;\n    using arr_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16,\
    \ 16> arr_h;\n      BitFieldModel<uint32_t, 0, 16> arr_l;\n    };\n  };\n\npublic:\n\
    \  using arr = ArrReg<BaseAddress + 0x002C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccr1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ccr1_h = FieldModel<uint32_t, address, 16, 16>;\n    using\
    \ ccr1_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16, 16> ccr1_h;\n\
    \      BitFieldModel<uint32_t, 0, 16> ccr1_l;\n    };\n  };\n\npublic:\n  using\
    \ ccr1 = Ccr1Reg<BaseAddress + 0x0034>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Ccr2Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   using ccr2_h = FieldModel<uint32_t, address, 16, 16>;\n    using ccr2_l =\
    \ FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 16, 16> ccr2_h;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr2_l;\n    };\n  };\n\npublic:\n  using ccr2 = Ccr2Reg<BaseAddress\
    \ + 0x0038>;\n\nprivate:\n  template<unsigned int address>\n  class Ccr3Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ccr3_h =\
    \ FieldModel<uint32_t, address, 16, 16>;\n    using ccr3_l = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 16, 16> ccr3_h;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr3_l;\n    };\n  };\n\npublic:\n  using ccr3 = Ccr3Reg<BaseAddress\
    \ + 0x003C>;\n\nprivate:\n  template<unsigned int address>\n  class Ccr4Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ccr4_h =\
    \ FieldModel<uint32_t, address, 16, 16>;\n    using ccr4_l = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 16, 16> ccr4_h;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr4_l;\n    };\n  };\n\npublic:\n  using ccr4 = Ccr4Reg<BaseAddress\
    \ + 0x0040>;\n\nprivate:\n  template<unsigned int address>\n  class DcrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using dbl = FieldModel<uint32_t,\
    \ address, 8, 5>;\n    using dba = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8,\
    \ 5> dbl;\n      BitFieldModel<uint32_t, 0, 5> dba;\n    };\n  };\n\npublic:\n\
    \  using dcr = DcrReg<BaseAddress + 0x0048>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DmarReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using dmab = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> dmab;\n    };\n  };\n\npublic:\n  using dmar = DmarReg<BaseAddress + 0x004C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class _orReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using itr1_rmp = FieldModel<uint32_t, address,\
    \ 10, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 10, 2> itr1_rmp;\n    };\n  };\n\npublic:\n  using _or = _orReg<BaseAddress\
    \ + 0x0050>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_TIM2_H */\n"
  name: TIM2
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_TIM3_H\n#define DRAL_STM32F446_TIM3_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass tim3\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40000400;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ckd = FieldModel<uint32_t, address, 8, 2>;\n\
    \    using arpe = FieldModel<uint32_t, address, 7, 1>;\n    using cms = FieldModel<uint32_t,\
    \ address, 5, 2>;\n    using dir = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ opm = FieldModel<uint32_t, address, 3, 1>;\n    using urs = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using udis = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using cen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 2> ckd;\n    \
    \  BitFieldModel<uint32_t, 7, 1> arpe;\n      BitFieldModel<uint32_t, 5, 2> cms;\n\
    \      BitFieldModel<uint32_t, 4, 1> dir;\n      BitFieldModel<uint32_t, 3, 1>\
    \ opm;\n      BitFieldModel<uint32_t, 2, 1> urs;\n      BitFieldModel<uint32_t,\
    \ 1, 1> udis;\n      BitFieldModel<uint32_t, 0, 1> cen;\n    };\n  };\n\npublic:\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ti1s = FieldModel<uint32_t, address, 7, 1>;\n    using mms\
    \ = FieldModel<uint32_t, address, 4, 3>;\n    using ccds = FieldModel<uint32_t,\
    \ address, 3, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> ti1s;\n      BitFieldModel<uint32_t, 4, 3>\
    \ mms;\n      BitFieldModel<uint32_t, 3, 1> ccds;\n    };\n  };\n\npublic:\n \
    \ using cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class SmcrReg : public RegisterModel<uint32_t, address>\n  {\n \
    \ public:\n    using etp = FieldModel<uint32_t, address, 15, 1>;\n    using ece\
    \ = FieldModel<uint32_t, address, 14, 1>;\n    using etps = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    using etf = FieldModel<uint32_t, address, 8, 4>;\n   \
    \ using msm = FieldModel<uint32_t, address, 7, 1>;\n    using ts = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    using sms = FieldModel<uint32_t, address, 0, 3>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 15,\
    \ 1> etp;\n      BitFieldModel<uint32_t, 14, 1> ece;\n      BitFieldModel<uint32_t,\
    \ 12, 2> etps;\n      BitFieldModel<uint32_t, 8, 4> etf;\n      BitFieldModel<uint32_t,\
    \ 7, 1> msm;\n      BitFieldModel<uint32_t, 4, 3> ts;\n      BitFieldModel<uint32_t,\
    \ 0, 3> sms;\n    };\n  };\n\npublic:\n  using smcr = SmcrReg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DierReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using tde = FieldModel<uint32_t, address, 14,\
    \ 1>;\n    using cc4de = FieldModel<uint32_t, address, 12, 1>;\n    using cc3de\
    \ = FieldModel<uint32_t, address, 11, 1>;\n    using cc2de = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using cc1de = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using ude = FieldModel<uint32_t, address, 8, 1>;\n    using tie = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using cc4ie = FieldModel<uint32_t, address, 4, 1>;\n  \
    \  using cc3ie = FieldModel<uint32_t, address, 3, 1>;\n    using cc2ie = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc1ie = FieldModel<uint32_t, address, 1, 1>;\n  \
    \  using uie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 14, 1> tde;\n   \
    \   BitFieldModel<uint32_t, 12, 1> cc4de;\n      BitFieldModel<uint32_t, 11, 1>\
    \ cc3de;\n      BitFieldModel<uint32_t, 10, 1> cc2de;\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc1de;\n      BitFieldModel<uint32_t, 8, 1> ude;\n      BitFieldModel<uint32_t,\
    \ 6, 1> tie;\n      BitFieldModel<uint32_t, 4, 1> cc4ie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3ie;\n      BitFieldModel<uint32_t, 2, 1> cc2ie;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1ie;\n      BitFieldModel<uint32_t, 0, 1> uie;\n    };\n  };\n\npublic:\n\
    \  using dier = DierReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class SrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using cc4of = FieldModel<uint32_t, address, 12, 1>;\n    using\
    \ cc3of = FieldModel<uint32_t, address, 11, 1>;\n    using cc2of = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using cc1of = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using tif = FieldModel<uint32_t, address, 6, 1>;\n    using cc4if = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using cc3if = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using cc2if = FieldModel<uint32_t, address, 2, 1>;\n    using cc1if = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using uif = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 12,\
    \ 1> cc4of;\n      BitFieldModel<uint32_t, 11, 1> cc3of;\n      BitFieldModel<uint32_t,\
    \ 10, 1> cc2of;\n      BitFieldModel<uint32_t, 9, 1> cc1of;\n      BitFieldModel<uint32_t,\
    \ 6, 1> tif;\n      BitFieldModel<uint32_t, 4, 1> cc4if;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3if;\n      BitFieldModel<uint32_t, 2, 1> cc2if;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1if;\n      BitFieldModel<uint32_t, 0, 1> uif;\n    };\n  };\n\npublic:\n\
    \  using sr = SrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class EgrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using tg = FieldModel<uint32_t, address, 6, 1>;\n    using cc4g = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using cc3g = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using cc2g = FieldModel<uint32_t, address, 2, 1>;\n    using cc1g = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ug = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 6,\
    \ 1> tg;\n      BitFieldModel<uint32_t, 4, 1> cc4g;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3g;\n      BitFieldModel<uint32_t, 2, 1> cc2g;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1g;\n      BitFieldModel<uint32_t, 0, 1> ug;\n    };\n  };\n\npublic:\n\
    \  using egr = EgrReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr1_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using oc2ce = FieldModel<uint32_t, address, 15, 1>;\n   \
    \ using oc2m = FieldModel<uint32_t, address, 12, 3>;\n    using oc2pe = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using oc2fe = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using cc2s = FieldModel<uint32_t, address, 8, 2>;\n    using oc1ce = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using oc1m = FieldModel<uint32_t, address, 4, 3>;\n   \
    \ using oc1pe = FieldModel<uint32_t, address, 3, 1>;\n    using oc1fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 15, 1> oc2ce;\n      BitFieldModel<uint32_t, 12, 3> oc2m;\n      BitFieldModel<uint32_t,\
    \ 11, 1> oc2pe;\n      BitFieldModel<uint32_t, 10, 1> oc2fe;\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc2s;\n      BitFieldModel<uint32_t, 7, 1> oc1ce;\n      BitFieldModel<uint32_t,\
    \ 4, 3> oc1m;\n      BitFieldModel<uint32_t, 3, 1> oc1pe;\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc1fe;\n      BitFieldModel<uint32_t, 0, 2> cc1s;\n    };\n  };\n\npublic:\n\
    \  using ccmr1_output = Ccmr1_outputReg<BaseAddress + 0x0018>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Ccmr1_inputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ic2f = FieldModel<uint32_t, address, 12,\
    \ 4>;\n    using ic2pcs = FieldModel<uint32_t, address, 10, 2>;\n    using cc2s\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    using ic1f = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using icpcs = FieldModel<uint32_t, address, 2, 2>;\n  \
    \  using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 12, 4> ic2f;\n  \
    \    BitFieldModel<uint32_t, 10, 2> ic2pcs;\n      BitFieldModel<uint32_t, 8,\
    \ 2> cc2s;\n      BitFieldModel<uint32_t, 4, 4> ic1f;\n      BitFieldModel<uint32_t,\
    \ 2, 2> icpcs;\n      BitFieldModel<uint32_t, 0, 2> cc1s;\n    };\n  };\n\npublic:\n\
    \  using ccmr1_input = Ccmr1_inputReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr2_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using oc4ce = FieldModel<uint32_t, address, 15, 1>;\n   \
    \ using oc4m = FieldModel<uint32_t, address, 12, 3>;\n    using oc4pe = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using oc4fe = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using cc4s = FieldModel<uint32_t, address, 8, 2>;\n    using oc3ce = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using oc3m = FieldModel<uint32_t, address, 4, 3>;\n   \
    \ using oc3pe = FieldModel<uint32_t, address, 3, 1>;\n    using oc3fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc3s = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 15, 1> oc4ce;\n      BitFieldModel<uint32_t, 12, 3> oc4m;\n      BitFieldModel<uint32_t,\
    \ 11, 1> oc4pe;\n      BitFieldModel<uint32_t, 10, 1> oc4fe;\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc4s;\n      BitFieldModel<uint32_t, 7, 1> oc3ce;\n      BitFieldModel<uint32_t,\
    \ 4, 3> oc3m;\n      BitFieldModel<uint32_t, 3, 1> oc3pe;\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc3fe;\n      BitFieldModel<uint32_t, 0, 2> cc3s;\n    };\n  };\n\npublic:\n\
    \  using ccmr2_output = Ccmr2_outputReg<BaseAddress + 0x001C>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Ccmr2_inputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ic4f = FieldModel<uint32_t, address, 12,\
    \ 4>;\n    using ic4psc = FieldModel<uint32_t, address, 10, 2>;\n    using cc4s\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    using ic3f = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using ic3psc = FieldModel<uint32_t, address, 2, 2>;\n \
    \   using cc3s = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 12, 4> ic4f;\n\
    \      BitFieldModel<uint32_t, 10, 2> ic4psc;\n      BitFieldModel<uint32_t, 8,\
    \ 2> cc4s;\n      BitFieldModel<uint32_t, 4, 4> ic3f;\n      BitFieldModel<uint32_t,\
    \ 2, 2> ic3psc;\n      BitFieldModel<uint32_t, 0, 2> cc3s;\n    };\n  };\n\npublic:\n\
    \  using ccmr2_input = Ccmr2_inputReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CcerReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using cc4np = FieldModel<uint32_t, address, 15, 1>;\n    using\
    \ cc4p = FieldModel<uint32_t, address, 13, 1>;\n    using cc4e = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using cc3np = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using cc3p = FieldModel<uint32_t, address, 9, 1>;\n    using cc3e = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using cc2np = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using cc2p = FieldModel<uint32_t, address, 5, 1>;\n    using cc2e = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using cc1np = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using cc1p = FieldModel<uint32_t, address, 1, 1>;\n    using cc1e = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> cc4np;\n      BitFieldModel<uint32_t, 13,\
    \ 1> cc4p;\n      BitFieldModel<uint32_t, 12, 1> cc4e;\n      BitFieldModel<uint32_t,\
    \ 11, 1> cc3np;\n      BitFieldModel<uint32_t, 9, 1> cc3p;\n      BitFieldModel<uint32_t,\
    \ 8, 1> cc3e;\n      BitFieldModel<uint32_t, 7, 1> cc2np;\n      BitFieldModel<uint32_t,\
    \ 5, 1> cc2p;\n      BitFieldModel<uint32_t, 4, 1> cc2e;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc1np;\n      BitFieldModel<uint32_t, 1, 1> cc1p;\n      BitFieldModel<uint32_t,\
    \ 0, 1> cc1e;\n    };\n  };\n\npublic:\n  using ccer = CcerReg<BaseAddress + 0x0020>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CntReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cnt_h = FieldModel<uint32_t, address, 16,\
    \ 16>;\n    using cnt_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16,\
    \ 16> cnt_h;\n      BitFieldModel<uint32_t, 0, 16> cnt_l;\n    };\n  };\n\npublic:\n\
    \  using cnt = CntReg<BaseAddress + 0x0024>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class PscReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using psc = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> psc;\n    };\n  };\n\npublic:\n  using psc = PscReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class ArrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using arr_h = FieldModel<uint32_t, address, 16,\
    \ 16>;\n    using arr_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16,\
    \ 16> arr_h;\n      BitFieldModel<uint32_t, 0, 16> arr_l;\n    };\n  };\n\npublic:\n\
    \  using arr = ArrReg<BaseAddress + 0x002C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccr1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ccr1_h = FieldModel<uint32_t, address, 16, 16>;\n    using\
    \ ccr1_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16, 16> ccr1_h;\n\
    \      BitFieldModel<uint32_t, 0, 16> ccr1_l;\n    };\n  };\n\npublic:\n  using\
    \ ccr1 = Ccr1Reg<BaseAddress + 0x0034>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Ccr2Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   using ccr2_h = FieldModel<uint32_t, address, 16, 16>;\n    using ccr2_l =\
    \ FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 16, 16> ccr2_h;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr2_l;\n    };\n  };\n\npublic:\n  using ccr2 = Ccr2Reg<BaseAddress\
    \ + 0x0038>;\n\nprivate:\n  template<unsigned int address>\n  class Ccr3Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ccr3_h =\
    \ FieldModel<uint32_t, address, 16, 16>;\n    using ccr3_l = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 16, 16> ccr3_h;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr3_l;\n    };\n  };\n\npublic:\n  using ccr3 = Ccr3Reg<BaseAddress\
    \ + 0x003C>;\n\nprivate:\n  template<unsigned int address>\n  class Ccr4Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ccr4_h =\
    \ FieldModel<uint32_t, address, 16, 16>;\n    using ccr4_l = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 16, 16> ccr4_h;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr4_l;\n    };\n  };\n\npublic:\n  using ccr4 = Ccr4Reg<BaseAddress\
    \ + 0x0040>;\n\nprivate:\n  template<unsigned int address>\n  class DcrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using dbl = FieldModel<uint32_t,\
    \ address, 8, 5>;\n    using dba = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8,\
    \ 5> dbl;\n      BitFieldModel<uint32_t, 0, 5> dba;\n    };\n  };\n\npublic:\n\
    \  using dcr = DcrReg<BaseAddress + 0x0048>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DmarReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using dmab = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> dmab;\n    };\n  };\n\npublic:\n  using dmar = DmarReg<BaseAddress + 0x004C>;\n\
    \n\n};\n\n}\n\n#endif /* DRAL_STM32F446_TIM3_H */\n"
  name: TIM3
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_TIM4_H\n#define DRAL_STM32F446_TIM4_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass tim4\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40000800;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ckd = FieldModel<uint32_t, address, 8, 2>;\n\
    \    using arpe = FieldModel<uint32_t, address, 7, 1>;\n    using cms = FieldModel<uint32_t,\
    \ address, 5, 2>;\n    using dir = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ opm = FieldModel<uint32_t, address, 3, 1>;\n    using urs = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using udis = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using cen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 2> ckd;\n    \
    \  BitFieldModel<uint32_t, 7, 1> arpe;\n      BitFieldModel<uint32_t, 5, 2> cms;\n\
    \      BitFieldModel<uint32_t, 4, 1> dir;\n      BitFieldModel<uint32_t, 3, 1>\
    \ opm;\n      BitFieldModel<uint32_t, 2, 1> urs;\n      BitFieldModel<uint32_t,\
    \ 1, 1> udis;\n      BitFieldModel<uint32_t, 0, 1> cen;\n    };\n  };\n\npublic:\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ti1s = FieldModel<uint32_t, address, 7, 1>;\n    using mms\
    \ = FieldModel<uint32_t, address, 4, 3>;\n    using ccds = FieldModel<uint32_t,\
    \ address, 3, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> ti1s;\n      BitFieldModel<uint32_t, 4, 3>\
    \ mms;\n      BitFieldModel<uint32_t, 3, 1> ccds;\n    };\n  };\n\npublic:\n \
    \ using cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class SmcrReg : public RegisterModel<uint32_t, address>\n  {\n \
    \ public:\n    using etp = FieldModel<uint32_t, address, 15, 1>;\n    using ece\
    \ = FieldModel<uint32_t, address, 14, 1>;\n    using etps = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    using etf = FieldModel<uint32_t, address, 8, 4>;\n   \
    \ using msm = FieldModel<uint32_t, address, 7, 1>;\n    using ts = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    using sms = FieldModel<uint32_t, address, 0, 3>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 15,\
    \ 1> etp;\n      BitFieldModel<uint32_t, 14, 1> ece;\n      BitFieldModel<uint32_t,\
    \ 12, 2> etps;\n      BitFieldModel<uint32_t, 8, 4> etf;\n      BitFieldModel<uint32_t,\
    \ 7, 1> msm;\n      BitFieldModel<uint32_t, 4, 3> ts;\n      BitFieldModel<uint32_t,\
    \ 0, 3> sms;\n    };\n  };\n\npublic:\n  using smcr = SmcrReg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DierReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using tde = FieldModel<uint32_t, address, 14,\
    \ 1>;\n    using cc4de = FieldModel<uint32_t, address, 12, 1>;\n    using cc3de\
    \ = FieldModel<uint32_t, address, 11, 1>;\n    using cc2de = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using cc1de = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using ude = FieldModel<uint32_t, address, 8, 1>;\n    using tie = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using cc4ie = FieldModel<uint32_t, address, 4, 1>;\n  \
    \  using cc3ie = FieldModel<uint32_t, address, 3, 1>;\n    using cc2ie = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc1ie = FieldModel<uint32_t, address, 1, 1>;\n  \
    \  using uie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 14, 1> tde;\n   \
    \   BitFieldModel<uint32_t, 12, 1> cc4de;\n      BitFieldModel<uint32_t, 11, 1>\
    \ cc3de;\n      BitFieldModel<uint32_t, 10, 1> cc2de;\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc1de;\n      BitFieldModel<uint32_t, 8, 1> ude;\n      BitFieldModel<uint32_t,\
    \ 6, 1> tie;\n      BitFieldModel<uint32_t, 4, 1> cc4ie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3ie;\n      BitFieldModel<uint32_t, 2, 1> cc2ie;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1ie;\n      BitFieldModel<uint32_t, 0, 1> uie;\n    };\n  };\n\npublic:\n\
    \  using dier = DierReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class SrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using cc4of = FieldModel<uint32_t, address, 12, 1>;\n    using\
    \ cc3of = FieldModel<uint32_t, address, 11, 1>;\n    using cc2of = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using cc1of = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using tif = FieldModel<uint32_t, address, 6, 1>;\n    using cc4if = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using cc3if = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using cc2if = FieldModel<uint32_t, address, 2, 1>;\n    using cc1if = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using uif = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 12,\
    \ 1> cc4of;\n      BitFieldModel<uint32_t, 11, 1> cc3of;\n      BitFieldModel<uint32_t,\
    \ 10, 1> cc2of;\n      BitFieldModel<uint32_t, 9, 1> cc1of;\n      BitFieldModel<uint32_t,\
    \ 6, 1> tif;\n      BitFieldModel<uint32_t, 4, 1> cc4if;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3if;\n      BitFieldModel<uint32_t, 2, 1> cc2if;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1if;\n      BitFieldModel<uint32_t, 0, 1> uif;\n    };\n  };\n\npublic:\n\
    \  using sr = SrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class EgrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using tg = FieldModel<uint32_t, address, 6, 1>;\n    using cc4g = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using cc3g = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using cc2g = FieldModel<uint32_t, address, 2, 1>;\n    using cc1g = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ug = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 6,\
    \ 1> tg;\n      BitFieldModel<uint32_t, 4, 1> cc4g;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3g;\n      BitFieldModel<uint32_t, 2, 1> cc2g;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1g;\n      BitFieldModel<uint32_t, 0, 1> ug;\n    };\n  };\n\npublic:\n\
    \  using egr = EgrReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr1_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using oc2ce = FieldModel<uint32_t, address, 15, 1>;\n   \
    \ using oc2m = FieldModel<uint32_t, address, 12, 3>;\n    using oc2pe = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using oc2fe = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using cc2s = FieldModel<uint32_t, address, 8, 2>;\n    using oc1ce = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using oc1m = FieldModel<uint32_t, address, 4, 3>;\n   \
    \ using oc1pe = FieldModel<uint32_t, address, 3, 1>;\n    using oc1fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 15, 1> oc2ce;\n      BitFieldModel<uint32_t, 12, 3> oc2m;\n      BitFieldModel<uint32_t,\
    \ 11, 1> oc2pe;\n      BitFieldModel<uint32_t, 10, 1> oc2fe;\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc2s;\n      BitFieldModel<uint32_t, 7, 1> oc1ce;\n      BitFieldModel<uint32_t,\
    \ 4, 3> oc1m;\n      BitFieldModel<uint32_t, 3, 1> oc1pe;\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc1fe;\n      BitFieldModel<uint32_t, 0, 2> cc1s;\n    };\n  };\n\npublic:\n\
    \  using ccmr1_output = Ccmr1_outputReg<BaseAddress + 0x0018>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Ccmr1_inputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ic2f = FieldModel<uint32_t, address, 12,\
    \ 4>;\n    using ic2pcs = FieldModel<uint32_t, address, 10, 2>;\n    using cc2s\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    using ic1f = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using icpcs = FieldModel<uint32_t, address, 2, 2>;\n  \
    \  using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 12, 4> ic2f;\n  \
    \    BitFieldModel<uint32_t, 10, 2> ic2pcs;\n      BitFieldModel<uint32_t, 8,\
    \ 2> cc2s;\n      BitFieldModel<uint32_t, 4, 4> ic1f;\n      BitFieldModel<uint32_t,\
    \ 2, 2> icpcs;\n      BitFieldModel<uint32_t, 0, 2> cc1s;\n    };\n  };\n\npublic:\n\
    \  using ccmr1_input = Ccmr1_inputReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr2_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using oc4ce = FieldModel<uint32_t, address, 15, 1>;\n   \
    \ using oc4m = FieldModel<uint32_t, address, 12, 3>;\n    using oc4pe = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using oc4fe = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using cc4s = FieldModel<uint32_t, address, 8, 2>;\n    using oc3ce = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using oc3m = FieldModel<uint32_t, address, 4, 3>;\n   \
    \ using oc3pe = FieldModel<uint32_t, address, 3, 1>;\n    using oc3fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc3s = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 15, 1> oc4ce;\n      BitFieldModel<uint32_t, 12, 3> oc4m;\n      BitFieldModel<uint32_t,\
    \ 11, 1> oc4pe;\n      BitFieldModel<uint32_t, 10, 1> oc4fe;\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc4s;\n      BitFieldModel<uint32_t, 7, 1> oc3ce;\n      BitFieldModel<uint32_t,\
    \ 4, 3> oc3m;\n      BitFieldModel<uint32_t, 3, 1> oc3pe;\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc3fe;\n      BitFieldModel<uint32_t, 0, 2> cc3s;\n    };\n  };\n\npublic:\n\
    \  using ccmr2_output = Ccmr2_outputReg<BaseAddress + 0x001C>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Ccmr2_inputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ic4f = FieldModel<uint32_t, address, 12,\
    \ 4>;\n    using ic4psc = FieldModel<uint32_t, address, 10, 2>;\n    using cc4s\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    using ic3f = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using ic3psc = FieldModel<uint32_t, address, 2, 2>;\n \
    \   using cc3s = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 12, 4> ic4f;\n\
    \      BitFieldModel<uint32_t, 10, 2> ic4psc;\n      BitFieldModel<uint32_t, 8,\
    \ 2> cc4s;\n      BitFieldModel<uint32_t, 4, 4> ic3f;\n      BitFieldModel<uint32_t,\
    \ 2, 2> ic3psc;\n      BitFieldModel<uint32_t, 0, 2> cc3s;\n    };\n  };\n\npublic:\n\
    \  using ccmr2_input = Ccmr2_inputReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CcerReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using cc4np = FieldModel<uint32_t, address, 15, 1>;\n    using\
    \ cc4p = FieldModel<uint32_t, address, 13, 1>;\n    using cc4e = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using cc3np = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using cc3p = FieldModel<uint32_t, address, 9, 1>;\n    using cc3e = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using cc2np = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using cc2p = FieldModel<uint32_t, address, 5, 1>;\n    using cc2e = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using cc1np = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using cc1p = FieldModel<uint32_t, address, 1, 1>;\n    using cc1e = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> cc4np;\n      BitFieldModel<uint32_t, 13,\
    \ 1> cc4p;\n      BitFieldModel<uint32_t, 12, 1> cc4e;\n      BitFieldModel<uint32_t,\
    \ 11, 1> cc3np;\n      BitFieldModel<uint32_t, 9, 1> cc3p;\n      BitFieldModel<uint32_t,\
    \ 8, 1> cc3e;\n      BitFieldModel<uint32_t, 7, 1> cc2np;\n      BitFieldModel<uint32_t,\
    \ 5, 1> cc2p;\n      BitFieldModel<uint32_t, 4, 1> cc2e;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc1np;\n      BitFieldModel<uint32_t, 1, 1> cc1p;\n      BitFieldModel<uint32_t,\
    \ 0, 1> cc1e;\n    };\n  };\n\npublic:\n  using ccer = CcerReg<BaseAddress + 0x0020>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CntReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cnt_h = FieldModel<uint32_t, address, 16,\
    \ 16>;\n    using cnt_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16,\
    \ 16> cnt_h;\n      BitFieldModel<uint32_t, 0, 16> cnt_l;\n    };\n  };\n\npublic:\n\
    \  using cnt = CntReg<BaseAddress + 0x0024>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class PscReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using psc = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> psc;\n    };\n  };\n\npublic:\n  using psc = PscReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class ArrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using arr_h = FieldModel<uint32_t, address, 16,\
    \ 16>;\n    using arr_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16,\
    \ 16> arr_h;\n      BitFieldModel<uint32_t, 0, 16> arr_l;\n    };\n  };\n\npublic:\n\
    \  using arr = ArrReg<BaseAddress + 0x002C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccr1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ccr1_h = FieldModel<uint32_t, address, 16, 16>;\n    using\
    \ ccr1_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16, 16> ccr1_h;\n\
    \      BitFieldModel<uint32_t, 0, 16> ccr1_l;\n    };\n  };\n\npublic:\n  using\
    \ ccr1 = Ccr1Reg<BaseAddress + 0x0034>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Ccr2Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   using ccr2_h = FieldModel<uint32_t, address, 16, 16>;\n    using ccr2_l =\
    \ FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 16, 16> ccr2_h;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr2_l;\n    };\n  };\n\npublic:\n  using ccr2 = Ccr2Reg<BaseAddress\
    \ + 0x0038>;\n\nprivate:\n  template<unsigned int address>\n  class Ccr3Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ccr3_h =\
    \ FieldModel<uint32_t, address, 16, 16>;\n    using ccr3_l = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 16, 16> ccr3_h;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr3_l;\n    };\n  };\n\npublic:\n  using ccr3 = Ccr3Reg<BaseAddress\
    \ + 0x003C>;\n\nprivate:\n  template<unsigned int address>\n  class Ccr4Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ccr4_h =\
    \ FieldModel<uint32_t, address, 16, 16>;\n    using ccr4_l = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 16, 16> ccr4_h;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr4_l;\n    };\n  };\n\npublic:\n  using ccr4 = Ccr4Reg<BaseAddress\
    \ + 0x0040>;\n\nprivate:\n  template<unsigned int address>\n  class DcrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using dbl = FieldModel<uint32_t,\
    \ address, 8, 5>;\n    using dba = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8,\
    \ 5> dbl;\n      BitFieldModel<uint32_t, 0, 5> dba;\n    };\n  };\n\npublic:\n\
    \  using dcr = DcrReg<BaseAddress + 0x0048>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DmarReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using dmab = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> dmab;\n    };\n  };\n\npublic:\n  using dmar = DmarReg<BaseAddress + 0x004C>;\n\
    \n\n};\n\n}\n\n#endif /* DRAL_STM32F446_TIM4_H */\n"
  name: TIM4
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_TIM5_H\n#define DRAL_STM32F446_TIM5_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass tim5\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40000C00;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ckd = FieldModel<uint32_t, address, 8, 2>;\n\
    \    using arpe = FieldModel<uint32_t, address, 7, 1>;\n    using cms = FieldModel<uint32_t,\
    \ address, 5, 2>;\n    using dir = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ opm = FieldModel<uint32_t, address, 3, 1>;\n    using urs = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using udis = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using cen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 2> ckd;\n    \
    \  BitFieldModel<uint32_t, 7, 1> arpe;\n      BitFieldModel<uint32_t, 5, 2> cms;\n\
    \      BitFieldModel<uint32_t, 4, 1> dir;\n      BitFieldModel<uint32_t, 3, 1>\
    \ opm;\n      BitFieldModel<uint32_t, 2, 1> urs;\n      BitFieldModel<uint32_t,\
    \ 1, 1> udis;\n      BitFieldModel<uint32_t, 0, 1> cen;\n    };\n  };\n\npublic:\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ti1s = FieldModel<uint32_t, address, 7, 1>;\n    using mms\
    \ = FieldModel<uint32_t, address, 4, 3>;\n    using ccds = FieldModel<uint32_t,\
    \ address, 3, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> ti1s;\n      BitFieldModel<uint32_t, 4, 3>\
    \ mms;\n      BitFieldModel<uint32_t, 3, 1> ccds;\n    };\n  };\n\npublic:\n \
    \ using cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class SmcrReg : public RegisterModel<uint32_t, address>\n  {\n \
    \ public:\n    using etp = FieldModel<uint32_t, address, 15, 1>;\n    using ece\
    \ = FieldModel<uint32_t, address, 14, 1>;\n    using etps = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    using etf = FieldModel<uint32_t, address, 8, 4>;\n   \
    \ using msm = FieldModel<uint32_t, address, 7, 1>;\n    using ts = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    using sms = FieldModel<uint32_t, address, 0, 3>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 15,\
    \ 1> etp;\n      BitFieldModel<uint32_t, 14, 1> ece;\n      BitFieldModel<uint32_t,\
    \ 12, 2> etps;\n      BitFieldModel<uint32_t, 8, 4> etf;\n      BitFieldModel<uint32_t,\
    \ 7, 1> msm;\n      BitFieldModel<uint32_t, 4, 3> ts;\n      BitFieldModel<uint32_t,\
    \ 0, 3> sms;\n    };\n  };\n\npublic:\n  using smcr = SmcrReg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DierReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using tde = FieldModel<uint32_t, address, 14,\
    \ 1>;\n    using cc4de = FieldModel<uint32_t, address, 12, 1>;\n    using cc3de\
    \ = FieldModel<uint32_t, address, 11, 1>;\n    using cc2de = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using cc1de = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using ude = FieldModel<uint32_t, address, 8, 1>;\n    using tie = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using cc4ie = FieldModel<uint32_t, address, 4, 1>;\n  \
    \  using cc3ie = FieldModel<uint32_t, address, 3, 1>;\n    using cc2ie = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc1ie = FieldModel<uint32_t, address, 1, 1>;\n  \
    \  using uie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 14, 1> tde;\n   \
    \   BitFieldModel<uint32_t, 12, 1> cc4de;\n      BitFieldModel<uint32_t, 11, 1>\
    \ cc3de;\n      BitFieldModel<uint32_t, 10, 1> cc2de;\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc1de;\n      BitFieldModel<uint32_t, 8, 1> ude;\n      BitFieldModel<uint32_t,\
    \ 6, 1> tie;\n      BitFieldModel<uint32_t, 4, 1> cc4ie;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3ie;\n      BitFieldModel<uint32_t, 2, 1> cc2ie;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1ie;\n      BitFieldModel<uint32_t, 0, 1> uie;\n    };\n  };\n\npublic:\n\
    \  using dier = DierReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class SrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using cc4of = FieldModel<uint32_t, address, 12, 1>;\n    using\
    \ cc3of = FieldModel<uint32_t, address, 11, 1>;\n    using cc2of = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using cc1of = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using tif = FieldModel<uint32_t, address, 6, 1>;\n    using cc4if = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using cc3if = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using cc2if = FieldModel<uint32_t, address, 2, 1>;\n    using cc1if = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using uif = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 12,\
    \ 1> cc4of;\n      BitFieldModel<uint32_t, 11, 1> cc3of;\n      BitFieldModel<uint32_t,\
    \ 10, 1> cc2of;\n      BitFieldModel<uint32_t, 9, 1> cc1of;\n      BitFieldModel<uint32_t,\
    \ 6, 1> tif;\n      BitFieldModel<uint32_t, 4, 1> cc4if;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3if;\n      BitFieldModel<uint32_t, 2, 1> cc2if;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1if;\n      BitFieldModel<uint32_t, 0, 1> uif;\n    };\n  };\n\npublic:\n\
    \  using sr = SrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class EgrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using tg = FieldModel<uint32_t, address, 6, 1>;\n    using cc4g = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using cc3g = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using cc2g = FieldModel<uint32_t, address, 2, 1>;\n    using cc1g = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ug = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 6,\
    \ 1> tg;\n      BitFieldModel<uint32_t, 4, 1> cc4g;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3g;\n      BitFieldModel<uint32_t, 2, 1> cc2g;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1g;\n      BitFieldModel<uint32_t, 0, 1> ug;\n    };\n  };\n\npublic:\n\
    \  using egr = EgrReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr1_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using oc2ce = FieldModel<uint32_t, address, 15, 1>;\n   \
    \ using oc2m = FieldModel<uint32_t, address, 12, 3>;\n    using oc2pe = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using oc2fe = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using cc2s = FieldModel<uint32_t, address, 8, 2>;\n    using oc1ce = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using oc1m = FieldModel<uint32_t, address, 4, 3>;\n   \
    \ using oc1pe = FieldModel<uint32_t, address, 3, 1>;\n    using oc1fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 15, 1> oc2ce;\n      BitFieldModel<uint32_t, 12, 3> oc2m;\n      BitFieldModel<uint32_t,\
    \ 11, 1> oc2pe;\n      BitFieldModel<uint32_t, 10, 1> oc2fe;\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc2s;\n      BitFieldModel<uint32_t, 7, 1> oc1ce;\n      BitFieldModel<uint32_t,\
    \ 4, 3> oc1m;\n      BitFieldModel<uint32_t, 3, 1> oc1pe;\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc1fe;\n      BitFieldModel<uint32_t, 0, 2> cc1s;\n    };\n  };\n\npublic:\n\
    \  using ccmr1_output = Ccmr1_outputReg<BaseAddress + 0x0018>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Ccmr1_inputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ic2f = FieldModel<uint32_t, address, 12,\
    \ 4>;\n    using ic2pcs = FieldModel<uint32_t, address, 10, 2>;\n    using cc2s\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    using ic1f = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using icpcs = FieldModel<uint32_t, address, 2, 2>;\n  \
    \  using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 12, 4> ic2f;\n  \
    \    BitFieldModel<uint32_t, 10, 2> ic2pcs;\n      BitFieldModel<uint32_t, 8,\
    \ 2> cc2s;\n      BitFieldModel<uint32_t, 4, 4> ic1f;\n      BitFieldModel<uint32_t,\
    \ 2, 2> icpcs;\n      BitFieldModel<uint32_t, 0, 2> cc1s;\n    };\n  };\n\npublic:\n\
    \  using ccmr1_input = Ccmr1_inputReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr2_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using oc4ce = FieldModel<uint32_t, address, 15, 1>;\n   \
    \ using oc4m = FieldModel<uint32_t, address, 12, 3>;\n    using oc4pe = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using oc4fe = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using cc4s = FieldModel<uint32_t, address, 8, 2>;\n    using oc3ce = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using oc3m = FieldModel<uint32_t, address, 4, 3>;\n   \
    \ using oc3pe = FieldModel<uint32_t, address, 3, 1>;\n    using oc3fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc3s = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 15, 1> oc4ce;\n      BitFieldModel<uint32_t, 12, 3> oc4m;\n      BitFieldModel<uint32_t,\
    \ 11, 1> oc4pe;\n      BitFieldModel<uint32_t, 10, 1> oc4fe;\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc4s;\n      BitFieldModel<uint32_t, 7, 1> oc3ce;\n      BitFieldModel<uint32_t,\
    \ 4, 3> oc3m;\n      BitFieldModel<uint32_t, 3, 1> oc3pe;\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc3fe;\n      BitFieldModel<uint32_t, 0, 2> cc3s;\n    };\n  };\n\npublic:\n\
    \  using ccmr2_output = Ccmr2_outputReg<BaseAddress + 0x001C>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Ccmr2_inputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ic4f = FieldModel<uint32_t, address, 12,\
    \ 4>;\n    using ic4psc = FieldModel<uint32_t, address, 10, 2>;\n    using cc4s\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    using ic3f = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    using ic3psc = FieldModel<uint32_t, address, 2, 2>;\n \
    \   using cc3s = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 12, 4> ic4f;\n\
    \      BitFieldModel<uint32_t, 10, 2> ic4psc;\n      BitFieldModel<uint32_t, 8,\
    \ 2> cc4s;\n      BitFieldModel<uint32_t, 4, 4> ic3f;\n      BitFieldModel<uint32_t,\
    \ 2, 2> ic3psc;\n      BitFieldModel<uint32_t, 0, 2> cc3s;\n    };\n  };\n\npublic:\n\
    \  using ccmr2_input = Ccmr2_inputReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CcerReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using cc4np = FieldModel<uint32_t, address, 15, 1>;\n    using\
    \ cc4p = FieldModel<uint32_t, address, 13, 1>;\n    using cc4e = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using cc3np = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using cc3p = FieldModel<uint32_t, address, 9, 1>;\n    using cc3e = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using cc2np = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using cc2p = FieldModel<uint32_t, address, 5, 1>;\n    using cc2e = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using cc1np = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using cc1p = FieldModel<uint32_t, address, 1, 1>;\n    using cc1e = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 15, 1> cc4np;\n      BitFieldModel<uint32_t, 13,\
    \ 1> cc4p;\n      BitFieldModel<uint32_t, 12, 1> cc4e;\n      BitFieldModel<uint32_t,\
    \ 11, 1> cc3np;\n      BitFieldModel<uint32_t, 9, 1> cc3p;\n      BitFieldModel<uint32_t,\
    \ 8, 1> cc3e;\n      BitFieldModel<uint32_t, 7, 1> cc2np;\n      BitFieldModel<uint32_t,\
    \ 5, 1> cc2p;\n      BitFieldModel<uint32_t, 4, 1> cc2e;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc1np;\n      BitFieldModel<uint32_t, 1, 1> cc1p;\n      BitFieldModel<uint32_t,\
    \ 0, 1> cc1e;\n    };\n  };\n\npublic:\n  using ccer = CcerReg<BaseAddress + 0x0020>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CntReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cnt_h = FieldModel<uint32_t, address, 16,\
    \ 16>;\n    using cnt_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16,\
    \ 16> cnt_h;\n      BitFieldModel<uint32_t, 0, 16> cnt_l;\n    };\n  };\n\npublic:\n\
    \  using cnt = CntReg<BaseAddress + 0x0024>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class PscReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using psc = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> psc;\n    };\n  };\n\npublic:\n  using psc = PscReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class ArrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using arr_h = FieldModel<uint32_t, address, 16,\
    \ 16>;\n    using arr_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16,\
    \ 16> arr_h;\n      BitFieldModel<uint32_t, 0, 16> arr_l;\n    };\n  };\n\npublic:\n\
    \  using arr = ArrReg<BaseAddress + 0x002C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccr1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ccr1_h = FieldModel<uint32_t, address, 16, 16>;\n    using\
    \ ccr1_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16, 16> ccr1_h;\n\
    \      BitFieldModel<uint32_t, 0, 16> ccr1_l;\n    };\n  };\n\npublic:\n  using\
    \ ccr1 = Ccr1Reg<BaseAddress + 0x0034>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Ccr2Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   using ccr2_h = FieldModel<uint32_t, address, 16, 16>;\n    using ccr2_l =\
    \ FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 16, 16> ccr2_h;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr2_l;\n    };\n  };\n\npublic:\n  using ccr2 = Ccr2Reg<BaseAddress\
    \ + 0x0038>;\n\nprivate:\n  template<unsigned int address>\n  class Ccr3Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ccr3_h =\
    \ FieldModel<uint32_t, address, 16, 16>;\n    using ccr3_l = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 16, 16> ccr3_h;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr3_l;\n    };\n  };\n\npublic:\n  using ccr3 = Ccr3Reg<BaseAddress\
    \ + 0x003C>;\n\nprivate:\n  template<unsigned int address>\n  class Ccr4Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ccr4_h =\
    \ FieldModel<uint32_t, address, 16, 16>;\n    using ccr4_l = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 16, 16> ccr4_h;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr4_l;\n    };\n  };\n\npublic:\n  using ccr4 = Ccr4Reg<BaseAddress\
    \ + 0x0040>;\n\nprivate:\n  template<unsigned int address>\n  class DcrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using dbl = FieldModel<uint32_t,\
    \ address, 8, 5>;\n    using dba = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8,\
    \ 5> dbl;\n      BitFieldModel<uint32_t, 0, 5> dba;\n    };\n  };\n\npublic:\n\
    \  using dcr = DcrReg<BaseAddress + 0x0048>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DmarReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using dmab = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> dmab;\n    };\n  };\n\npublic:\n  using dmar = DmarReg<BaseAddress + 0x004C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class _orReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using it4_rmp = FieldModel<uint32_t, address,\
    \ 6, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 6, 2> it4_rmp;\n    };\n  };\n\npublic:\n  using _or = _orReg<BaseAddress +\
    \ 0x0050>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_TIM5_H */\n"
  name: TIM5
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_TIM9_H\n#define DRAL_STM32F446_TIM9_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass tim9\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40014000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ckd = FieldModel<uint32_t, address, 8, 2>;\n\
    \    using arpe = FieldModel<uint32_t, address, 7, 1>;\n    using opm = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using urs = FieldModel<uint32_t, address, 2, 1>;\n    using\
    \ udis = FieldModel<uint32_t, address, 1, 1>;\n    using cen = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 8, 2> ckd;\n      BitFieldModel<uint32_t, 7, 1>\
    \ arpe;\n      BitFieldModel<uint32_t, 3, 1> opm;\n      BitFieldModel<uint32_t,\
    \ 2, 1> urs;\n      BitFieldModel<uint32_t, 1, 1> udis;\n      BitFieldModel<uint32_t,\
    \ 0, 1> cen;\n    };\n  };\n\npublic:\n  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Cr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using mms = FieldModel<uint32_t, address, 4, 3>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 4, 3> mms;\n    };\n  };\n\npublic:\n  using cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class SmcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using msm = FieldModel<uint32_t, address, 7, 1>;\n\
    \    using ts = FieldModel<uint32_t, address, 4, 3>;\n    using sms = FieldModel<uint32_t,\
    \ address, 0, 3>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> msm;\n      BitFieldModel<uint32_t, 4, 3>\
    \ ts;\n      BitFieldModel<uint32_t, 0, 3> sms;\n    };\n  };\n\npublic:\n  using\
    \ smcr = SmcrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class DierReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   using tie = FieldModel<uint32_t, address, 6, 1>;\n    using cc2ie = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc1ie = FieldModel<uint32_t, address, 1, 1>;\n  \
    \  using uie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 6, 1> tie;\n    \
    \  BitFieldModel<uint32_t, 2, 1> cc2ie;\n      BitFieldModel<uint32_t, 1, 1> cc1ie;\n\
    \      BitFieldModel<uint32_t, 0, 1> uie;\n    };\n  };\n\npublic:\n  using dier\
    \ = DierReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class SrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ using cc2of = FieldModel<uint32_t, address, 10, 1>;\n    using cc1of = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using tif = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ cc2if = FieldModel<uint32_t, address, 2, 1>;\n    using cc1if = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using uif = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 10,\
    \ 1> cc2of;\n      BitFieldModel<uint32_t, 9, 1> cc1of;\n      BitFieldModel<uint32_t,\
    \ 6, 1> tif;\n      BitFieldModel<uint32_t, 2, 1> cc2if;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1if;\n      BitFieldModel<uint32_t, 0, 1> uif;\n    };\n  };\n\npublic:\n\
    \  using sr = SrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class EgrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using tg = FieldModel<uint32_t, address, 6, 1>;\n    using cc2g = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc1g = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using ug = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 6, 1> tg;\n     \
    \ BitFieldModel<uint32_t, 2, 1> cc2g;\n      BitFieldModel<uint32_t, 1, 1> cc1g;\n\
    \      BitFieldModel<uint32_t, 0, 1> ug;\n    };\n  };\n\npublic:\n  using egr\
    \ = EgrReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Ccmr1_outputReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using oc2m = FieldModel<uint32_t, address, 12, 3>;\n    using oc2pe = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using oc2fe = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using cc2s = FieldModel<uint32_t, address, 8, 2>;\n    using oc1m = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    using oc1pe = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using oc1fe = FieldModel<uint32_t, address, 2, 1>;\n    using cc1s = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 12, 3> oc2m;\n      BitFieldModel<uint32_t, 11,\
    \ 1> oc2pe;\n      BitFieldModel<uint32_t, 10, 1> oc2fe;\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc2s;\n      BitFieldModel<uint32_t, 4, 3> oc1m;\n      BitFieldModel<uint32_t,\
    \ 3, 1> oc1pe;\n      BitFieldModel<uint32_t, 2, 1> oc1fe;\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc1s;\n    };\n  };\n\npublic:\n  using ccmr1_output = Ccmr1_outputReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class Ccmr1_inputReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ic2f =\
    \ FieldModel<uint32_t, address, 12, 3>;\n    using ic2pcs = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    using cc2s = FieldModel<uint32_t, address, 8, 2>;\n  \
    \  using ic1f = FieldModel<uint32_t, address, 4, 3>;\n    using icpcs = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 12, 3> ic2f;\n      BitFieldModel<uint32_t, 10, 2> ic2pcs;\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc2s;\n      BitFieldModel<uint32_t, 4, 3> ic1f;\n      BitFieldModel<uint32_t,\
    \ 2, 2> icpcs;\n      BitFieldModel<uint32_t, 0, 2> cc1s;\n    };\n  };\n\npublic:\n\
    \  using ccmr1_input = Ccmr1_inputReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CcerReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using cc2np = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ cc2p = FieldModel<uint32_t, address, 5, 1>;\n    using cc2e = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using cc1np = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using cc1p = FieldModel<uint32_t, address, 1, 1>;\n    using cc1e = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> cc2np;\n      BitFieldModel<uint32_t, 5,\
    \ 1> cc2p;\n      BitFieldModel<uint32_t, 4, 1> cc2e;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc1np;\n      BitFieldModel<uint32_t, 1, 1> cc1p;\n      BitFieldModel<uint32_t,\
    \ 0, 1> cc1e;\n    };\n  };\n\npublic:\n  using ccer = CcerReg<BaseAddress + 0x0020>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CntReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cnt = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> cnt;\n    };\n  };\n\npublic:\n  using cnt = CntReg<BaseAddress + 0x0024>;\n\
    \nprivate:\n  template<unsigned int address>\n  class PscReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using psc = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> psc;\n    };\n  };\n\npublic:\n  using psc = PscReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class ArrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using arr = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> arr;\n    };\n  };\n\npublic:\n  using arr = ArrReg<BaseAddress + 0x002C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Ccr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ccr1 = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr1;\n    };\n  };\n\npublic:\n  using ccr1 = Ccr1Reg<BaseAddress +\
    \ 0x0034>;\n\nprivate:\n  template<unsigned int address>\n  class Ccr2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using ccr2 = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> ccr2;\n    };\n  };\n\npublic:\n  using\
    \ ccr2 = Ccr2Reg<BaseAddress + 0x0038>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_TIM9_H\
    \ */\n"
  name: TIM9
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_TIM12_H\n#define DRAL_STM32F446_TIM12_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass tim12\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40001800;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ckd = FieldModel<uint32_t, address, 8, 2>;\n\
    \    using arpe = FieldModel<uint32_t, address, 7, 1>;\n    using opm = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using urs = FieldModel<uint32_t, address, 2, 1>;\n    using\
    \ udis = FieldModel<uint32_t, address, 1, 1>;\n    using cen = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 8, 2> ckd;\n      BitFieldModel<uint32_t, 7, 1>\
    \ arpe;\n      BitFieldModel<uint32_t, 3, 1> opm;\n      BitFieldModel<uint32_t,\
    \ 2, 1> urs;\n      BitFieldModel<uint32_t, 1, 1> udis;\n      BitFieldModel<uint32_t,\
    \ 0, 1> cen;\n    };\n  };\n\npublic:\n  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Cr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using mms = FieldModel<uint32_t, address, 4, 3>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 4, 3> mms;\n    };\n  };\n\npublic:\n  using cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class SmcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using msm = FieldModel<uint32_t, address, 7, 1>;\n\
    \    using ts = FieldModel<uint32_t, address, 4, 3>;\n    using sms = FieldModel<uint32_t,\
    \ address, 0, 3>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> msm;\n      BitFieldModel<uint32_t, 4, 3>\
    \ ts;\n      BitFieldModel<uint32_t, 0, 3> sms;\n    };\n  };\n\npublic:\n  using\
    \ smcr = SmcrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class DierReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   using tie = FieldModel<uint32_t, address, 6, 1>;\n    using cc2ie = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc1ie = FieldModel<uint32_t, address, 1, 1>;\n  \
    \  using uie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 6, 1> tie;\n    \
    \  BitFieldModel<uint32_t, 2, 1> cc2ie;\n      BitFieldModel<uint32_t, 1, 1> cc1ie;\n\
    \      BitFieldModel<uint32_t, 0, 1> uie;\n    };\n  };\n\npublic:\n  using dier\
    \ = DierReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class SrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ using cc2of = FieldModel<uint32_t, address, 10, 1>;\n    using cc1of = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using tif = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ cc2if = FieldModel<uint32_t, address, 2, 1>;\n    using cc1if = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using uif = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 10,\
    \ 1> cc2of;\n      BitFieldModel<uint32_t, 9, 1> cc1of;\n      BitFieldModel<uint32_t,\
    \ 6, 1> tif;\n      BitFieldModel<uint32_t, 2, 1> cc2if;\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1if;\n      BitFieldModel<uint32_t, 0, 1> uif;\n    };\n  };\n\npublic:\n\
    \  using sr = SrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class EgrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using tg = FieldModel<uint32_t, address, 6, 1>;\n    using cc2g = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using cc1g = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using ug = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 6, 1> tg;\n     \
    \ BitFieldModel<uint32_t, 2, 1> cc2g;\n      BitFieldModel<uint32_t, 1, 1> cc1g;\n\
    \      BitFieldModel<uint32_t, 0, 1> ug;\n    };\n  };\n\npublic:\n  using egr\
    \ = EgrReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Ccmr1_outputReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using oc2m = FieldModel<uint32_t, address, 12, 3>;\n    using oc2pe = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using oc2fe = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using cc2s = FieldModel<uint32_t, address, 8, 2>;\n    using oc1m = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    using oc1pe = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using oc1fe = FieldModel<uint32_t, address, 2, 1>;\n    using cc1s = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 12, 3> oc2m;\n      BitFieldModel<uint32_t, 11,\
    \ 1> oc2pe;\n      BitFieldModel<uint32_t, 10, 1> oc2fe;\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc2s;\n      BitFieldModel<uint32_t, 4, 3> oc1m;\n      BitFieldModel<uint32_t,\
    \ 3, 1> oc1pe;\n      BitFieldModel<uint32_t, 2, 1> oc1fe;\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc1s;\n    };\n  };\n\npublic:\n  using ccmr1_output = Ccmr1_outputReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class Ccmr1_inputReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ic2f =\
    \ FieldModel<uint32_t, address, 12, 3>;\n    using ic2pcs = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    using cc2s = FieldModel<uint32_t, address, 8, 2>;\n  \
    \  using ic1f = FieldModel<uint32_t, address, 4, 3>;\n    using icpcs = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 12, 3> ic2f;\n      BitFieldModel<uint32_t, 10, 2> ic2pcs;\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc2s;\n      BitFieldModel<uint32_t, 4, 3> ic1f;\n      BitFieldModel<uint32_t,\
    \ 2, 2> icpcs;\n      BitFieldModel<uint32_t, 0, 2> cc1s;\n    };\n  };\n\npublic:\n\
    \  using ccmr1_input = Ccmr1_inputReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CcerReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using cc2np = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ cc2p = FieldModel<uint32_t, address, 5, 1>;\n    using cc2e = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using cc1np = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using cc1p = FieldModel<uint32_t, address, 1, 1>;\n    using cc1e = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> cc2np;\n      BitFieldModel<uint32_t, 5,\
    \ 1> cc2p;\n      BitFieldModel<uint32_t, 4, 1> cc2e;\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc1np;\n      BitFieldModel<uint32_t, 1, 1> cc1p;\n      BitFieldModel<uint32_t,\
    \ 0, 1> cc1e;\n    };\n  };\n\npublic:\n  using ccer = CcerReg<BaseAddress + 0x0020>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CntReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cnt = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> cnt;\n    };\n  };\n\npublic:\n  using cnt = CntReg<BaseAddress + 0x0024>;\n\
    \nprivate:\n  template<unsigned int address>\n  class PscReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using psc = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> psc;\n    };\n  };\n\npublic:\n  using psc = PscReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class ArrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using arr = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> arr;\n    };\n  };\n\npublic:\n  using arr = ArrReg<BaseAddress + 0x002C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Ccr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ccr1 = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr1;\n    };\n  };\n\npublic:\n  using ccr1 = Ccr1Reg<BaseAddress +\
    \ 0x0034>;\n\nprivate:\n  template<unsigned int address>\n  class Ccr2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using ccr2 = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> ccr2;\n    };\n  };\n\npublic:\n  using\
    \ ccr2 = Ccr2Reg<BaseAddress + 0x0038>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_TIM12_H\
    \ */\n"
  name: TIM12
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_TIM10_H\n#define DRAL_STM32F446_TIM10_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass tim10\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40014400;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ckd = FieldModel<uint32_t, address, 8, 2>;\n\
    \    using arpe = FieldModel<uint32_t, address, 7, 1>;\n    using urs = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using udis = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using cen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 2> ckd;\n    \
    \  BitFieldModel<uint32_t, 7, 1> arpe;\n      BitFieldModel<uint32_t, 2, 1> urs;\n\
    \      BitFieldModel<uint32_t, 1, 1> udis;\n      BitFieldModel<uint32_t, 0, 1>\
    \ cen;\n    };\n  };\n\npublic:\n  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DierReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cc1ie = FieldModel<uint32_t, address, 1,\
    \ 1>;\n    using uie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n   \
    \ union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 1, 1>\
    \ cc1ie;\n      BitFieldModel<uint32_t, 0, 1> uie;\n    };\n  };\n\npublic:\n\
    \  using dier = DierReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class SrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using cc1of = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ cc1if = FieldModel<uint32_t, address, 1, 1>;\n    using uif = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 9, 1> cc1of;\n      BitFieldModel<uint32_t, 1,\
    \ 1> cc1if;\n      BitFieldModel<uint32_t, 0, 1> uif;\n    };\n  };\n\npublic:\n\
    \  using sr = SrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class EgrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using cc1g = FieldModel<uint32_t, address, 1, 1>;\n    using ug = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 1, 1> cc1g;\n      BitFieldModel<uint32_t, 0, 1>\
    \ ug;\n    };\n  };\n\npublic:\n  using egr = EgrReg<BaseAddress + 0x0014>;\n\n\
    private:\n  template<unsigned int address>\n  class Ccmr1_outputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using oc1m = FieldModel<uint32_t, address, 4,\
    \ 3>;\n    using oc1pe = FieldModel<uint32_t, address, 3, 1>;\n    using oc1fe\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    using cc1s = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 4, 3> oc1m;\n      BitFieldModel<uint32_t, 3, 1>\
    \ oc1pe;\n      BitFieldModel<uint32_t, 2, 1> oc1fe;\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc1s;\n    };\n  };\n\npublic:\n  using ccmr1_output = Ccmr1_outputReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class Ccmr1_inputReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ic1f =\
    \ FieldModel<uint32_t, address, 4, 4>;\n    using icpcs = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 4, 4> ic1f;\n      BitFieldModel<uint32_t, 2, 2> icpcs;\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc1s;\n    };\n  };\n\npublic:\n  using ccmr1_input = Ccmr1_inputReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class CcerReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using cc1np = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using cc1p = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using cc1e = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 3, 1> cc1np;\n  \
    \    BitFieldModel<uint32_t, 1, 1> cc1p;\n      BitFieldModel<uint32_t, 0, 1>\
    \ cc1e;\n    };\n  };\n\npublic:\n  using ccer = CcerReg<BaseAddress + 0x0020>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CntReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cnt = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> cnt;\n    };\n  };\n\npublic:\n  using cnt = CntReg<BaseAddress + 0x0024>;\n\
    \nprivate:\n  template<unsigned int address>\n  class PscReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using psc = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> psc;\n    };\n  };\n\npublic:\n  using psc = PscReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class ArrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using arr = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> arr;\n    };\n  };\n\npublic:\n  using arr = ArrReg<BaseAddress + 0x002C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Ccr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ccr1 = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr1;\n    };\n  };\n\npublic:\n  using ccr1 = Ccr1Reg<BaseAddress +\
    \ 0x0034>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_TIM10_H */\n"
  name: TIM10
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_TIM13_H\n#define DRAL_STM32F446_TIM13_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass tim13\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40001C00;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ckd = FieldModel<uint32_t, address, 8, 2>;\n\
    \    using arpe = FieldModel<uint32_t, address, 7, 1>;\n    using urs = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using udis = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using cen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 2> ckd;\n    \
    \  BitFieldModel<uint32_t, 7, 1> arpe;\n      BitFieldModel<uint32_t, 2, 1> urs;\n\
    \      BitFieldModel<uint32_t, 1, 1> udis;\n      BitFieldModel<uint32_t, 0, 1>\
    \ cen;\n    };\n  };\n\npublic:\n  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DierReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cc1ie = FieldModel<uint32_t, address, 1,\
    \ 1>;\n    using uie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n   \
    \ union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 1, 1>\
    \ cc1ie;\n      BitFieldModel<uint32_t, 0, 1> uie;\n    };\n  };\n\npublic:\n\
    \  using dier = DierReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class SrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using cc1of = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ cc1if = FieldModel<uint32_t, address, 1, 1>;\n    using uif = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 9, 1> cc1of;\n      BitFieldModel<uint32_t, 1,\
    \ 1> cc1if;\n      BitFieldModel<uint32_t, 0, 1> uif;\n    };\n  };\n\npublic:\n\
    \  using sr = SrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class EgrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using cc1g = FieldModel<uint32_t, address, 1, 1>;\n    using ug = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 1, 1> cc1g;\n      BitFieldModel<uint32_t, 0, 1>\
    \ ug;\n    };\n  };\n\npublic:\n  using egr = EgrReg<BaseAddress + 0x0014>;\n\n\
    private:\n  template<unsigned int address>\n  class Ccmr1_outputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using oc1m = FieldModel<uint32_t, address, 4,\
    \ 3>;\n    using oc1pe = FieldModel<uint32_t, address, 3, 1>;\n    using oc1fe\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    using cc1s = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 4, 3> oc1m;\n      BitFieldModel<uint32_t, 3, 1>\
    \ oc1pe;\n      BitFieldModel<uint32_t, 2, 1> oc1fe;\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc1s;\n    };\n  };\n\npublic:\n  using ccmr1_output = Ccmr1_outputReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class Ccmr1_inputReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ic1f =\
    \ FieldModel<uint32_t, address, 4, 4>;\n    using icpcs = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 4, 4> ic1f;\n      BitFieldModel<uint32_t, 2, 2> icpcs;\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc1s;\n    };\n  };\n\npublic:\n  using ccmr1_input = Ccmr1_inputReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class CcerReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using cc1np = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using cc1p = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using cc1e = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 3, 1> cc1np;\n  \
    \    BitFieldModel<uint32_t, 1, 1> cc1p;\n      BitFieldModel<uint32_t, 0, 1>\
    \ cc1e;\n    };\n  };\n\npublic:\n  using ccer = CcerReg<BaseAddress + 0x0020>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CntReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cnt = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> cnt;\n    };\n  };\n\npublic:\n  using cnt = CntReg<BaseAddress + 0x0024>;\n\
    \nprivate:\n  template<unsigned int address>\n  class PscReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using psc = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> psc;\n    };\n  };\n\npublic:\n  using psc = PscReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class ArrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using arr = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> arr;\n    };\n  };\n\npublic:\n  using arr = ArrReg<BaseAddress + 0x002C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Ccr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ccr1 = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr1;\n    };\n  };\n\npublic:\n  using ccr1 = Ccr1Reg<BaseAddress +\
    \ 0x0034>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_TIM13_H */\n"
  name: TIM13
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_TIM14_H\n#define DRAL_STM32F446_TIM14_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass tim14\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40002000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ckd = FieldModel<uint32_t, address, 8, 2>;\n\
    \    using arpe = FieldModel<uint32_t, address, 7, 1>;\n    using urs = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using udis = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using cen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 2> ckd;\n    \
    \  BitFieldModel<uint32_t, 7, 1> arpe;\n      BitFieldModel<uint32_t, 2, 1> urs;\n\
    \      BitFieldModel<uint32_t, 1, 1> udis;\n      BitFieldModel<uint32_t, 0, 1>\
    \ cen;\n    };\n  };\n\npublic:\n  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DierReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cc1ie = FieldModel<uint32_t, address, 1,\
    \ 1>;\n    using uie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n   \
    \ union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 1, 1>\
    \ cc1ie;\n      BitFieldModel<uint32_t, 0, 1> uie;\n    };\n  };\n\npublic:\n\
    \  using dier = DierReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class SrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using cc1of = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ cc1if = FieldModel<uint32_t, address, 1, 1>;\n    using uif = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 9, 1> cc1of;\n      BitFieldModel<uint32_t, 1,\
    \ 1> cc1if;\n      BitFieldModel<uint32_t, 0, 1> uif;\n    };\n  };\n\npublic:\n\
    \  using sr = SrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class EgrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using cc1g = FieldModel<uint32_t, address, 1, 1>;\n    using ug = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 1, 1> cc1g;\n      BitFieldModel<uint32_t, 0, 1>\
    \ ug;\n    };\n  };\n\npublic:\n  using egr = EgrReg<BaseAddress + 0x0014>;\n\n\
    private:\n  template<unsigned int address>\n  class Ccmr1_outputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using oc1m = FieldModel<uint32_t, address, 4,\
    \ 3>;\n    using oc1pe = FieldModel<uint32_t, address, 3, 1>;\n    using oc1fe\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    using cc1s = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 4, 3> oc1m;\n      BitFieldModel<uint32_t, 3, 1>\
    \ oc1pe;\n      BitFieldModel<uint32_t, 2, 1> oc1fe;\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc1s;\n    };\n  };\n\npublic:\n  using ccmr1_output = Ccmr1_outputReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class Ccmr1_inputReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ic1f =\
    \ FieldModel<uint32_t, address, 4, 4>;\n    using icpcs = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 4, 4> ic1f;\n      BitFieldModel<uint32_t, 2, 2> icpcs;\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc1s;\n    };\n  };\n\npublic:\n  using ccmr1_input = Ccmr1_inputReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class CcerReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using cc1np = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using cc1p = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using cc1e = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 3, 1> cc1np;\n  \
    \    BitFieldModel<uint32_t, 1, 1> cc1p;\n      BitFieldModel<uint32_t, 0, 1>\
    \ cc1e;\n    };\n  };\n\npublic:\n  using ccer = CcerReg<BaseAddress + 0x0020>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CntReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cnt = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> cnt;\n    };\n  };\n\npublic:\n  using cnt = CntReg<BaseAddress + 0x0024>;\n\
    \nprivate:\n  template<unsigned int address>\n  class PscReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using psc = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> psc;\n    };\n  };\n\npublic:\n  using psc = PscReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class ArrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using arr = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> arr;\n    };\n  };\n\npublic:\n  using arr = ArrReg<BaseAddress + 0x002C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Ccr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ccr1 = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr1;\n    };\n  };\n\npublic:\n  using ccr1 = Ccr1Reg<BaseAddress +\
    \ 0x0034>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_TIM14_H */\n"
  name: TIM14
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_TIM11_H\n#define DRAL_STM32F446_TIM11_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass tim11\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40014800;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ckd = FieldModel<uint32_t, address, 8, 2>;\n\
    \    using arpe = FieldModel<uint32_t, address, 7, 1>;\n    using urs = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using udis = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using cen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 2> ckd;\n    \
    \  BitFieldModel<uint32_t, 7, 1> arpe;\n      BitFieldModel<uint32_t, 2, 1> urs;\n\
    \      BitFieldModel<uint32_t, 1, 1> udis;\n      BitFieldModel<uint32_t, 0, 1>\
    \ cen;\n    };\n  };\n\npublic:\n  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DierReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cc1ie = FieldModel<uint32_t, address, 1,\
    \ 1>;\n    using uie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n   \
    \ union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 1, 1>\
    \ cc1ie;\n      BitFieldModel<uint32_t, 0, 1> uie;\n    };\n  };\n\npublic:\n\
    \  using dier = DierReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class SrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using cc1of = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ cc1if = FieldModel<uint32_t, address, 1, 1>;\n    using uif = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 9, 1> cc1of;\n      BitFieldModel<uint32_t, 1,\
    \ 1> cc1if;\n      BitFieldModel<uint32_t, 0, 1> uif;\n    };\n  };\n\npublic:\n\
    \  using sr = SrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class EgrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using cc1g = FieldModel<uint32_t, address, 1, 1>;\n    using ug = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 1, 1> cc1g;\n      BitFieldModel<uint32_t, 0, 1>\
    \ ug;\n    };\n  };\n\npublic:\n  using egr = EgrReg<BaseAddress + 0x0014>;\n\n\
    private:\n  template<unsigned int address>\n  class Ccmr1_outputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using oc1m = FieldModel<uint32_t, address, 4,\
    \ 3>;\n    using oc1pe = FieldModel<uint32_t, address, 3, 1>;\n    using oc1fe\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    using cc1s = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 4, 3> oc1m;\n      BitFieldModel<uint32_t, 3, 1>\
    \ oc1pe;\n      BitFieldModel<uint32_t, 2, 1> oc1fe;\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc1s;\n    };\n  };\n\npublic:\n  using ccmr1_output = Ccmr1_outputReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class Ccmr1_inputReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ic1f =\
    \ FieldModel<uint32_t, address, 4, 4>;\n    using icpcs = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 4, 4> ic1f;\n      BitFieldModel<uint32_t, 2, 2> icpcs;\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc1s;\n    };\n  };\n\npublic:\n  using ccmr1_input = Ccmr1_inputReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class CcerReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using cc1np = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using cc1p = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using cc1e = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 3, 1> cc1np;\n  \
    \    BitFieldModel<uint32_t, 1, 1> cc1p;\n      BitFieldModel<uint32_t, 0, 1>\
    \ cc1e;\n    };\n  };\n\npublic:\n  using ccer = CcerReg<BaseAddress + 0x0020>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CntReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cnt = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> cnt;\n    };\n  };\n\npublic:\n  using cnt = CntReg<BaseAddress + 0x0024>;\n\
    \nprivate:\n  template<unsigned int address>\n  class PscReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using psc = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> psc;\n    };\n  };\n\npublic:\n  using psc = PscReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class ArrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using arr = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> arr;\n    };\n  };\n\npublic:\n  using arr = ArrReg<BaseAddress + 0x002C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Ccr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ccr1 = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ccr1;\n    };\n  };\n\npublic:\n  using ccr1 = Ccr1Reg<BaseAddress +\
    \ 0x0034>;\n\nprivate:\n  template<unsigned int address>\n  class OrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using rmp = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 2> rmp;\n    };\n  };\n\npublic:\n  using or_\
    \ = OrReg<BaseAddress + 0x0050>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_TIM11_H\
    \ */\n"
  name: TIM11
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_TIM6_H\n#define DRAL_STM32F446_TIM6_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass tim6\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40001000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using arpe = FieldModel<uint32_t, address, 7,\
    \ 1>;\n    using opm = FieldModel<uint32_t, address, 3, 1>;\n    using urs = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using udis = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using cen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 7, 1> arpe;\n   \
    \   BitFieldModel<uint32_t, 3, 1> opm;\n      BitFieldModel<uint32_t, 2, 1> urs;\n\
    \      BitFieldModel<uint32_t, 1, 1> udis;\n      BitFieldModel<uint32_t, 0, 1>\
    \ cen;\n    };\n  };\n\npublic:\n  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Cr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using mms = FieldModel<uint32_t, address, 4, 3>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 4, 3> mms;\n    };\n  };\n\npublic:\n  using cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DierReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ude = FieldModel<uint32_t, address, 8, 1>;\n\
    \    using uie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 1> ude;\n\
    \      BitFieldModel<uint32_t, 0, 1> uie;\n    };\n  };\n\npublic:\n  using dier\
    \ = DierReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class SrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ using uif = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> uif;\n    };\n\
    \  };\n\npublic:\n  using sr = SrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class EgrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ug = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 1> ug;\n    };\n  };\n\npublic:\n  using egr = EgrReg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CntReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cnt = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> cnt;\n    };\n  };\n\npublic:\n  using cnt = CntReg<BaseAddress + 0x0024>;\n\
    \nprivate:\n  template<unsigned int address>\n  class PscReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using psc = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> psc;\n    };\n  };\n\npublic:\n  using psc = PscReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class ArrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using arr = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> arr;\n    };\n  };\n\npublic:\n  using arr = ArrReg<BaseAddress + 0x002C>;\n\
    \n\n};\n\n}\n\n#endif /* DRAL_STM32F446_TIM6_H */\n"
  name: TIM6
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_TIM7_H\n#define DRAL_STM32F446_TIM7_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass tim7\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40001400;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using arpe = FieldModel<uint32_t, address, 7,\
    \ 1>;\n    using opm = FieldModel<uint32_t, address, 3, 1>;\n    using urs = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using udis = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using cen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 7, 1> arpe;\n   \
    \   BitFieldModel<uint32_t, 3, 1> opm;\n      BitFieldModel<uint32_t, 2, 1> urs;\n\
    \      BitFieldModel<uint32_t, 1, 1> udis;\n      BitFieldModel<uint32_t, 0, 1>\
    \ cen;\n    };\n  };\n\npublic:\n  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Cr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using mms = FieldModel<uint32_t, address, 4, 3>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 4, 3> mms;\n    };\n  };\n\npublic:\n  using cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DierReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ude = FieldModel<uint32_t, address, 8, 1>;\n\
    \    using uie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 1> ude;\n\
    \      BitFieldModel<uint32_t, 0, 1> uie;\n    };\n  };\n\npublic:\n  using dier\
    \ = DierReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class SrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ using uif = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> uif;\n    };\n\
    \  };\n\npublic:\n  using sr = SrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class EgrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ug = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 1> ug;\n    };\n  };\n\npublic:\n  using egr = EgrReg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CntReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cnt = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> cnt;\n    };\n  };\n\npublic:\n  using cnt = CntReg<BaseAddress + 0x0024>;\n\
    \nprivate:\n  template<unsigned int address>\n  class PscReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using psc = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> psc;\n    };\n  };\n\npublic:\n  using psc = PscReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class ArrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using arr = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> arr;\n    };\n  };\n\npublic:\n  using arr = ArrReg<BaseAddress + 0x002C>;\n\
    \n\n};\n\n}\n\n#endif /* DRAL_STM32F446_TIM7_H */\n"
  name: TIM7
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_CRC_H\n#define DRAL_STM32F446_CRC_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass crc\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40023000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class DrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dr = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> dr;\n    };\n  };\n\npublic:\n  using dr = DrReg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class IdrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using idr = FieldModel<uint32_t, address, 0, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> idr;\n    };\n  };\n\npublic:\n  using idr = IdrReg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cr = FieldModel<uint32_t, address, 0, 1>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> cr;\n    };\n  };\n\npublic:\n  using cr = CrReg<BaseAddress + 0x0008>;\n\
    \n\n};\n\n}\n\n#endif /* DRAL_STM32F446_CRC_H */\n"
  name: CRC
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_OTG_FS_GLOBAL_H\n#define DRAL_STM32F446_OTG_FS_GLOBAL_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass otg_fs_global\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x50000000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_gotgctlReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using srqscs = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using srq = FieldModel<uint32_t, address, 1, 1>;\n    using avaloen\
    \ = FieldModel<uint32_t, address, 4, 1>;\n    using bvaloen = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using bvaloval = FieldModel<uint32_t, address, 7, 1>;\n\
    \    using hngscs = FieldModel<uint32_t, address, 8, 1>;\n    using hnprq = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using hshnpen = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using dhnpen = FieldModel<uint32_t, address, 11, 1>;\n    using cidsts =\
    \ FieldModel<uint32_t, address, 16, 1>;\n    using dbct = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using asvld = FieldModel<uint32_t, address, 18, 1>;\n\
    \    using bsvld = FieldModel<uint32_t, address, 19, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> srqscs;\n\
    \      BitFieldModel<uint32_t, 1, 1> srq;\n      BitFieldModel<uint32_t, 4, 1>\
    \ avaloen;\n      BitFieldModel<uint32_t, 6, 1> bvaloen;\n      BitFieldModel<uint32_t,\
    \ 7, 1> bvaloval;\n      BitFieldModel<uint32_t, 8, 1> hngscs;\n      BitFieldModel<uint32_t,\
    \ 9, 1> hnprq;\n      BitFieldModel<uint32_t, 10, 1> hshnpen;\n      BitFieldModel<uint32_t,\
    \ 11, 1> dhnpen;\n      BitFieldModel<uint32_t, 16, 1> cidsts;\n      BitFieldModel<uint32_t,\
    \ 17, 1> dbct;\n      BitFieldModel<uint32_t, 18, 1> asvld;\n      BitFieldModel<uint32_t,\
    \ 19, 1> bsvld;\n    };\n  };\n\npublic:\n  using fs_gotgctl = Fs_gotgctlReg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_gotgintReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using sedet =\
    \ FieldModel<uint32_t, address, 2, 1>;\n    using srsschg = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using hnsschg = FieldModel<uint32_t, address, 9, 1>;\n\
    \    using hngdet = FieldModel<uint32_t, address, 17, 1>;\n    using adtochg =\
    \ FieldModel<uint32_t, address, 18, 1>;\n    using dbcdne = FieldModel<uint32_t,\
    \ address, 19, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 2, 1> sedet;\n      BitFieldModel<uint32_t, 8,\
    \ 1> srsschg;\n      BitFieldModel<uint32_t, 9, 1> hnsschg;\n      BitFieldModel<uint32_t,\
    \ 17, 1> hngdet;\n      BitFieldModel<uint32_t, 18, 1> adtochg;\n      BitFieldModel<uint32_t,\
    \ 19, 1> dbcdne;\n    };\n  };\n\npublic:\n  using fs_gotgint = Fs_gotgintReg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_gahbcfgReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using gint =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using txfelvl = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using ptxfelvl = FieldModel<uint32_t, address, 8, 1>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> gint;\n      BitFieldModel<uint32_t, 7, 1> txfelvl;\n      BitFieldModel<uint32_t,\
    \ 8, 1> ptxfelvl;\n    };\n  };\n\npublic:\n  using fs_gahbcfg = Fs_gahbcfgReg<BaseAddress\
    \ + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_gusbcfgReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using tocal =\
    \ FieldModel<uint32_t, address, 0, 3>;\n    using physel = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using srpcap = FieldModel<uint32_t, address, 8, 1>;\n \
    \   using hnpcap = FieldModel<uint32_t, address, 9, 1>;\n    using trdt = FieldModel<uint32_t,\
    \ address, 10, 4>;\n    using fhmod = FieldModel<uint32_t, address, 29, 1>;\n\
    \    using fdmod = FieldModel<uint32_t, address, 30, 1>;\n    using ctxpkt = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 3> tocal;\n      BitFieldModel<uint32_t, 6,\
    \ 1> physel;\n      BitFieldModel<uint32_t, 8, 1> srpcap;\n      BitFieldModel<uint32_t,\
    \ 9, 1> hnpcap;\n      BitFieldModel<uint32_t, 10, 4> trdt;\n      BitFieldModel<uint32_t,\
    \ 29, 1> fhmod;\n      BitFieldModel<uint32_t, 30, 1> fdmod;\n      BitFieldModel<uint32_t,\
    \ 31, 1> ctxpkt;\n    };\n  };\n\npublic:\n  using fs_gusbcfg = Fs_gusbcfgReg<BaseAddress\
    \ + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_grstctlReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using csrst =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using hsrst = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using fcrst = FieldModel<uint32_t, address, 2, 1>;\n  \
    \  using rxfflsh = FieldModel<uint32_t, address, 4, 1>;\n    using txfflsh = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using txfnum = FieldModel<uint32_t, address, 6, 5>;\n \
    \   using ahbidl = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> csrst;\n\
    \      BitFieldModel<uint32_t, 1, 1> hsrst;\n      BitFieldModel<uint32_t, 2,\
    \ 1> fcrst;\n      BitFieldModel<uint32_t, 4, 1> rxfflsh;\n      BitFieldModel<uint32_t,\
    \ 5, 1> txfflsh;\n      BitFieldModel<uint32_t, 6, 5> txfnum;\n      BitFieldModel<uint32_t,\
    \ 31, 1> ahbidl;\n    };\n  };\n\npublic:\n  using fs_grstctl = Fs_grstctlReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_gintstsReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using cmod =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using mmis = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using otgint = FieldModel<uint32_t, address, 2, 1>;\n \
    \   using sof = FieldModel<uint32_t, address, 3, 1>;\n    using rxflvl = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using nptxfe = FieldModel<uint32_t, address, 5, 1>;\n \
    \   using ginakeff = FieldModel<uint32_t, address, 6, 1>;\n    using goutnakeff\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    using esusp = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using usbsusp = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using usbrst = FieldModel<uint32_t, address, 12, 1>;\n    using enumdne =\
    \ FieldModel<uint32_t, address, 13, 1>;\n    using isoodrp = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using eopf = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using iepint = FieldModel<uint32_t, address, 18, 1>;\n    using oepint = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using iisoixfr = FieldModel<uint32_t, address, 20, 1>;\n\
    \    using ipxfr_incompisoout = FieldModel<uint32_t, address, 21, 1>;\n    using\
    \ hprtint = FieldModel<uint32_t, address, 24, 1>;\n    using hcint = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using ptxfe = FieldModel<uint32_t, address, 26, 1>;\n\
    \    using cidschg = FieldModel<uint32_t, address, 28, 1>;\n    using discint\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using srqint = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    using wkupint = FieldModel<uint32_t, address, 31, 1>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> cmod;\n      BitFieldModel<uint32_t, 1, 1> mmis;\n      BitFieldModel<uint32_t,\
    \ 2, 1> otgint;\n      BitFieldModel<uint32_t, 3, 1> sof;\n      BitFieldModel<uint32_t,\
    \ 4, 1> rxflvl;\n      BitFieldModel<uint32_t, 5, 1> nptxfe;\n      BitFieldModel<uint32_t,\
    \ 6, 1> ginakeff;\n      BitFieldModel<uint32_t, 7, 1> goutnakeff;\n      BitFieldModel<uint32_t,\
    \ 10, 1> esusp;\n      BitFieldModel<uint32_t, 11, 1> usbsusp;\n      BitFieldModel<uint32_t,\
    \ 12, 1> usbrst;\n      BitFieldModel<uint32_t, 13, 1> enumdne;\n      BitFieldModel<uint32_t,\
    \ 14, 1> isoodrp;\n      BitFieldModel<uint32_t, 15, 1> eopf;\n      BitFieldModel<uint32_t,\
    \ 18, 1> iepint;\n      BitFieldModel<uint32_t, 19, 1> oepint;\n      BitFieldModel<uint32_t,\
    \ 20, 1> iisoixfr;\n      BitFieldModel<uint32_t, 21, 1> ipxfr_incompisoout;\n\
    \      BitFieldModel<uint32_t, 24, 1> hprtint;\n      BitFieldModel<uint32_t,\
    \ 25, 1> hcint;\n      BitFieldModel<uint32_t, 26, 1> ptxfe;\n      BitFieldModel<uint32_t,\
    \ 28, 1> cidschg;\n      BitFieldModel<uint32_t, 29, 1> discint;\n      BitFieldModel<uint32_t,\
    \ 30, 1> srqint;\n      BitFieldModel<uint32_t, 31, 1> wkupint;\n    };\n  };\n\
    \npublic:\n  using fs_gintsts = Fs_gintstsReg<BaseAddress + 0x0014>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_gintmskReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using mmism = FieldModel<uint32_t, address, 1,\
    \ 1>;\n    using otgint = FieldModel<uint32_t, address, 2, 1>;\n    using sofm\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using rxflvlm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using nptxfem = FieldModel<uint32_t, address, 5, 1>;\n\
    \    using ginakeffm = FieldModel<uint32_t, address, 6, 1>;\n    using gonakeffm\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    using esuspm = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using usbsuspm = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using usbrst = FieldModel<uint32_t, address, 12, 1>;\n    using enumdnem\
    \ = FieldModel<uint32_t, address, 13, 1>;\n    using isoodrpm = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using eopfm = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using epmism = FieldModel<uint32_t, address, 17, 1>;\n    using iepint =\
    \ FieldModel<uint32_t, address, 18, 1>;\n    using oepint = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using iisoixfrm = FieldModel<uint32_t, address, 20, 1>;\n\
    \    using ipxfrm_iisooxfrm = FieldModel<uint32_t, address, 21, 1>;\n    using\
    \ prtim = FieldModel<uint32_t, address, 24, 1>;\n    using hcim = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using ptxfem = FieldModel<uint32_t, address, 26, 1>;\n\
    \    using cidschgm = FieldModel<uint32_t, address, 28, 1>;\n    using discint\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using srqim = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    using wuim = FieldModel<uint32_t, address, 31, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 1, 1> mmism;\n      BitFieldModel<uint32_t, 2, 1> otgint;\n      BitFieldModel<uint32_t,\
    \ 3, 1> sofm;\n      BitFieldModel<uint32_t, 4, 1> rxflvlm;\n      BitFieldModel<uint32_t,\
    \ 5, 1> nptxfem;\n      BitFieldModel<uint32_t, 6, 1> ginakeffm;\n      BitFieldModel<uint32_t,\
    \ 7, 1> gonakeffm;\n      BitFieldModel<uint32_t, 10, 1> esuspm;\n      BitFieldModel<uint32_t,\
    \ 11, 1> usbsuspm;\n      BitFieldModel<uint32_t, 12, 1> usbrst;\n      BitFieldModel<uint32_t,\
    \ 13, 1> enumdnem;\n      BitFieldModel<uint32_t, 14, 1> isoodrpm;\n      BitFieldModel<uint32_t,\
    \ 15, 1> eopfm;\n      BitFieldModel<uint32_t, 17, 1> epmism;\n      BitFieldModel<uint32_t,\
    \ 18, 1> iepint;\n      BitFieldModel<uint32_t, 19, 1> oepint;\n      BitFieldModel<uint32_t,\
    \ 20, 1> iisoixfrm;\n      BitFieldModel<uint32_t, 21, 1> ipxfrm_iisooxfrm;\n\
    \      BitFieldModel<uint32_t, 24, 1> prtim;\n      BitFieldModel<uint32_t, 25,\
    \ 1> hcim;\n      BitFieldModel<uint32_t, 26, 1> ptxfem;\n      BitFieldModel<uint32_t,\
    \ 28, 1> cidschgm;\n      BitFieldModel<uint32_t, 29, 1> discint;\n      BitFieldModel<uint32_t,\
    \ 30, 1> srqim;\n      BitFieldModel<uint32_t, 31, 1> wuim;\n    };\n  };\n\n\
    public:\n  using fs_gintmsk = Fs_gintmskReg<BaseAddress + 0x0018>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_grxstsr_deviceReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using epnum = FieldModel<uint32_t, address, 0,\
    \ 4>;\n    using bcnt = FieldModel<uint32_t, address, 4, 11>;\n    using dpid\
    \ = FieldModel<uint32_t, address, 15, 2>;\n    using pktsts = FieldModel<uint32_t,\
    \ address, 17, 4>;\n    using frmnum = FieldModel<uint32_t, address, 21, 4>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 4> epnum;\n      BitFieldModel<uint32_t, 4, 11> bcnt;\n      BitFieldModel<uint32_t,\
    \ 15, 2> dpid;\n      BitFieldModel<uint32_t, 17, 4> pktsts;\n      BitFieldModel<uint32_t,\
    \ 21, 4> frmnum;\n    };\n  };\n\npublic:\n  using fs_grxstsr_device = Fs_grxstsr_deviceReg<BaseAddress\
    \ + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_grxstsp_deviceReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using epnum =\
    \ FieldModel<uint32_t, address, 0, 4>;\n    using bcnt = FieldModel<uint32_t,\
    \ address, 4, 11>;\n    using dpid = FieldModel<uint32_t, address, 15, 2>;\n \
    \   using pktsts = FieldModel<uint32_t, address, 17, 4>;\n    using frmnum = FieldModel<uint32_t,\
    \ address, 21, 4>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 4> epnum;\n      BitFieldModel<uint32_t, 4,\
    \ 11> bcnt;\n      BitFieldModel<uint32_t, 15, 2> dpid;\n      BitFieldModel<uint32_t,\
    \ 17, 4> pktsts;\n      BitFieldModel<uint32_t, 21, 4> frmnum;\n    };\n  };\n\
    \npublic:\n  using fs_grxstsp_device = Fs_grxstsp_deviceReg<BaseAddress + 0x0020>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Fs_grxstsr_hostReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using epnum = FieldModel<uint32_t,\
    \ address, 0, 4>;\n    using bcnt = FieldModel<uint32_t, address, 4, 11>;\n  \
    \  using dpid = FieldModel<uint32_t, address, 15, 2>;\n    using pktsts = FieldModel<uint32_t,\
    \ address, 17, 4>;\n    using frmnum = FieldModel<uint32_t, address, 21, 4>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 4> epnum;\n      BitFieldModel<uint32_t, 4, 11> bcnt;\n      BitFieldModel<uint32_t,\
    \ 15, 2> dpid;\n      BitFieldModel<uint32_t, 17, 4> pktsts;\n      BitFieldModel<uint32_t,\
    \ 21, 4> frmnum;\n    };\n  };\n\npublic:\n  using fs_grxstsr_host = Fs_grxstsr_hostReg<BaseAddress\
    \ + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_grxstsp_hostReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using epnum =\
    \ FieldModel<uint32_t, address, 0, 4>;\n    using bcnt = FieldModel<uint32_t,\
    \ address, 4, 11>;\n    using dpid = FieldModel<uint32_t, address, 15, 2>;\n \
    \   using pktsts = FieldModel<uint32_t, address, 17, 4>;\n    using frmnum = FieldModel<uint32_t,\
    \ address, 21, 4>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 4> epnum;\n      BitFieldModel<uint32_t, 4,\
    \ 11> bcnt;\n      BitFieldModel<uint32_t, 15, 2> dpid;\n      BitFieldModel<uint32_t,\
    \ 17, 4> pktsts;\n      BitFieldModel<uint32_t, 21, 4> frmnum;\n    };\n  };\n\
    \npublic:\n  using fs_grxstsp_host = Fs_grxstsp_hostReg<BaseAddress + 0x0020>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Fs_grxfsizReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using rxfd = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> rxfd;\n    };\n  };\n\npublic:\n  using fs_grxfsiz = Fs_grxfsizReg<BaseAddress\
    \ + 0x0024>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_gnptxfsiz_deviceReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using tx0fsa\
    \ = FieldModel<uint32_t, address, 0, 16>;\n    using tx0fd = FieldModel<uint32_t,\
    \ address, 16, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> tx0fsa;\n      BitFieldModel<uint32_t, 16,\
    \ 16> tx0fd;\n    };\n  };\n\npublic:\n  using fs_gnptxfsiz_device = Fs_gnptxfsiz_deviceReg<BaseAddress\
    \ + 0x0028>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_gnptxfsiz_hostReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using nptxfsa\
    \ = FieldModel<uint32_t, address, 0, 16>;\n    using nptxfd = FieldModel<uint32_t,\
    \ address, 16, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> nptxfsa;\n      BitFieldModel<uint32_t,\
    \ 16, 16> nptxfd;\n    };\n  };\n\npublic:\n  using fs_gnptxfsiz_host = Fs_gnptxfsiz_hostReg<BaseAddress\
    \ + 0x0028>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_gnptxstsReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using nptxfsav\
    \ = FieldModel<uint32_t, address, 0, 16>;\n    using nptqxsav = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using nptxqtop = FieldModel<uint32_t, address, 24, 7>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> nptxfsav;\n      BitFieldModel<uint32_t, 16, 8> nptqxsav;\n      BitFieldModel<uint32_t,\
    \ 24, 7> nptxqtop;\n    };\n  };\n\npublic:\n  using fs_gnptxsts = Fs_gnptxstsReg<BaseAddress\
    \ + 0x002C>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_gccfgReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using pwrdwn\
    \ = FieldModel<uint32_t, address, 16, 1>;\n    using vbusasen = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    using vbusbsen = FieldModel<uint32_t, address, 19, 1>;\n\
    \    using sofouten = FieldModel<uint32_t, address, 20, 1>;\n\n  public:\n   \
    \ union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16, 1>\
    \ pwrdwn;\n      BitFieldModel<uint32_t, 18, 1> vbusasen;\n      BitFieldModel<uint32_t,\
    \ 19, 1> vbusbsen;\n      BitFieldModel<uint32_t, 20, 1> sofouten;\n    };\n \
    \ };\n\npublic:\n  using fs_gccfg = Fs_gccfgReg<BaseAddress + 0x0038>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_cidReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using product_id = FieldModel<uint32_t, address,\
    \ 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> product_id;\n    };\n  };\n\npublic:\n  using fs_cid = Fs_cidReg<BaseAddress\
    \ + 0x003C>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hptxfsizReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ptxsa =\
    \ FieldModel<uint32_t, address, 0, 16>;\n    using ptxfsiz = FieldModel<uint32_t,\
    \ address, 16, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> ptxsa;\n      BitFieldModel<uint32_t, 16,\
    \ 16> ptxfsiz;\n    };\n  };\n\npublic:\n  using fs_hptxfsiz = Fs_hptxfsizReg<BaseAddress\
    \ + 0x0100>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_dieptxf1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ineptxsa\
    \ = FieldModel<uint32_t, address, 0, 16>;\n    using ineptxfd = FieldModel<uint32_t,\
    \ address, 16, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> ineptxsa;\n      BitFieldModel<uint32_t,\
    \ 16, 16> ineptxfd;\n    };\n  };\n\npublic:\n  using fs_dieptxf1 = Fs_dieptxf1Reg<BaseAddress\
    \ + 0x0104>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_dieptxf2Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ineptxsa\
    \ = FieldModel<uint32_t, address, 0, 16>;\n    using ineptxfd = FieldModel<uint32_t,\
    \ address, 16, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> ineptxsa;\n      BitFieldModel<uint32_t,\
    \ 16, 16> ineptxfd;\n    };\n  };\n\npublic:\n  using fs_dieptxf2 = Fs_dieptxf2Reg<BaseAddress\
    \ + 0x0108>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_dieptxf3Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ineptxsa\
    \ = FieldModel<uint32_t, address, 0, 16>;\n    using ineptxfd = FieldModel<uint32_t,\
    \ address, 16, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> ineptxsa;\n      BitFieldModel<uint32_t,\
    \ 16, 16> ineptxfd;\n    };\n  };\n\npublic:\n  using fs_dieptxf3 = Fs_dieptxf3Reg<BaseAddress\
    \ + 0x010C>;\n\nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n\
    \  class Fs_grxstsx_deviceBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using epnum = FieldModel<uint32_t, address,\
    \ 0, 4, bankOffset>;\n    using bcnt = FieldModel<uint32_t, address, 4, 11, bankOffset>;\n\
    \    using dpid = FieldModel<uint32_t, address, 15, 2, bankOffset>;\n    using\
    \ pktsts = FieldModel<uint32_t, address, 17, 4, bankOffset>;\n    using frmnum\
    \ = FieldModel<uint32_t, address, 21, 4, bankOffset>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 4> epnum;\n\
    \      BitFieldModel<uint32_t, 4, 11> bcnt;\n      BitFieldModel<uint32_t, 15,\
    \ 2> dpid;\n      BitFieldModel<uint32_t, 17, 4> pktsts;\n      BitFieldModel<uint32_t,\
    \ 21, 4> frmnum;\n    };\n  };\n\npublic:\n  using fs_grxstsx_device = Fs_grxstsx_deviceBankReg<BaseAddress\
    \ + 0x001C, 0x0004>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class Fs_grxstsx_hostBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using epnum = FieldModel<uint32_t,\
    \ address, 0, 4, bankOffset>;\n    using bcnt = FieldModel<uint32_t, address,\
    \ 4, 11, bankOffset>;\n    using dpid = FieldModel<uint32_t, address, 15, 2, bankOffset>;\n\
    \    using pktsts = FieldModel<uint32_t, address, 17, 4, bankOffset>;\n    using\
    \ frmnum = FieldModel<uint32_t, address, 21, 4, bankOffset>;\n\n  public:\n  \
    \  union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 4>\
    \ epnum;\n      BitFieldModel<uint32_t, 4, 11> bcnt;\n      BitFieldModel<uint32_t,\
    \ 15, 2> dpid;\n      BitFieldModel<uint32_t, 17, 4> pktsts;\n      BitFieldModel<uint32_t,\
    \ 21, 4> frmnum;\n    };\n  };\n\npublic:\n  using fs_grxstsx_host = Fs_grxstsx_hostBankReg<BaseAddress\
    \ + 0x001C, 0x0004>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class Fs_dieptxfxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using ineptxsa = FieldModel<uint32_t,\
    \ address, 0, 16, bankOffset>;\n    using ineptxfd = FieldModel<uint32_t, address,\
    \ 16, 16, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> ineptxsa;\n      BitFieldModel<uint32_t,\
    \ 16, 16> ineptxfd;\n    };\n  };\n\npublic:\n  using fs_dieptxfx = Fs_dieptxfxBankReg<BaseAddress\
    \ + 0x0104, 0x0004>;\n};\n\n}\n\n#endif /* DRAL_STM32F446_OTG_FS_GLOBAL_H */\n"
  name: OTG_FS_GLOBAL
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_OTG_FS_HOST_H\n#define DRAL_STM32F446_OTG_FS_HOST_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass otg_fs_host\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x50000400;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_hcfgReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using fslspcs = FieldModel<uint32_t, address,\
    \ 0, 2>;\n    using fslss = FieldModel<uint32_t, address, 2, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 2> fslspcs;\n      BitFieldModel<uint32_t, 2, 1> fslss;\n    };\n  };\n\npublic:\n\
    \  using fs_hcfg = Fs_hcfgReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class HfirReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using frivl = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> frivl;\n    };\n  };\n\npublic:\n  using hfir = HfirReg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Fs_hfnumReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using frnum = FieldModel<uint32_t, address, 0,\
    \ 16>;\n    using ftrem = FieldModel<uint32_t, address, 16, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> frnum;\n      BitFieldModel<uint32_t, 16, 16> ftrem;\n    };\n  };\n\npublic:\n\
    \  using fs_hfnum = Fs_hfnumReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Fs_hptxstsReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ptxfsavl = FieldModel<uint32_t, address, 0, 16>;\n\
    \    using ptxqsav = FieldModel<uint32_t, address, 16, 8>;\n    using ptxqtop\
    \ = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 16> ptxfsavl;\n     \
    \ BitFieldModel<uint32_t, 16, 8> ptxqsav;\n      BitFieldModel<uint32_t, 24, 8>\
    \ ptxqtop;\n    };\n  };\n\npublic:\n  using fs_hptxsts = Fs_hptxstsReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class HaintReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using haint = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> haint;\n    };\n  };\n\npublic:\n  using\
    \ haint = HaintReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class HaintmskReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using haintm = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> haintm;\n    };\n  };\n\npublic:\n  using haintmsk = HaintmskReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hprtReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using pcsts =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using pcdet = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using pena = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using penchng = FieldModel<uint32_t, address, 3, 1>;\n    using poca = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using pocchng = FieldModel<uint32_t, address, 5, 1>;\n\
    \    using pres = FieldModel<uint32_t, address, 6, 1>;\n    using psusp = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using prst = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using plsts = FieldModel<uint32_t, address, 10, 2>;\n    using ppwr = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using ptctl = FieldModel<uint32_t, address, 13, 4>;\n\
    \    using pspd = FieldModel<uint32_t, address, 17, 2>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> pcsts;\n\
    \      BitFieldModel<uint32_t, 1, 1> pcdet;\n      BitFieldModel<uint32_t, 2,\
    \ 1> pena;\n      BitFieldModel<uint32_t, 3, 1> penchng;\n      BitFieldModel<uint32_t,\
    \ 4, 1> poca;\n      BitFieldModel<uint32_t, 5, 1> pocchng;\n      BitFieldModel<uint32_t,\
    \ 6, 1> pres;\n      BitFieldModel<uint32_t, 7, 1> psusp;\n      BitFieldModel<uint32_t,\
    \ 8, 1> prst;\n      BitFieldModel<uint32_t, 10, 2> plsts;\n      BitFieldModel<uint32_t,\
    \ 12, 1> ppwr;\n      BitFieldModel<uint32_t, 13, 4> ptctl;\n      BitFieldModel<uint32_t,\
    \ 17, 2> pspd;\n    };\n  };\n\npublic:\n  using fs_hprt = Fs_hprtReg<BaseAddress\
    \ + 0x0040>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcchar0Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    using epnum = FieldModel<uint32_t,\
    \ address, 11, 4>;\n    using epdir = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using lsdev = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using mcnt = FieldModel<uint32_t, address, 20, 2>;\n \
    \   using dad = FieldModel<uint32_t, address, 22, 7>;\n    using oddfrm = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using chdis = FieldModel<uint32_t, address, 30, 1>;\n\
    \    using chena = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n\
    \      BitFieldModel<uint32_t, 11, 4> epnum;\n      BitFieldModel<uint32_t, 15,\
    \ 1> epdir;\n      BitFieldModel<uint32_t, 17, 1> lsdev;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 20, 2> mcnt;\n      BitFieldModel<uint32_t,\
    \ 22, 7> dad;\n      BitFieldModel<uint32_t, 29, 1> oddfrm;\n      BitFieldModel<uint32_t,\
    \ 30, 1> chdis;\n      BitFieldModel<uint32_t, 31, 1> chena;\n    };\n  };\n\n\
    public:\n  using fs_hcchar0 = Fs_hcchar0Reg<BaseAddress + 0x0100>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_hcchar1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using mpsiz = FieldModel<uint32_t, address, 0,\
    \ 11>;\n    using epnum = FieldModel<uint32_t, address, 11, 4>;\n    using epdir\
    \ = FieldModel<uint32_t, address, 15, 1>;\n    using lsdev = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using eptyp = FieldModel<uint32_t, address, 18, 2>;\n\
    \    using mcnt = FieldModel<uint32_t, address, 20, 2>;\n    using dad = FieldModel<uint32_t,\
    \ address, 22, 7>;\n    using oddfrm = FieldModel<uint32_t, address, 29, 1>;\n\
    \    using chdis = FieldModel<uint32_t, address, 30, 1>;\n    using chena = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 11> mpsiz;\n      BitFieldModel<uint32_t, 11,\
    \ 4> epnum;\n      BitFieldModel<uint32_t, 15, 1> epdir;\n      BitFieldModel<uint32_t,\
    \ 17, 1> lsdev;\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      BitFieldModel<uint32_t,\
    \ 20, 2> mcnt;\n      BitFieldModel<uint32_t, 22, 7> dad;\n      BitFieldModel<uint32_t,\
    \ 29, 1> oddfrm;\n      BitFieldModel<uint32_t, 30, 1> chdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> chena;\n    };\n  };\n\npublic:\n  using fs_hcchar1 = Fs_hcchar1Reg<BaseAddress\
    \ + 0x0120>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcchar2Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    using epnum = FieldModel<uint32_t,\
    \ address, 11, 4>;\n    using epdir = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using lsdev = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using mcnt = FieldModel<uint32_t, address, 20, 2>;\n \
    \   using dad = FieldModel<uint32_t, address, 22, 7>;\n    using oddfrm = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using chdis = FieldModel<uint32_t, address, 30, 1>;\n\
    \    using chena = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n\
    \      BitFieldModel<uint32_t, 11, 4> epnum;\n      BitFieldModel<uint32_t, 15,\
    \ 1> epdir;\n      BitFieldModel<uint32_t, 17, 1> lsdev;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 20, 2> mcnt;\n      BitFieldModel<uint32_t,\
    \ 22, 7> dad;\n      BitFieldModel<uint32_t, 29, 1> oddfrm;\n      BitFieldModel<uint32_t,\
    \ 30, 1> chdis;\n      BitFieldModel<uint32_t, 31, 1> chena;\n    };\n  };\n\n\
    public:\n  using fs_hcchar2 = Fs_hcchar2Reg<BaseAddress + 0x0140>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_hcchar3Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using mpsiz = FieldModel<uint32_t, address, 0,\
    \ 11>;\n    using epnum = FieldModel<uint32_t, address, 11, 4>;\n    using epdir\
    \ = FieldModel<uint32_t, address, 15, 1>;\n    using lsdev = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using eptyp = FieldModel<uint32_t, address, 18, 2>;\n\
    \    using mcnt = FieldModel<uint32_t, address, 20, 2>;\n    using dad = FieldModel<uint32_t,\
    \ address, 22, 7>;\n    using oddfrm = FieldModel<uint32_t, address, 29, 1>;\n\
    \    using chdis = FieldModel<uint32_t, address, 30, 1>;\n    using chena = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 11> mpsiz;\n      BitFieldModel<uint32_t, 11,\
    \ 4> epnum;\n      BitFieldModel<uint32_t, 15, 1> epdir;\n      BitFieldModel<uint32_t,\
    \ 17, 1> lsdev;\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      BitFieldModel<uint32_t,\
    \ 20, 2> mcnt;\n      BitFieldModel<uint32_t, 22, 7> dad;\n      BitFieldModel<uint32_t,\
    \ 29, 1> oddfrm;\n      BitFieldModel<uint32_t, 30, 1> chdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> chena;\n    };\n  };\n\npublic:\n  using fs_hcchar3 = Fs_hcchar3Reg<BaseAddress\
    \ + 0x0160>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcchar4Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    using epnum = FieldModel<uint32_t,\
    \ address, 11, 4>;\n    using epdir = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using lsdev = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using mcnt = FieldModel<uint32_t, address, 20, 2>;\n \
    \   using dad = FieldModel<uint32_t, address, 22, 7>;\n    using oddfrm = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using chdis = FieldModel<uint32_t, address, 30, 1>;\n\
    \    using chena = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n\
    \      BitFieldModel<uint32_t, 11, 4> epnum;\n      BitFieldModel<uint32_t, 15,\
    \ 1> epdir;\n      BitFieldModel<uint32_t, 17, 1> lsdev;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 20, 2> mcnt;\n      BitFieldModel<uint32_t,\
    \ 22, 7> dad;\n      BitFieldModel<uint32_t, 29, 1> oddfrm;\n      BitFieldModel<uint32_t,\
    \ 30, 1> chdis;\n      BitFieldModel<uint32_t, 31, 1> chena;\n    };\n  };\n\n\
    public:\n  using fs_hcchar4 = Fs_hcchar4Reg<BaseAddress + 0x0180>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_hcchar5Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using mpsiz = FieldModel<uint32_t, address, 0,\
    \ 11>;\n    using epnum = FieldModel<uint32_t, address, 11, 4>;\n    using epdir\
    \ = FieldModel<uint32_t, address, 15, 1>;\n    using lsdev = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using eptyp = FieldModel<uint32_t, address, 18, 2>;\n\
    \    using mcnt = FieldModel<uint32_t, address, 20, 2>;\n    using dad = FieldModel<uint32_t,\
    \ address, 22, 7>;\n    using oddfrm = FieldModel<uint32_t, address, 29, 1>;\n\
    \    using chdis = FieldModel<uint32_t, address, 30, 1>;\n    using chena = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 11> mpsiz;\n      BitFieldModel<uint32_t, 11,\
    \ 4> epnum;\n      BitFieldModel<uint32_t, 15, 1> epdir;\n      BitFieldModel<uint32_t,\
    \ 17, 1> lsdev;\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      BitFieldModel<uint32_t,\
    \ 20, 2> mcnt;\n      BitFieldModel<uint32_t, 22, 7> dad;\n      BitFieldModel<uint32_t,\
    \ 29, 1> oddfrm;\n      BitFieldModel<uint32_t, 30, 1> chdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> chena;\n    };\n  };\n\npublic:\n  using fs_hcchar5 = Fs_hcchar5Reg<BaseAddress\
    \ + 0x01A0>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcchar6Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    using epnum = FieldModel<uint32_t,\
    \ address, 11, 4>;\n    using epdir = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using lsdev = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using mcnt = FieldModel<uint32_t, address, 20, 2>;\n \
    \   using dad = FieldModel<uint32_t, address, 22, 7>;\n    using oddfrm = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using chdis = FieldModel<uint32_t, address, 30, 1>;\n\
    \    using chena = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n\
    \      BitFieldModel<uint32_t, 11, 4> epnum;\n      BitFieldModel<uint32_t, 15,\
    \ 1> epdir;\n      BitFieldModel<uint32_t, 17, 1> lsdev;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 20, 2> mcnt;\n      BitFieldModel<uint32_t,\
    \ 22, 7> dad;\n      BitFieldModel<uint32_t, 29, 1> oddfrm;\n      BitFieldModel<uint32_t,\
    \ 30, 1> chdis;\n      BitFieldModel<uint32_t, 31, 1> chena;\n    };\n  };\n\n\
    public:\n  using fs_hcchar6 = Fs_hcchar6Reg<BaseAddress + 0x01C0>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_hcchar7Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using mpsiz = FieldModel<uint32_t, address, 0,\
    \ 11>;\n    using epnum = FieldModel<uint32_t, address, 11, 4>;\n    using epdir\
    \ = FieldModel<uint32_t, address, 15, 1>;\n    using lsdev = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using eptyp = FieldModel<uint32_t, address, 18, 2>;\n\
    \    using mcnt = FieldModel<uint32_t, address, 20, 2>;\n    using dad = FieldModel<uint32_t,\
    \ address, 22, 7>;\n    using oddfrm = FieldModel<uint32_t, address, 29, 1>;\n\
    \    using chdis = FieldModel<uint32_t, address, 30, 1>;\n    using chena = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 11> mpsiz;\n      BitFieldModel<uint32_t, 11,\
    \ 4> epnum;\n      BitFieldModel<uint32_t, 15, 1> epdir;\n      BitFieldModel<uint32_t,\
    \ 17, 1> lsdev;\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      BitFieldModel<uint32_t,\
    \ 20, 2> mcnt;\n      BitFieldModel<uint32_t, 22, 7> dad;\n      BitFieldModel<uint32_t,\
    \ 29, 1> oddfrm;\n      BitFieldModel<uint32_t, 30, 1> chdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> chena;\n    };\n  };\n\npublic:\n  using fs_hcchar7 = Fs_hcchar7Reg<BaseAddress\
    \ + 0x01E0>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcint0Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chh = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    using stall = FieldModel<uint32_t, address, 3, 1>;\n    using nak\
    \ = FieldModel<uint32_t, address, 4, 1>;\n    using ack = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using txerr = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using bberr = FieldModel<uint32_t, address, 8, 1>;\n    using frmor = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dterr = FieldModel<uint32_t, address, 10, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1> chh;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stall;\n      BitFieldModel<uint32_t, 4, 1> nak;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberr;\n      BitFieldModel<uint32_t, 9, 1> frmor;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterr;\n    };\n  };\n\npublic:\n  using fs_hcint0 = Fs_hcint0Reg<BaseAddress\
    \ + 0x0108>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcint1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chh = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    using stall = FieldModel<uint32_t, address, 3, 1>;\n    using nak\
    \ = FieldModel<uint32_t, address, 4, 1>;\n    using ack = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using txerr = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using bberr = FieldModel<uint32_t, address, 8, 1>;\n    using frmor = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dterr = FieldModel<uint32_t, address, 10, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1> chh;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stall;\n      BitFieldModel<uint32_t, 4, 1> nak;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberr;\n      BitFieldModel<uint32_t, 9, 1> frmor;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterr;\n    };\n  };\n\npublic:\n  using fs_hcint1 = Fs_hcint1Reg<BaseAddress\
    \ + 0x0128>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcint2Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chh = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    using stall = FieldModel<uint32_t, address, 3, 1>;\n    using nak\
    \ = FieldModel<uint32_t, address, 4, 1>;\n    using ack = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using txerr = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using bberr = FieldModel<uint32_t, address, 8, 1>;\n    using frmor = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dterr = FieldModel<uint32_t, address, 10, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1> chh;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stall;\n      BitFieldModel<uint32_t, 4, 1> nak;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberr;\n      BitFieldModel<uint32_t, 9, 1> frmor;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterr;\n    };\n  };\n\npublic:\n  using fs_hcint2 = Fs_hcint2Reg<BaseAddress\
    \ + 0x0148>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcint3Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chh = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    using stall = FieldModel<uint32_t, address, 3, 1>;\n    using nak\
    \ = FieldModel<uint32_t, address, 4, 1>;\n    using ack = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using txerr = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using bberr = FieldModel<uint32_t, address, 8, 1>;\n    using frmor = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dterr = FieldModel<uint32_t, address, 10, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1> chh;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stall;\n      BitFieldModel<uint32_t, 4, 1> nak;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberr;\n      BitFieldModel<uint32_t, 9, 1> frmor;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterr;\n    };\n  };\n\npublic:\n  using fs_hcint3 = Fs_hcint3Reg<BaseAddress\
    \ + 0x0168>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcint4Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chh = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    using stall = FieldModel<uint32_t, address, 3, 1>;\n    using nak\
    \ = FieldModel<uint32_t, address, 4, 1>;\n    using ack = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using txerr = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using bberr = FieldModel<uint32_t, address, 8, 1>;\n    using frmor = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dterr = FieldModel<uint32_t, address, 10, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1> chh;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stall;\n      BitFieldModel<uint32_t, 4, 1> nak;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberr;\n      BitFieldModel<uint32_t, 9, 1> frmor;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterr;\n    };\n  };\n\npublic:\n  using fs_hcint4 = Fs_hcint4Reg<BaseAddress\
    \ + 0x0188>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcint5Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chh = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    using stall = FieldModel<uint32_t, address, 3, 1>;\n    using nak\
    \ = FieldModel<uint32_t, address, 4, 1>;\n    using ack = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using txerr = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using bberr = FieldModel<uint32_t, address, 8, 1>;\n    using frmor = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dterr = FieldModel<uint32_t, address, 10, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1> chh;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stall;\n      BitFieldModel<uint32_t, 4, 1> nak;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberr;\n      BitFieldModel<uint32_t, 9, 1> frmor;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterr;\n    };\n  };\n\npublic:\n  using fs_hcint5 = Fs_hcint5Reg<BaseAddress\
    \ + 0x01A8>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcint6Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chh = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    using stall = FieldModel<uint32_t, address, 3, 1>;\n    using nak\
    \ = FieldModel<uint32_t, address, 4, 1>;\n    using ack = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using txerr = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using bberr = FieldModel<uint32_t, address, 8, 1>;\n    using frmor = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dterr = FieldModel<uint32_t, address, 10, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1> chh;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stall;\n      BitFieldModel<uint32_t, 4, 1> nak;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberr;\n      BitFieldModel<uint32_t, 9, 1> frmor;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterr;\n    };\n  };\n\npublic:\n  using fs_hcint6 = Fs_hcint6Reg<BaseAddress\
    \ + 0x01C8>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcint7Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chh = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    using stall = FieldModel<uint32_t, address, 3, 1>;\n    using nak\
    \ = FieldModel<uint32_t, address, 4, 1>;\n    using ack = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using txerr = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using bberr = FieldModel<uint32_t, address, 8, 1>;\n    using frmor = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dterr = FieldModel<uint32_t, address, 10, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1> chh;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stall;\n      BitFieldModel<uint32_t, 4, 1> nak;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberr;\n      BitFieldModel<uint32_t, 9, 1> frmor;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterr;\n    };\n  };\n\npublic:\n  using fs_hcint7 = Fs_hcint7Reg<BaseAddress\
    \ + 0x01E8>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcintmsk0Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrcm =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chhm = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using stallm = FieldModel<uint32_t, address, 3, 1>;\n \
    \   using nakm = FieldModel<uint32_t, address, 4, 1>;\n    using ackm = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using nyet = FieldModel<uint32_t, address, 6, 1>;\n   \
    \ using txerrm = FieldModel<uint32_t, address, 7, 1>;\n    using bberrm = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using frmorm = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using dterrm = FieldModel<uint32_t, address, 10, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> xfrcm;\n\
    \      BitFieldModel<uint32_t, 1, 1> chhm;\n      BitFieldModel<uint32_t, 3, 1>\
    \ stallm;\n      BitFieldModel<uint32_t, 4, 1> nakm;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ackm;\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerrm;\n      BitFieldModel<uint32_t, 8, 1> bberrm;\n      BitFieldModel<uint32_t,\
    \ 9, 1> frmorm;\n      BitFieldModel<uint32_t, 10, 1> dterrm;\n    };\n  };\n\n\
    public:\n  using fs_hcintmsk0 = Fs_hcintmsk0Reg<BaseAddress + 0x010C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_hcintmsk1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using xfrcm = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using chhm = FieldModel<uint32_t, address, 1, 1>;\n    using stallm\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using nakm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ackm = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using nyet = FieldModel<uint32_t, address, 6, 1>;\n    using txerrm = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bberrm = FieldModel<uint32_t, address, 8, 1>;\n \
    \   using frmorm = FieldModel<uint32_t, address, 9, 1>;\n    using dterrm = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      BitFieldModel<uint32_t, 1,\
    \ 1> chhm;\n      BitFieldModel<uint32_t, 3, 1> stallm;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nakm;\n      BitFieldModel<uint32_t, 5, 1> ackm;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nyet;\n      BitFieldModel<uint32_t, 7, 1> txerrm;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberrm;\n      BitFieldModel<uint32_t, 9, 1> frmorm;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterrm;\n    };\n  };\n\npublic:\n  using fs_hcintmsk1 = Fs_hcintmsk1Reg<BaseAddress\
    \ + 0x012C>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcintmsk2Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrcm =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chhm = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using stallm = FieldModel<uint32_t, address, 3, 1>;\n \
    \   using nakm = FieldModel<uint32_t, address, 4, 1>;\n    using ackm = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using nyet = FieldModel<uint32_t, address, 6, 1>;\n   \
    \ using txerrm = FieldModel<uint32_t, address, 7, 1>;\n    using bberrm = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using frmorm = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using dterrm = FieldModel<uint32_t, address, 10, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> xfrcm;\n\
    \      BitFieldModel<uint32_t, 1, 1> chhm;\n      BitFieldModel<uint32_t, 3, 1>\
    \ stallm;\n      BitFieldModel<uint32_t, 4, 1> nakm;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ackm;\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerrm;\n      BitFieldModel<uint32_t, 8, 1> bberrm;\n      BitFieldModel<uint32_t,\
    \ 9, 1> frmorm;\n      BitFieldModel<uint32_t, 10, 1> dterrm;\n    };\n  };\n\n\
    public:\n  using fs_hcintmsk2 = Fs_hcintmsk2Reg<BaseAddress + 0x014C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_hcintmsk3Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using xfrcm = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using chhm = FieldModel<uint32_t, address, 1, 1>;\n    using stallm\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using nakm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ackm = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using nyet = FieldModel<uint32_t, address, 6, 1>;\n    using txerrm = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bberrm = FieldModel<uint32_t, address, 8, 1>;\n \
    \   using frmorm = FieldModel<uint32_t, address, 9, 1>;\n    using dterrm = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      BitFieldModel<uint32_t, 1,\
    \ 1> chhm;\n      BitFieldModel<uint32_t, 3, 1> stallm;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nakm;\n      BitFieldModel<uint32_t, 5, 1> ackm;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nyet;\n      BitFieldModel<uint32_t, 7, 1> txerrm;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberrm;\n      BitFieldModel<uint32_t, 9, 1> frmorm;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterrm;\n    };\n  };\n\npublic:\n  using fs_hcintmsk3 = Fs_hcintmsk3Reg<BaseAddress\
    \ + 0x016C>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcintmsk4Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrcm =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chhm = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using stallm = FieldModel<uint32_t, address, 3, 1>;\n \
    \   using nakm = FieldModel<uint32_t, address, 4, 1>;\n    using ackm = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using nyet = FieldModel<uint32_t, address, 6, 1>;\n   \
    \ using txerrm = FieldModel<uint32_t, address, 7, 1>;\n    using bberrm = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using frmorm = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using dterrm = FieldModel<uint32_t, address, 10, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> xfrcm;\n\
    \      BitFieldModel<uint32_t, 1, 1> chhm;\n      BitFieldModel<uint32_t, 3, 1>\
    \ stallm;\n      BitFieldModel<uint32_t, 4, 1> nakm;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ackm;\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerrm;\n      BitFieldModel<uint32_t, 8, 1> bberrm;\n      BitFieldModel<uint32_t,\
    \ 9, 1> frmorm;\n      BitFieldModel<uint32_t, 10, 1> dterrm;\n    };\n  };\n\n\
    public:\n  using fs_hcintmsk4 = Fs_hcintmsk4Reg<BaseAddress + 0x018C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_hcintmsk5Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using xfrcm = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using chhm = FieldModel<uint32_t, address, 1, 1>;\n    using stallm\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using nakm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ackm = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using nyet = FieldModel<uint32_t, address, 6, 1>;\n    using txerrm = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bberrm = FieldModel<uint32_t, address, 8, 1>;\n \
    \   using frmorm = FieldModel<uint32_t, address, 9, 1>;\n    using dterrm = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      BitFieldModel<uint32_t, 1,\
    \ 1> chhm;\n      BitFieldModel<uint32_t, 3, 1> stallm;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nakm;\n      BitFieldModel<uint32_t, 5, 1> ackm;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nyet;\n      BitFieldModel<uint32_t, 7, 1> txerrm;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberrm;\n      BitFieldModel<uint32_t, 9, 1> frmorm;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterrm;\n    };\n  };\n\npublic:\n  using fs_hcintmsk5 = Fs_hcintmsk5Reg<BaseAddress\
    \ + 0x01AC>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcintmsk6Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrcm =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chhm = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using stallm = FieldModel<uint32_t, address, 3, 1>;\n \
    \   using nakm = FieldModel<uint32_t, address, 4, 1>;\n    using ackm = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using nyet = FieldModel<uint32_t, address, 6, 1>;\n   \
    \ using txerrm = FieldModel<uint32_t, address, 7, 1>;\n    using bberrm = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using frmorm = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using dterrm = FieldModel<uint32_t, address, 10, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> xfrcm;\n\
    \      BitFieldModel<uint32_t, 1, 1> chhm;\n      BitFieldModel<uint32_t, 3, 1>\
    \ stallm;\n      BitFieldModel<uint32_t, 4, 1> nakm;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ackm;\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerrm;\n      BitFieldModel<uint32_t, 8, 1> bberrm;\n      BitFieldModel<uint32_t,\
    \ 9, 1> frmorm;\n      BitFieldModel<uint32_t, 10, 1> dterrm;\n    };\n  };\n\n\
    public:\n  using fs_hcintmsk6 = Fs_hcintmsk6Reg<BaseAddress + 0x01CC>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_hcintmsk7Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using xfrcm = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using chhm = FieldModel<uint32_t, address, 1, 1>;\n    using stallm\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using nakm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ackm = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using nyet = FieldModel<uint32_t, address, 6, 1>;\n    using txerrm = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bberrm = FieldModel<uint32_t, address, 8, 1>;\n \
    \   using frmorm = FieldModel<uint32_t, address, 9, 1>;\n    using dterrm = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      BitFieldModel<uint32_t, 1,\
    \ 1> chhm;\n      BitFieldModel<uint32_t, 3, 1> stallm;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nakm;\n      BitFieldModel<uint32_t, 5, 1> ackm;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nyet;\n      BitFieldModel<uint32_t, 7, 1> txerrm;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberrm;\n      BitFieldModel<uint32_t, 9, 1> frmorm;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterrm;\n    };\n  };\n\npublic:\n  using fs_hcintmsk7 = Fs_hcintmsk7Reg<BaseAddress\
    \ + 0x01EC>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hctsiz0Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using dpid = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  using fs_hctsiz0 = Fs_hctsiz0Reg<BaseAddress\
    \ + 0x0110>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hctsiz1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using dpid = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  using fs_hctsiz1 = Fs_hctsiz1Reg<BaseAddress\
    \ + 0x0130>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hctsiz2Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using dpid = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  using fs_hctsiz2 = Fs_hctsiz2Reg<BaseAddress\
    \ + 0x0150>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hctsiz3Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using dpid = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  using fs_hctsiz3 = Fs_hctsiz3Reg<BaseAddress\
    \ + 0x0170>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hctsiz4Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using dpid = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  using fs_hctsiz4 = Fs_hctsiz4Reg<BaseAddress\
    \ + 0x0190>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hctsiz5Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using dpid = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  using fs_hctsiz5 = Fs_hctsiz5Reg<BaseAddress\
    \ + 0x01B0>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hctsiz6Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using dpid = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  using fs_hctsiz6 = Fs_hctsiz6Reg<BaseAddress\
    \ + 0x01D0>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hctsiz7Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using dpid = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  using fs_hctsiz7 = Fs_hctsiz7Reg<BaseAddress\
    \ + 0x01F0>;\n\nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n\
    \  class Fs_hccharxBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n\
    \  {\n  public:\n    using mpsiz = FieldModel<uint32_t, address, 0, 11, bankOffset>;\n\
    \    using epnum = FieldModel<uint32_t, address, 11, 4, bankOffset>;\n    using\
    \ epdir = FieldModel<uint32_t, address, 15, 1, bankOffset>;\n    using lsdev =\
    \ FieldModel<uint32_t, address, 17, 1, bankOffset>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2, bankOffset>;\n    using mcnt = FieldModel<uint32_t, address,\
    \ 20, 2, bankOffset>;\n    using dad = FieldModel<uint32_t, address, 22, 7, bankOffset>;\n\
    \    using oddfrm = FieldModel<uint32_t, address, 29, 1, bankOffset>;\n    using\
    \ chdis = FieldModel<uint32_t, address, 30, 1, bankOffset>;\n    using chena =\
    \ FieldModel<uint32_t, address, 31, 1, bankOffset>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n \
    \     BitFieldModel<uint32_t, 11, 4> epnum;\n      BitFieldModel<uint32_t, 15,\
    \ 1> epdir;\n      BitFieldModel<uint32_t, 17, 1> lsdev;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 20, 2> mcnt;\n      BitFieldModel<uint32_t,\
    \ 22, 7> dad;\n      BitFieldModel<uint32_t, 29, 1> oddfrm;\n      BitFieldModel<uint32_t,\
    \ 30, 1> chdis;\n      BitFieldModel<uint32_t, 31, 1> chena;\n    };\n  };\n\n\
    public:\n  using fs_hccharx = Fs_hccharxBankReg<BaseAddress + 0x0100, 0x0020>;\n\
    \nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n  class\
    \ Fs_hcintxBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n\
    \  {\n  public:\n    using xfrc = FieldModel<uint32_t, address, 0, 1, bankOffset>;\n\
    \    using chh = FieldModel<uint32_t, address, 1, 1, bankOffset>;\n    using stall\
    \ = FieldModel<uint32_t, address, 3, 1, bankOffset>;\n    using nak = FieldModel<uint32_t,\
    \ address, 4, 1, bankOffset>;\n    using ack = FieldModel<uint32_t, address, 5,\
    \ 1, bankOffset>;\n    using txerr = FieldModel<uint32_t, address, 7, 1, bankOffset>;\n\
    \    using bberr = FieldModel<uint32_t, address, 8, 1, bankOffset>;\n    using\
    \ frmor = FieldModel<uint32_t, address, 9, 1, bankOffset>;\n    using dterr =\
    \ FieldModel<uint32_t, address, 10, 1, bankOffset>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n   \
    \   BitFieldModel<uint32_t, 1, 1> chh;\n      BitFieldModel<uint32_t, 3, 1> stall;\n\
    \      BitFieldModel<uint32_t, 4, 1> nak;\n      BitFieldModel<uint32_t, 5, 1>\
    \ ack;\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberr;\n      BitFieldModel<uint32_t, 9, 1> frmor;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterr;\n    };\n  };\n\npublic:\n  using fs_hcintx = Fs_hcintxBankReg<BaseAddress\
    \ + 0x0108, 0x0020>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class Fs_hcintmskxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using xfrcm = FieldModel<uint32_t,\
    \ address, 0, 1, bankOffset>;\n    using chhm = FieldModel<uint32_t, address,\
    \ 1, 1, bankOffset>;\n    using stallm = FieldModel<uint32_t, address, 3, 1, bankOffset>;\n\
    \    using nakm = FieldModel<uint32_t, address, 4, 1, bankOffset>;\n    using\
    \ ackm = FieldModel<uint32_t, address, 5, 1, bankOffset>;\n    using nyet = FieldModel<uint32_t,\
    \ address, 6, 1, bankOffset>;\n    using txerrm = FieldModel<uint32_t, address,\
    \ 7, 1, bankOffset>;\n    using bberrm = FieldModel<uint32_t, address, 8, 1, bankOffset>;\n\
    \    using frmorm = FieldModel<uint32_t, address, 9, 1, bankOffset>;\n    using\
    \ dterrm = FieldModel<uint32_t, address, 10, 1, bankOffset>;\n\n  public:\n  \
    \  union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1>\
    \ xfrcm;\n      BitFieldModel<uint32_t, 1, 1> chhm;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stallm;\n      BitFieldModel<uint32_t, 4, 1> nakm;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ackm;\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerrm;\n      BitFieldModel<uint32_t, 8, 1> bberrm;\n      BitFieldModel<uint32_t,\
    \ 9, 1> frmorm;\n      BitFieldModel<uint32_t, 10, 1> dterrm;\n    };\n  };\n\n\
    public:\n  using fs_hcintmskx = Fs_hcintmskxBankReg<BaseAddress + 0x010C, 0x0020>;\n\
    \nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n  class\
    \ Fs_hctsizxBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n\
    \  {\n  public:\n    using xfrsiz = FieldModel<uint32_t, address, 0, 19, bankOffset>;\n\
    \    using pktcnt = FieldModel<uint32_t, address, 19, 10, bankOffset>;\n    using\
    \ dpid = FieldModel<uint32_t, address, 29, 2, bankOffset>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 19> xfrsiz;\n\
    \      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  using fs_hctsizx = Fs_hctsizxBankReg<BaseAddress\
    \ + 0x0110, 0x0020>;\n};\n\n}\n\n#endif /* DRAL_STM32F446_OTG_FS_HOST_H */\n"
  name: OTG_FS_HOST
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_OTG_FS_DEVICE_H\n#define DRAL_STM32F446_OTG_FS_DEVICE_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass otg_fs_device\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x50000800;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_dcfgReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dspd = FieldModel<uint32_t, address, 0,\
    \ 2>;\n    using nzlsohsk = FieldModel<uint32_t, address, 2, 1>;\n    using dad\
    \ = FieldModel<uint32_t, address, 4, 7>;\n    using pfivl = FieldModel<uint32_t,\
    \ address, 11, 2>;\n    using erratim = FieldModel<uint32_t, address, 15, 1>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 2> dspd;\n      BitFieldModel<uint32_t, 2, 1> nzlsohsk;\n      BitFieldModel<uint32_t,\
    \ 4, 7> dad;\n      BitFieldModel<uint32_t, 11, 2> pfivl;\n      BitFieldModel<uint32_t,\
    \ 15, 1> erratim;\n    };\n  };\n\npublic:\n  using fs_dcfg = Fs_dcfgReg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_dctlReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using rwusig\
    \ = FieldModel<uint32_t, address, 0, 1>;\n    using sdis = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ginsts = FieldModel<uint32_t, address, 2, 1>;\n \
    \   using gonsts = FieldModel<uint32_t, address, 3, 1>;\n    using tctl = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    using sginak = FieldModel<uint32_t, address, 7, 1>;\n \
    \   using cginak = FieldModel<uint32_t, address, 8, 1>;\n    using sgonak = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using cgonak = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using poprgdne = FieldModel<uint32_t, address, 11, 1>;\n\n  public:\n   \
    \ union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1>\
    \ rwusig;\n      BitFieldModel<uint32_t, 1, 1> sdis;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ginsts;\n      BitFieldModel<uint32_t, 3, 1> gonsts;\n      BitFieldModel<uint32_t,\
    \ 4, 3> tctl;\n      BitFieldModel<uint32_t, 7, 1> sginak;\n      BitFieldModel<uint32_t,\
    \ 8, 1> cginak;\n      BitFieldModel<uint32_t, 9, 1> sgonak;\n      BitFieldModel<uint32_t,\
    \ 10, 1> cgonak;\n      BitFieldModel<uint32_t, 11, 1> poprgdne;\n    };\n  };\n\
    \npublic:\n  using fs_dctl = Fs_dctlReg<BaseAddress + 0x0004>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Fs_dstsReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using suspsts = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    using enumspd = FieldModel<uint32_t, address, 1, 2>;\n    using\
    \ eerr = FieldModel<uint32_t, address, 3, 1>;\n    using fnsof = FieldModel<uint32_t,\
    \ address, 8, 14>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> suspsts;\n      BitFieldModel<uint32_t, 1,\
    \ 2> enumspd;\n      BitFieldModel<uint32_t, 3, 1> eerr;\n      BitFieldModel<uint32_t,\
    \ 8, 14> fnsof;\n    };\n  };\n\npublic:\n  using fs_dsts = Fs_dstsReg<BaseAddress\
    \ + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_diepmskReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrcm =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using epdm = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using tom = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ ittxfemsk = FieldModel<uint32_t, address, 4, 1>;\n    using inepnmm = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using inepnem = FieldModel<uint32_t, address, 6, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrcm;\n      BitFieldModel<uint32_t, 1, 1> epdm;\n      BitFieldModel<uint32_t,\
    \ 3, 1> tom;\n      BitFieldModel<uint32_t, 4, 1> ittxfemsk;\n      BitFieldModel<uint32_t,\
    \ 5, 1> inepnmm;\n      BitFieldModel<uint32_t, 6, 1> inepnem;\n    };\n  };\n\
    \npublic:\n  using fs_diepmsk = Fs_diepmskReg<BaseAddress + 0x0010>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_doepmskReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using xfrcm = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using epdm = FieldModel<uint32_t, address, 1, 1>;\n    using stupm\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using otepdm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      BitFieldModel<uint32_t, 1,\
    \ 1> epdm;\n      BitFieldModel<uint32_t, 3, 1> stupm;\n      BitFieldModel<uint32_t,\
    \ 4, 1> otepdm;\n    };\n  };\n\npublic:\n  using fs_doepmsk = Fs_doepmskReg<BaseAddress\
    \ + 0x0014>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_daintReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using iepint\
    \ = FieldModel<uint32_t, address, 0, 16>;\n    using oepint = FieldModel<uint32_t,\
    \ address, 16, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> iepint;\n      BitFieldModel<uint32_t, 16,\
    \ 16> oepint;\n    };\n  };\n\npublic:\n  using fs_daint = Fs_daintReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_daintmskReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using iepm =\
    \ FieldModel<uint32_t, address, 0, 16>;\n    using oepm = FieldModel<uint32_t,\
    \ address, 16, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> iepm;\n      BitFieldModel<uint32_t, 16,\
    \ 16> oepm;\n    };\n  };\n\npublic:\n  using fs_daintmsk = Fs_daintmskReg<BaseAddress\
    \ + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class DvbusdisReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using vbusdt\
    \ = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 16> vbusdt;\n    };\n\
    \  };\n\npublic:\n  using dvbusdis = DvbusdisReg<BaseAddress + 0x0028>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class DvbuspulseReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dvbusp = FieldModel<uint32_t, address, 0,\
    \ 12>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 12> dvbusp;\n    };\n  };\n\npublic:\n  using dvbuspulse = DvbuspulseReg<BaseAddress\
    \ + 0x002C>;\n\nprivate:\n  template<unsigned int address>\n  class DiepempmskReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ineptxfem\
    \ = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 16> ineptxfem;\n    };\n\
    \  };\n\npublic:\n  using diepempmsk = DiepempmskReg<BaseAddress + 0x0034>;\n\n\
    private:\n  template<unsigned int address>\n  class Fs_diepctl0Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using mpsiz = FieldModel<uint32_t, address, 0,\
    \ 2>;\n    using usbaep = FieldModel<uint32_t, address, 15, 1>;\n    using naksts\
    \ = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using stall = FieldModel<uint32_t, address, 21, 1>;\n\
    \    using txfnum = FieldModel<uint32_t, address, 22, 4>;\n    using cnak = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using snak = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using epdis = FieldModel<uint32_t, address, 30, 1>;\n    using epena = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 2> mpsiz;\n      BitFieldModel<uint32_t, 15,\
    \ 1> usbaep;\n      BitFieldModel<uint32_t, 17, 1> naksts;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 21, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 22, 4> txfnum;\n      BitFieldModel<uint32_t, 26, 1> cnak;\n      BitFieldModel<uint32_t,\
    \ 27, 1> snak;\n      BitFieldModel<uint32_t, 30, 1> epdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> epena;\n    };\n  };\n\npublic:\n  using fs_diepctl0 = Fs_diepctl0Reg<BaseAddress\
    \ + 0x0100>;\n\nprivate:\n  template<unsigned int address>\n  class Diepctl1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using epena =\
    \ FieldModel<uint32_t, address, 31, 1>;\n    using epdis = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    using soddfrm_sd1pid = FieldModel<uint32_t, address, 29,\
    \ 1>;\n    using sd0pid_sevnfrm = FieldModel<uint32_t, address, 28, 1>;\n    using\
    \ snak = FieldModel<uint32_t, address, 27, 1>;\n    using cnak = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using txfnum = FieldModel<uint32_t, address, 22, 4>;\n\
    \    using stall = FieldModel<uint32_t, address, 21, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using naksts = FieldModel<uint32_t, address, 17, 1>;\n\
    \    using eonum_dpid = FieldModel<uint32_t, address, 16, 1>;\n    using usbaep\
    \ = FieldModel<uint32_t, address, 15, 1>;\n    using mpsiz = FieldModel<uint32_t,\
    \ address, 0, 11>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 31, 1> epena;\n      BitFieldModel<uint32_t, 30,\
    \ 1> epdis;\n      BitFieldModel<uint32_t, 29, 1> soddfrm_sd1pid;\n      BitFieldModel<uint32_t,\
    \ 28, 1> sd0pid_sevnfrm;\n      BitFieldModel<uint32_t, 27, 1> snak;\n      BitFieldModel<uint32_t,\
    \ 26, 1> cnak;\n      BitFieldModel<uint32_t, 22, 4> txfnum;\n      BitFieldModel<uint32_t,\
    \ 21, 1> stall;\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      BitFieldModel<uint32_t,\
    \ 17, 1> naksts;\n      BitFieldModel<uint32_t, 16, 1> eonum_dpid;\n      BitFieldModel<uint32_t,\
    \ 15, 1> usbaep;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n    };\n  };\n\n\
    public:\n  using diepctl1 = Diepctl1Reg<BaseAddress + 0x0120>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Diepctl2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using epena = FieldModel<uint32_t, address, 31,\
    \ 1>;\n    using epdis = FieldModel<uint32_t, address, 30, 1>;\n    using soddfrm\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using sd0pid_sevnfrm = FieldModel<uint32_t,\
    \ address, 28, 1>;\n    using snak = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using cnak = FieldModel<uint32_t, address, 26, 1>;\n    using txfnum = FieldModel<uint32_t,\
    \ address, 22, 4>;\n    using stall = FieldModel<uint32_t, address, 21, 1>;\n\
    \    using eptyp = FieldModel<uint32_t, address, 18, 2>;\n    using naksts = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using eonum_dpid = FieldModel<uint32_t, address, 16, 1>;\n\
    \    using usbaep = FieldModel<uint32_t, address, 15, 1>;\n    using mpsiz = FieldModel<uint32_t,\
    \ address, 0, 11>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 31, 1> epena;\n      BitFieldModel<uint32_t, 30,\
    \ 1> epdis;\n      BitFieldModel<uint32_t, 29, 1> soddfrm;\n      BitFieldModel<uint32_t,\
    \ 28, 1> sd0pid_sevnfrm;\n      BitFieldModel<uint32_t, 27, 1> snak;\n      BitFieldModel<uint32_t,\
    \ 26, 1> cnak;\n      BitFieldModel<uint32_t, 22, 4> txfnum;\n      BitFieldModel<uint32_t,\
    \ 21, 1> stall;\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      BitFieldModel<uint32_t,\
    \ 17, 1> naksts;\n      BitFieldModel<uint32_t, 16, 1> eonum_dpid;\n      BitFieldModel<uint32_t,\
    \ 15, 1> usbaep;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n    };\n  };\n\n\
    public:\n  using diepctl2 = Diepctl2Reg<BaseAddress + 0x0140>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Diepctl3Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using epena = FieldModel<uint32_t, address, 31,\
    \ 1>;\n    using epdis = FieldModel<uint32_t, address, 30, 1>;\n    using soddfrm\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using sd0pid_sevnfrm = FieldModel<uint32_t,\
    \ address, 28, 1>;\n    using snak = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using cnak = FieldModel<uint32_t, address, 26, 1>;\n    using txfnum = FieldModel<uint32_t,\
    \ address, 22, 4>;\n    using stall = FieldModel<uint32_t, address, 21, 1>;\n\
    \    using eptyp = FieldModel<uint32_t, address, 18, 2>;\n    using naksts = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using eonum_dpid = FieldModel<uint32_t, address, 16, 1>;\n\
    \    using usbaep = FieldModel<uint32_t, address, 15, 1>;\n    using mpsiz = FieldModel<uint32_t,\
    \ address, 0, 11>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 31, 1> epena;\n      BitFieldModel<uint32_t, 30,\
    \ 1> epdis;\n      BitFieldModel<uint32_t, 29, 1> soddfrm;\n      BitFieldModel<uint32_t,\
    \ 28, 1> sd0pid_sevnfrm;\n      BitFieldModel<uint32_t, 27, 1> snak;\n      BitFieldModel<uint32_t,\
    \ 26, 1> cnak;\n      BitFieldModel<uint32_t, 22, 4> txfnum;\n      BitFieldModel<uint32_t,\
    \ 21, 1> stall;\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      BitFieldModel<uint32_t,\
    \ 17, 1> naksts;\n      BitFieldModel<uint32_t, 16, 1> eonum_dpid;\n      BitFieldModel<uint32_t,\
    \ 15, 1> usbaep;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n    };\n  };\n\n\
    public:\n  using diepctl3 = Diepctl3Reg<BaseAddress + 0x0160>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Doepctl0Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using epena = FieldModel<uint32_t, address, 31,\
    \ 1>;\n    using epdis = FieldModel<uint32_t, address, 30, 1>;\n    using snak\
    \ = FieldModel<uint32_t, address, 27, 1>;\n    using cnak = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using stall = FieldModel<uint32_t, address, 21, 1>;\n\
    \    using snpm = FieldModel<uint32_t, address, 20, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using naksts = FieldModel<uint32_t, address, 17, 1>;\n\
    \    using usbaep = FieldModel<uint32_t, address, 15, 1>;\n    using mpsiz = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 31, 1> epena;\n      BitFieldModel<uint32_t, 30,\
    \ 1> epdis;\n      BitFieldModel<uint32_t, 27, 1> snak;\n      BitFieldModel<uint32_t,\
    \ 26, 1> cnak;\n      BitFieldModel<uint32_t, 21, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 20, 1> snpm;\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      BitFieldModel<uint32_t,\
    \ 17, 1> naksts;\n      BitFieldModel<uint32_t, 15, 1> usbaep;\n      BitFieldModel<uint32_t,\
    \ 0, 2> mpsiz;\n    };\n  };\n\npublic:\n  using doepctl0 = Doepctl0Reg<BaseAddress\
    \ + 0x0300>;\n\nprivate:\n  template<unsigned int address>\n  class Doepctl1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using epena =\
    \ FieldModel<uint32_t, address, 31, 1>;\n    using epdis = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    using soddfrm = FieldModel<uint32_t, address, 29, 1>;\n\
    \    using sd0pid_sevnfrm = FieldModel<uint32_t, address, 28, 1>;\n    using snak\
    \ = FieldModel<uint32_t, address, 27, 1>;\n    using cnak = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using stall = FieldModel<uint32_t, address, 21, 1>;\n\
    \    using snpm = FieldModel<uint32_t, address, 20, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using naksts = FieldModel<uint32_t, address, 17, 1>;\n\
    \    using eonum_dpid = FieldModel<uint32_t, address, 16, 1>;\n    using usbaep\
    \ = FieldModel<uint32_t, address, 15, 1>;\n    using mpsiz = FieldModel<uint32_t,\
    \ address, 0, 11>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 31, 1> epena;\n      BitFieldModel<uint32_t, 30,\
    \ 1> epdis;\n      BitFieldModel<uint32_t, 29, 1> soddfrm;\n      BitFieldModel<uint32_t,\
    \ 28, 1> sd0pid_sevnfrm;\n      BitFieldModel<uint32_t, 27, 1> snak;\n      BitFieldModel<uint32_t,\
    \ 26, 1> cnak;\n      BitFieldModel<uint32_t, 21, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 20, 1> snpm;\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      BitFieldModel<uint32_t,\
    \ 17, 1> naksts;\n      BitFieldModel<uint32_t, 16, 1> eonum_dpid;\n      BitFieldModel<uint32_t,\
    \ 15, 1> usbaep;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n    };\n  };\n\n\
    public:\n  using doepctl1 = Doepctl1Reg<BaseAddress + 0x0320>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Doepctl2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using epena = FieldModel<uint32_t, address, 31,\
    \ 1>;\n    using epdis = FieldModel<uint32_t, address, 30, 1>;\n    using soddfrm\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using sd0pid_sevnfrm = FieldModel<uint32_t,\
    \ address, 28, 1>;\n    using snak = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using cnak = FieldModel<uint32_t, address, 26, 1>;\n    using stall = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    using snpm = FieldModel<uint32_t, address, 20, 1>;\n \
    \   using eptyp = FieldModel<uint32_t, address, 18, 2>;\n    using naksts = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using eonum_dpid = FieldModel<uint32_t, address, 16, 1>;\n\
    \    using usbaep = FieldModel<uint32_t, address, 15, 1>;\n    using mpsiz = FieldModel<uint32_t,\
    \ address, 0, 11>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 31, 1> epena;\n      BitFieldModel<uint32_t, 30,\
    \ 1> epdis;\n      BitFieldModel<uint32_t, 29, 1> soddfrm;\n      BitFieldModel<uint32_t,\
    \ 28, 1> sd0pid_sevnfrm;\n      BitFieldModel<uint32_t, 27, 1> snak;\n      BitFieldModel<uint32_t,\
    \ 26, 1> cnak;\n      BitFieldModel<uint32_t, 21, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 20, 1> snpm;\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      BitFieldModel<uint32_t,\
    \ 17, 1> naksts;\n      BitFieldModel<uint32_t, 16, 1> eonum_dpid;\n      BitFieldModel<uint32_t,\
    \ 15, 1> usbaep;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n    };\n  };\n\n\
    public:\n  using doepctl2 = Doepctl2Reg<BaseAddress + 0x0340>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Doepctl3Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using epena = FieldModel<uint32_t, address, 31,\
    \ 1>;\n    using epdis = FieldModel<uint32_t, address, 30, 1>;\n    using soddfrm\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using sd0pid_sevnfrm = FieldModel<uint32_t,\
    \ address, 28, 1>;\n    using snak = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using cnak = FieldModel<uint32_t, address, 26, 1>;\n    using stall = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    using snpm = FieldModel<uint32_t, address, 20, 1>;\n \
    \   using eptyp = FieldModel<uint32_t, address, 18, 2>;\n    using naksts = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using eonum_dpid = FieldModel<uint32_t, address, 16, 1>;\n\
    \    using usbaep = FieldModel<uint32_t, address, 15, 1>;\n    using mpsiz = FieldModel<uint32_t,\
    \ address, 0, 11>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 31, 1> epena;\n      BitFieldModel<uint32_t, 30,\
    \ 1> epdis;\n      BitFieldModel<uint32_t, 29, 1> soddfrm;\n      BitFieldModel<uint32_t,\
    \ 28, 1> sd0pid_sevnfrm;\n      BitFieldModel<uint32_t, 27, 1> snak;\n      BitFieldModel<uint32_t,\
    \ 26, 1> cnak;\n      BitFieldModel<uint32_t, 21, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 20, 1> snpm;\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      BitFieldModel<uint32_t,\
    \ 17, 1> naksts;\n      BitFieldModel<uint32_t, 16, 1> eonum_dpid;\n      BitFieldModel<uint32_t,\
    \ 15, 1> usbaep;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n    };\n  };\n\n\
    public:\n  using doepctl3 = Doepctl3Reg<BaseAddress + 0x0360>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Diepint0Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using txfe = FieldModel<uint32_t, address, 7,\
    \ 1>;\n    using inepne = FieldModel<uint32_t, address, 6, 1>;\n    using ittxfe\
    \ = FieldModel<uint32_t, address, 4, 1>;\n    using toc = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n \
    \   using xfrc = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 7, 1> txfe;\n\
    \      BitFieldModel<uint32_t, 6, 1> inepne;\n      BitFieldModel<uint32_t, 4,\
    \ 1> ittxfe;\n      BitFieldModel<uint32_t, 3, 1> toc;\n      BitFieldModel<uint32_t,\
    \ 1, 1> epdisd;\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n    };\n  };\n\npublic:\n\
    \  using diepint0 = Diepint0Reg<BaseAddress + 0x0108>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Diepint1Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using txfe = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ inepne = FieldModel<uint32_t, address, 6, 1>;\n    using ittxfe = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using toc = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ epdisd = FieldModel<uint32_t, address, 1, 1>;\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> txfe;\n      BitFieldModel<uint32_t, 6, 1>\
    \ inepne;\n      BitFieldModel<uint32_t, 4, 1> ittxfe;\n      BitFieldModel<uint32_t,\
    \ 3, 1> toc;\n      BitFieldModel<uint32_t, 1, 1> epdisd;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n    };\n  };\n\npublic:\n  using diepint1 = Diepint1Reg<BaseAddress\
    \ + 0x0128>;\n\nprivate:\n  template<unsigned int address>\n  class Diepint2Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using txfe =\
    \ FieldModel<uint32_t, address, 7, 1>;\n    using inepne = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using ittxfe = FieldModel<uint32_t, address, 4, 1>;\n \
    \   using toc = FieldModel<uint32_t, address, 3, 1>;\n    using epdisd = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using xfrc = FieldModel<uint32_t, address, 0, 1>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txfe;\n      BitFieldModel<uint32_t, 6, 1> inepne;\n      BitFieldModel<uint32_t,\
    \ 4, 1> ittxfe;\n      BitFieldModel<uint32_t, 3, 1> toc;\n      BitFieldModel<uint32_t,\
    \ 1, 1> epdisd;\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n    };\n  };\n\npublic:\n\
    \  using diepint2 = Diepint2Reg<BaseAddress + 0x0148>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Diepint3Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using txfe = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ inepne = FieldModel<uint32_t, address, 6, 1>;\n    using ittxfe = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using toc = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ epdisd = FieldModel<uint32_t, address, 1, 1>;\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 7, 1> txfe;\n      BitFieldModel<uint32_t, 6, 1>\
    \ inepne;\n      BitFieldModel<uint32_t, 4, 1> ittxfe;\n      BitFieldModel<uint32_t,\
    \ 3, 1> toc;\n      BitFieldModel<uint32_t, 1, 1> epdisd;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n    };\n  };\n\npublic:\n  using diepint3 = Diepint3Reg<BaseAddress\
    \ + 0x0168>;\n\nprivate:\n  template<unsigned int address>\n  class Doepint0Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using b2bstup\
    \ = FieldModel<uint32_t, address, 6, 1>;\n    using otepdis = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using stup = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using epdisd = FieldModel<uint32_t, address, 1, 1>;\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 6, 1> b2bstup;\n      BitFieldModel<uint32_t, 4,\
    \ 1> otepdis;\n      BitFieldModel<uint32_t, 3, 1> stup;\n      BitFieldModel<uint32_t,\
    \ 1, 1> epdisd;\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n    };\n  };\n\npublic:\n\
    \  using doepint0 = Doepint0Reg<BaseAddress + 0x0308>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Doepint1Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using b2bstup = FieldModel<uint32_t, address, 6, 1>;\n  \
    \  using otepdis = FieldModel<uint32_t, address, 4, 1>;\n    using stup = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n \
    \   using xfrc = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 6, 1> b2bstup;\n\
    \      BitFieldModel<uint32_t, 4, 1> otepdis;\n      BitFieldModel<uint32_t, 3,\
    \ 1> stup;\n      BitFieldModel<uint32_t, 1, 1> epdisd;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n    };\n  };\n\npublic:\n  using doepint1 = Doepint1Reg<BaseAddress\
    \ + 0x0328>;\n\nprivate:\n  template<unsigned int address>\n  class Doepint2Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using b2bstup\
    \ = FieldModel<uint32_t, address, 6, 1>;\n    using otepdis = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using stup = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using epdisd = FieldModel<uint32_t, address, 1, 1>;\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 6, 1> b2bstup;\n      BitFieldModel<uint32_t, 4,\
    \ 1> otepdis;\n      BitFieldModel<uint32_t, 3, 1> stup;\n      BitFieldModel<uint32_t,\
    \ 1, 1> epdisd;\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n    };\n  };\n\npublic:\n\
    \  using doepint2 = Doepint2Reg<BaseAddress + 0x0348>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Doepint3Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using b2bstup = FieldModel<uint32_t, address, 6, 1>;\n  \
    \  using otepdis = FieldModel<uint32_t, address, 4, 1>;\n    using stup = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n \
    \   using xfrc = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 6, 1> b2bstup;\n\
    \      BitFieldModel<uint32_t, 4, 1> otepdis;\n      BitFieldModel<uint32_t, 3,\
    \ 1> stup;\n      BitFieldModel<uint32_t, 1, 1> epdisd;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n    };\n  };\n\npublic:\n  using doepint3 = Doepint3Reg<BaseAddress\
    \ + 0x0368>;\n\nprivate:\n  template<unsigned int address>\n  class Dieptsiz0Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using pktcnt\
    \ = FieldModel<uint32_t, address, 19, 2>;\n    using xfrsiz = FieldModel<uint32_t,\
    \ address, 0, 7>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 19, 2> pktcnt;\n      BitFieldModel<uint32_t, 0,\
    \ 7> xfrsiz;\n    };\n  };\n\npublic:\n  using dieptsiz0 = Dieptsiz0Reg<BaseAddress\
    \ + 0x0110>;\n\nprivate:\n  template<unsigned int address>\n  class Doeptsiz0Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using stupcnt\
    \ = FieldModel<uint32_t, address, 29, 2>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using xfrsiz = FieldModel<uint32_t, address, 0, 7>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 29, 2> stupcnt;\n      BitFieldModel<uint32_t, 19, 1> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 0, 7> xfrsiz;\n    };\n  };\n\npublic:\n  using doeptsiz0 = Doeptsiz0Reg<BaseAddress\
    \ + 0x0310>;\n\nprivate:\n  template<unsigned int address>\n  class Dieptsiz1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mcnt =\
    \ FieldModel<uint32_t, address, 29, 2>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using xfrsiz = FieldModel<uint32_t, address, 0, 19>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 29, 2> mcnt;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n    };\n  };\n\npublic:\n  using dieptsiz1 = Dieptsiz1Reg<BaseAddress\
    \ + 0x0130>;\n\nprivate:\n  template<unsigned int address>\n  class Dieptsiz2Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mcnt =\
    \ FieldModel<uint32_t, address, 29, 2>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using xfrsiz = FieldModel<uint32_t, address, 0, 19>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 29, 2> mcnt;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n    };\n  };\n\npublic:\n  using dieptsiz2 = Dieptsiz2Reg<BaseAddress\
    \ + 0x0150>;\n\nprivate:\n  template<unsigned int address>\n  class Dieptsiz3Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mcnt =\
    \ FieldModel<uint32_t, address, 29, 2>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using xfrsiz = FieldModel<uint32_t, address, 0, 19>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 29, 2> mcnt;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n    };\n  };\n\npublic:\n  using dieptsiz3 = Dieptsiz3Reg<BaseAddress\
    \ + 0x0170>;\n\nprivate:\n  template<unsigned int address>\n  class Dtxfsts0Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ineptfsav\
    \ = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 16> ineptfsav;\n    };\n\
    \  };\n\npublic:\n  using dtxfsts0 = Dtxfsts0Reg<BaseAddress + 0x0118>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Dtxfsts1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ineptfsav = FieldModel<uint32_t, address,\
    \ 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ineptfsav;\n    };\n  };\n\npublic:\n  using dtxfsts1 = Dtxfsts1Reg<BaseAddress\
    \ + 0x0138>;\n\nprivate:\n  template<unsigned int address>\n  class Dtxfsts2Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ineptfsav\
    \ = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 16> ineptfsav;\n    };\n\
    \  };\n\npublic:\n  using dtxfsts2 = Dtxfsts2Reg<BaseAddress + 0x0158>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Dtxfsts3Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ineptfsav = FieldModel<uint32_t, address,\
    \ 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ineptfsav;\n    };\n  };\n\npublic:\n  using dtxfsts3 = Dtxfsts3Reg<BaseAddress\
    \ + 0x0178>;\n\nprivate:\n  template<unsigned int address>\n  class Doeptsiz1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using rxdpid_stupcnt\
    \ = FieldModel<uint32_t, address, 29, 2>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using xfrsiz = FieldModel<uint32_t, address, 0, 19>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 29, 2> rxdpid_stupcnt;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n    \
    \  BitFieldModel<uint32_t, 0, 19> xfrsiz;\n    };\n  };\n\npublic:\n  using doeptsiz1\
    \ = Doeptsiz1Reg<BaseAddress + 0x0330>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Doeptsiz2Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using rxdpid_stupcnt = FieldModel<uint32_t, address, 29, 2>;\n    using pktcnt\
    \ = FieldModel<uint32_t, address, 19, 10>;\n    using xfrsiz = FieldModel<uint32_t,\
    \ address, 0, 19>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 29, 2> rxdpid_stupcnt;\n      BitFieldModel<uint32_t,\
    \ 19, 10> pktcnt;\n      BitFieldModel<uint32_t, 0, 19> xfrsiz;\n    };\n  };\n\
    \npublic:\n  using doeptsiz2 = Doeptsiz2Reg<BaseAddress + 0x0350>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Doeptsiz3Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using rxdpid_stupcnt = FieldModel<uint32_t, address,\
    \ 29, 2>;\n    using pktcnt = FieldModel<uint32_t, address, 19, 10>;\n    using\
    \ xfrsiz = FieldModel<uint32_t, address, 0, 19>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 29, 2> rxdpid_stupcnt;\n\
    \      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n    };\n  };\n\npublic:\n  using doeptsiz3 = Doeptsiz3Reg<BaseAddress\
    \ + 0x0370>;\n\nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n\
    \  class DiepctlxBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n\
    \  {\n  public:\n    using epena = FieldModel<uint32_t, address, 31, 1, bankOffset>;\n\
    \    using epdis = FieldModel<uint32_t, address, 30, 1, bankOffset>;\n    using\
    \ soddfrm = FieldModel<uint32_t, address, 29, 1, bankOffset>;\n    using sd0pid_sevnfrm\
    \ = FieldModel<uint32_t, address, 28, 1, bankOffset>;\n    using snak = FieldModel<uint32_t,\
    \ address, 27, 1, bankOffset>;\n    using cnak = FieldModel<uint32_t, address,\
    \ 26, 1, bankOffset>;\n    using txfnum = FieldModel<uint32_t, address, 22, 4,\
    \ bankOffset>;\n    using stall = FieldModel<uint32_t, address, 21, 1, bankOffset>;\n\
    \    using eptyp = FieldModel<uint32_t, address, 18, 2, bankOffset>;\n    using\
    \ naksts = FieldModel<uint32_t, address, 17, 1, bankOffset>;\n    using eonum_dpid\
    \ = FieldModel<uint32_t, address, 16, 1, bankOffset>;\n    using usbaep = FieldModel<uint32_t,\
    \ address, 15, 1, bankOffset>;\n    using mpsiz = FieldModel<uint32_t, address,\
    \ 0, 11, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 31, 1> epena;\n      BitFieldModel<uint32_t, 30,\
    \ 1> epdis;\n      BitFieldModel<uint32_t, 29, 1> soddfrm;\n      BitFieldModel<uint32_t,\
    \ 28, 1> sd0pid_sevnfrm;\n      BitFieldModel<uint32_t, 27, 1> snak;\n      BitFieldModel<uint32_t,\
    \ 26, 1> cnak;\n      BitFieldModel<uint32_t, 22, 4> txfnum;\n      BitFieldModel<uint32_t,\
    \ 21, 1> stall;\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      BitFieldModel<uint32_t,\
    \ 17, 1> naksts;\n      BitFieldModel<uint32_t, 16, 1> eonum_dpid;\n      BitFieldModel<uint32_t,\
    \ 15, 1> usbaep;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n    };\n  };\n\n\
    public:\n  using diepctlx = DiepctlxBankReg<BaseAddress + 0x0140, 0x0020>;\n\n\
    private:\n  template<unsigned int address, unsigned int bankOffset>\n  class DoepctlxBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    using epena = FieldModel<uint32_t, address, 31, 1, bankOffset>;\n    using\
    \ epdis = FieldModel<uint32_t, address, 30, 1, bankOffset>;\n    using soddfrm\
    \ = FieldModel<uint32_t, address, 29, 1, bankOffset>;\n    using sd0pid_sevnfrm\
    \ = FieldModel<uint32_t, address, 28, 1, bankOffset>;\n    using snak = FieldModel<uint32_t,\
    \ address, 27, 1, bankOffset>;\n    using cnak = FieldModel<uint32_t, address,\
    \ 26, 1, bankOffset>;\n    using stall = FieldModel<uint32_t, address, 21, 1,\
    \ bankOffset>;\n    using snpm = FieldModel<uint32_t, address, 20, 1, bankOffset>;\n\
    \    using eptyp = FieldModel<uint32_t, address, 18, 2, bankOffset>;\n    using\
    \ naksts = FieldModel<uint32_t, address, 17, 1, bankOffset>;\n    using eonum_dpid\
    \ = FieldModel<uint32_t, address, 16, 1, bankOffset>;\n    using usbaep = FieldModel<uint32_t,\
    \ address, 15, 1, bankOffset>;\n    using mpsiz = FieldModel<uint32_t, address,\
    \ 0, 11, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 31, 1> epena;\n      BitFieldModel<uint32_t, 30,\
    \ 1> epdis;\n      BitFieldModel<uint32_t, 29, 1> soddfrm;\n      BitFieldModel<uint32_t,\
    \ 28, 1> sd0pid_sevnfrm;\n      BitFieldModel<uint32_t, 27, 1> snak;\n      BitFieldModel<uint32_t,\
    \ 26, 1> cnak;\n      BitFieldModel<uint32_t, 21, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 20, 1> snpm;\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      BitFieldModel<uint32_t,\
    \ 17, 1> naksts;\n      BitFieldModel<uint32_t, 16, 1> eonum_dpid;\n      BitFieldModel<uint32_t,\
    \ 15, 1> usbaep;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n    };\n  };\n\n\
    public:\n  using doepctlx = DoepctlxBankReg<BaseAddress + 0x0320, 0x0020>;\n\n\
    private:\n  template<unsigned int address, unsigned int bankOffset>\n  class DiepintxBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    using txfe = FieldModel<uint32_t, address, 7, 1, bankOffset>;\n    using\
    \ inepne = FieldModel<uint32_t, address, 6, 1, bankOffset>;\n    using ittxfe\
    \ = FieldModel<uint32_t, address, 4, 1, bankOffset>;\n    using toc = FieldModel<uint32_t,\
    \ address, 3, 1, bankOffset>;\n    using epdisd = FieldModel<uint32_t, address,\
    \ 1, 1, bankOffset>;\n    using xfrc = FieldModel<uint32_t, address, 0, 1, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txfe;\n      BitFieldModel<uint32_t, 6, 1> inepne;\n      BitFieldModel<uint32_t,\
    \ 4, 1> ittxfe;\n      BitFieldModel<uint32_t, 3, 1> toc;\n      BitFieldModel<uint32_t,\
    \ 1, 1> epdisd;\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n    };\n  };\n\npublic:\n\
    \  using diepintx = DiepintxBankReg<BaseAddress + 0x0108, 0x0020>;\n\nprivate:\n\
    \  template<unsigned int address, unsigned int bankOffset>\n  class DoepintxBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    using b2bstup = FieldModel<uint32_t, address, 6, 1, bankOffset>;\n    using\
    \ otepdis = FieldModel<uint32_t, address, 4, 1, bankOffset>;\n    using stup =\
    \ FieldModel<uint32_t, address, 3, 1, bankOffset>;\n    using epdisd = FieldModel<uint32_t,\
    \ address, 1, 1, bankOffset>;\n    using xfrc = FieldModel<uint32_t, address,\
    \ 0, 1, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 6, 1> b2bstup;\n      BitFieldModel<uint32_t, 4,\
    \ 1> otepdis;\n      BitFieldModel<uint32_t, 3, 1> stup;\n      BitFieldModel<uint32_t,\
    \ 1, 1> epdisd;\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n    };\n  };\n\npublic:\n\
    \  using doepintx = DoepintxBankReg<BaseAddress + 0x0308, 0x0020>;\n\nprivate:\n\
    \  template<unsigned int address, unsigned int bankOffset>\n  class DieptsizxBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    using mcnt = FieldModel<uint32_t, address, 29, 2, bankOffset>;\n    using\
    \ pktcnt = FieldModel<uint32_t, address, 19, 10, bankOffset>;\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19, bankOffset>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 29, 2> mcnt;\n\
    \      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n    };\n  };\n\npublic:\n  using dieptsizx = DieptsizxBankReg<BaseAddress\
    \ + 0x0130, 0x0020>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class DtxfstsxBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using ineptfsav = FieldModel<uint32_t, address,\
    \ 0, 16, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> ineptfsav;\n    };\n  };\n\npublic:\n  using\
    \ dtxfstsx = DtxfstsxBankReg<BaseAddress + 0x0118, 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class DoeptsizxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using rxdpid_stupcnt = FieldModel<uint32_t,\
    \ address, 29, 2, bankOffset>;\n    using pktcnt = FieldModel<uint32_t, address,\
    \ 19, 10, bankOffset>;\n    using xfrsiz = FieldModel<uint32_t, address, 0, 19,\
    \ bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n   \
    \   BitFieldModel<uint32_t, 29, 2> rxdpid_stupcnt;\n      BitFieldModel<uint32_t,\
    \ 19, 10> pktcnt;\n      BitFieldModel<uint32_t, 0, 19> xfrsiz;\n    };\n  };\n\
    \npublic:\n  using doeptsizx = DoeptsizxBankReg<BaseAddress + 0x0330, 0x0020>;\n\
    };\n\n}\n\n#endif /* DRAL_STM32F446_OTG_FS_DEVICE_H */\n"
  name: OTG_FS_DEVICE
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_OTG_FS_PWRCLK_H\n#define DRAL_STM32F446_OTG_FS_PWRCLK_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass otg_fs_pwrclk\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x50000E00;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_pcgcctlReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using stppclk = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    using gatehclk = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ physusp = FieldModel<uint32_t, address, 4, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> stppclk;\n\
    \      BitFieldModel<uint32_t, 1, 1> gatehclk;\n      BitFieldModel<uint32_t,\
    \ 4, 1> physusp;\n    };\n  };\n\npublic:\n  using fs_pcgcctl = Fs_pcgcctlReg<BaseAddress\
    \ + 0x0000>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_OTG_FS_PWRCLK_H */\n"
  name: OTG_FS_PWRCLK
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_CAN1_H\n#define DRAL_STM32F446_CAN1_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass can1\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40006400;\n\nprivate:\n\
    \  template<unsigned int address>\n  class McrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dbf = FieldModel<uint32_t, address, 16,\
    \ 1>;\n    using reset = FieldModel<uint32_t, address, 15, 1>;\n    using ttcm\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    using abom = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using awum = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using nart = FieldModel<uint32_t, address, 4, 1>;\n    using rflm = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using txfp = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using sleep = FieldModel<uint32_t, address, 1, 1>;\n    using inrq = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 16, 1> dbf;\n      BitFieldModel<uint32_t, 15,\
    \ 1> reset;\n      BitFieldModel<uint32_t, 7, 1> ttcm;\n      BitFieldModel<uint32_t,\
    \ 6, 1> abom;\n      BitFieldModel<uint32_t, 5, 1> awum;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nart;\n      BitFieldModel<uint32_t, 3, 1> rflm;\n      BitFieldModel<uint32_t,\
    \ 2, 1> txfp;\n      BitFieldModel<uint32_t, 1, 1> sleep;\n      BitFieldModel<uint32_t,\
    \ 0, 1> inrq;\n    };\n  };\n\npublic:\n  using mcr = McrReg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class MsrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using rx = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using samp = FieldModel<uint32_t, address, 10, 1>;\n    using rxm = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using txm = FieldModel<uint32_t, address, 8, 1>;\n    using\
    \ slaki = FieldModel<uint32_t, address, 4, 1>;\n    using wkui = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using erri = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using slak = FieldModel<uint32_t, address, 1, 1>;\n    using inak = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 11, 1> rx;\n      BitFieldModel<uint32_t, 10, 1>\
    \ samp;\n      BitFieldModel<uint32_t, 9, 1> rxm;\n      BitFieldModel<uint32_t,\
    \ 8, 1> txm;\n      BitFieldModel<uint32_t, 4, 1> slaki;\n      BitFieldModel<uint32_t,\
    \ 3, 1> wkui;\n      BitFieldModel<uint32_t, 2, 1> erri;\n      BitFieldModel<uint32_t,\
    \ 1, 1> slak;\n      BitFieldModel<uint32_t, 0, 1> inak;\n    };\n  };\n\npublic:\n\
    \  using msr = MsrReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class TsrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using low2 = FieldModel<uint32_t, address, 31, 1>;\n    using\
    \ low1 = FieldModel<uint32_t, address, 30, 1>;\n    using low0 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using tme2 = FieldModel<uint32_t, address, 28, 1>;\n \
    \   using tme1 = FieldModel<uint32_t, address, 27, 1>;\n    using tme0 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using code = FieldModel<uint32_t, address, 24, 2>;\n \
    \   using abrq2 = FieldModel<uint32_t, address, 23, 1>;\n    using terr2 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using alst2 = FieldModel<uint32_t, address, 18, 1>;\n\
    \    using txok2 = FieldModel<uint32_t, address, 17, 1>;\n    using rqcp2 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using abrq1 = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using terr1 = FieldModel<uint32_t, address, 11, 1>;\n    using alst1 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using txok1 = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using rqcp1 = FieldModel<uint32_t, address, 8, 1>;\n    using abrq0 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using terr0 = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using alst0 = FieldModel<uint32_t, address, 2, 1>;\n    using txok0 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using rqcp0 = FieldModel<uint32_t, address, 0, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 31, 1> low2;\n      BitFieldModel<uint32_t, 30, 1> low1;\n      BitFieldModel<uint32_t,\
    \ 29, 1> low0;\n      BitFieldModel<uint32_t, 28, 1> tme2;\n      BitFieldModel<uint32_t,\
    \ 27, 1> tme1;\n      BitFieldModel<uint32_t, 26, 1> tme0;\n      BitFieldModel<uint32_t,\
    \ 24, 2> code;\n      BitFieldModel<uint32_t, 23, 1> abrq2;\n      BitFieldModel<uint32_t,\
    \ 19, 1> terr2;\n      BitFieldModel<uint32_t, 18, 1> alst2;\n      BitFieldModel<uint32_t,\
    \ 17, 1> txok2;\n      BitFieldModel<uint32_t, 16, 1> rqcp2;\n      BitFieldModel<uint32_t,\
    \ 15, 1> abrq1;\n      BitFieldModel<uint32_t, 11, 1> terr1;\n      BitFieldModel<uint32_t,\
    \ 10, 1> alst1;\n      BitFieldModel<uint32_t, 9, 1> txok1;\n      BitFieldModel<uint32_t,\
    \ 8, 1> rqcp1;\n      BitFieldModel<uint32_t, 7, 1> abrq0;\n      BitFieldModel<uint32_t,\
    \ 3, 1> terr0;\n      BitFieldModel<uint32_t, 2, 1> alst0;\n      BitFieldModel<uint32_t,\
    \ 1, 1> txok0;\n      BitFieldModel<uint32_t, 0, 1> rqcp0;\n    };\n  };\n\npublic:\n\
    \  using tsr = TsrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Rf0rReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using rfom0 = FieldModel<uint32_t, address, 5, 1>;\n    using\
    \ fovr0 = FieldModel<uint32_t, address, 4, 1>;\n    using full0 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using fmp0 = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 5, 1> rfom0;\n      BitFieldModel<uint32_t, 4, 1> fovr0;\n      BitFieldModel<uint32_t,\
    \ 3, 1> full0;\n      BitFieldModel<uint32_t, 0, 2> fmp0;\n    };\n  };\n\npublic:\n\
    \  using rf0r = Rf0rReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Rf1rReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using rfom1 = FieldModel<uint32_t, address, 5, 1>;\n    using\
    \ fovr1 = FieldModel<uint32_t, address, 4, 1>;\n    using full1 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using fmp1 = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 5, 1> rfom1;\n      BitFieldModel<uint32_t, 4, 1> fovr1;\n      BitFieldModel<uint32_t,\
    \ 3, 1> full1;\n      BitFieldModel<uint32_t, 0, 2> fmp1;\n    };\n  };\n\npublic:\n\
    \  using rf1r = Rf1rReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class IerReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using slkie = FieldModel<uint32_t, address, 17, 1>;\n    using\
    \ wkuie = FieldModel<uint32_t, address, 16, 1>;\n    using errie = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using lecie = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using bofie = FieldModel<uint32_t, address, 10, 1>;\n    using epvie = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using ewgie = FieldModel<uint32_t, address, 8, 1>;\n  \
    \  using fovie1 = FieldModel<uint32_t, address, 6, 1>;\n    using ffie1 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fmpie1 = FieldModel<uint32_t, address, 4, 1>;\n \
    \   using fovie0 = FieldModel<uint32_t, address, 3, 1>;\n    using ffie0 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fmpie0 = FieldModel<uint32_t, address, 1, 1>;\n \
    \   using tmeie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 17, 1> slkie;\n\
    \      BitFieldModel<uint32_t, 16, 1> wkuie;\n      BitFieldModel<uint32_t, 15,\
    \ 1> errie;\n      BitFieldModel<uint32_t, 11, 1> lecie;\n      BitFieldModel<uint32_t,\
    \ 10, 1> bofie;\n      BitFieldModel<uint32_t, 9, 1> epvie;\n      BitFieldModel<uint32_t,\
    \ 8, 1> ewgie;\n      BitFieldModel<uint32_t, 6, 1> fovie1;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ffie1;\n      BitFieldModel<uint32_t, 4, 1> fmpie1;\n      BitFieldModel<uint32_t,\
    \ 3, 1> fovie0;\n      BitFieldModel<uint32_t, 2, 1> ffie0;\n      BitFieldModel<uint32_t,\
    \ 1, 1> fmpie0;\n      BitFieldModel<uint32_t, 0, 1> tmeie;\n    };\n  };\n\n\
    public:\n  using ier = IerReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class EsrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using rec = FieldModel<uint32_t, address, 24, 8>;\n    using tec\
    \ = FieldModel<uint32_t, address, 16, 8>;\n    using lec = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    using boff = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using epvf = FieldModel<uint32_t, address, 1, 1>;\n    using ewgf = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 24, 8> rec;\n      BitFieldModel<uint32_t, 16,\
    \ 8> tec;\n      BitFieldModel<uint32_t, 4, 3> lec;\n      BitFieldModel<uint32_t,\
    \ 2, 1> boff;\n      BitFieldModel<uint32_t, 1, 1> epvf;\n      BitFieldModel<uint32_t,\
    \ 0, 1> ewgf;\n    };\n  };\n\npublic:\n  using esr = EsrReg<BaseAddress + 0x0018>;\n\
    \nprivate:\n  template<unsigned int address>\n  class BtrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using silm = FieldModel<uint32_t, address, 31,\
    \ 1>;\n    using lbkm = FieldModel<uint32_t, address, 30, 1>;\n    using sjw =\
    \ FieldModel<uint32_t, address, 24, 2>;\n    using ts2 = FieldModel<uint32_t,\
    \ address, 20, 3>;\n    using ts1 = FieldModel<uint32_t, address, 16, 4>;\n  \
    \  using brp = FieldModel<uint32_t, address, 0, 10>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 31, 1> silm;\n  \
    \    BitFieldModel<uint32_t, 30, 1> lbkm;\n      BitFieldModel<uint32_t, 24, 2>\
    \ sjw;\n      BitFieldModel<uint32_t, 20, 3> ts2;\n      BitFieldModel<uint32_t,\
    \ 16, 4> ts1;\n      BitFieldModel<uint32_t, 0, 10> brp;\n    };\n  };\n\npublic:\n\
    \  using btr = BtrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ti0rReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using stid = FieldModel<uint32_t, address, 21, 11>;\n    using\
    \ exid = FieldModel<uint32_t, address, 3, 18>;\n    using ide = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using rtr = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ txrq = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n  \
    \  {\n      uint32_t value;\n      BitFieldModel<uint32_t, 21, 11> stid;\n   \
    \   BitFieldModel<uint32_t, 3, 18> exid;\n      BitFieldModel<uint32_t, 2, 1>\
    \ ide;\n      BitFieldModel<uint32_t, 1, 1> rtr;\n      BitFieldModel<uint32_t,\
    \ 0, 1> txrq;\n    };\n  };\n\npublic:\n  using ti0r = Ti0rReg<BaseAddress + 0x0180>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Tdt0rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using time = FieldModel<uint32_t, address, 16,\
    \ 16>;\n    using tgt = FieldModel<uint32_t, address, 8, 1>;\n    using dlc =\
    \ FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n    union reg\n    {\n  \
    \    uint32_t value;\n      BitFieldModel<uint32_t, 16, 16> time;\n      BitFieldModel<uint32_t,\
    \ 8, 1> tgt;\n      BitFieldModel<uint32_t, 0, 4> dlc;\n    };\n  };\n\npublic:\n\
    \  using tdt0r = Tdt0rReg<BaseAddress + 0x0184>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Tdl0rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using data3 = FieldModel<uint32_t, address, 24, 8>;\n    using\
    \ data2 = FieldModel<uint32_t, address, 16, 8>;\n    using data1 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using data0 = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> data3;\n      BitFieldModel<uint32_t, 16, 8> data2;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data1;\n      BitFieldModel<uint32_t, 0, 8> data0;\n    };\n  };\n\npublic:\n\
    \  using tdl0r = Tdl0rReg<BaseAddress + 0x0188>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Tdh0rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using data7 = FieldModel<uint32_t, address, 24, 8>;\n    using\
    \ data6 = FieldModel<uint32_t, address, 16, 8>;\n    using data5 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using data4 = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> data7;\n      BitFieldModel<uint32_t, 16, 8> data6;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data5;\n      BitFieldModel<uint32_t, 0, 8> data4;\n    };\n  };\n\npublic:\n\
    \  using tdh0r = Tdh0rReg<BaseAddress + 0x018C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ti1rReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using stid = FieldModel<uint32_t, address, 21, 11>;\n    using\
    \ exid = FieldModel<uint32_t, address, 3, 18>;\n    using ide = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using rtr = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ txrq = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n  \
    \  {\n      uint32_t value;\n      BitFieldModel<uint32_t, 21, 11> stid;\n   \
    \   BitFieldModel<uint32_t, 3, 18> exid;\n      BitFieldModel<uint32_t, 2, 1>\
    \ ide;\n      BitFieldModel<uint32_t, 1, 1> rtr;\n      BitFieldModel<uint32_t,\
    \ 0, 1> txrq;\n    };\n  };\n\npublic:\n  using ti1r = Ti1rReg<BaseAddress + 0x0190>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Tdt1rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using time = FieldModel<uint32_t, address, 16,\
    \ 16>;\n    using tgt = FieldModel<uint32_t, address, 8, 1>;\n    using dlc =\
    \ FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n    union reg\n    {\n  \
    \    uint32_t value;\n      BitFieldModel<uint32_t, 16, 16> time;\n      BitFieldModel<uint32_t,\
    \ 8, 1> tgt;\n      BitFieldModel<uint32_t, 0, 4> dlc;\n    };\n  };\n\npublic:\n\
    \  using tdt1r = Tdt1rReg<BaseAddress + 0x0194>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Tdl1rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using data3 = FieldModel<uint32_t, address, 24, 8>;\n    using\
    \ data2 = FieldModel<uint32_t, address, 16, 8>;\n    using data1 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using data0 = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> data3;\n      BitFieldModel<uint32_t, 16, 8> data2;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data1;\n      BitFieldModel<uint32_t, 0, 8> data0;\n    };\n  };\n\npublic:\n\
    \  using tdl1r = Tdl1rReg<BaseAddress + 0x0198>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Tdh1rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using data7 = FieldModel<uint32_t, address, 24, 8>;\n    using\
    \ data6 = FieldModel<uint32_t, address, 16, 8>;\n    using data5 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using data4 = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> data7;\n      BitFieldModel<uint32_t, 16, 8> data6;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data5;\n      BitFieldModel<uint32_t, 0, 8> data4;\n    };\n  };\n\npublic:\n\
    \  using tdh1r = Tdh1rReg<BaseAddress + 0x019C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ti2rReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using stid = FieldModel<uint32_t, address, 21, 11>;\n    using\
    \ exid = FieldModel<uint32_t, address, 3, 18>;\n    using ide = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using rtr = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ txrq = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n  \
    \  {\n      uint32_t value;\n      BitFieldModel<uint32_t, 21, 11> stid;\n   \
    \   BitFieldModel<uint32_t, 3, 18> exid;\n      BitFieldModel<uint32_t, 2, 1>\
    \ ide;\n      BitFieldModel<uint32_t, 1, 1> rtr;\n      BitFieldModel<uint32_t,\
    \ 0, 1> txrq;\n    };\n  };\n\npublic:\n  using ti2r = Ti2rReg<BaseAddress + 0x01A0>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Tdt2rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using time = FieldModel<uint32_t, address, 16,\
    \ 16>;\n    using tgt = FieldModel<uint32_t, address, 8, 1>;\n    using dlc =\
    \ FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n    union reg\n    {\n  \
    \    uint32_t value;\n      BitFieldModel<uint32_t, 16, 16> time;\n      BitFieldModel<uint32_t,\
    \ 8, 1> tgt;\n      BitFieldModel<uint32_t, 0, 4> dlc;\n    };\n  };\n\npublic:\n\
    \  using tdt2r = Tdt2rReg<BaseAddress + 0x01A4>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Tdl2rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using data3 = FieldModel<uint32_t, address, 24, 8>;\n    using\
    \ data2 = FieldModel<uint32_t, address, 16, 8>;\n    using data1 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using data0 = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> data3;\n      BitFieldModel<uint32_t, 16, 8> data2;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data1;\n      BitFieldModel<uint32_t, 0, 8> data0;\n    };\n  };\n\npublic:\n\
    \  using tdl2r = Tdl2rReg<BaseAddress + 0x01A8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Tdh2rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using data7 = FieldModel<uint32_t, address, 24, 8>;\n    using\
    \ data6 = FieldModel<uint32_t, address, 16, 8>;\n    using data5 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using data4 = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> data7;\n      BitFieldModel<uint32_t, 16, 8> data6;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data5;\n      BitFieldModel<uint32_t, 0, 8> data4;\n    };\n  };\n\npublic:\n\
    \  using tdh2r = Tdh2rReg<BaseAddress + 0x01AC>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ri0rReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using stid = FieldModel<uint32_t, address, 21, 11>;\n    using\
    \ exid = FieldModel<uint32_t, address, 3, 18>;\n    using ide = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using rtr = FieldModel<uint32_t, address, 1, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 21,\
    \ 11> stid;\n      BitFieldModel<uint32_t, 3, 18> exid;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ide;\n      BitFieldModel<uint32_t, 1, 1> rtr;\n    };\n  };\n\npublic:\n\
    \  using ri0r = Ri0rReg<BaseAddress + 0x01B0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Rdt0rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using time = FieldModel<uint32_t, address, 16, 16>;\n    using\
    \ fmi = FieldModel<uint32_t, address, 8, 8>;\n    using dlc = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 16, 16> time;\n      BitFieldModel<uint32_t, 8,\
    \ 8> fmi;\n      BitFieldModel<uint32_t, 0, 4> dlc;\n    };\n  };\n\npublic:\n\
    \  using rdt0r = Rdt0rReg<BaseAddress + 0x01B4>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Rdl0rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using data3 = FieldModel<uint32_t, address, 24, 8>;\n    using\
    \ data2 = FieldModel<uint32_t, address, 16, 8>;\n    using data1 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using data0 = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> data3;\n      BitFieldModel<uint32_t, 16, 8> data2;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data1;\n      BitFieldModel<uint32_t, 0, 8> data0;\n    };\n  };\n\npublic:\n\
    \  using rdl0r = Rdl0rReg<BaseAddress + 0x01B8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Rdh0rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using data7 = FieldModel<uint32_t, address, 24, 8>;\n    using\
    \ data6 = FieldModel<uint32_t, address, 16, 8>;\n    using data5 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using data4 = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> data7;\n      BitFieldModel<uint32_t, 16, 8> data6;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data5;\n      BitFieldModel<uint32_t, 0, 8> data4;\n    };\n  };\n\npublic:\n\
    \  using rdh0r = Rdh0rReg<BaseAddress + 0x01BC>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ri1rReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using stid = FieldModel<uint32_t, address, 21, 11>;\n    using\
    \ exid = FieldModel<uint32_t, address, 3, 18>;\n    using ide = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using rtr = FieldModel<uint32_t, address, 1, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 21,\
    \ 11> stid;\n      BitFieldModel<uint32_t, 3, 18> exid;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ide;\n      BitFieldModel<uint32_t, 1, 1> rtr;\n    };\n  };\n\npublic:\n\
    \  using ri1r = Ri1rReg<BaseAddress + 0x01C0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Rdt1rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using time = FieldModel<uint32_t, address, 16, 16>;\n    using\
    \ fmi = FieldModel<uint32_t, address, 8, 8>;\n    using dlc = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 16, 16> time;\n      BitFieldModel<uint32_t, 8,\
    \ 8> fmi;\n      BitFieldModel<uint32_t, 0, 4> dlc;\n    };\n  };\n\npublic:\n\
    \  using rdt1r = Rdt1rReg<BaseAddress + 0x01C4>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Rdl1rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using data3 = FieldModel<uint32_t, address, 24, 8>;\n    using\
    \ data2 = FieldModel<uint32_t, address, 16, 8>;\n    using data1 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using data0 = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> data3;\n      BitFieldModel<uint32_t, 16, 8> data2;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data1;\n      BitFieldModel<uint32_t, 0, 8> data0;\n    };\n  };\n\npublic:\n\
    \  using rdl1r = Rdl1rReg<BaseAddress + 0x01C8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Rdh1rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using data7 = FieldModel<uint32_t, address, 24, 8>;\n    using\
    \ data6 = FieldModel<uint32_t, address, 16, 8>;\n    using data5 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using data4 = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> data7;\n      BitFieldModel<uint32_t, 16, 8> data6;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data5;\n      BitFieldModel<uint32_t, 0, 8> data4;\n    };\n  };\n\npublic:\n\
    \  using rdh1r = Rdh1rReg<BaseAddress + 0x01CC>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class FmrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using can2sb = FieldModel<uint32_t, address, 8, 6>;\n    using\
    \ finit = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n \
    \   {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 6> can2sb;\n  \
    \    BitFieldModel<uint32_t, 0, 1> finit;\n    };\n  };\n\npublic:\n  using fmr\
    \ = FmrReg<BaseAddress + 0x0200>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Fm1rReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   using fbm0 = FieldModel<uint32_t, address, 0, 1>;\n    using fbm1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using fbm2 = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using fbm3 = FieldModel<uint32_t, address, 3, 1>;\n    using fbm4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using fbm5 = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using fbm6 = FieldModel<uint32_t, address, 6, 1>;\n    using fbm7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using fbm8 = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using fbm9 = FieldModel<uint32_t, address, 9, 1>;\n    using fbm10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using fbm11 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using fbm12 = FieldModel<uint32_t, address, 12, 1>;\n    using fbm13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using fbm14 = FieldModel<uint32_t, address, 14, 1>;\n\
    \    using fbm15 = FieldModel<uint32_t, address, 15, 1>;\n    using fbm16 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using fbm17 = FieldModel<uint32_t, address, 17, 1>;\n\
    \    using fbm18 = FieldModel<uint32_t, address, 18, 1>;\n    using fbm19 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using fbm20 = FieldModel<uint32_t, address, 20, 1>;\n\
    \    using fbm21 = FieldModel<uint32_t, address, 21, 1>;\n    using fbm22 = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    using fbm23 = FieldModel<uint32_t, address, 23, 1>;\n\
    \    using fbm24 = FieldModel<uint32_t, address, 24, 1>;\n    using fbm25 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using fbm26 = FieldModel<uint32_t, address, 26, 1>;\n\
    \    using fbm27 = FieldModel<uint32_t, address, 27, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fbm0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fbm1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fbm2;\n      BitFieldModel<uint32_t, 3, 1> fbm3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fbm4;\n      BitFieldModel<uint32_t, 5, 1> fbm5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fbm6;\n      BitFieldModel<uint32_t, 7, 1> fbm7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fbm8;\n      BitFieldModel<uint32_t, 9, 1> fbm9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fbm10;\n      BitFieldModel<uint32_t, 11, 1> fbm11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fbm12;\n      BitFieldModel<uint32_t, 13, 1> fbm13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fbm14;\n      BitFieldModel<uint32_t, 15, 1> fbm15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fbm16;\n      BitFieldModel<uint32_t, 17, 1> fbm17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fbm18;\n      BitFieldModel<uint32_t, 19, 1> fbm19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fbm20;\n      BitFieldModel<uint32_t, 21, 1> fbm21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fbm22;\n      BitFieldModel<uint32_t, 23, 1> fbm23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fbm24;\n      BitFieldModel<uint32_t, 25, 1> fbm25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fbm26;\n      BitFieldModel<uint32_t, 27, 1> fbm27;\n    };\n  };\n\n\
    public:\n  using fm1r = Fm1rReg<BaseAddress + 0x0204>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Fs1rReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fsc0 = FieldModel<uint32_t, address, 0, 1>;\n    using fsc1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fsc2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fsc3 = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using fsc4 = FieldModel<uint32_t, address, 4, 1>;\n    using fsc5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fsc6 = FieldModel<uint32_t, address, 6, 1>;\n   \
    \ using fsc7 = FieldModel<uint32_t, address, 7, 1>;\n    using fsc8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fsc9 = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using fsc10 = FieldModel<uint32_t, address, 10, 1>;\n    using fsc11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fsc12 = FieldModel<uint32_t, address, 12, 1>;\n\
    \    using fsc13 = FieldModel<uint32_t, address, 13, 1>;\n    using fsc14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fsc15 = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using fsc16 = FieldModel<uint32_t, address, 16, 1>;\n    using fsc17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fsc18 = FieldModel<uint32_t, address, 18, 1>;\n\
    \    using fsc19 = FieldModel<uint32_t, address, 19, 1>;\n    using fsc20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fsc21 = FieldModel<uint32_t, address, 21, 1>;\n\
    \    using fsc22 = FieldModel<uint32_t, address, 22, 1>;\n    using fsc23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fsc24 = FieldModel<uint32_t, address, 24, 1>;\n\
    \    using fsc25 = FieldModel<uint32_t, address, 25, 1>;\n    using fsc26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fsc27 = FieldModel<uint32_t, address, 27, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> fsc0;\n      BitFieldModel<uint32_t, 1, 1> fsc1;\n      BitFieldModel<uint32_t,\
    \ 2, 1> fsc2;\n      BitFieldModel<uint32_t, 3, 1> fsc3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fsc4;\n      BitFieldModel<uint32_t, 5, 1> fsc5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fsc6;\n      BitFieldModel<uint32_t, 7, 1> fsc7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fsc8;\n      BitFieldModel<uint32_t, 9, 1> fsc9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fsc10;\n      BitFieldModel<uint32_t, 11, 1> fsc11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fsc12;\n      BitFieldModel<uint32_t, 13, 1> fsc13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fsc14;\n      BitFieldModel<uint32_t, 15, 1> fsc15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fsc16;\n      BitFieldModel<uint32_t, 17, 1> fsc17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fsc18;\n      BitFieldModel<uint32_t, 19, 1> fsc19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fsc20;\n      BitFieldModel<uint32_t, 21, 1> fsc21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fsc22;\n      BitFieldModel<uint32_t, 23, 1> fsc23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fsc24;\n      BitFieldModel<uint32_t, 25, 1> fsc25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fsc26;\n      BitFieldModel<uint32_t, 27, 1> fsc27;\n    };\n  };\n\n\
    public:\n  using fs1r = Fs1rReg<BaseAddress + 0x020C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ffa1rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using ffa0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ ffa1 = FieldModel<uint32_t, address, 1, 1>;\n    using ffa2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using ffa3 = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using ffa4 = FieldModel<uint32_t, address, 4, 1>;\n    using ffa5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using ffa6 = FieldModel<uint32_t, address, 6, 1>;\n   \
    \ using ffa7 = FieldModel<uint32_t, address, 7, 1>;\n    using ffa8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using ffa9 = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using ffa10 = FieldModel<uint32_t, address, 10, 1>;\n    using ffa11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using ffa12 = FieldModel<uint32_t, address, 12, 1>;\n\
    \    using ffa13 = FieldModel<uint32_t, address, 13, 1>;\n    using ffa14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using ffa15 = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using ffa16 = FieldModel<uint32_t, address, 16, 1>;\n    using ffa17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using ffa18 = FieldModel<uint32_t, address, 18, 1>;\n\
    \    using ffa19 = FieldModel<uint32_t, address, 19, 1>;\n    using ffa20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using ffa21 = FieldModel<uint32_t, address, 21, 1>;\n\
    \    using ffa22 = FieldModel<uint32_t, address, 22, 1>;\n    using ffa23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using ffa24 = FieldModel<uint32_t, address, 24, 1>;\n\
    \    using ffa25 = FieldModel<uint32_t, address, 25, 1>;\n    using ffa26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using ffa27 = FieldModel<uint32_t, address, 27, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> ffa0;\n      BitFieldModel<uint32_t, 1, 1> ffa1;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ffa2;\n      BitFieldModel<uint32_t, 3, 1> ffa3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> ffa4;\n      BitFieldModel<uint32_t, 5, 1> ffa5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> ffa6;\n      BitFieldModel<uint32_t, 7, 1> ffa7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> ffa8;\n      BitFieldModel<uint32_t, 9, 1> ffa9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> ffa10;\n      BitFieldModel<uint32_t, 11, 1> ffa11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> ffa12;\n      BitFieldModel<uint32_t, 13, 1> ffa13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> ffa14;\n      BitFieldModel<uint32_t, 15, 1> ffa15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> ffa16;\n      BitFieldModel<uint32_t, 17, 1> ffa17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> ffa18;\n      BitFieldModel<uint32_t, 19, 1> ffa19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> ffa20;\n      BitFieldModel<uint32_t, 21, 1> ffa21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> ffa22;\n      BitFieldModel<uint32_t, 23, 1> ffa23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> ffa24;\n      BitFieldModel<uint32_t, 25, 1> ffa25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> ffa26;\n      BitFieldModel<uint32_t, 27, 1> ffa27;\n    };\n  };\n\n\
    public:\n  using ffa1r = Ffa1rReg<BaseAddress + 0x0214>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Fa1rReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fact0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fact1 = FieldModel<uint32_t, address, 1, 1>;\n    using fact2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fact3 = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using fact4 = FieldModel<uint32_t, address, 4, 1>;\n    using fact5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fact6 = FieldModel<uint32_t, address, 6, 1>;\n  \
    \  using fact7 = FieldModel<uint32_t, address, 7, 1>;\n    using fact8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fact9 = FieldModel<uint32_t, address, 9, 1>;\n  \
    \  using fact10 = FieldModel<uint32_t, address, 10, 1>;\n    using fact11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fact12 = FieldModel<uint32_t, address, 12, 1>;\n\
    \    using fact13 = FieldModel<uint32_t, address, 13, 1>;\n    using fact14 =\
    \ FieldModel<uint32_t, address, 14, 1>;\n    using fact15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using fact16 = FieldModel<uint32_t, address, 16, 1>;\n\
    \    using fact17 = FieldModel<uint32_t, address, 17, 1>;\n    using fact18 =\
    \ FieldModel<uint32_t, address, 18, 1>;\n    using fact19 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using fact20 = FieldModel<uint32_t, address, 20, 1>;\n\
    \    using fact21 = FieldModel<uint32_t, address, 21, 1>;\n    using fact22 =\
    \ FieldModel<uint32_t, address, 22, 1>;\n    using fact23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fact24 = FieldModel<uint32_t, address, 24, 1>;\n\
    \    using fact25 = FieldModel<uint32_t, address, 25, 1>;\n    using fact26 =\
    \ FieldModel<uint32_t, address, 26, 1>;\n    using fact27 = FieldModel<uint32_t,\
    \ address, 27, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> fact0;\n      BitFieldModel<uint32_t, 1,\
    \ 1> fact1;\n      BitFieldModel<uint32_t, 2, 1> fact2;\n      BitFieldModel<uint32_t,\
    \ 3, 1> fact3;\n      BitFieldModel<uint32_t, 4, 1> fact4;\n      BitFieldModel<uint32_t,\
    \ 5, 1> fact5;\n      BitFieldModel<uint32_t, 6, 1> fact6;\n      BitFieldModel<uint32_t,\
    \ 7, 1> fact7;\n      BitFieldModel<uint32_t, 8, 1> fact8;\n      BitFieldModel<uint32_t,\
    \ 9, 1> fact9;\n      BitFieldModel<uint32_t, 10, 1> fact10;\n      BitFieldModel<uint32_t,\
    \ 11, 1> fact11;\n      BitFieldModel<uint32_t, 12, 1> fact12;\n      BitFieldModel<uint32_t,\
    \ 13, 1> fact13;\n      BitFieldModel<uint32_t, 14, 1> fact14;\n      BitFieldModel<uint32_t,\
    \ 15, 1> fact15;\n      BitFieldModel<uint32_t, 16, 1> fact16;\n      BitFieldModel<uint32_t,\
    \ 17, 1> fact17;\n      BitFieldModel<uint32_t, 18, 1> fact18;\n      BitFieldModel<uint32_t,\
    \ 19, 1> fact19;\n      BitFieldModel<uint32_t, 20, 1> fact20;\n      BitFieldModel<uint32_t,\
    \ 21, 1> fact21;\n      BitFieldModel<uint32_t, 22, 1> fact22;\n      BitFieldModel<uint32_t,\
    \ 23, 1> fact23;\n      BitFieldModel<uint32_t, 24, 1> fact24;\n      BitFieldModel<uint32_t,\
    \ 25, 1> fact25;\n      BitFieldModel<uint32_t, 26, 1> fact26;\n      BitFieldModel<uint32_t,\
    \ 27, 1> fact27;\n    };\n  };\n\npublic:\n  using fa1r = Fa1rReg<BaseAddress\
    \ + 0x021C>;\n\nprivate:\n  template<unsigned int address>\n  class F0r1Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using fb0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ fb2 = FieldModel<uint32_t, address, 2, 1>;\n    using fb3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ fb5 = FieldModel<uint32_t, address, 5, 1>;\n    using fb6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ fb8 = FieldModel<uint32_t, address, 8, 1>;\n    using fb9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using fb10 = FieldModel<uint32_t, address, 10, 1>;\n  \
    \  using fb11 = FieldModel<uint32_t, address, 11, 1>;\n    using fb12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using fb13 = FieldModel<uint32_t, address, 13, 1>;\n \
    \   using fb14 = FieldModel<uint32_t, address, 14, 1>;\n    using fb15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using fb16 = FieldModel<uint32_t, address, 16, 1>;\n \
    \   using fb17 = FieldModel<uint32_t, address, 17, 1>;\n    using fb18 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    using fb19 = FieldModel<uint32_t, address, 19, 1>;\n \
    \   using fb20 = FieldModel<uint32_t, address, 20, 1>;\n    using fb21 = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    using fb22 = FieldModel<uint32_t, address, 22, 1>;\n \
    \   using fb23 = FieldModel<uint32_t, address, 23, 1>;\n    using fb24 = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    using fb25 = FieldModel<uint32_t, address, 25, 1>;\n \
    \   using fb26 = FieldModel<uint32_t, address, 26, 1>;\n    using fb27 = FieldModel<uint32_t,\
    \ address, 27, 1>;\n    using fb28 = FieldModel<uint32_t, address, 28, 1>;\n \
    \   using fb29 = FieldModel<uint32_t, address, 29, 1>;\n    using fb30 = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> fb0;\n      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t,\
    \ 2, 1> fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f0r1 = F0r1Reg<BaseAddress + 0x0240>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F0r2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f0r2 = F0r2Reg<BaseAddress + 0x0244>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F1r1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f1r1 = F1r1Reg<BaseAddress + 0x0248>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F1r2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f1r2 = F1r2Reg<BaseAddress + 0x024C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F2r1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f2r1 = F2r1Reg<BaseAddress + 0x0250>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F2r2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f2r2 = F2r2Reg<BaseAddress + 0x0254>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F3r1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f3r1 = F3r1Reg<BaseAddress + 0x0258>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F3r2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f3r2 = F3r2Reg<BaseAddress + 0x025C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F4r1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f4r1 = F4r1Reg<BaseAddress + 0x0260>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F4r2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f4r2 = F4r2Reg<BaseAddress + 0x0264>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F5r1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f5r1 = F5r1Reg<BaseAddress + 0x0268>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F5r2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f5r2 = F5r2Reg<BaseAddress + 0x026C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F6r1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f6r1 = F6r1Reg<BaseAddress + 0x0270>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F6r2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f6r2 = F6r2Reg<BaseAddress + 0x0274>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F7r1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f7r1 = F7r1Reg<BaseAddress + 0x0278>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F7r2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f7r2 = F7r2Reg<BaseAddress + 0x027C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F8r1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f8r1 = F8r1Reg<BaseAddress + 0x0280>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F8r2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f8r2 = F8r2Reg<BaseAddress + 0x0284>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F9r1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f9r1 = F9r1Reg<BaseAddress + 0x0288>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F9r2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f9r2 = F9r2Reg<BaseAddress + 0x028C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F10r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f10r1 = F10r1Reg<BaseAddress + 0x0290>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F10r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f10r2 = F10r2Reg<BaseAddress + 0x0294>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F11r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f11r1 = F11r1Reg<BaseAddress + 0x0298>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F11r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f11r2 = F11r2Reg<BaseAddress + 0x029C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F12r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f12r1 = F12r1Reg<BaseAddress + 0x02A0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F12r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f12r2 = F12r2Reg<BaseAddress + 0x02A4>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F13r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f13r1 = F13r1Reg<BaseAddress + 0x02A8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F13r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f13r2 = F13r2Reg<BaseAddress + 0x02AC>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F14r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f14r1 = F14r1Reg<BaseAddress + 0x02B0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F14r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f14r2 = F14r2Reg<BaseAddress + 0x02B4>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F15r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f15r1 = F15r1Reg<BaseAddress + 0x02B8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F15r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f15r2 = F15r2Reg<BaseAddress + 0x02BC>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F16r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f16r1 = F16r1Reg<BaseAddress + 0x02C0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F16r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f16r2 = F16r2Reg<BaseAddress + 0x02C4>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F17r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f17r1 = F17r1Reg<BaseAddress + 0x02C8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F17r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f17r2 = F17r2Reg<BaseAddress + 0x02CC>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F18r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f18r1 = F18r1Reg<BaseAddress + 0x02D0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F18r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f18r2 = F18r2Reg<BaseAddress + 0x02D4>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F19r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f19r1 = F19r1Reg<BaseAddress + 0x02D8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F19r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f19r2 = F19r2Reg<BaseAddress + 0x02DC>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F20r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f20r1 = F20r1Reg<BaseAddress + 0x02E0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F20r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f20r2 = F20r2Reg<BaseAddress + 0x02E4>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F21r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f21r1 = F21r1Reg<BaseAddress + 0x02E8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F21r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f21r2 = F21r2Reg<BaseAddress + 0x02EC>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F22r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f22r1 = F22r1Reg<BaseAddress + 0x02F0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F22r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f22r2 = F22r2Reg<BaseAddress + 0x02F4>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F23r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f23r1 = F23r1Reg<BaseAddress + 0x02F8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F23r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f23r2 = F23r2Reg<BaseAddress + 0x02FC>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F24r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f24r1 = F24r1Reg<BaseAddress + 0x0300>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F24r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f24r2 = F24r2Reg<BaseAddress + 0x0304>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F25r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f25r1 = F25r1Reg<BaseAddress + 0x0308>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F25r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f25r2 = F25r2Reg<BaseAddress + 0x030C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F26r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f26r1 = F26r1Reg<BaseAddress + 0x0310>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F26r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f26r2 = F26r2Reg<BaseAddress + 0x0314>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F27r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f27r1 = F27r1Reg<BaseAddress + 0x0318>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F27r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f27r2 = F27r2Reg<BaseAddress + 0x031C>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class TixrBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using stid = FieldModel<uint32_t,\
    \ address, 21, 11, bankOffset>;\n    using exid = FieldModel<uint32_t, address,\
    \ 3, 18, bankOffset>;\n    using ide = FieldModel<uint32_t, address, 2, 1, bankOffset>;\n\
    \    using rtr = FieldModel<uint32_t, address, 1, 1, bankOffset>;\n    using txrq\
    \ = FieldModel<uint32_t, address, 0, 1, bankOffset>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 21, 11> stid;\n \
    \     BitFieldModel<uint32_t, 3, 18> exid;\n      BitFieldModel<uint32_t, 2, 1>\
    \ ide;\n      BitFieldModel<uint32_t, 1, 1> rtr;\n      BitFieldModel<uint32_t,\
    \ 0, 1> txrq;\n    };\n  };\n\npublic:\n  using tixr = TixrBankReg<BaseAddress\
    \ + 0x0180, 0x0010>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class TdtxrBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using time = FieldModel<uint32_t, address,\
    \ 16, 16, bankOffset>;\n    using tgt = FieldModel<uint32_t, address, 8, 1, bankOffset>;\n\
    \    using dlc = FieldModel<uint32_t, address, 0, 4, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16,\
    \ 16> time;\n      BitFieldModel<uint32_t, 8, 1> tgt;\n      BitFieldModel<uint32_t,\
    \ 0, 4> dlc;\n    };\n  };\n\npublic:\n  using tdtxr = TdtxrBankReg<BaseAddress\
    \ + 0x0184, 0x0010>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class TdlxrBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using data3 = FieldModel<uint32_t, address,\
    \ 24, 8, bankOffset>;\n    using data2 = FieldModel<uint32_t, address, 16, 8,\
    \ bankOffset>;\n    using data1 = FieldModel<uint32_t, address, 8, 8, bankOffset>;\n\
    \    using data0 = FieldModel<uint32_t, address, 0, 8, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 24,\
    \ 8> data3;\n      BitFieldModel<uint32_t, 16, 8> data2;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data1;\n      BitFieldModel<uint32_t, 0, 8> data0;\n    };\n  };\n\npublic:\n\
    \  using tdlxr = TdlxrBankReg<BaseAddress + 0x0188, 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class TdhxrBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using data7 = FieldModel<uint32_t,\
    \ address, 24, 8, bankOffset>;\n    using data6 = FieldModel<uint32_t, address,\
    \ 16, 8, bankOffset>;\n    using data5 = FieldModel<uint32_t, address, 8, 8, bankOffset>;\n\
    \    using data4 = FieldModel<uint32_t, address, 0, 8, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 24,\
    \ 8> data7;\n      BitFieldModel<uint32_t, 16, 8> data6;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data5;\n      BitFieldModel<uint32_t, 0, 8> data4;\n    };\n  };\n\npublic:\n\
    \  using tdhxr = TdhxrBankReg<BaseAddress + 0x018C, 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class RixrBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using stid = FieldModel<uint32_t,\
    \ address, 21, 11, bankOffset>;\n    using exid = FieldModel<uint32_t, address,\
    \ 3, 18, bankOffset>;\n    using ide = FieldModel<uint32_t, address, 2, 1, bankOffset>;\n\
    \    using rtr = FieldModel<uint32_t, address, 1, 1, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 21,\
    \ 11> stid;\n      BitFieldModel<uint32_t, 3, 18> exid;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ide;\n      BitFieldModel<uint32_t, 1, 1> rtr;\n    };\n  };\n\npublic:\n\
    \  using rixr = RixrBankReg<BaseAddress + 0x01B0, 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class RdtxrBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using time = FieldModel<uint32_t,\
    \ address, 16, 16, bankOffset>;\n    using fmi = FieldModel<uint32_t, address,\
    \ 8, 8, bankOffset>;\n    using dlc = FieldModel<uint32_t, address, 0, 4, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 16, 16> time;\n      BitFieldModel<uint32_t, 8, 8> fmi;\n      BitFieldModel<uint32_t,\
    \ 0, 4> dlc;\n    };\n  };\n\npublic:\n  using rdtxr = RdtxrBankReg<BaseAddress\
    \ + 0x01B4, 0x0010>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class Fxr2BankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0,\
    \ 1, bankOffset>;\n    using fb1 = FieldModel<uint32_t, address, 1, 1, bankOffset>;\n\
    \    using fb2 = FieldModel<uint32_t, address, 2, 1, bankOffset>;\n    using fb3\
    \ = FieldModel<uint32_t, address, 3, 1, bankOffset>;\n    using fb4 = FieldModel<uint32_t,\
    \ address, 4, 1, bankOffset>;\n    using fb5 = FieldModel<uint32_t, address, 5,\
    \ 1, bankOffset>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1, bankOffset>;\n\
    \    using fb7 = FieldModel<uint32_t, address, 7, 1, bankOffset>;\n    using fb8\
    \ = FieldModel<uint32_t, address, 8, 1, bankOffset>;\n    using fb9 = FieldModel<uint32_t,\
    \ address, 9, 1, bankOffset>;\n    using fb10 = FieldModel<uint32_t, address,\
    \ 10, 1, bankOffset>;\n    using fb11 = FieldModel<uint32_t, address, 11, 1, bankOffset>;\n\
    \    using fb12 = FieldModel<uint32_t, address, 12, 1, bankOffset>;\n    using\
    \ fb13 = FieldModel<uint32_t, address, 13, 1, bankOffset>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1, bankOffset>;\n    using fb15 = FieldModel<uint32_t, address,\
    \ 15, 1, bankOffset>;\n    using fb16 = FieldModel<uint32_t, address, 16, 1, bankOffset>;\n\
    \    using fb17 = FieldModel<uint32_t, address, 17, 1, bankOffset>;\n    using\
    \ fb18 = FieldModel<uint32_t, address, 18, 1, bankOffset>;\n    using fb19 = FieldModel<uint32_t,\
    \ address, 19, 1, bankOffset>;\n    using fb20 = FieldModel<uint32_t, address,\
    \ 20, 1, bankOffset>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1, bankOffset>;\n\
    \    using fb22 = FieldModel<uint32_t, address, 22, 1, bankOffset>;\n    using\
    \ fb23 = FieldModel<uint32_t, address, 23, 1, bankOffset>;\n    using fb24 = FieldModel<uint32_t,\
    \ address, 24, 1, bankOffset>;\n    using fb25 = FieldModel<uint32_t, address,\
    \ 25, 1, bankOffset>;\n    using fb26 = FieldModel<uint32_t, address, 26, 1, bankOffset>;\n\
    \    using fb27 = FieldModel<uint32_t, address, 27, 1, bankOffset>;\n    using\
    \ fb28 = FieldModel<uint32_t, address, 28, 1, bankOffset>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1, bankOffset>;\n    using fb30 = FieldModel<uint32_t, address,\
    \ 30, 1, bankOffset>;\n    using fb31 = FieldModel<uint32_t, address, 31, 1, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> fb0;\n      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t,\
    \ 2, 1> fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using fxr2 = Fxr2BankReg<BaseAddress + 0x024C, 0x0008>;\n};\n\n}\n\n#endif\
    \ /* DRAL_STM32F446_CAN1_H */\n"
  name: CAN1
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_CAN2_H\n#define DRAL_STM32F446_CAN2_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass can2\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40006800;\n\nprivate:\n\
    \  template<unsigned int address>\n  class McrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dbf = FieldModel<uint32_t, address, 16,\
    \ 1>;\n    using reset = FieldModel<uint32_t, address, 15, 1>;\n    using ttcm\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    using abom = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using awum = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using nart = FieldModel<uint32_t, address, 4, 1>;\n    using rflm = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using txfp = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using sleep = FieldModel<uint32_t, address, 1, 1>;\n    using inrq = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 16, 1> dbf;\n      BitFieldModel<uint32_t, 15,\
    \ 1> reset;\n      BitFieldModel<uint32_t, 7, 1> ttcm;\n      BitFieldModel<uint32_t,\
    \ 6, 1> abom;\n      BitFieldModel<uint32_t, 5, 1> awum;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nart;\n      BitFieldModel<uint32_t, 3, 1> rflm;\n      BitFieldModel<uint32_t,\
    \ 2, 1> txfp;\n      BitFieldModel<uint32_t, 1, 1> sleep;\n      BitFieldModel<uint32_t,\
    \ 0, 1> inrq;\n    };\n  };\n\npublic:\n  using mcr = McrReg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class MsrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using rx = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using samp = FieldModel<uint32_t, address, 10, 1>;\n    using rxm = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using txm = FieldModel<uint32_t, address, 8, 1>;\n    using\
    \ slaki = FieldModel<uint32_t, address, 4, 1>;\n    using wkui = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using erri = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using slak = FieldModel<uint32_t, address, 1, 1>;\n    using inak = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 11, 1> rx;\n      BitFieldModel<uint32_t, 10, 1>\
    \ samp;\n      BitFieldModel<uint32_t, 9, 1> rxm;\n      BitFieldModel<uint32_t,\
    \ 8, 1> txm;\n      BitFieldModel<uint32_t, 4, 1> slaki;\n      BitFieldModel<uint32_t,\
    \ 3, 1> wkui;\n      BitFieldModel<uint32_t, 2, 1> erri;\n      BitFieldModel<uint32_t,\
    \ 1, 1> slak;\n      BitFieldModel<uint32_t, 0, 1> inak;\n    };\n  };\n\npublic:\n\
    \  using msr = MsrReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class TsrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using low2 = FieldModel<uint32_t, address, 31, 1>;\n    using\
    \ low1 = FieldModel<uint32_t, address, 30, 1>;\n    using low0 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using tme2 = FieldModel<uint32_t, address, 28, 1>;\n \
    \   using tme1 = FieldModel<uint32_t, address, 27, 1>;\n    using tme0 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using code = FieldModel<uint32_t, address, 24, 2>;\n \
    \   using abrq2 = FieldModel<uint32_t, address, 23, 1>;\n    using terr2 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using alst2 = FieldModel<uint32_t, address, 18, 1>;\n\
    \    using txok2 = FieldModel<uint32_t, address, 17, 1>;\n    using rqcp2 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using abrq1 = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using terr1 = FieldModel<uint32_t, address, 11, 1>;\n    using alst1 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using txok1 = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using rqcp1 = FieldModel<uint32_t, address, 8, 1>;\n    using abrq0 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using terr0 = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using alst0 = FieldModel<uint32_t, address, 2, 1>;\n    using txok0 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using rqcp0 = FieldModel<uint32_t, address, 0, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 31, 1> low2;\n      BitFieldModel<uint32_t, 30, 1> low1;\n      BitFieldModel<uint32_t,\
    \ 29, 1> low0;\n      BitFieldModel<uint32_t, 28, 1> tme2;\n      BitFieldModel<uint32_t,\
    \ 27, 1> tme1;\n      BitFieldModel<uint32_t, 26, 1> tme0;\n      BitFieldModel<uint32_t,\
    \ 24, 2> code;\n      BitFieldModel<uint32_t, 23, 1> abrq2;\n      BitFieldModel<uint32_t,\
    \ 19, 1> terr2;\n      BitFieldModel<uint32_t, 18, 1> alst2;\n      BitFieldModel<uint32_t,\
    \ 17, 1> txok2;\n      BitFieldModel<uint32_t, 16, 1> rqcp2;\n      BitFieldModel<uint32_t,\
    \ 15, 1> abrq1;\n      BitFieldModel<uint32_t, 11, 1> terr1;\n      BitFieldModel<uint32_t,\
    \ 10, 1> alst1;\n      BitFieldModel<uint32_t, 9, 1> txok1;\n      BitFieldModel<uint32_t,\
    \ 8, 1> rqcp1;\n      BitFieldModel<uint32_t, 7, 1> abrq0;\n      BitFieldModel<uint32_t,\
    \ 3, 1> terr0;\n      BitFieldModel<uint32_t, 2, 1> alst0;\n      BitFieldModel<uint32_t,\
    \ 1, 1> txok0;\n      BitFieldModel<uint32_t, 0, 1> rqcp0;\n    };\n  };\n\npublic:\n\
    \  using tsr = TsrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Rf0rReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using rfom0 = FieldModel<uint32_t, address, 5, 1>;\n    using\
    \ fovr0 = FieldModel<uint32_t, address, 4, 1>;\n    using full0 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using fmp0 = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 5, 1> rfom0;\n      BitFieldModel<uint32_t, 4, 1> fovr0;\n      BitFieldModel<uint32_t,\
    \ 3, 1> full0;\n      BitFieldModel<uint32_t, 0, 2> fmp0;\n    };\n  };\n\npublic:\n\
    \  using rf0r = Rf0rReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Rf1rReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using rfom1 = FieldModel<uint32_t, address, 5, 1>;\n    using\
    \ fovr1 = FieldModel<uint32_t, address, 4, 1>;\n    using full1 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using fmp1 = FieldModel<uint32_t, address, 0, 2>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 5, 1> rfom1;\n      BitFieldModel<uint32_t, 4, 1> fovr1;\n      BitFieldModel<uint32_t,\
    \ 3, 1> full1;\n      BitFieldModel<uint32_t, 0, 2> fmp1;\n    };\n  };\n\npublic:\n\
    \  using rf1r = Rf1rReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class IerReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using slkie = FieldModel<uint32_t, address, 17, 1>;\n    using\
    \ wkuie = FieldModel<uint32_t, address, 16, 1>;\n    using errie = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using lecie = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using bofie = FieldModel<uint32_t, address, 10, 1>;\n    using epvie = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using ewgie = FieldModel<uint32_t, address, 8, 1>;\n  \
    \  using fovie1 = FieldModel<uint32_t, address, 6, 1>;\n    using ffie1 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fmpie1 = FieldModel<uint32_t, address, 4, 1>;\n \
    \   using fovie0 = FieldModel<uint32_t, address, 3, 1>;\n    using ffie0 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fmpie0 = FieldModel<uint32_t, address, 1, 1>;\n \
    \   using tmeie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 17, 1> slkie;\n\
    \      BitFieldModel<uint32_t, 16, 1> wkuie;\n      BitFieldModel<uint32_t, 15,\
    \ 1> errie;\n      BitFieldModel<uint32_t, 11, 1> lecie;\n      BitFieldModel<uint32_t,\
    \ 10, 1> bofie;\n      BitFieldModel<uint32_t, 9, 1> epvie;\n      BitFieldModel<uint32_t,\
    \ 8, 1> ewgie;\n      BitFieldModel<uint32_t, 6, 1> fovie1;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ffie1;\n      BitFieldModel<uint32_t, 4, 1> fmpie1;\n      BitFieldModel<uint32_t,\
    \ 3, 1> fovie0;\n      BitFieldModel<uint32_t, 2, 1> ffie0;\n      BitFieldModel<uint32_t,\
    \ 1, 1> fmpie0;\n      BitFieldModel<uint32_t, 0, 1> tmeie;\n    };\n  };\n\n\
    public:\n  using ier = IerReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class EsrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using rec = FieldModel<uint32_t, address, 24, 8>;\n    using tec\
    \ = FieldModel<uint32_t, address, 16, 8>;\n    using lec = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    using boff = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using epvf = FieldModel<uint32_t, address, 1, 1>;\n    using ewgf = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 24, 8> rec;\n      BitFieldModel<uint32_t, 16,\
    \ 8> tec;\n      BitFieldModel<uint32_t, 4, 3> lec;\n      BitFieldModel<uint32_t,\
    \ 2, 1> boff;\n      BitFieldModel<uint32_t, 1, 1> epvf;\n      BitFieldModel<uint32_t,\
    \ 0, 1> ewgf;\n    };\n  };\n\npublic:\n  using esr = EsrReg<BaseAddress + 0x0018>;\n\
    \nprivate:\n  template<unsigned int address>\n  class BtrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using silm = FieldModel<uint32_t, address, 31,\
    \ 1>;\n    using lbkm = FieldModel<uint32_t, address, 30, 1>;\n    using sjw =\
    \ FieldModel<uint32_t, address, 24, 2>;\n    using ts2 = FieldModel<uint32_t,\
    \ address, 20, 3>;\n    using ts1 = FieldModel<uint32_t, address, 16, 4>;\n  \
    \  using brp = FieldModel<uint32_t, address, 0, 10>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 31, 1> silm;\n  \
    \    BitFieldModel<uint32_t, 30, 1> lbkm;\n      BitFieldModel<uint32_t, 24, 2>\
    \ sjw;\n      BitFieldModel<uint32_t, 20, 3> ts2;\n      BitFieldModel<uint32_t,\
    \ 16, 4> ts1;\n      BitFieldModel<uint32_t, 0, 10> brp;\n    };\n  };\n\npublic:\n\
    \  using btr = BtrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ti0rReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using stid = FieldModel<uint32_t, address, 21, 11>;\n    using\
    \ exid = FieldModel<uint32_t, address, 3, 18>;\n    using ide = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using rtr = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ txrq = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n  \
    \  {\n      uint32_t value;\n      BitFieldModel<uint32_t, 21, 11> stid;\n   \
    \   BitFieldModel<uint32_t, 3, 18> exid;\n      BitFieldModel<uint32_t, 2, 1>\
    \ ide;\n      BitFieldModel<uint32_t, 1, 1> rtr;\n      BitFieldModel<uint32_t,\
    \ 0, 1> txrq;\n    };\n  };\n\npublic:\n  using ti0r = Ti0rReg<BaseAddress + 0x0180>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Tdt0rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using time = FieldModel<uint32_t, address, 16,\
    \ 16>;\n    using tgt = FieldModel<uint32_t, address, 8, 1>;\n    using dlc =\
    \ FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n    union reg\n    {\n  \
    \    uint32_t value;\n      BitFieldModel<uint32_t, 16, 16> time;\n      BitFieldModel<uint32_t,\
    \ 8, 1> tgt;\n      BitFieldModel<uint32_t, 0, 4> dlc;\n    };\n  };\n\npublic:\n\
    \  using tdt0r = Tdt0rReg<BaseAddress + 0x0184>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Tdl0rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using data3 = FieldModel<uint32_t, address, 24, 8>;\n    using\
    \ data2 = FieldModel<uint32_t, address, 16, 8>;\n    using data1 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using data0 = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> data3;\n      BitFieldModel<uint32_t, 16, 8> data2;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data1;\n      BitFieldModel<uint32_t, 0, 8> data0;\n    };\n  };\n\npublic:\n\
    \  using tdl0r = Tdl0rReg<BaseAddress + 0x0188>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Tdh0rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using data7 = FieldModel<uint32_t, address, 24, 8>;\n    using\
    \ data6 = FieldModel<uint32_t, address, 16, 8>;\n    using data5 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using data4 = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> data7;\n      BitFieldModel<uint32_t, 16, 8> data6;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data5;\n      BitFieldModel<uint32_t, 0, 8> data4;\n    };\n  };\n\npublic:\n\
    \  using tdh0r = Tdh0rReg<BaseAddress + 0x018C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ti1rReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using stid = FieldModel<uint32_t, address, 21, 11>;\n    using\
    \ exid = FieldModel<uint32_t, address, 3, 18>;\n    using ide = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using rtr = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ txrq = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n  \
    \  {\n      uint32_t value;\n      BitFieldModel<uint32_t, 21, 11> stid;\n   \
    \   BitFieldModel<uint32_t, 3, 18> exid;\n      BitFieldModel<uint32_t, 2, 1>\
    \ ide;\n      BitFieldModel<uint32_t, 1, 1> rtr;\n      BitFieldModel<uint32_t,\
    \ 0, 1> txrq;\n    };\n  };\n\npublic:\n  using ti1r = Ti1rReg<BaseAddress + 0x0190>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Tdt1rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using time = FieldModel<uint32_t, address, 16,\
    \ 16>;\n    using tgt = FieldModel<uint32_t, address, 8, 1>;\n    using dlc =\
    \ FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n    union reg\n    {\n  \
    \    uint32_t value;\n      BitFieldModel<uint32_t, 16, 16> time;\n      BitFieldModel<uint32_t,\
    \ 8, 1> tgt;\n      BitFieldModel<uint32_t, 0, 4> dlc;\n    };\n  };\n\npublic:\n\
    \  using tdt1r = Tdt1rReg<BaseAddress + 0x0194>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Tdl1rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using data3 = FieldModel<uint32_t, address, 24, 8>;\n    using\
    \ data2 = FieldModel<uint32_t, address, 16, 8>;\n    using data1 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using data0 = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> data3;\n      BitFieldModel<uint32_t, 16, 8> data2;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data1;\n      BitFieldModel<uint32_t, 0, 8> data0;\n    };\n  };\n\npublic:\n\
    \  using tdl1r = Tdl1rReg<BaseAddress + 0x0198>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Tdh1rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using data7 = FieldModel<uint32_t, address, 24, 8>;\n    using\
    \ data6 = FieldModel<uint32_t, address, 16, 8>;\n    using data5 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using data4 = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> data7;\n      BitFieldModel<uint32_t, 16, 8> data6;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data5;\n      BitFieldModel<uint32_t, 0, 8> data4;\n    };\n  };\n\npublic:\n\
    \  using tdh1r = Tdh1rReg<BaseAddress + 0x019C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ti2rReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using stid = FieldModel<uint32_t, address, 21, 11>;\n    using\
    \ exid = FieldModel<uint32_t, address, 3, 18>;\n    using ide = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using rtr = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ txrq = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n  \
    \  {\n      uint32_t value;\n      BitFieldModel<uint32_t, 21, 11> stid;\n   \
    \   BitFieldModel<uint32_t, 3, 18> exid;\n      BitFieldModel<uint32_t, 2, 1>\
    \ ide;\n      BitFieldModel<uint32_t, 1, 1> rtr;\n      BitFieldModel<uint32_t,\
    \ 0, 1> txrq;\n    };\n  };\n\npublic:\n  using ti2r = Ti2rReg<BaseAddress + 0x01A0>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Tdt2rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using time = FieldModel<uint32_t, address, 16,\
    \ 16>;\n    using tgt = FieldModel<uint32_t, address, 8, 1>;\n    using dlc =\
    \ FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n    union reg\n    {\n  \
    \    uint32_t value;\n      BitFieldModel<uint32_t, 16, 16> time;\n      BitFieldModel<uint32_t,\
    \ 8, 1> tgt;\n      BitFieldModel<uint32_t, 0, 4> dlc;\n    };\n  };\n\npublic:\n\
    \  using tdt2r = Tdt2rReg<BaseAddress + 0x01A4>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Tdl2rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using data3 = FieldModel<uint32_t, address, 24, 8>;\n    using\
    \ data2 = FieldModel<uint32_t, address, 16, 8>;\n    using data1 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using data0 = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> data3;\n      BitFieldModel<uint32_t, 16, 8> data2;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data1;\n      BitFieldModel<uint32_t, 0, 8> data0;\n    };\n  };\n\npublic:\n\
    \  using tdl2r = Tdl2rReg<BaseAddress + 0x01A8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Tdh2rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using data7 = FieldModel<uint32_t, address, 24, 8>;\n    using\
    \ data6 = FieldModel<uint32_t, address, 16, 8>;\n    using data5 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using data4 = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> data7;\n      BitFieldModel<uint32_t, 16, 8> data6;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data5;\n      BitFieldModel<uint32_t, 0, 8> data4;\n    };\n  };\n\npublic:\n\
    \  using tdh2r = Tdh2rReg<BaseAddress + 0x01AC>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ri0rReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using stid = FieldModel<uint32_t, address, 21, 11>;\n    using\
    \ exid = FieldModel<uint32_t, address, 3, 18>;\n    using ide = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using rtr = FieldModel<uint32_t, address, 1, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 21,\
    \ 11> stid;\n      BitFieldModel<uint32_t, 3, 18> exid;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ide;\n      BitFieldModel<uint32_t, 1, 1> rtr;\n    };\n  };\n\npublic:\n\
    \  using ri0r = Ri0rReg<BaseAddress + 0x01B0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Rdt0rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using time = FieldModel<uint32_t, address, 16, 16>;\n    using\
    \ fmi = FieldModel<uint32_t, address, 8, 8>;\n    using dlc = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 16, 16> time;\n      BitFieldModel<uint32_t, 8,\
    \ 8> fmi;\n      BitFieldModel<uint32_t, 0, 4> dlc;\n    };\n  };\n\npublic:\n\
    \  using rdt0r = Rdt0rReg<BaseAddress + 0x01B4>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Rdl0rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using data3 = FieldModel<uint32_t, address, 24, 8>;\n    using\
    \ data2 = FieldModel<uint32_t, address, 16, 8>;\n    using data1 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using data0 = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> data3;\n      BitFieldModel<uint32_t, 16, 8> data2;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data1;\n      BitFieldModel<uint32_t, 0, 8> data0;\n    };\n  };\n\npublic:\n\
    \  using rdl0r = Rdl0rReg<BaseAddress + 0x01B8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Rdh0rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using data7 = FieldModel<uint32_t, address, 24, 8>;\n    using\
    \ data6 = FieldModel<uint32_t, address, 16, 8>;\n    using data5 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using data4 = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> data7;\n      BitFieldModel<uint32_t, 16, 8> data6;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data5;\n      BitFieldModel<uint32_t, 0, 8> data4;\n    };\n  };\n\npublic:\n\
    \  using rdh0r = Rdh0rReg<BaseAddress + 0x01BC>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ri1rReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using stid = FieldModel<uint32_t, address, 21, 11>;\n    using\
    \ exid = FieldModel<uint32_t, address, 3, 18>;\n    using ide = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using rtr = FieldModel<uint32_t, address, 1, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 21,\
    \ 11> stid;\n      BitFieldModel<uint32_t, 3, 18> exid;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ide;\n      BitFieldModel<uint32_t, 1, 1> rtr;\n    };\n  };\n\npublic:\n\
    \  using ri1r = Ri1rReg<BaseAddress + 0x01C0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Rdt1rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using time = FieldModel<uint32_t, address, 16, 16>;\n    using\
    \ fmi = FieldModel<uint32_t, address, 8, 8>;\n    using dlc = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 16, 16> time;\n      BitFieldModel<uint32_t, 8,\
    \ 8> fmi;\n      BitFieldModel<uint32_t, 0, 4> dlc;\n    };\n  };\n\npublic:\n\
    \  using rdt1r = Rdt1rReg<BaseAddress + 0x01C4>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Rdl1rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using data3 = FieldModel<uint32_t, address, 24, 8>;\n    using\
    \ data2 = FieldModel<uint32_t, address, 16, 8>;\n    using data1 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using data0 = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> data3;\n      BitFieldModel<uint32_t, 16, 8> data2;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data1;\n      BitFieldModel<uint32_t, 0, 8> data0;\n    };\n  };\n\npublic:\n\
    \  using rdl1r = Rdl1rReg<BaseAddress + 0x01C8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Rdh1rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using data7 = FieldModel<uint32_t, address, 24, 8>;\n    using\
    \ data6 = FieldModel<uint32_t, address, 16, 8>;\n    using data5 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using data4 = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> data7;\n      BitFieldModel<uint32_t, 16, 8> data6;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data5;\n      BitFieldModel<uint32_t, 0, 8> data4;\n    };\n  };\n\npublic:\n\
    \  using rdh1r = Rdh1rReg<BaseAddress + 0x01CC>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class FmrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using can2sb = FieldModel<uint32_t, address, 8, 6>;\n    using\
    \ finit = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n \
    \   {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8, 6> can2sb;\n  \
    \    BitFieldModel<uint32_t, 0, 1> finit;\n    };\n  };\n\npublic:\n  using fmr\
    \ = FmrReg<BaseAddress + 0x0200>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Fm1rReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   using fbm0 = FieldModel<uint32_t, address, 0, 1>;\n    using fbm1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using fbm2 = FieldModel<uint32_t, address, 2, 1>;\n   \
    \ using fbm3 = FieldModel<uint32_t, address, 3, 1>;\n    using fbm4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using fbm5 = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using fbm6 = FieldModel<uint32_t, address, 6, 1>;\n    using fbm7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using fbm8 = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using fbm9 = FieldModel<uint32_t, address, 9, 1>;\n    using fbm10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using fbm11 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using fbm12 = FieldModel<uint32_t, address, 12, 1>;\n    using fbm13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using fbm14 = FieldModel<uint32_t, address, 14, 1>;\n\
    \    using fbm15 = FieldModel<uint32_t, address, 15, 1>;\n    using fbm16 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using fbm17 = FieldModel<uint32_t, address, 17, 1>;\n\
    \    using fbm18 = FieldModel<uint32_t, address, 18, 1>;\n    using fbm19 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using fbm20 = FieldModel<uint32_t, address, 20, 1>;\n\
    \    using fbm21 = FieldModel<uint32_t, address, 21, 1>;\n    using fbm22 = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    using fbm23 = FieldModel<uint32_t, address, 23, 1>;\n\
    \    using fbm24 = FieldModel<uint32_t, address, 24, 1>;\n    using fbm25 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using fbm26 = FieldModel<uint32_t, address, 26, 1>;\n\
    \    using fbm27 = FieldModel<uint32_t, address, 27, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fbm0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fbm1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fbm2;\n      BitFieldModel<uint32_t, 3, 1> fbm3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fbm4;\n      BitFieldModel<uint32_t, 5, 1> fbm5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fbm6;\n      BitFieldModel<uint32_t, 7, 1> fbm7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fbm8;\n      BitFieldModel<uint32_t, 9, 1> fbm9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fbm10;\n      BitFieldModel<uint32_t, 11, 1> fbm11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fbm12;\n      BitFieldModel<uint32_t, 13, 1> fbm13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fbm14;\n      BitFieldModel<uint32_t, 15, 1> fbm15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fbm16;\n      BitFieldModel<uint32_t, 17, 1> fbm17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fbm18;\n      BitFieldModel<uint32_t, 19, 1> fbm19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fbm20;\n      BitFieldModel<uint32_t, 21, 1> fbm21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fbm22;\n      BitFieldModel<uint32_t, 23, 1> fbm23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fbm24;\n      BitFieldModel<uint32_t, 25, 1> fbm25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fbm26;\n      BitFieldModel<uint32_t, 27, 1> fbm27;\n    };\n  };\n\n\
    public:\n  using fm1r = Fm1rReg<BaseAddress + 0x0204>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Fs1rReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fsc0 = FieldModel<uint32_t, address, 0, 1>;\n    using fsc1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fsc2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fsc3 = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using fsc4 = FieldModel<uint32_t, address, 4, 1>;\n    using fsc5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fsc6 = FieldModel<uint32_t, address, 6, 1>;\n   \
    \ using fsc7 = FieldModel<uint32_t, address, 7, 1>;\n    using fsc8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fsc9 = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using fsc10 = FieldModel<uint32_t, address, 10, 1>;\n    using fsc11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fsc12 = FieldModel<uint32_t, address, 12, 1>;\n\
    \    using fsc13 = FieldModel<uint32_t, address, 13, 1>;\n    using fsc14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fsc15 = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using fsc16 = FieldModel<uint32_t, address, 16, 1>;\n    using fsc17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fsc18 = FieldModel<uint32_t, address, 18, 1>;\n\
    \    using fsc19 = FieldModel<uint32_t, address, 19, 1>;\n    using fsc20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fsc21 = FieldModel<uint32_t, address, 21, 1>;\n\
    \    using fsc22 = FieldModel<uint32_t, address, 22, 1>;\n    using fsc23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fsc24 = FieldModel<uint32_t, address, 24, 1>;\n\
    \    using fsc25 = FieldModel<uint32_t, address, 25, 1>;\n    using fsc26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fsc27 = FieldModel<uint32_t, address, 27, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> fsc0;\n      BitFieldModel<uint32_t, 1, 1> fsc1;\n      BitFieldModel<uint32_t,\
    \ 2, 1> fsc2;\n      BitFieldModel<uint32_t, 3, 1> fsc3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fsc4;\n      BitFieldModel<uint32_t, 5, 1> fsc5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fsc6;\n      BitFieldModel<uint32_t, 7, 1> fsc7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fsc8;\n      BitFieldModel<uint32_t, 9, 1> fsc9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fsc10;\n      BitFieldModel<uint32_t, 11, 1> fsc11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fsc12;\n      BitFieldModel<uint32_t, 13, 1> fsc13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fsc14;\n      BitFieldModel<uint32_t, 15, 1> fsc15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fsc16;\n      BitFieldModel<uint32_t, 17, 1> fsc17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fsc18;\n      BitFieldModel<uint32_t, 19, 1> fsc19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fsc20;\n      BitFieldModel<uint32_t, 21, 1> fsc21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fsc22;\n      BitFieldModel<uint32_t, 23, 1> fsc23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fsc24;\n      BitFieldModel<uint32_t, 25, 1> fsc25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fsc26;\n      BitFieldModel<uint32_t, 27, 1> fsc27;\n    };\n  };\n\n\
    public:\n  using fs1r = Fs1rReg<BaseAddress + 0x020C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ffa1rReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using ffa0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ ffa1 = FieldModel<uint32_t, address, 1, 1>;\n    using ffa2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using ffa3 = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using ffa4 = FieldModel<uint32_t, address, 4, 1>;\n    using ffa5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using ffa6 = FieldModel<uint32_t, address, 6, 1>;\n   \
    \ using ffa7 = FieldModel<uint32_t, address, 7, 1>;\n    using ffa8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using ffa9 = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using ffa10 = FieldModel<uint32_t, address, 10, 1>;\n    using ffa11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using ffa12 = FieldModel<uint32_t, address, 12, 1>;\n\
    \    using ffa13 = FieldModel<uint32_t, address, 13, 1>;\n    using ffa14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using ffa15 = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using ffa16 = FieldModel<uint32_t, address, 16, 1>;\n    using ffa17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using ffa18 = FieldModel<uint32_t, address, 18, 1>;\n\
    \    using ffa19 = FieldModel<uint32_t, address, 19, 1>;\n    using ffa20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using ffa21 = FieldModel<uint32_t, address, 21, 1>;\n\
    \    using ffa22 = FieldModel<uint32_t, address, 22, 1>;\n    using ffa23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using ffa24 = FieldModel<uint32_t, address, 24, 1>;\n\
    \    using ffa25 = FieldModel<uint32_t, address, 25, 1>;\n    using ffa26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using ffa27 = FieldModel<uint32_t, address, 27, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> ffa0;\n      BitFieldModel<uint32_t, 1, 1> ffa1;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ffa2;\n      BitFieldModel<uint32_t, 3, 1> ffa3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> ffa4;\n      BitFieldModel<uint32_t, 5, 1> ffa5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> ffa6;\n      BitFieldModel<uint32_t, 7, 1> ffa7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> ffa8;\n      BitFieldModel<uint32_t, 9, 1> ffa9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> ffa10;\n      BitFieldModel<uint32_t, 11, 1> ffa11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> ffa12;\n      BitFieldModel<uint32_t, 13, 1> ffa13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> ffa14;\n      BitFieldModel<uint32_t, 15, 1> ffa15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> ffa16;\n      BitFieldModel<uint32_t, 17, 1> ffa17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> ffa18;\n      BitFieldModel<uint32_t, 19, 1> ffa19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> ffa20;\n      BitFieldModel<uint32_t, 21, 1> ffa21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> ffa22;\n      BitFieldModel<uint32_t, 23, 1> ffa23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> ffa24;\n      BitFieldModel<uint32_t, 25, 1> ffa25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> ffa26;\n      BitFieldModel<uint32_t, 27, 1> ffa27;\n    };\n  };\n\n\
    public:\n  using ffa1r = Ffa1rReg<BaseAddress + 0x0214>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Fa1rReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fact0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fact1 = FieldModel<uint32_t, address, 1, 1>;\n    using fact2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fact3 = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using fact4 = FieldModel<uint32_t, address, 4, 1>;\n    using fact5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fact6 = FieldModel<uint32_t, address, 6, 1>;\n  \
    \  using fact7 = FieldModel<uint32_t, address, 7, 1>;\n    using fact8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fact9 = FieldModel<uint32_t, address, 9, 1>;\n  \
    \  using fact10 = FieldModel<uint32_t, address, 10, 1>;\n    using fact11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fact12 = FieldModel<uint32_t, address, 12, 1>;\n\
    \    using fact13 = FieldModel<uint32_t, address, 13, 1>;\n    using fact14 =\
    \ FieldModel<uint32_t, address, 14, 1>;\n    using fact15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using fact16 = FieldModel<uint32_t, address, 16, 1>;\n\
    \    using fact17 = FieldModel<uint32_t, address, 17, 1>;\n    using fact18 =\
    \ FieldModel<uint32_t, address, 18, 1>;\n    using fact19 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using fact20 = FieldModel<uint32_t, address, 20, 1>;\n\
    \    using fact21 = FieldModel<uint32_t, address, 21, 1>;\n    using fact22 =\
    \ FieldModel<uint32_t, address, 22, 1>;\n    using fact23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fact24 = FieldModel<uint32_t, address, 24, 1>;\n\
    \    using fact25 = FieldModel<uint32_t, address, 25, 1>;\n    using fact26 =\
    \ FieldModel<uint32_t, address, 26, 1>;\n    using fact27 = FieldModel<uint32_t,\
    \ address, 27, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> fact0;\n      BitFieldModel<uint32_t, 1,\
    \ 1> fact1;\n      BitFieldModel<uint32_t, 2, 1> fact2;\n      BitFieldModel<uint32_t,\
    \ 3, 1> fact3;\n      BitFieldModel<uint32_t, 4, 1> fact4;\n      BitFieldModel<uint32_t,\
    \ 5, 1> fact5;\n      BitFieldModel<uint32_t, 6, 1> fact6;\n      BitFieldModel<uint32_t,\
    \ 7, 1> fact7;\n      BitFieldModel<uint32_t, 8, 1> fact8;\n      BitFieldModel<uint32_t,\
    \ 9, 1> fact9;\n      BitFieldModel<uint32_t, 10, 1> fact10;\n      BitFieldModel<uint32_t,\
    \ 11, 1> fact11;\n      BitFieldModel<uint32_t, 12, 1> fact12;\n      BitFieldModel<uint32_t,\
    \ 13, 1> fact13;\n      BitFieldModel<uint32_t, 14, 1> fact14;\n      BitFieldModel<uint32_t,\
    \ 15, 1> fact15;\n      BitFieldModel<uint32_t, 16, 1> fact16;\n      BitFieldModel<uint32_t,\
    \ 17, 1> fact17;\n      BitFieldModel<uint32_t, 18, 1> fact18;\n      BitFieldModel<uint32_t,\
    \ 19, 1> fact19;\n      BitFieldModel<uint32_t, 20, 1> fact20;\n      BitFieldModel<uint32_t,\
    \ 21, 1> fact21;\n      BitFieldModel<uint32_t, 22, 1> fact22;\n      BitFieldModel<uint32_t,\
    \ 23, 1> fact23;\n      BitFieldModel<uint32_t, 24, 1> fact24;\n      BitFieldModel<uint32_t,\
    \ 25, 1> fact25;\n      BitFieldModel<uint32_t, 26, 1> fact26;\n      BitFieldModel<uint32_t,\
    \ 27, 1> fact27;\n    };\n  };\n\npublic:\n  using fa1r = Fa1rReg<BaseAddress\
    \ + 0x021C>;\n\nprivate:\n  template<unsigned int address>\n  class F0r1Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using fb0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ fb2 = FieldModel<uint32_t, address, 2, 1>;\n    using fb3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ fb5 = FieldModel<uint32_t, address, 5, 1>;\n    using fb6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ fb8 = FieldModel<uint32_t, address, 8, 1>;\n    using fb9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using fb10 = FieldModel<uint32_t, address, 10, 1>;\n  \
    \  using fb11 = FieldModel<uint32_t, address, 11, 1>;\n    using fb12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using fb13 = FieldModel<uint32_t, address, 13, 1>;\n \
    \   using fb14 = FieldModel<uint32_t, address, 14, 1>;\n    using fb15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using fb16 = FieldModel<uint32_t, address, 16, 1>;\n \
    \   using fb17 = FieldModel<uint32_t, address, 17, 1>;\n    using fb18 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    using fb19 = FieldModel<uint32_t, address, 19, 1>;\n \
    \   using fb20 = FieldModel<uint32_t, address, 20, 1>;\n    using fb21 = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    using fb22 = FieldModel<uint32_t, address, 22, 1>;\n \
    \   using fb23 = FieldModel<uint32_t, address, 23, 1>;\n    using fb24 = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    using fb25 = FieldModel<uint32_t, address, 25, 1>;\n \
    \   using fb26 = FieldModel<uint32_t, address, 26, 1>;\n    using fb27 = FieldModel<uint32_t,\
    \ address, 27, 1>;\n    using fb28 = FieldModel<uint32_t, address, 28, 1>;\n \
    \   using fb29 = FieldModel<uint32_t, address, 29, 1>;\n    using fb30 = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> fb0;\n      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t,\
    \ 2, 1> fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f0r1 = F0r1Reg<BaseAddress + 0x0240>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F0r2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f0r2 = F0r2Reg<BaseAddress + 0x0244>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F1r1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f1r1 = F1r1Reg<BaseAddress + 0x0248>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F1r2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f1r2 = F1r2Reg<BaseAddress + 0x024C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F2r1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f2r1 = F2r1Reg<BaseAddress + 0x0250>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F2r2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f2r2 = F2r2Reg<BaseAddress + 0x0254>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F3r1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f3r1 = F3r1Reg<BaseAddress + 0x0258>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F3r2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f3r2 = F3r2Reg<BaseAddress + 0x025C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F4r1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f4r1 = F4r1Reg<BaseAddress + 0x0260>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F4r2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f4r2 = F4r2Reg<BaseAddress + 0x0264>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F5r1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f5r1 = F5r1Reg<BaseAddress + 0x0268>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F5r2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f5r2 = F5r2Reg<BaseAddress + 0x026C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F6r1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f6r1 = F6r1Reg<BaseAddress + 0x0270>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F6r2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f6r2 = F6r2Reg<BaseAddress + 0x0274>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F7r1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f7r1 = F7r1Reg<BaseAddress + 0x0278>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F7r2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f7r2 = F7r2Reg<BaseAddress + 0x027C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F8r1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f8r1 = F8r1Reg<BaseAddress + 0x0280>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F8r2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f8r2 = F8r2Reg<BaseAddress + 0x0284>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F9r1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f9r1 = F9r1Reg<BaseAddress + 0x0288>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F9r2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using fb1\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f9r2 = F9r2Reg<BaseAddress + 0x028C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F10r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f10r1 = F10r1Reg<BaseAddress + 0x0290>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F10r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f10r2 = F10r2Reg<BaseAddress + 0x0294>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F11r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f11r1 = F11r1Reg<BaseAddress + 0x0298>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F11r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f11r2 = F11r2Reg<BaseAddress + 0x029C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F12r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f12r1 = F12r1Reg<BaseAddress + 0x02A0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F12r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f12r2 = F12r2Reg<BaseAddress + 0x02A4>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F13r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f13r1 = F13r1Reg<BaseAddress + 0x02A8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F13r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f13r2 = F13r2Reg<BaseAddress + 0x02AC>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F14r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f14r1 = F14r1Reg<BaseAddress + 0x02B0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F14r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f14r2 = F14r2Reg<BaseAddress + 0x02B4>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F15r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f15r1 = F15r1Reg<BaseAddress + 0x02B8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F15r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f15r2 = F15r2Reg<BaseAddress + 0x02BC>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F16r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f16r1 = F16r1Reg<BaseAddress + 0x02C0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F16r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f16r2 = F16r2Reg<BaseAddress + 0x02C4>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F17r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f17r1 = F17r1Reg<BaseAddress + 0x02C8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F17r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f17r2 = F17r2Reg<BaseAddress + 0x02CC>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F18r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f18r1 = F18r1Reg<BaseAddress + 0x02D0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F18r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f18r2 = F18r2Reg<BaseAddress + 0x02D4>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F19r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f19r1 = F19r1Reg<BaseAddress + 0x02D8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F19r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f19r2 = F19r2Reg<BaseAddress + 0x02DC>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F20r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f20r1 = F20r1Reg<BaseAddress + 0x02E0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F20r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f20r2 = F20r2Reg<BaseAddress + 0x02E4>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F21r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f21r1 = F21r1Reg<BaseAddress + 0x02E8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F21r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f21r2 = F21r2Reg<BaseAddress + 0x02EC>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F22r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f22r1 = F22r1Reg<BaseAddress + 0x02F0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F22r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f22r2 = F22r2Reg<BaseAddress + 0x02F4>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F23r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f23r1 = F23r1Reg<BaseAddress + 0x02F8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F23r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f23r2 = F23r2Reg<BaseAddress + 0x02FC>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F24r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f24r1 = F24r1Reg<BaseAddress + 0x0300>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F24r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f24r2 = F24r2Reg<BaseAddress + 0x0304>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F25r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f25r1 = F25r1Reg<BaseAddress + 0x0308>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F25r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f25r2 = F25r2Reg<BaseAddress + 0x030C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F26r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f26r1 = F26r1Reg<BaseAddress + 0x0310>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F26r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f26r2 = F26r2Reg<BaseAddress + 0x0314>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F27r1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f27r1 = F27r1Reg<BaseAddress + 0x0318>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class F27r2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ fb1 = FieldModel<uint32_t, address, 1, 1>;\n    using fb2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using fb3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ fb4 = FieldModel<uint32_t, address, 4, 1>;\n    using fb5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ fb7 = FieldModel<uint32_t, address, 7, 1>;\n    using fb8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fb9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ fb10 = FieldModel<uint32_t, address, 10, 1>;\n    using fb11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using fb12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using fb13 = FieldModel<uint32_t, address, 13, 1>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using fb15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using fb16 = FieldModel<uint32_t, address, 16, 1>;\n    using fb17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using fb18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using fb19 = FieldModel<uint32_t, address, 19, 1>;\n    using fb20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using fb22 = FieldModel<uint32_t, address, 22, 1>;\n    using fb23 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using fb24 = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using fb25 = FieldModel<uint32_t, address, 25, 1>;\n    using fb26 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using fb27 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using fb28 = FieldModel<uint32_t, address, 28, 1>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fb30 = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using fb31 = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> fb0;\n\
    \      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using f27r2 = F27r2Reg<BaseAddress + 0x031C>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class TixrBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using stid = FieldModel<uint32_t,\
    \ address, 21, 11, bankOffset>;\n    using exid = FieldModel<uint32_t, address,\
    \ 3, 18, bankOffset>;\n    using ide = FieldModel<uint32_t, address, 2, 1, bankOffset>;\n\
    \    using rtr = FieldModel<uint32_t, address, 1, 1, bankOffset>;\n    using txrq\
    \ = FieldModel<uint32_t, address, 0, 1, bankOffset>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 21, 11> stid;\n \
    \     BitFieldModel<uint32_t, 3, 18> exid;\n      BitFieldModel<uint32_t, 2, 1>\
    \ ide;\n      BitFieldModel<uint32_t, 1, 1> rtr;\n      BitFieldModel<uint32_t,\
    \ 0, 1> txrq;\n    };\n  };\n\npublic:\n  using tixr = TixrBankReg<BaseAddress\
    \ + 0x0180, 0x0010>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class TdtxrBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using time = FieldModel<uint32_t, address,\
    \ 16, 16, bankOffset>;\n    using tgt = FieldModel<uint32_t, address, 8, 1, bankOffset>;\n\
    \    using dlc = FieldModel<uint32_t, address, 0, 4, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16,\
    \ 16> time;\n      BitFieldModel<uint32_t, 8, 1> tgt;\n      BitFieldModel<uint32_t,\
    \ 0, 4> dlc;\n    };\n  };\n\npublic:\n  using tdtxr = TdtxrBankReg<BaseAddress\
    \ + 0x0184, 0x0010>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class TdlxrBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using data3 = FieldModel<uint32_t, address,\
    \ 24, 8, bankOffset>;\n    using data2 = FieldModel<uint32_t, address, 16, 8,\
    \ bankOffset>;\n    using data1 = FieldModel<uint32_t, address, 8, 8, bankOffset>;\n\
    \    using data0 = FieldModel<uint32_t, address, 0, 8, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 24,\
    \ 8> data3;\n      BitFieldModel<uint32_t, 16, 8> data2;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data1;\n      BitFieldModel<uint32_t, 0, 8> data0;\n    };\n  };\n\npublic:\n\
    \  using tdlxr = TdlxrBankReg<BaseAddress + 0x0188, 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class TdhxrBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using data7 = FieldModel<uint32_t,\
    \ address, 24, 8, bankOffset>;\n    using data6 = FieldModel<uint32_t, address,\
    \ 16, 8, bankOffset>;\n    using data5 = FieldModel<uint32_t, address, 8, 8, bankOffset>;\n\
    \    using data4 = FieldModel<uint32_t, address, 0, 8, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 24,\
    \ 8> data7;\n      BitFieldModel<uint32_t, 16, 8> data6;\n      BitFieldModel<uint32_t,\
    \ 8, 8> data5;\n      BitFieldModel<uint32_t, 0, 8> data4;\n    };\n  };\n\npublic:\n\
    \  using tdhxr = TdhxrBankReg<BaseAddress + 0x018C, 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class RixrBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using stid = FieldModel<uint32_t,\
    \ address, 21, 11, bankOffset>;\n    using exid = FieldModel<uint32_t, address,\
    \ 3, 18, bankOffset>;\n    using ide = FieldModel<uint32_t, address, 2, 1, bankOffset>;\n\
    \    using rtr = FieldModel<uint32_t, address, 1, 1, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 21,\
    \ 11> stid;\n      BitFieldModel<uint32_t, 3, 18> exid;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ide;\n      BitFieldModel<uint32_t, 1, 1> rtr;\n    };\n  };\n\npublic:\n\
    \  using rixr = RixrBankReg<BaseAddress + 0x01B0, 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class RdtxrBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using time = FieldModel<uint32_t,\
    \ address, 16, 16, bankOffset>;\n    using fmi = FieldModel<uint32_t, address,\
    \ 8, 8, bankOffset>;\n    using dlc = FieldModel<uint32_t, address, 0, 4, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 16, 16> time;\n      BitFieldModel<uint32_t, 8, 8> fmi;\n      BitFieldModel<uint32_t,\
    \ 0, 4> dlc;\n    };\n  };\n\npublic:\n  using rdtxr = RdtxrBankReg<BaseAddress\
    \ + 0x01B4, 0x0010>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class Fxr2BankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using fb0 = FieldModel<uint32_t, address, 0,\
    \ 1, bankOffset>;\n    using fb1 = FieldModel<uint32_t, address, 1, 1, bankOffset>;\n\
    \    using fb2 = FieldModel<uint32_t, address, 2, 1, bankOffset>;\n    using fb3\
    \ = FieldModel<uint32_t, address, 3, 1, bankOffset>;\n    using fb4 = FieldModel<uint32_t,\
    \ address, 4, 1, bankOffset>;\n    using fb5 = FieldModel<uint32_t, address, 5,\
    \ 1, bankOffset>;\n    using fb6 = FieldModel<uint32_t, address, 6, 1, bankOffset>;\n\
    \    using fb7 = FieldModel<uint32_t, address, 7, 1, bankOffset>;\n    using fb8\
    \ = FieldModel<uint32_t, address, 8, 1, bankOffset>;\n    using fb9 = FieldModel<uint32_t,\
    \ address, 9, 1, bankOffset>;\n    using fb10 = FieldModel<uint32_t, address,\
    \ 10, 1, bankOffset>;\n    using fb11 = FieldModel<uint32_t, address, 11, 1, bankOffset>;\n\
    \    using fb12 = FieldModel<uint32_t, address, 12, 1, bankOffset>;\n    using\
    \ fb13 = FieldModel<uint32_t, address, 13, 1, bankOffset>;\n    using fb14 = FieldModel<uint32_t,\
    \ address, 14, 1, bankOffset>;\n    using fb15 = FieldModel<uint32_t, address,\
    \ 15, 1, bankOffset>;\n    using fb16 = FieldModel<uint32_t, address, 16, 1, bankOffset>;\n\
    \    using fb17 = FieldModel<uint32_t, address, 17, 1, bankOffset>;\n    using\
    \ fb18 = FieldModel<uint32_t, address, 18, 1, bankOffset>;\n    using fb19 = FieldModel<uint32_t,\
    \ address, 19, 1, bankOffset>;\n    using fb20 = FieldModel<uint32_t, address,\
    \ 20, 1, bankOffset>;\n    using fb21 = FieldModel<uint32_t, address, 21, 1, bankOffset>;\n\
    \    using fb22 = FieldModel<uint32_t, address, 22, 1, bankOffset>;\n    using\
    \ fb23 = FieldModel<uint32_t, address, 23, 1, bankOffset>;\n    using fb24 = FieldModel<uint32_t,\
    \ address, 24, 1, bankOffset>;\n    using fb25 = FieldModel<uint32_t, address,\
    \ 25, 1, bankOffset>;\n    using fb26 = FieldModel<uint32_t, address, 26, 1, bankOffset>;\n\
    \    using fb27 = FieldModel<uint32_t, address, 27, 1, bankOffset>;\n    using\
    \ fb28 = FieldModel<uint32_t, address, 28, 1, bankOffset>;\n    using fb29 = FieldModel<uint32_t,\
    \ address, 29, 1, bankOffset>;\n    using fb30 = FieldModel<uint32_t, address,\
    \ 30, 1, bankOffset>;\n    using fb31 = FieldModel<uint32_t, address, 31, 1, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> fb0;\n      BitFieldModel<uint32_t, 1, 1> fb1;\n      BitFieldModel<uint32_t,\
    \ 2, 1> fb2;\n      BitFieldModel<uint32_t, 3, 1> fb3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> fb4;\n      BitFieldModel<uint32_t, 5, 1> fb5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> fb6;\n      BitFieldModel<uint32_t, 7, 1> fb7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> fb8;\n      BitFieldModel<uint32_t, 9, 1> fb9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> fb10;\n      BitFieldModel<uint32_t, 11, 1> fb11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> fb12;\n      BitFieldModel<uint32_t, 13, 1> fb13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> fb14;\n      BitFieldModel<uint32_t, 15, 1> fb15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fb16;\n      BitFieldModel<uint32_t, 17, 1> fb17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> fb18;\n      BitFieldModel<uint32_t, 19, 1> fb19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> fb20;\n      BitFieldModel<uint32_t, 21, 1> fb21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> fb22;\n      BitFieldModel<uint32_t, 23, 1> fb23;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fb24;\n      BitFieldModel<uint32_t, 25, 1> fb25;\n      BitFieldModel<uint32_t,\
    \ 26, 1> fb26;\n      BitFieldModel<uint32_t, 27, 1> fb27;\n      BitFieldModel<uint32_t,\
    \ 28, 1> fb28;\n      BitFieldModel<uint32_t, 29, 1> fb29;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fb30;\n      BitFieldModel<uint32_t, 31, 1> fb31;\n    };\n  };\n\npublic:\n\
    \  using fxr2 = Fxr2BankReg<BaseAddress + 0x024C, 0x0008>;\n};\n\n}\n\n#endif\
    \ /* DRAL_STM32F446_CAN2_H */\n"
  name: CAN2
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_NVIC_H\n#define DRAL_STM32F446_NVIC_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass nvic\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0xE000E100;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Iser0Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using setena = FieldModel<uint32_t, address, 0,\
    \ 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> setena;\n    };\n  };\n\npublic:\n  using iser0 = Iser0Reg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class Iser1Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using setena =\
    \ FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> setena;\n    };\n\
    \  };\n\npublic:\n  using iser1 = Iser1Reg<BaseAddress + 0x0004>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Iser2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using setena = FieldModel<uint32_t, address, 0,\
    \ 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> setena;\n    };\n  };\n\npublic:\n  using iser2 = Iser2Reg<BaseAddress\
    \ + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class Icer0Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using clrena =\
    \ FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> clrena;\n    };\n\
    \  };\n\npublic:\n  using icer0 = Icer0Reg<BaseAddress + 0x0080>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Icer1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using clrena = FieldModel<uint32_t, address, 0,\
    \ 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> clrena;\n    };\n  };\n\npublic:\n  using icer1 = Icer1Reg<BaseAddress\
    \ + 0x0084>;\n\nprivate:\n  template<unsigned int address>\n  class Icer2Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using clrena =\
    \ FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> clrena;\n    };\n\
    \  };\n\npublic:\n  using icer2 = Icer2Reg<BaseAddress + 0x0088>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Ispr0Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using setpend = FieldModel<uint32_t, address,\
    \ 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> setpend;\n    };\n  };\n\npublic:\n  using ispr0 = Ispr0Reg<BaseAddress\
    \ + 0x0100>;\n\nprivate:\n  template<unsigned int address>\n  class Ispr1Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using setpend =\
    \ FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> setpend;\n    };\n\
    \  };\n\npublic:\n  using ispr1 = Ispr1Reg<BaseAddress + 0x0104>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Ispr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using setpend = FieldModel<uint32_t, address,\
    \ 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> setpend;\n    };\n  };\n\npublic:\n  using ispr2 = Ispr2Reg<BaseAddress\
    \ + 0x0108>;\n\nprivate:\n  template<unsigned int address>\n  class Icpr0Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using clrpend =\
    \ FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> clrpend;\n    };\n\
    \  };\n\npublic:\n  using icpr0 = Icpr0Reg<BaseAddress + 0x0180>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Icpr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using clrpend = FieldModel<uint32_t, address,\
    \ 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> clrpend;\n    };\n  };\n\npublic:\n  using icpr1 = Icpr1Reg<BaseAddress\
    \ + 0x0184>;\n\nprivate:\n  template<unsigned int address>\n  class Icpr2Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using clrpend =\
    \ FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> clrpend;\n    };\n\
    \  };\n\npublic:\n  using icpr2 = Icpr2Reg<BaseAddress + 0x0188>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Iabr0Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using active = FieldModel<uint32_t, address, 0,\
    \ 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> active;\n    };\n  };\n\npublic:\n  using iabr0 = Iabr0Reg<BaseAddress\
    \ + 0x0200>;\n\nprivate:\n  template<unsigned int address>\n  class Iabr1Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using active =\
    \ FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> active;\n    };\n\
    \  };\n\npublic:\n  using iabr1 = Iabr1Reg<BaseAddress + 0x0204>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Iabr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using active = FieldModel<uint32_t, address, 0,\
    \ 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> active;\n    };\n  };\n\npublic:\n  using iabr2 = Iabr2Reg<BaseAddress\
    \ + 0x0208>;\n\nprivate:\n  template<unsigned int address>\n  class Ipr0Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ipr_n0 =\
    \ FieldModel<uint32_t, address, 0, 8>;\n    using ipr_n1 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using ipr_n2 = FieldModel<uint32_t, address, 16, 8>;\n\
    \    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 8> ipr_n0;\n\
    \      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t, 16,\
    \ 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\npublic:\n\
    \  using ipr0 = Ipr0Reg<BaseAddress + 0x0300>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ ipr_n1 = FieldModel<uint32_t, address, 8, 8>;\n    using ipr_n2 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  using ipr1 = Ipr1Reg<BaseAddress + 0x0304>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ ipr_n1 = FieldModel<uint32_t, address, 8, 8>;\n    using ipr_n2 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  using ipr2 = Ipr2Reg<BaseAddress + 0x0308>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr3Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ ipr_n1 = FieldModel<uint32_t, address, 8, 8>;\n    using ipr_n2 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  using ipr3 = Ipr3Reg<BaseAddress + 0x030C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr4Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ ipr_n1 = FieldModel<uint32_t, address, 8, 8>;\n    using ipr_n2 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  using ipr4 = Ipr4Reg<BaseAddress + 0x0310>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr5Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ ipr_n1 = FieldModel<uint32_t, address, 8, 8>;\n    using ipr_n2 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  using ipr5 = Ipr5Reg<BaseAddress + 0x0314>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr6Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ ipr_n1 = FieldModel<uint32_t, address, 8, 8>;\n    using ipr_n2 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  using ipr6 = Ipr6Reg<BaseAddress + 0x0318>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr7Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ ipr_n1 = FieldModel<uint32_t, address, 8, 8>;\n    using ipr_n2 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  using ipr7 = Ipr7Reg<BaseAddress + 0x031C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr8Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ ipr_n1 = FieldModel<uint32_t, address, 8, 8>;\n    using ipr_n2 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  using ipr8 = Ipr8Reg<BaseAddress + 0x0320>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr9Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ ipr_n1 = FieldModel<uint32_t, address, 8, 8>;\n    using ipr_n2 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  using ipr9 = Ipr9Reg<BaseAddress + 0x0324>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr10Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ ipr_n1 = FieldModel<uint32_t, address, 8, 8>;\n    using ipr_n2 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  using ipr10 = Ipr10Reg<BaseAddress + 0x0328>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr11Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ ipr_n1 = FieldModel<uint32_t, address, 8, 8>;\n    using ipr_n2 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  using ipr11 = Ipr11Reg<BaseAddress + 0x032C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr12Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ ipr_n1 = FieldModel<uint32_t, address, 8, 8>;\n    using ipr_n2 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  using ipr12 = Ipr12Reg<BaseAddress + 0x0330>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr13Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ ipr_n1 = FieldModel<uint32_t, address, 8, 8>;\n    using ipr_n2 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  using ipr13 = Ipr13Reg<BaseAddress + 0x0334>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr14Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ ipr_n1 = FieldModel<uint32_t, address, 8, 8>;\n    using ipr_n2 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  using ipr14 = Ipr14Reg<BaseAddress + 0x0338>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr15Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ ipr_n1 = FieldModel<uint32_t, address, 8, 8>;\n    using ipr_n2 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  using ipr15 = Ipr15Reg<BaseAddress + 0x033C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr16Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ ipr_n1 = FieldModel<uint32_t, address, 8, 8>;\n    using ipr_n2 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  using ipr16 = Ipr16Reg<BaseAddress + 0x0340>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr17Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ ipr_n1 = FieldModel<uint32_t, address, 8, 8>;\n    using ipr_n2 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  using ipr17 = Ipr17Reg<BaseAddress + 0x0344>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr18Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ ipr_n1 = FieldModel<uint32_t, address, 8, 8>;\n    using ipr_n2 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  using ipr18 = Ipr18Reg<BaseAddress + 0x0348>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr19Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ ipr_n1 = FieldModel<uint32_t, address, 8, 8>;\n    using ipr_n2 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  using ipr19 = Ipr19Reg<BaseAddress + 0x034C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr20Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ ipr_n1 = FieldModel<uint32_t, address, 8, 8>;\n    using ipr_n2 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  using ipr20 = Ipr20Reg<BaseAddress + 0x0350>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr21Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    \n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      \n    };\n  };\n\npublic:\n  using ipr21 = Ipr21Reg<BaseAddress + 0x0354>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Ipr22Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    \n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      \n    };\n  };\n\npublic:\n  using ipr22 = Ipr22Reg<BaseAddress\
    \ + 0x0358>;\n\nprivate:\n  template<unsigned int address>\n  class Ipr23Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    \n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      \n    };\n  };\n\npublic:\n\
    \  using ipr23 = Ipr23Reg<BaseAddress + 0x035C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr24Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    \n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      \n    };\n  };\n\npublic:\n  using ipr24 = Ipr24Reg<BaseAddress + 0x0360>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Ipr25Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    \n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      \n    };\n  };\n\npublic:\n  using ipr25 = Ipr25Reg<BaseAddress\
    \ + 0x0364>;\n\nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n\
    \  class IserxBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n\
    \  {\n  public:\n    using setena = FieldModel<uint32_t, address, 0, 32, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> setena;\n    };\n  };\n\npublic:\n  using iserx = IserxBankReg<BaseAddress\
    \ + 0x0000, 0x0004>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class IcerxBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using clrena = FieldModel<uint32_t, address,\
    \ 0, 32, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> clrena;\n    };\n  };\n\npublic:\n  using\
    \ icerx = IcerxBankReg<BaseAddress + 0x0080, 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class IsprxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using setpend = FieldModel<uint32_t,\
    \ address, 0, 32, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      BitFieldModel<uint32_t, 0, 32> setpend;\n    };\n  };\n\npublic:\n\
    \  using isprx = IsprxBankReg<BaseAddress + 0x0100, 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class IcprxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using clrpend = FieldModel<uint32_t,\
    \ address, 0, 32, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      BitFieldModel<uint32_t, 0, 32> clrpend;\n    };\n  };\n\npublic:\n\
    \  using icprx = IcprxBankReg<BaseAddress + 0x0180, 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class IabrxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using active = FieldModel<uint32_t,\
    \ address, 0, 32, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      BitFieldModel<uint32_t, 0, 32> active;\n    };\n  };\n\npublic:\n\
    \  using iabrx = IabrxBankReg<BaseAddress + 0x0200, 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class IprxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using ipr_n0 = FieldModel<uint32_t,\
    \ address, 0, 8, bankOffset>;\n    using ipr_n1 = FieldModel<uint32_t, address,\
    \ 8, 8, bankOffset>;\n    using ipr_n2 = FieldModel<uint32_t, address, 16, 8,\
    \ bankOffset>;\n    using ipr_n3 = FieldModel<uint32_t, address, 24, 8, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  using iprx = IprxBankReg<BaseAddress + 0x0300, 0x0004>;\n\nprivate:\n\
    \  template<unsigned int address, unsigned int bankOffset>\n  class Ipr2xBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    \n\n  public:\n    union reg\n    {\n      uint32_t value;\n      \n    };\n\
    \  };\n\npublic:\n  using ipr2x = Ipr2xBankReg<BaseAddress + 0x0354, 0x0004>;\n\
    };\n\n}\n\n#endif /* DRAL_STM32F446_NVIC_H */\n"
  name: NVIC
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_FLASH_H\n#define DRAL_STM32F446_FLASH_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass flash\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40023C00;\n\nprivate:\n\
    \  template<unsigned int address>\n  class AcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using latency = FieldModel<uint32_t, address,\
    \ 0, 3>;\n    using prften = FieldModel<uint32_t, address, 8, 1>;\n    using icen\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    using dcen = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using icrst = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using dcrst = FieldModel<uint32_t, address, 12, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 3> latency;\n\
    \      BitFieldModel<uint32_t, 8, 1> prften;\n      BitFieldModel<uint32_t, 9,\
    \ 1> icen;\n      BitFieldModel<uint32_t, 10, 1> dcen;\n      BitFieldModel<uint32_t,\
    \ 11, 1> icrst;\n      BitFieldModel<uint32_t, 12, 1> dcrst;\n    };\n  };\n\n\
    public:\n  using acr = AcrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class KeyrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using key = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 32> key;\n    };\n  };\n\npublic:\n  using keyr = KeyrReg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class OptkeyrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using optkey = FieldModel<uint32_t, address, 0,\
    \ 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> optkey;\n    };\n  };\n\npublic:\n  using optkeyr = OptkeyrReg<BaseAddress\
    \ + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class SrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using eop = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using operr = FieldModel<uint32_t, address, 1, 1>;\n  \
    \  using wrperr = FieldModel<uint32_t, address, 4, 1>;\n    using pgaerr = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using pgperr = FieldModel<uint32_t, address, 6, 1>;\n \
    \   using pgserr = FieldModel<uint32_t, address, 7, 1>;\n    using rderr = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using bsy = FieldModel<uint32_t, address, 16, 1>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> eop;\n      BitFieldModel<uint32_t, 1, 1> operr;\n      BitFieldModel<uint32_t,\
    \ 4, 1> wrperr;\n      BitFieldModel<uint32_t, 5, 1> pgaerr;\n      BitFieldModel<uint32_t,\
    \ 6, 1> pgperr;\n      BitFieldModel<uint32_t, 7, 1> pgserr;\n      BitFieldModel<uint32_t,\
    \ 8, 1> rderr;\n      BitFieldModel<uint32_t, 16, 1> bsy;\n    };\n  };\n\npublic:\n\
    \  using sr = SrReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class CrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using pg = FieldModel<uint32_t, address, 0, 1>;\n    using ser = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using mer = FieldModel<uint32_t, address, 2, 1>;\n    using\
    \ snb = FieldModel<uint32_t, address, 3, 4>;\n    using psize = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    using strt = FieldModel<uint32_t, address, 16, 1>;\n  \
    \  using eopie = FieldModel<uint32_t, address, 24, 1>;\n    using errie = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using lock = FieldModel<uint32_t, address, 31, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> pg;\n      BitFieldModel<uint32_t, 1, 1> ser;\n      BitFieldModel<uint32_t,\
    \ 2, 1> mer;\n      BitFieldModel<uint32_t, 3, 4> snb;\n      BitFieldModel<uint32_t,\
    \ 8, 2> psize;\n      BitFieldModel<uint32_t, 16, 1> strt;\n      BitFieldModel<uint32_t,\
    \ 24, 1> eopie;\n      BitFieldModel<uint32_t, 25, 1> errie;\n      BitFieldModel<uint32_t,\
    \ 31, 1> lock;\n    };\n  };\n\npublic:\n  using cr = CrReg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class OptcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using optlock = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    using optstrt = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ bor_lev = FieldModel<uint32_t, address, 2, 2>;\n    using wdg_sw = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using nrst_stop = FieldModel<uint32_t, address, 6, 1>;\n\
    \    using nrst_stdby = FieldModel<uint32_t, address, 7, 1>;\n    using rdp =\
    \ FieldModel<uint32_t, address, 8, 8>;\n    using nwrp = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using sprmod = FieldModel<uint32_t, address, 31, 1>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> optlock;\n      BitFieldModel<uint32_t, 1, 1> optstrt;\n      BitFieldModel<uint32_t,\
    \ 2, 2> bor_lev;\n      BitFieldModel<uint32_t, 5, 1> wdg_sw;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nrst_stop;\n      BitFieldModel<uint32_t, 7, 1> nrst_stdby;\n      BitFieldModel<uint32_t,\
    \ 8, 8> rdp;\n      BitFieldModel<uint32_t, 16, 8> nwrp;\n      BitFieldModel<uint32_t,\
    \ 31, 1> sprmod;\n    };\n  };\n\npublic:\n  using optcr = OptcrReg<BaseAddress\
    \ + 0x0014>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_FLASH_H */\n"
  name: FLASH
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_EXTI_H\n#define DRAL_STM32F446_EXTI_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass exti\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40013C00;\n\nprivate:\n\
    \  template<unsigned int address>\n  class ImrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using mr0 = FieldModel<uint32_t, address, 0, 1>;\n\
    \    using mr1 = FieldModel<uint32_t, address, 1, 1>;\n    using mr2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using mr3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ mr4 = FieldModel<uint32_t, address, 4, 1>;\n    using mr5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using mr6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ mr7 = FieldModel<uint32_t, address, 7, 1>;\n    using mr8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using mr9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ mr10 = FieldModel<uint32_t, address, 10, 1>;\n    using mr11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using mr12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using mr13 = FieldModel<uint32_t, address, 13, 1>;\n    using mr14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using mr15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using mr16 = FieldModel<uint32_t, address, 16, 1>;\n    using mr17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using mr18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using mr19 = FieldModel<uint32_t, address, 19, 1>;\n    using mr20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using mr21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using mr22 = FieldModel<uint32_t, address, 22, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> mr0;\n\
    \      BitFieldModel<uint32_t, 1, 1> mr1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ mr2;\n      BitFieldModel<uint32_t, 3, 1> mr3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> mr4;\n      BitFieldModel<uint32_t, 5, 1> mr5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> mr6;\n      BitFieldModel<uint32_t, 7, 1> mr7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> mr8;\n      BitFieldModel<uint32_t, 9, 1> mr9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> mr10;\n      BitFieldModel<uint32_t, 11, 1> mr11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> mr12;\n      BitFieldModel<uint32_t, 13, 1> mr13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> mr14;\n      BitFieldModel<uint32_t, 15, 1> mr15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> mr16;\n      BitFieldModel<uint32_t, 17, 1> mr17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> mr18;\n      BitFieldModel<uint32_t, 19, 1> mr19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> mr20;\n      BitFieldModel<uint32_t, 21, 1> mr21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> mr22;\n    };\n  };\n\npublic:\n  using imr = ImrReg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class EmrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using mr0 = FieldModel<uint32_t, address, 0, 1>;\n\
    \    using mr1 = FieldModel<uint32_t, address, 1, 1>;\n    using mr2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using mr3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ mr4 = FieldModel<uint32_t, address, 4, 1>;\n    using mr5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using mr6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ mr7 = FieldModel<uint32_t, address, 7, 1>;\n    using mr8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using mr9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ mr10 = FieldModel<uint32_t, address, 10, 1>;\n    using mr11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using mr12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using mr13 = FieldModel<uint32_t, address, 13, 1>;\n    using mr14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using mr15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using mr16 = FieldModel<uint32_t, address, 16, 1>;\n    using mr17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using mr18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using mr19 = FieldModel<uint32_t, address, 19, 1>;\n    using mr20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using mr21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using mr22 = FieldModel<uint32_t, address, 22, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> mr0;\n\
    \      BitFieldModel<uint32_t, 1, 1> mr1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ mr2;\n      BitFieldModel<uint32_t, 3, 1> mr3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> mr4;\n      BitFieldModel<uint32_t, 5, 1> mr5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> mr6;\n      BitFieldModel<uint32_t, 7, 1> mr7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> mr8;\n      BitFieldModel<uint32_t, 9, 1> mr9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> mr10;\n      BitFieldModel<uint32_t, 11, 1> mr11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> mr12;\n      BitFieldModel<uint32_t, 13, 1> mr13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> mr14;\n      BitFieldModel<uint32_t, 15, 1> mr15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> mr16;\n      BitFieldModel<uint32_t, 17, 1> mr17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> mr18;\n      BitFieldModel<uint32_t, 19, 1> mr19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> mr20;\n      BitFieldModel<uint32_t, 21, 1> mr21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> mr22;\n    };\n  };\n\npublic:\n  using emr = EmrReg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class RtsrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using tr0 = FieldModel<uint32_t, address, 0, 1>;\n\
    \    using tr1 = FieldModel<uint32_t, address, 1, 1>;\n    using tr2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using tr3 = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ tr4 = FieldModel<uint32_t, address, 4, 1>;\n    using tr5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using tr6 = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ tr7 = FieldModel<uint32_t, address, 7, 1>;\n    using tr8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using tr9 = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ tr10 = FieldModel<uint32_t, address, 10, 1>;\n    using tr11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using tr12 = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using tr13 = FieldModel<uint32_t, address, 13, 1>;\n    using tr14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using tr15 = FieldModel<uint32_t, address, 15, 1>;\n \
    \   using tr16 = FieldModel<uint32_t, address, 16, 1>;\n    using tr17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using tr18 = FieldModel<uint32_t, address, 18, 1>;\n \
    \   using tr19 = FieldModel<uint32_t, address, 19, 1>;\n    using tr20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using tr21 = FieldModel<uint32_t, address, 21, 1>;\n \
    \   using tr22 = FieldModel<uint32_t, address, 22, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> tr0;\n\
    \      BitFieldModel<uint32_t, 1, 1> tr1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ tr2;\n      BitFieldModel<uint32_t, 3, 1> tr3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> tr4;\n      BitFieldModel<uint32_t, 5, 1> tr5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> tr6;\n      BitFieldModel<uint32_t, 7, 1> tr7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> tr8;\n      BitFieldModel<uint32_t, 9, 1> tr9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> tr10;\n      BitFieldModel<uint32_t, 11, 1> tr11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> tr12;\n      BitFieldModel<uint32_t, 13, 1> tr13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> tr14;\n      BitFieldModel<uint32_t, 15, 1> tr15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> tr16;\n      BitFieldModel<uint32_t, 17, 1> tr17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> tr18;\n      BitFieldModel<uint32_t, 19, 1> tr19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> tr20;\n      BitFieldModel<uint32_t, 21, 1> tr21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> tr22;\n    };\n  };\n\npublic:\n  using rtsr = RtsrReg<BaseAddress +\
    \ 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class FtsrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using tr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using tr1 = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ tr2 = FieldModel<uint32_t, address, 2, 1>;\n    using tr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using tr4 = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ tr5 = FieldModel<uint32_t, address, 5, 1>;\n    using tr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using tr7 = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ tr8 = FieldModel<uint32_t, address, 8, 1>;\n    using tr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using tr10 = FieldModel<uint32_t, address, 10, 1>;\n  \
    \  using tr11 = FieldModel<uint32_t, address, 11, 1>;\n    using tr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using tr13 = FieldModel<uint32_t, address, 13, 1>;\n \
    \   using tr14 = FieldModel<uint32_t, address, 14, 1>;\n    using tr15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using tr16 = FieldModel<uint32_t, address, 16, 1>;\n \
    \   using tr17 = FieldModel<uint32_t, address, 17, 1>;\n    using tr18 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    using tr19 = FieldModel<uint32_t, address, 19, 1>;\n \
    \   using tr20 = FieldModel<uint32_t, address, 20, 1>;\n    using tr21 = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    using tr22 = FieldModel<uint32_t, address, 22, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> tr0;\n      BitFieldModel<uint32_t, 1, 1> tr1;\n      BitFieldModel<uint32_t,\
    \ 2, 1> tr2;\n      BitFieldModel<uint32_t, 3, 1> tr3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> tr4;\n      BitFieldModel<uint32_t, 5, 1> tr5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> tr6;\n      BitFieldModel<uint32_t, 7, 1> tr7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> tr8;\n      BitFieldModel<uint32_t, 9, 1> tr9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> tr10;\n      BitFieldModel<uint32_t, 11, 1> tr11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> tr12;\n      BitFieldModel<uint32_t, 13, 1> tr13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> tr14;\n      BitFieldModel<uint32_t, 15, 1> tr15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> tr16;\n      BitFieldModel<uint32_t, 17, 1> tr17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> tr18;\n      BitFieldModel<uint32_t, 19, 1> tr19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> tr20;\n      BitFieldModel<uint32_t, 21, 1> tr21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> tr22;\n    };\n  };\n\npublic:\n  using ftsr = FtsrReg<BaseAddress +\
    \ 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class SwierReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using swier0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using swier1 = FieldModel<uint32_t, address, 1, 1>;\n \
    \   using swier2 = FieldModel<uint32_t, address, 2, 1>;\n    using swier3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using swier4 = FieldModel<uint32_t, address, 4, 1>;\n \
    \   using swier5 = FieldModel<uint32_t, address, 5, 1>;\n    using swier6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using swier7 = FieldModel<uint32_t, address, 7, 1>;\n \
    \   using swier8 = FieldModel<uint32_t, address, 8, 1>;\n    using swier9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using swier10 = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using swier11 = FieldModel<uint32_t, address, 11, 1>;\n    using swier12\
    \ = FieldModel<uint32_t, address, 12, 1>;\n    using swier13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using swier14 = FieldModel<uint32_t, address, 14, 1>;\n\
    \    using swier15 = FieldModel<uint32_t, address, 15, 1>;\n    using swier16\
    \ = FieldModel<uint32_t, address, 16, 1>;\n    using swier17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using swier18 = FieldModel<uint32_t, address, 18, 1>;\n\
    \    using swier19 = FieldModel<uint32_t, address, 19, 1>;\n    using swier20\
    \ = FieldModel<uint32_t, address, 20, 1>;\n    using swier21 = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    using swier22 = FieldModel<uint32_t, address, 22, 1>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> swier0;\n      BitFieldModel<uint32_t, 1, 1> swier1;\n      BitFieldModel<uint32_t,\
    \ 2, 1> swier2;\n      BitFieldModel<uint32_t, 3, 1> swier3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> swier4;\n      BitFieldModel<uint32_t, 5, 1> swier5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> swier6;\n      BitFieldModel<uint32_t, 7, 1> swier7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> swier8;\n      BitFieldModel<uint32_t, 9, 1> swier9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> swier10;\n      BitFieldModel<uint32_t, 11, 1> swier11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> swier12;\n      BitFieldModel<uint32_t, 13, 1> swier13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> swier14;\n      BitFieldModel<uint32_t, 15, 1> swier15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> swier16;\n      BitFieldModel<uint32_t, 17, 1> swier17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> swier18;\n      BitFieldModel<uint32_t, 19, 1> swier19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> swier20;\n      BitFieldModel<uint32_t, 21, 1> swier21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> swier22;\n    };\n  };\n\npublic:\n  using swier = SwierReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class PrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using pr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using pr1 = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ pr2 = FieldModel<uint32_t, address, 2, 1>;\n    using pr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using pr4 = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ pr5 = FieldModel<uint32_t, address, 5, 1>;\n    using pr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using pr7 = FieldModel<uint32_t, address, 7, 1>;\n    using\
    \ pr8 = FieldModel<uint32_t, address, 8, 1>;\n    using pr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using pr10 = FieldModel<uint32_t, address, 10, 1>;\n  \
    \  using pr11 = FieldModel<uint32_t, address, 11, 1>;\n    using pr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using pr13 = FieldModel<uint32_t, address, 13, 1>;\n \
    \   using pr14 = FieldModel<uint32_t, address, 14, 1>;\n    using pr15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using pr16 = FieldModel<uint32_t, address, 16, 1>;\n \
    \   using pr17 = FieldModel<uint32_t, address, 17, 1>;\n    using pr18 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    using pr19 = FieldModel<uint32_t, address, 19, 1>;\n \
    \   using pr20 = FieldModel<uint32_t, address, 20, 1>;\n    using pr21 = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    using pr22 = FieldModel<uint32_t, address, 22, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> pr0;\n      BitFieldModel<uint32_t, 1, 1> pr1;\n      BitFieldModel<uint32_t,\
    \ 2, 1> pr2;\n      BitFieldModel<uint32_t, 3, 1> pr3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> pr4;\n      BitFieldModel<uint32_t, 5, 1> pr5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> pr6;\n      BitFieldModel<uint32_t, 7, 1> pr7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> pr8;\n      BitFieldModel<uint32_t, 9, 1> pr9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> pr10;\n      BitFieldModel<uint32_t, 11, 1> pr11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> pr12;\n      BitFieldModel<uint32_t, 13, 1> pr13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> pr14;\n      BitFieldModel<uint32_t, 15, 1> pr15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> pr16;\n      BitFieldModel<uint32_t, 17, 1> pr17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> pr18;\n      BitFieldModel<uint32_t, 19, 1> pr19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> pr20;\n      BitFieldModel<uint32_t, 21, 1> pr21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> pr22;\n    };\n  };\n\npublic:\n  using pr = PrReg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n  class\
    \ XmrBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n\
    \  public:\n    using mr0 = FieldModel<uint32_t, address, 0, 1, bankOffset>;\n\
    \    using mr1 = FieldModel<uint32_t, address, 1, 1, bankOffset>;\n    using mr2\
    \ = FieldModel<uint32_t, address, 2, 1, bankOffset>;\n    using mr3 = FieldModel<uint32_t,\
    \ address, 3, 1, bankOffset>;\n    using mr4 = FieldModel<uint32_t, address, 4,\
    \ 1, bankOffset>;\n    using mr5 = FieldModel<uint32_t, address, 5, 1, bankOffset>;\n\
    \    using mr6 = FieldModel<uint32_t, address, 6, 1, bankOffset>;\n    using mr7\
    \ = FieldModel<uint32_t, address, 7, 1, bankOffset>;\n    using mr8 = FieldModel<uint32_t,\
    \ address, 8, 1, bankOffset>;\n    using mr9 = FieldModel<uint32_t, address, 9,\
    \ 1, bankOffset>;\n    using mr10 = FieldModel<uint32_t, address, 10, 1, bankOffset>;\n\
    \    using mr11 = FieldModel<uint32_t, address, 11, 1, bankOffset>;\n    using\
    \ mr12 = FieldModel<uint32_t, address, 12, 1, bankOffset>;\n    using mr13 = FieldModel<uint32_t,\
    \ address, 13, 1, bankOffset>;\n    using mr14 = FieldModel<uint32_t, address,\
    \ 14, 1, bankOffset>;\n    using mr15 = FieldModel<uint32_t, address, 15, 1, bankOffset>;\n\
    \    using mr16 = FieldModel<uint32_t, address, 16, 1, bankOffset>;\n    using\
    \ mr17 = FieldModel<uint32_t, address, 17, 1, bankOffset>;\n    using mr18 = FieldModel<uint32_t,\
    \ address, 18, 1, bankOffset>;\n    using mr19 = FieldModel<uint32_t, address,\
    \ 19, 1, bankOffset>;\n    using mr20 = FieldModel<uint32_t, address, 20, 1, bankOffset>;\n\
    \    using mr21 = FieldModel<uint32_t, address, 21, 1, bankOffset>;\n    using\
    \ mr22 = FieldModel<uint32_t, address, 22, 1, bankOffset>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> mr0;\n\
    \      BitFieldModel<uint32_t, 1, 1> mr1;\n      BitFieldModel<uint32_t, 2, 1>\
    \ mr2;\n      BitFieldModel<uint32_t, 3, 1> mr3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> mr4;\n      BitFieldModel<uint32_t, 5, 1> mr5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> mr6;\n      BitFieldModel<uint32_t, 7, 1> mr7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> mr8;\n      BitFieldModel<uint32_t, 9, 1> mr9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> mr10;\n      BitFieldModel<uint32_t, 11, 1> mr11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> mr12;\n      BitFieldModel<uint32_t, 13, 1> mr13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> mr14;\n      BitFieldModel<uint32_t, 15, 1> mr15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> mr16;\n      BitFieldModel<uint32_t, 17, 1> mr17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> mr18;\n      BitFieldModel<uint32_t, 19, 1> mr19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> mr20;\n      BitFieldModel<uint32_t, 21, 1> mr21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> mr22;\n    };\n  };\n\npublic:\n  using xmr = XmrBankReg<BaseAddress\
    \ + 0x0000, 0x0004>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class XtsrBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using tr0 = FieldModel<uint32_t, address, 0,\
    \ 1, bankOffset>;\n    using tr1 = FieldModel<uint32_t, address, 1, 1, bankOffset>;\n\
    \    using tr2 = FieldModel<uint32_t, address, 2, 1, bankOffset>;\n    using tr3\
    \ = FieldModel<uint32_t, address, 3, 1, bankOffset>;\n    using tr4 = FieldModel<uint32_t,\
    \ address, 4, 1, bankOffset>;\n    using tr5 = FieldModel<uint32_t, address, 5,\
    \ 1, bankOffset>;\n    using tr6 = FieldModel<uint32_t, address, 6, 1, bankOffset>;\n\
    \    using tr7 = FieldModel<uint32_t, address, 7, 1, bankOffset>;\n    using tr8\
    \ = FieldModel<uint32_t, address, 8, 1, bankOffset>;\n    using tr9 = FieldModel<uint32_t,\
    \ address, 9, 1, bankOffset>;\n    using tr10 = FieldModel<uint32_t, address,\
    \ 10, 1, bankOffset>;\n    using tr11 = FieldModel<uint32_t, address, 11, 1, bankOffset>;\n\
    \    using tr12 = FieldModel<uint32_t, address, 12, 1, bankOffset>;\n    using\
    \ tr13 = FieldModel<uint32_t, address, 13, 1, bankOffset>;\n    using tr14 = FieldModel<uint32_t,\
    \ address, 14, 1, bankOffset>;\n    using tr15 = FieldModel<uint32_t, address,\
    \ 15, 1, bankOffset>;\n    using tr16 = FieldModel<uint32_t, address, 16, 1, bankOffset>;\n\
    \    using tr17 = FieldModel<uint32_t, address, 17, 1, bankOffset>;\n    using\
    \ tr18 = FieldModel<uint32_t, address, 18, 1, bankOffset>;\n    using tr19 = FieldModel<uint32_t,\
    \ address, 19, 1, bankOffset>;\n    using tr20 = FieldModel<uint32_t, address,\
    \ 20, 1, bankOffset>;\n    using tr21 = FieldModel<uint32_t, address, 21, 1, bankOffset>;\n\
    \    using tr22 = FieldModel<uint32_t, address, 22, 1, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 1> tr0;\n      BitFieldModel<uint32_t, 1, 1> tr1;\n      BitFieldModel<uint32_t,\
    \ 2, 1> tr2;\n      BitFieldModel<uint32_t, 3, 1> tr3;\n      BitFieldModel<uint32_t,\
    \ 4, 1> tr4;\n      BitFieldModel<uint32_t, 5, 1> tr5;\n      BitFieldModel<uint32_t,\
    \ 6, 1> tr6;\n      BitFieldModel<uint32_t, 7, 1> tr7;\n      BitFieldModel<uint32_t,\
    \ 8, 1> tr8;\n      BitFieldModel<uint32_t, 9, 1> tr9;\n      BitFieldModel<uint32_t,\
    \ 10, 1> tr10;\n      BitFieldModel<uint32_t, 11, 1> tr11;\n      BitFieldModel<uint32_t,\
    \ 12, 1> tr12;\n      BitFieldModel<uint32_t, 13, 1> tr13;\n      BitFieldModel<uint32_t,\
    \ 14, 1> tr14;\n      BitFieldModel<uint32_t, 15, 1> tr15;\n      BitFieldModel<uint32_t,\
    \ 16, 1> tr16;\n      BitFieldModel<uint32_t, 17, 1> tr17;\n      BitFieldModel<uint32_t,\
    \ 18, 1> tr18;\n      BitFieldModel<uint32_t, 19, 1> tr19;\n      BitFieldModel<uint32_t,\
    \ 20, 1> tr20;\n      BitFieldModel<uint32_t, 21, 1> tr21;\n      BitFieldModel<uint32_t,\
    \ 22, 1> tr22;\n    };\n  };\n\npublic:\n  using xtsr = XtsrBankReg<BaseAddress\
    \ + 0x0008, 0x0004>;\n};\n\n}\n\n#endif /* DRAL_STM32F446_EXTI_H */\n"
  name: EXTI
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_OTG_HS_GLOBAL_H\n#define DRAL_STM32F446_OTG_HS_GLOBAL_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass otg_hs_global\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40040000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_gotgctlReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using srqscs = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using srq = FieldModel<uint32_t, address, 1, 1>;\n    using hngscs\
    \ = FieldModel<uint32_t, address, 8, 1>;\n    using hnprq = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using hshnpen = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using dhnpen = FieldModel<uint32_t, address, 11, 1>;\n    using cidsts =\
    \ FieldModel<uint32_t, address, 16, 1>;\n    using dbct = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using asvld = FieldModel<uint32_t, address, 18, 1>;\n\
    \    using bsvld = FieldModel<uint32_t, address, 19, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> srqscs;\n\
    \      BitFieldModel<uint32_t, 1, 1> srq;\n      BitFieldModel<uint32_t, 8, 1>\
    \ hngscs;\n      BitFieldModel<uint32_t, 9, 1> hnprq;\n      BitFieldModel<uint32_t,\
    \ 10, 1> hshnpen;\n      BitFieldModel<uint32_t, 11, 1> dhnpen;\n      BitFieldModel<uint32_t,\
    \ 16, 1> cidsts;\n      BitFieldModel<uint32_t, 17, 1> dbct;\n      BitFieldModel<uint32_t,\
    \ 18, 1> asvld;\n      BitFieldModel<uint32_t, 19, 1> bsvld;\n    };\n  };\n\n\
    public:\n  using otg_hs_gotgctl = Otg_hs_gotgctlReg<BaseAddress + 0x0000>;\n\n\
    private:\n  template<unsigned int address>\n  class Otg_hs_gotgintReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using sedet = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using srsschg = FieldModel<uint32_t, address, 8, 1>;\n\
    \    using hnsschg = FieldModel<uint32_t, address, 9, 1>;\n    using hngdet =\
    \ FieldModel<uint32_t, address, 17, 1>;\n    using adtochg = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    using dbcdne = FieldModel<uint32_t, address, 19, 1>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 2, 1> sedet;\n      BitFieldModel<uint32_t, 8, 1> srsschg;\n      BitFieldModel<uint32_t,\
    \ 9, 1> hnsschg;\n      BitFieldModel<uint32_t, 17, 1> hngdet;\n      BitFieldModel<uint32_t,\
    \ 18, 1> adtochg;\n      BitFieldModel<uint32_t, 19, 1> dbcdne;\n    };\n  };\n\
    \npublic:\n  using otg_hs_gotgint = Otg_hs_gotgintReg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_gahbcfgReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using gint = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using hbstlen = FieldModel<uint32_t, address, 1, 4>;\n\
    \    using dmaen = FieldModel<uint32_t, address, 5, 1>;\n    using txfelvl = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using ptxfelvl = FieldModel<uint32_t, address, 8, 1>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> gint;\n      BitFieldModel<uint32_t, 1, 4> hbstlen;\n      BitFieldModel<uint32_t,\
    \ 5, 1> dmaen;\n      BitFieldModel<uint32_t, 7, 1> txfelvl;\n      BitFieldModel<uint32_t,\
    \ 8, 1> ptxfelvl;\n    };\n  };\n\npublic:\n  using otg_hs_gahbcfg = Otg_hs_gahbcfgReg<BaseAddress\
    \ + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_gusbcfgReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using tocal =\
    \ FieldModel<uint32_t, address, 0, 3>;\n    using physel = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using srpcap = FieldModel<uint32_t, address, 8, 1>;\n \
    \   using hnpcap = FieldModel<uint32_t, address, 9, 1>;\n    using trdt = FieldModel<uint32_t,\
    \ address, 10, 4>;\n    using phylpcs = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using ulpifsls = FieldModel<uint32_t, address, 17, 1>;\n    using ulpiar\
    \ = FieldModel<uint32_t, address, 18, 1>;\n    using ulpicsm = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using ulpievbusd = FieldModel<uint32_t, address, 20, 1>;\n\
    \    using ulpievbusi = FieldModel<uint32_t, address, 21, 1>;\n    using tsdps\
    \ = FieldModel<uint32_t, address, 22, 1>;\n    using pcci = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using ptci = FieldModel<uint32_t, address, 24, 1>;\n \
    \   using ulpiipd = FieldModel<uint32_t, address, 25, 1>;\n    using fhmod = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using fdmod = FieldModel<uint32_t, address, 30, 1>;\n\
    \    using ctxpkt = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 3> tocal;\n\
    \      BitFieldModel<uint32_t, 6, 1> physel;\n      BitFieldModel<uint32_t, 8,\
    \ 1> srpcap;\n      BitFieldModel<uint32_t, 9, 1> hnpcap;\n      BitFieldModel<uint32_t,\
    \ 10, 4> trdt;\n      BitFieldModel<uint32_t, 15, 1> phylpcs;\n      BitFieldModel<uint32_t,\
    \ 17, 1> ulpifsls;\n      BitFieldModel<uint32_t, 18, 1> ulpiar;\n      BitFieldModel<uint32_t,\
    \ 19, 1> ulpicsm;\n      BitFieldModel<uint32_t, 20, 1> ulpievbusd;\n      BitFieldModel<uint32_t,\
    \ 21, 1> ulpievbusi;\n      BitFieldModel<uint32_t, 22, 1> tsdps;\n      BitFieldModel<uint32_t,\
    \ 23, 1> pcci;\n      BitFieldModel<uint32_t, 24, 1> ptci;\n      BitFieldModel<uint32_t,\
    \ 25, 1> ulpiipd;\n      BitFieldModel<uint32_t, 29, 1> fhmod;\n      BitFieldModel<uint32_t,\
    \ 30, 1> fdmod;\n      BitFieldModel<uint32_t, 31, 1> ctxpkt;\n    };\n  };\n\n\
    public:\n  using otg_hs_gusbcfg = Otg_hs_gusbcfgReg<BaseAddress + 0x000C>;\n\n\
    private:\n  template<unsigned int address>\n  class Otg_hs_grstctlReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using csrst = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using hsrst = FieldModel<uint32_t, address, 1, 1>;\n  \
    \  using fcrst = FieldModel<uint32_t, address, 2, 1>;\n    using rxfflsh = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using txfflsh = FieldModel<uint32_t, address, 5, 1>;\n\
    \    using txfnum = FieldModel<uint32_t, address, 6, 5>;\n    using dmareq = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    using ahbidl = FieldModel<uint32_t, address, 31, 1>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> csrst;\n      BitFieldModel<uint32_t, 1, 1> hsrst;\n      BitFieldModel<uint32_t,\
    \ 2, 1> fcrst;\n      BitFieldModel<uint32_t, 4, 1> rxfflsh;\n      BitFieldModel<uint32_t,\
    \ 5, 1> txfflsh;\n      BitFieldModel<uint32_t, 6, 5> txfnum;\n      BitFieldModel<uint32_t,\
    \ 30, 1> dmareq;\n      BitFieldModel<uint32_t, 31, 1> ahbidl;\n    };\n  };\n\
    \npublic:\n  using otg_hs_grstctl = Otg_hs_grstctlReg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_gintstsReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using cmod = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using mmis = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using otgint = FieldModel<uint32_t, address, 2, 1>;\n    using sof = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using rxflvl = FieldModel<uint32_t, address, 4, 1>;\n \
    \   using nptxfe = FieldModel<uint32_t, address, 5, 1>;\n    using ginakeff =\
    \ FieldModel<uint32_t, address, 6, 1>;\n    using boutnakeff = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using esusp = FieldModel<uint32_t, address, 10, 1>;\n \
    \   using usbsusp = FieldModel<uint32_t, address, 11, 1>;\n    using usbrst =\
    \ FieldModel<uint32_t, address, 12, 1>;\n    using enumdne = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using isoodrp = FieldModel<uint32_t, address, 14, 1>;\n\
    \    using eopf = FieldModel<uint32_t, address, 15, 1>;\n    using iepint = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    using oepint = FieldModel<uint32_t, address, 19, 1>;\n\
    \    using iisoixfr = FieldModel<uint32_t, address, 20, 1>;\n    using pxfr_incompisoout\
    \ = FieldModel<uint32_t, address, 21, 1>;\n    using datafsusp = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    using hprtint = FieldModel<uint32_t, address, 24, 1>;\n\
    \    using hcint = FieldModel<uint32_t, address, 25, 1>;\n    using ptxfe = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using cidschg = FieldModel<uint32_t, address, 28, 1>;\n\
    \    using discint = FieldModel<uint32_t, address, 29, 1>;\n    using srqint =\
    \ FieldModel<uint32_t, address, 30, 1>;\n    using wkuint = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> cmod;\n      BitFieldModel<uint32_t, 1, 1>\
    \ mmis;\n      BitFieldModel<uint32_t, 2, 1> otgint;\n      BitFieldModel<uint32_t,\
    \ 3, 1> sof;\n      BitFieldModel<uint32_t, 4, 1> rxflvl;\n      BitFieldModel<uint32_t,\
    \ 5, 1> nptxfe;\n      BitFieldModel<uint32_t, 6, 1> ginakeff;\n      BitFieldModel<uint32_t,\
    \ 7, 1> boutnakeff;\n      BitFieldModel<uint32_t, 10, 1> esusp;\n      BitFieldModel<uint32_t,\
    \ 11, 1> usbsusp;\n      BitFieldModel<uint32_t, 12, 1> usbrst;\n      BitFieldModel<uint32_t,\
    \ 13, 1> enumdne;\n      BitFieldModel<uint32_t, 14, 1> isoodrp;\n      BitFieldModel<uint32_t,\
    \ 15, 1> eopf;\n      BitFieldModel<uint32_t, 18, 1> iepint;\n      BitFieldModel<uint32_t,\
    \ 19, 1> oepint;\n      BitFieldModel<uint32_t, 20, 1> iisoixfr;\n      BitFieldModel<uint32_t,\
    \ 21, 1> pxfr_incompisoout;\n      BitFieldModel<uint32_t, 22, 1> datafsusp;\n\
    \      BitFieldModel<uint32_t, 24, 1> hprtint;\n      BitFieldModel<uint32_t,\
    \ 25, 1> hcint;\n      BitFieldModel<uint32_t, 26, 1> ptxfe;\n      BitFieldModel<uint32_t,\
    \ 28, 1> cidschg;\n      BitFieldModel<uint32_t, 29, 1> discint;\n      BitFieldModel<uint32_t,\
    \ 30, 1> srqint;\n      BitFieldModel<uint32_t, 31, 1> wkuint;\n    };\n  };\n\
    \npublic:\n  using otg_hs_gintsts = Otg_hs_gintstsReg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_gintmskReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using mmism = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using otgint = FieldModel<uint32_t, address, 2, 1>;\n \
    \   using sofm = FieldModel<uint32_t, address, 3, 1>;\n    using rxflvlm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using nptxfem = FieldModel<uint32_t, address, 5, 1>;\n\
    \    using ginakeffm = FieldModel<uint32_t, address, 6, 1>;\n    using gonakeffm\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    using esuspm = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using usbsuspm = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using usbrst = FieldModel<uint32_t, address, 12, 1>;\n    using enumdnem\
    \ = FieldModel<uint32_t, address, 13, 1>;\n    using isoodrpm = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    using eopfm = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using epmism = FieldModel<uint32_t, address, 17, 1>;\n    using iepint =\
    \ FieldModel<uint32_t, address, 18, 1>;\n    using oepint = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using iisoixfrm = FieldModel<uint32_t, address, 20, 1>;\n\
    \    using pxfrm_iisooxfrm = FieldModel<uint32_t, address, 21, 1>;\n    using\
    \ fsuspm = FieldModel<uint32_t, address, 22, 1>;\n    using prtim = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    using hcim = FieldModel<uint32_t, address, 25, 1>;\n \
    \   using ptxfem = FieldModel<uint32_t, address, 26, 1>;\n    using cidschgm =\
    \ FieldModel<uint32_t, address, 28, 1>;\n    using discint = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using srqim = FieldModel<uint32_t, address, 30, 1>;\n\
    \    using wuim = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 1, 1> mmism;\n\
    \      BitFieldModel<uint32_t, 2, 1> otgint;\n      BitFieldModel<uint32_t, 3,\
    \ 1> sofm;\n      BitFieldModel<uint32_t, 4, 1> rxflvlm;\n      BitFieldModel<uint32_t,\
    \ 5, 1> nptxfem;\n      BitFieldModel<uint32_t, 6, 1> ginakeffm;\n      BitFieldModel<uint32_t,\
    \ 7, 1> gonakeffm;\n      BitFieldModel<uint32_t, 10, 1> esuspm;\n      BitFieldModel<uint32_t,\
    \ 11, 1> usbsuspm;\n      BitFieldModel<uint32_t, 12, 1> usbrst;\n      BitFieldModel<uint32_t,\
    \ 13, 1> enumdnem;\n      BitFieldModel<uint32_t, 14, 1> isoodrpm;\n      BitFieldModel<uint32_t,\
    \ 15, 1> eopfm;\n      BitFieldModel<uint32_t, 17, 1> epmism;\n      BitFieldModel<uint32_t,\
    \ 18, 1> iepint;\n      BitFieldModel<uint32_t, 19, 1> oepint;\n      BitFieldModel<uint32_t,\
    \ 20, 1> iisoixfrm;\n      BitFieldModel<uint32_t, 21, 1> pxfrm_iisooxfrm;\n \
    \     BitFieldModel<uint32_t, 22, 1> fsuspm;\n      BitFieldModel<uint32_t, 24,\
    \ 1> prtim;\n      BitFieldModel<uint32_t, 25, 1> hcim;\n      BitFieldModel<uint32_t,\
    \ 26, 1> ptxfem;\n      BitFieldModel<uint32_t, 28, 1> cidschgm;\n      BitFieldModel<uint32_t,\
    \ 29, 1> discint;\n      BitFieldModel<uint32_t, 30, 1> srqim;\n      BitFieldModel<uint32_t,\
    \ 31, 1> wuim;\n    };\n  };\n\npublic:\n  using otg_hs_gintmsk = Otg_hs_gintmskReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_grxstsr_hostReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using chnum =\
    \ FieldModel<uint32_t, address, 0, 4>;\n    using bcnt = FieldModel<uint32_t,\
    \ address, 4, 11>;\n    using dpid = FieldModel<uint32_t, address, 15, 2>;\n \
    \   using pktsts = FieldModel<uint32_t, address, 17, 4>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 4> chnum;\n\
    \      BitFieldModel<uint32_t, 4, 11> bcnt;\n      BitFieldModel<uint32_t, 15,\
    \ 2> dpid;\n      BitFieldModel<uint32_t, 17, 4> pktsts;\n    };\n  };\n\npublic:\n\
    \  using otg_hs_grxstsr_host = Otg_hs_grxstsr_hostReg<BaseAddress + 0x001C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_grxstsp_hostReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using chnum = FieldModel<uint32_t,\
    \ address, 0, 4>;\n    using bcnt = FieldModel<uint32_t, address, 4, 11>;\n  \
    \  using dpid = FieldModel<uint32_t, address, 15, 2>;\n    using pktsts = FieldModel<uint32_t,\
    \ address, 17, 4>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 4> chnum;\n      BitFieldModel<uint32_t, 4,\
    \ 11> bcnt;\n      BitFieldModel<uint32_t, 15, 2> dpid;\n      BitFieldModel<uint32_t,\
    \ 17, 4> pktsts;\n    };\n  };\n\npublic:\n  using otg_hs_grxstsp_host = Otg_hs_grxstsp_hostReg<BaseAddress\
    \ + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_grxfsizReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using rxfd =\
    \ FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 0, 16> rxfd;\n    };\n  };\n\
    \npublic:\n  using otg_hs_grxfsiz = Otg_hs_grxfsizReg<BaseAddress + 0x0024>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_gnptxfsiz_hostReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using nptxfsa\
    \ = FieldModel<uint32_t, address, 0, 16>;\n    using nptxfd = FieldModel<uint32_t,\
    \ address, 16, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> nptxfsa;\n      BitFieldModel<uint32_t,\
    \ 16, 16> nptxfd;\n    };\n  };\n\npublic:\n  using otg_hs_gnptxfsiz_host = Otg_hs_gnptxfsiz_hostReg<BaseAddress\
    \ + 0x0028>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_tx0fsiz_peripheralReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using tx0fsa\
    \ = FieldModel<uint32_t, address, 0, 16>;\n    using tx0fd = FieldModel<uint32_t,\
    \ address, 16, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> tx0fsa;\n      BitFieldModel<uint32_t, 16,\
    \ 16> tx0fd;\n    };\n  };\n\npublic:\n  using otg_hs_tx0fsiz_peripheral = Otg_hs_tx0fsiz_peripheralReg<BaseAddress\
    \ + 0x0028>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_gnptxstsReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using nptxfsav\
    \ = FieldModel<uint32_t, address, 0, 16>;\n    using nptqxsav = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using nptxqtop = FieldModel<uint32_t, address, 24, 7>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> nptxfsav;\n      BitFieldModel<uint32_t, 16, 8> nptqxsav;\n      BitFieldModel<uint32_t,\
    \ 24, 7> nptxqtop;\n    };\n  };\n\npublic:\n  using otg_hs_gnptxsts = Otg_hs_gnptxstsReg<BaseAddress\
    \ + 0x002C>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_gccfgReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using pwrdwn\
    \ = FieldModel<uint32_t, address, 16, 1>;\n    using i2cpaden = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using vbusasen = FieldModel<uint32_t, address, 18, 1>;\n\
    \    using vbusbsen = FieldModel<uint32_t, address, 19, 1>;\n    using sofouten\
    \ = FieldModel<uint32_t, address, 20, 1>;\n    using novbussens = FieldModel<uint32_t,\
    \ address, 21, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 16, 1> pwrdwn;\n      BitFieldModel<uint32_t, 17,\
    \ 1> i2cpaden;\n      BitFieldModel<uint32_t, 18, 1> vbusasen;\n      BitFieldModel<uint32_t,\
    \ 19, 1> vbusbsen;\n      BitFieldModel<uint32_t, 20, 1> sofouten;\n      BitFieldModel<uint32_t,\
    \ 21, 1> novbussens;\n    };\n  };\n\npublic:\n  using otg_hs_gccfg = Otg_hs_gccfgReg<BaseAddress\
    \ + 0x0038>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_cidReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using product_id\
    \ = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> product_id;\n   \
    \ };\n  };\n\npublic:\n  using otg_hs_cid = Otg_hs_cidReg<BaseAddress + 0x003C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hptxfsizReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using ptxsa = FieldModel<uint32_t,\
    \ address, 0, 16>;\n    using ptxfd = FieldModel<uint32_t, address, 16, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ptxsa;\n      BitFieldModel<uint32_t, 16, 16> ptxfd;\n    };\n  };\n\n\
    public:\n  using otg_hs_hptxfsiz = Otg_hs_hptxfsizReg<BaseAddress + 0x0100>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_dieptxf1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using ineptxsa = FieldModel<uint32_t,\
    \ address, 0, 16>;\n    using ineptxfd = FieldModel<uint32_t, address, 16, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ineptxsa;\n      BitFieldModel<uint32_t, 16, 16> ineptxfd;\n    };\n\
    \  };\n\npublic:\n  using otg_hs_dieptxf1 = Otg_hs_dieptxf1Reg<BaseAddress + 0x0104>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_dieptxf2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using ineptxsa = FieldModel<uint32_t,\
    \ address, 0, 16>;\n    using ineptxfd = FieldModel<uint32_t, address, 16, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ineptxsa;\n      BitFieldModel<uint32_t, 16, 16> ineptxfd;\n    };\n\
    \  };\n\npublic:\n  using otg_hs_dieptxf2 = Otg_hs_dieptxf2Reg<BaseAddress + 0x0108>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_dieptxf3Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using ineptxsa = FieldModel<uint32_t,\
    \ address, 0, 16>;\n    using ineptxfd = FieldModel<uint32_t, address, 16, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ineptxsa;\n      BitFieldModel<uint32_t, 16, 16> ineptxfd;\n    };\n\
    \  };\n\npublic:\n  using otg_hs_dieptxf3 = Otg_hs_dieptxf3Reg<BaseAddress + 0x010C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_dieptxf4Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using ineptxsa = FieldModel<uint32_t,\
    \ address, 0, 16>;\n    using ineptxfd = FieldModel<uint32_t, address, 16, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ineptxsa;\n      BitFieldModel<uint32_t, 16, 16> ineptxfd;\n    };\n\
    \  };\n\npublic:\n  using otg_hs_dieptxf4 = Otg_hs_dieptxf4Reg<BaseAddress + 0x0110>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_dieptxf5Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using ineptxsa = FieldModel<uint32_t,\
    \ address, 0, 16>;\n    using ineptxfd = FieldModel<uint32_t, address, 16, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ineptxsa;\n      BitFieldModel<uint32_t, 16, 16> ineptxfd;\n    };\n\
    \  };\n\npublic:\n  using otg_hs_dieptxf5 = Otg_hs_dieptxf5Reg<BaseAddress + 0x0114>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_dieptxf6Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using ineptxsa = FieldModel<uint32_t,\
    \ address, 0, 16>;\n    using ineptxfd = FieldModel<uint32_t, address, 16, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ineptxsa;\n      BitFieldModel<uint32_t, 16, 16> ineptxfd;\n    };\n\
    \  };\n\npublic:\n  using otg_hs_dieptxf6 = Otg_hs_dieptxf6Reg<BaseAddress + 0x0118>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_dieptxf7Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using ineptxsa = FieldModel<uint32_t,\
    \ address, 0, 16>;\n    using ineptxfd = FieldModel<uint32_t, address, 16, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ineptxsa;\n      BitFieldModel<uint32_t, 16, 16> ineptxfd;\n    };\n\
    \  };\n\npublic:\n  using otg_hs_dieptxf7 = Otg_hs_dieptxf7Reg<BaseAddress + 0x011C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_grxstsr_peripheralReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using epnum =\
    \ FieldModel<uint32_t, address, 0, 4>;\n    using bcnt = FieldModel<uint32_t,\
    \ address, 4, 11>;\n    using dpid = FieldModel<uint32_t, address, 15, 2>;\n \
    \   using pktsts = FieldModel<uint32_t, address, 17, 4>;\n    using frmnum = FieldModel<uint32_t,\
    \ address, 21, 4>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 4> epnum;\n      BitFieldModel<uint32_t, 4,\
    \ 11> bcnt;\n      BitFieldModel<uint32_t, 15, 2> dpid;\n      BitFieldModel<uint32_t,\
    \ 17, 4> pktsts;\n      BitFieldModel<uint32_t, 21, 4> frmnum;\n    };\n  };\n\
    \npublic:\n  using otg_hs_grxstsr_peripheral = Otg_hs_grxstsr_peripheralReg<BaseAddress\
    \ + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_grxstsp_peripheralReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using epnum =\
    \ FieldModel<uint32_t, address, 0, 4>;\n    using bcnt = FieldModel<uint32_t,\
    \ address, 4, 11>;\n    using dpid = FieldModel<uint32_t, address, 15, 2>;\n \
    \   using pktsts = FieldModel<uint32_t, address, 17, 4>;\n    using frmnum = FieldModel<uint32_t,\
    \ address, 21, 4>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 4> epnum;\n      BitFieldModel<uint32_t, 4,\
    \ 11> bcnt;\n      BitFieldModel<uint32_t, 15, 2> dpid;\n      BitFieldModel<uint32_t,\
    \ 17, 4> pktsts;\n      BitFieldModel<uint32_t, 21, 4> frmnum;\n    };\n  };\n\
    \npublic:\n  using otg_hs_grxstsp_peripheral = Otg_hs_grxstsp_peripheralReg<BaseAddress\
    \ + 0x0020>;\n\nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n\
    \  class Otg_hs_grxstsx_hostBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using chnum = FieldModel<uint32_t, address,\
    \ 0, 4, bankOffset>;\n    using bcnt = FieldModel<uint32_t, address, 4, 11, bankOffset>;\n\
    \    using dpid = FieldModel<uint32_t, address, 15, 2, bankOffset>;\n    using\
    \ pktsts = FieldModel<uint32_t, address, 17, 4, bankOffset>;\n\n  public:\n  \
    \  union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 4>\
    \ chnum;\n      BitFieldModel<uint32_t, 4, 11> bcnt;\n      BitFieldModel<uint32_t,\
    \ 15, 2> dpid;\n      BitFieldModel<uint32_t, 17, 4> pktsts;\n    };\n  };\n\n\
    public:\n  using otg_hs_grxstsx_host = Otg_hs_grxstsx_hostBankReg<BaseAddress\
    \ + 0x001C, 0x0004>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class Otg_hs_dieptxfxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using ineptxsa = FieldModel<uint32_t,\
    \ address, 0, 16, bankOffset>;\n    using ineptxfd = FieldModel<uint32_t, address,\
    \ 16, 16, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> ineptxsa;\n      BitFieldModel<uint32_t,\
    \ 16, 16> ineptxfd;\n    };\n  };\n\npublic:\n  using otg_hs_dieptxfx = Otg_hs_dieptxfxBankReg<BaseAddress\
    \ + 0x0104, 0x0004>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class Otg_hs_grxstsx_peripheralBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using epnum = FieldModel<uint32_t,\
    \ address, 0, 4, bankOffset>;\n    using bcnt = FieldModel<uint32_t, address,\
    \ 4, 11, bankOffset>;\n    using dpid = FieldModel<uint32_t, address, 15, 2, bankOffset>;\n\
    \    using pktsts = FieldModel<uint32_t, address, 17, 4, bankOffset>;\n    using\
    \ frmnum = FieldModel<uint32_t, address, 21, 4, bankOffset>;\n\n  public:\n  \
    \  union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 4>\
    \ epnum;\n      BitFieldModel<uint32_t, 4, 11> bcnt;\n      BitFieldModel<uint32_t,\
    \ 15, 2> dpid;\n      BitFieldModel<uint32_t, 17, 4> pktsts;\n      BitFieldModel<uint32_t,\
    \ 21, 4> frmnum;\n    };\n  };\n\npublic:\n  using otg_hs_grxstsx_peripheral =\
    \ Otg_hs_grxstsx_peripheralBankReg<BaseAddress + 0x001C, 0x0004>;\n};\n\n}\n\n\
    #endif /* DRAL_STM32F446_OTG_HS_GLOBAL_H */\n"
  name: OTG_HS_GLOBAL
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_OTG_HS_HOST_H\n#define DRAL_STM32F446_OTG_HS_HOST_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass otg_hs_host\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40040400;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_hcfgReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using fslspcs = FieldModel<uint32_t, address,\
    \ 0, 2>;\n    using fslss = FieldModel<uint32_t, address, 2, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 2> fslspcs;\n      BitFieldModel<uint32_t, 2, 1> fslss;\n    };\n  };\n\npublic:\n\
    \  using otg_hs_hcfg = Otg_hs_hcfgReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Otg_hs_hfirReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using frivl = FieldModel<uint32_t, address, 0, 16>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> frivl;\n    };\n  };\n\npublic:\n  using otg_hs_hfir = Otg_hs_hfirReg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hfnumReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using frnum =\
    \ FieldModel<uint32_t, address, 0, 16>;\n    using ftrem = FieldModel<uint32_t,\
    \ address, 16, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> frnum;\n      BitFieldModel<uint32_t, 16,\
    \ 16> ftrem;\n    };\n  };\n\npublic:\n  using otg_hs_hfnum = Otg_hs_hfnumReg<BaseAddress\
    \ + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hptxstsReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ptxfsavl\
    \ = FieldModel<uint32_t, address, 0, 16>;\n    using ptxqsav = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    using ptxqtop = FieldModel<uint32_t, address, 24, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ptxfsavl;\n      BitFieldModel<uint32_t, 16, 8> ptxqsav;\n      BitFieldModel<uint32_t,\
    \ 24, 8> ptxqtop;\n    };\n  };\n\npublic:\n  using otg_hs_hptxsts = Otg_hs_hptxstsReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_haintReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using haint =\
    \ FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 0, 16> haint;\n    };\n \
    \ };\n\npublic:\n  using otg_hs_haint = Otg_hs_haintReg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_haintmskReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using haintm = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> haintm;\n    };\n  };\n\npublic:\n  using\
    \ otg_hs_haintmsk = Otg_hs_haintmskReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Otg_hs_hprtReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using pcsts = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ pcdet = FieldModel<uint32_t, address, 1, 1>;\n    using pena = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using penchng = FieldModel<uint32_t, address, 3, 1>;\n\
    \    using poca = FieldModel<uint32_t, address, 4, 1>;\n    using pocchng = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using pres = FieldModel<uint32_t, address, 6, 1>;\n   \
    \ using psusp = FieldModel<uint32_t, address, 7, 1>;\n    using prst = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using plsts = FieldModel<uint32_t, address, 10, 2>;\n \
    \   using ppwr = FieldModel<uint32_t, address, 12, 1>;\n    using ptctl = FieldModel<uint32_t,\
    \ address, 13, 4>;\n    using pspd = FieldModel<uint32_t, address, 17, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> pcsts;\n      BitFieldModel<uint32_t, 1, 1> pcdet;\n      BitFieldModel<uint32_t,\
    \ 2, 1> pena;\n      BitFieldModel<uint32_t, 3, 1> penchng;\n      BitFieldModel<uint32_t,\
    \ 4, 1> poca;\n      BitFieldModel<uint32_t, 5, 1> pocchng;\n      BitFieldModel<uint32_t,\
    \ 6, 1> pres;\n      BitFieldModel<uint32_t, 7, 1> psusp;\n      BitFieldModel<uint32_t,\
    \ 8, 1> prst;\n      BitFieldModel<uint32_t, 10, 2> plsts;\n      BitFieldModel<uint32_t,\
    \ 12, 1> ppwr;\n      BitFieldModel<uint32_t, 13, 4> ptctl;\n      BitFieldModel<uint32_t,\
    \ 17, 2> pspd;\n    };\n  };\n\npublic:\n  using otg_hs_hprt = Otg_hs_hprtReg<BaseAddress\
    \ + 0x0040>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcchar0Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    using epnum = FieldModel<uint32_t,\
    \ address, 11, 4>;\n    using epdir = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using lsdev = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using mc = FieldModel<uint32_t, address, 20, 2>;\n   \
    \ using dad = FieldModel<uint32_t, address, 22, 7>;\n    using oddfrm = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using chdis = FieldModel<uint32_t, address, 30, 1>;\n\
    \    using chena = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n\
    \      BitFieldModel<uint32_t, 11, 4> epnum;\n      BitFieldModel<uint32_t, 15,\
    \ 1> epdir;\n      BitFieldModel<uint32_t, 17, 1> lsdev;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 20, 2> mc;\n      BitFieldModel<uint32_t,\
    \ 22, 7> dad;\n      BitFieldModel<uint32_t, 29, 1> oddfrm;\n      BitFieldModel<uint32_t,\
    \ 30, 1> chdis;\n      BitFieldModel<uint32_t, 31, 1> chena;\n    };\n  };\n\n\
    public:\n  using otg_hs_hcchar0 = Otg_hs_hcchar0Reg<BaseAddress + 0x0100>;\n\n\
    private:\n  template<unsigned int address>\n  class Otg_hs_hcchar1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz = FieldModel<uint32_t,\
    \ address, 0, 11>;\n    using epnum = FieldModel<uint32_t, address, 11, 4>;\n\
    \    using epdir = FieldModel<uint32_t, address, 15, 1>;\n    using lsdev = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using eptyp = FieldModel<uint32_t, address, 18, 2>;\n\
    \    using mc = FieldModel<uint32_t, address, 20, 2>;\n    using dad = FieldModel<uint32_t,\
    \ address, 22, 7>;\n    using oddfrm = FieldModel<uint32_t, address, 29, 1>;\n\
    \    using chdis = FieldModel<uint32_t, address, 30, 1>;\n    using chena = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 11> mpsiz;\n      BitFieldModel<uint32_t, 11,\
    \ 4> epnum;\n      BitFieldModel<uint32_t, 15, 1> epdir;\n      BitFieldModel<uint32_t,\
    \ 17, 1> lsdev;\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      BitFieldModel<uint32_t,\
    \ 20, 2> mc;\n      BitFieldModel<uint32_t, 22, 7> dad;\n      BitFieldModel<uint32_t,\
    \ 29, 1> oddfrm;\n      BitFieldModel<uint32_t, 30, 1> chdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> chena;\n    };\n  };\n\npublic:\n  using otg_hs_hcchar1 = Otg_hs_hcchar1Reg<BaseAddress\
    \ + 0x0120>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcchar2Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    using epnum = FieldModel<uint32_t,\
    \ address, 11, 4>;\n    using epdir = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using lsdev = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using mc = FieldModel<uint32_t, address, 20, 2>;\n   \
    \ using dad = FieldModel<uint32_t, address, 22, 7>;\n    using oddfrm = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using chdis = FieldModel<uint32_t, address, 30, 1>;\n\
    \    using chena = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n\
    \      BitFieldModel<uint32_t, 11, 4> epnum;\n      BitFieldModel<uint32_t, 15,\
    \ 1> epdir;\n      BitFieldModel<uint32_t, 17, 1> lsdev;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 20, 2> mc;\n      BitFieldModel<uint32_t,\
    \ 22, 7> dad;\n      BitFieldModel<uint32_t, 29, 1> oddfrm;\n      BitFieldModel<uint32_t,\
    \ 30, 1> chdis;\n      BitFieldModel<uint32_t, 31, 1> chena;\n    };\n  };\n\n\
    public:\n  using otg_hs_hcchar2 = Otg_hs_hcchar2Reg<BaseAddress + 0x0140>;\n\n\
    private:\n  template<unsigned int address>\n  class Otg_hs_hcchar3Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz = FieldModel<uint32_t,\
    \ address, 0, 11>;\n    using epnum = FieldModel<uint32_t, address, 11, 4>;\n\
    \    using epdir = FieldModel<uint32_t, address, 15, 1>;\n    using lsdev = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using eptyp = FieldModel<uint32_t, address, 18, 2>;\n\
    \    using mc = FieldModel<uint32_t, address, 20, 2>;\n    using dad = FieldModel<uint32_t,\
    \ address, 22, 7>;\n    using oddfrm = FieldModel<uint32_t, address, 29, 1>;\n\
    \    using chdis = FieldModel<uint32_t, address, 30, 1>;\n    using chena = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 11> mpsiz;\n      BitFieldModel<uint32_t, 11,\
    \ 4> epnum;\n      BitFieldModel<uint32_t, 15, 1> epdir;\n      BitFieldModel<uint32_t,\
    \ 17, 1> lsdev;\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      BitFieldModel<uint32_t,\
    \ 20, 2> mc;\n      BitFieldModel<uint32_t, 22, 7> dad;\n      BitFieldModel<uint32_t,\
    \ 29, 1> oddfrm;\n      BitFieldModel<uint32_t, 30, 1> chdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> chena;\n    };\n  };\n\npublic:\n  using otg_hs_hcchar3 = Otg_hs_hcchar3Reg<BaseAddress\
    \ + 0x0160>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcchar4Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    using epnum = FieldModel<uint32_t,\
    \ address, 11, 4>;\n    using epdir = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using lsdev = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using mc = FieldModel<uint32_t, address, 20, 2>;\n   \
    \ using dad = FieldModel<uint32_t, address, 22, 7>;\n    using oddfrm = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using chdis = FieldModel<uint32_t, address, 30, 1>;\n\
    \    using chena = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n\
    \      BitFieldModel<uint32_t, 11, 4> epnum;\n      BitFieldModel<uint32_t, 15,\
    \ 1> epdir;\n      BitFieldModel<uint32_t, 17, 1> lsdev;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 20, 2> mc;\n      BitFieldModel<uint32_t,\
    \ 22, 7> dad;\n      BitFieldModel<uint32_t, 29, 1> oddfrm;\n      BitFieldModel<uint32_t,\
    \ 30, 1> chdis;\n      BitFieldModel<uint32_t, 31, 1> chena;\n    };\n  };\n\n\
    public:\n  using otg_hs_hcchar4 = Otg_hs_hcchar4Reg<BaseAddress + 0x0180>;\n\n\
    private:\n  template<unsigned int address>\n  class Otg_hs_hcchar5Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz = FieldModel<uint32_t,\
    \ address, 0, 11>;\n    using epnum = FieldModel<uint32_t, address, 11, 4>;\n\
    \    using epdir = FieldModel<uint32_t, address, 15, 1>;\n    using lsdev = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using eptyp = FieldModel<uint32_t, address, 18, 2>;\n\
    \    using mc = FieldModel<uint32_t, address, 20, 2>;\n    using dad = FieldModel<uint32_t,\
    \ address, 22, 7>;\n    using oddfrm = FieldModel<uint32_t, address, 29, 1>;\n\
    \    using chdis = FieldModel<uint32_t, address, 30, 1>;\n    using chena = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 11> mpsiz;\n      BitFieldModel<uint32_t, 11,\
    \ 4> epnum;\n      BitFieldModel<uint32_t, 15, 1> epdir;\n      BitFieldModel<uint32_t,\
    \ 17, 1> lsdev;\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      BitFieldModel<uint32_t,\
    \ 20, 2> mc;\n      BitFieldModel<uint32_t, 22, 7> dad;\n      BitFieldModel<uint32_t,\
    \ 29, 1> oddfrm;\n      BitFieldModel<uint32_t, 30, 1> chdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> chena;\n    };\n  };\n\npublic:\n  using otg_hs_hcchar5 = Otg_hs_hcchar5Reg<BaseAddress\
    \ + 0x01A0>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcchar6Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    using epnum = FieldModel<uint32_t,\
    \ address, 11, 4>;\n    using epdir = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using lsdev = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using mc = FieldModel<uint32_t, address, 20, 2>;\n   \
    \ using dad = FieldModel<uint32_t, address, 22, 7>;\n    using oddfrm = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using chdis = FieldModel<uint32_t, address, 30, 1>;\n\
    \    using chena = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n\
    \      BitFieldModel<uint32_t, 11, 4> epnum;\n      BitFieldModel<uint32_t, 15,\
    \ 1> epdir;\n      BitFieldModel<uint32_t, 17, 1> lsdev;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 20, 2> mc;\n      BitFieldModel<uint32_t,\
    \ 22, 7> dad;\n      BitFieldModel<uint32_t, 29, 1> oddfrm;\n      BitFieldModel<uint32_t,\
    \ 30, 1> chdis;\n      BitFieldModel<uint32_t, 31, 1> chena;\n    };\n  };\n\n\
    public:\n  using otg_hs_hcchar6 = Otg_hs_hcchar6Reg<BaseAddress + 0x01C0>;\n\n\
    private:\n  template<unsigned int address>\n  class Otg_hs_hcchar7Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz = FieldModel<uint32_t,\
    \ address, 0, 11>;\n    using epnum = FieldModel<uint32_t, address, 11, 4>;\n\
    \    using epdir = FieldModel<uint32_t, address, 15, 1>;\n    using lsdev = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using eptyp = FieldModel<uint32_t, address, 18, 2>;\n\
    \    using mc = FieldModel<uint32_t, address, 20, 2>;\n    using dad = FieldModel<uint32_t,\
    \ address, 22, 7>;\n    using oddfrm = FieldModel<uint32_t, address, 29, 1>;\n\
    \    using chdis = FieldModel<uint32_t, address, 30, 1>;\n    using chena = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 11> mpsiz;\n      BitFieldModel<uint32_t, 11,\
    \ 4> epnum;\n      BitFieldModel<uint32_t, 15, 1> epdir;\n      BitFieldModel<uint32_t,\
    \ 17, 1> lsdev;\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      BitFieldModel<uint32_t,\
    \ 20, 2> mc;\n      BitFieldModel<uint32_t, 22, 7> dad;\n      BitFieldModel<uint32_t,\
    \ 29, 1> oddfrm;\n      BitFieldModel<uint32_t, 30, 1> chdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> chena;\n    };\n  };\n\npublic:\n  using otg_hs_hcchar7 = Otg_hs_hcchar7Reg<BaseAddress\
    \ + 0x01E0>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcchar8Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    using epnum = FieldModel<uint32_t,\
    \ address, 11, 4>;\n    using epdir = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using lsdev = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using mc = FieldModel<uint32_t, address, 20, 2>;\n   \
    \ using dad = FieldModel<uint32_t, address, 22, 7>;\n    using oddfrm = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using chdis = FieldModel<uint32_t, address, 30, 1>;\n\
    \    using chena = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n\
    \      BitFieldModel<uint32_t, 11, 4> epnum;\n      BitFieldModel<uint32_t, 15,\
    \ 1> epdir;\n      BitFieldModel<uint32_t, 17, 1> lsdev;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 20, 2> mc;\n      BitFieldModel<uint32_t,\
    \ 22, 7> dad;\n      BitFieldModel<uint32_t, 29, 1> oddfrm;\n      BitFieldModel<uint32_t,\
    \ 30, 1> chdis;\n      BitFieldModel<uint32_t, 31, 1> chena;\n    };\n  };\n\n\
    public:\n  using otg_hs_hcchar8 = Otg_hs_hcchar8Reg<BaseAddress + 0x0200>;\n\n\
    private:\n  template<unsigned int address>\n  class Otg_hs_hcchar9Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz = FieldModel<uint32_t,\
    \ address, 0, 11>;\n    using epnum = FieldModel<uint32_t, address, 11, 4>;\n\
    \    using epdir = FieldModel<uint32_t, address, 15, 1>;\n    using lsdev = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using eptyp = FieldModel<uint32_t, address, 18, 2>;\n\
    \    using mc = FieldModel<uint32_t, address, 20, 2>;\n    using dad = FieldModel<uint32_t,\
    \ address, 22, 7>;\n    using oddfrm = FieldModel<uint32_t, address, 29, 1>;\n\
    \    using chdis = FieldModel<uint32_t, address, 30, 1>;\n    using chena = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 11> mpsiz;\n      BitFieldModel<uint32_t, 11,\
    \ 4> epnum;\n      BitFieldModel<uint32_t, 15, 1> epdir;\n      BitFieldModel<uint32_t,\
    \ 17, 1> lsdev;\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      BitFieldModel<uint32_t,\
    \ 20, 2> mc;\n      BitFieldModel<uint32_t, 22, 7> dad;\n      BitFieldModel<uint32_t,\
    \ 29, 1> oddfrm;\n      BitFieldModel<uint32_t, 30, 1> chdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> chena;\n    };\n  };\n\npublic:\n  using otg_hs_hcchar9 = Otg_hs_hcchar9Reg<BaseAddress\
    \ + 0x0220>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcchar10Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    using epnum = FieldModel<uint32_t,\
    \ address, 11, 4>;\n    using epdir = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using lsdev = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using mc = FieldModel<uint32_t, address, 20, 2>;\n   \
    \ using dad = FieldModel<uint32_t, address, 22, 7>;\n    using oddfrm = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using chdis = FieldModel<uint32_t, address, 30, 1>;\n\
    \    using chena = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n\
    \      BitFieldModel<uint32_t, 11, 4> epnum;\n      BitFieldModel<uint32_t, 15,\
    \ 1> epdir;\n      BitFieldModel<uint32_t, 17, 1> lsdev;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 20, 2> mc;\n      BitFieldModel<uint32_t,\
    \ 22, 7> dad;\n      BitFieldModel<uint32_t, 29, 1> oddfrm;\n      BitFieldModel<uint32_t,\
    \ 30, 1> chdis;\n      BitFieldModel<uint32_t, 31, 1> chena;\n    };\n  };\n\n\
    public:\n  using otg_hs_hcchar10 = Otg_hs_hcchar10Reg<BaseAddress + 0x0240>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcchar11Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz = FieldModel<uint32_t,\
    \ address, 0, 11>;\n    using epnum = FieldModel<uint32_t, address, 11, 4>;\n\
    \    using epdir = FieldModel<uint32_t, address, 15, 1>;\n    using lsdev = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using eptyp = FieldModel<uint32_t, address, 18, 2>;\n\
    \    using mc = FieldModel<uint32_t, address, 20, 2>;\n    using dad = FieldModel<uint32_t,\
    \ address, 22, 7>;\n    using oddfrm = FieldModel<uint32_t, address, 29, 1>;\n\
    \    using chdis = FieldModel<uint32_t, address, 30, 1>;\n    using chena = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 11> mpsiz;\n      BitFieldModel<uint32_t, 11,\
    \ 4> epnum;\n      BitFieldModel<uint32_t, 15, 1> epdir;\n      BitFieldModel<uint32_t,\
    \ 17, 1> lsdev;\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      BitFieldModel<uint32_t,\
    \ 20, 2> mc;\n      BitFieldModel<uint32_t, 22, 7> dad;\n      BitFieldModel<uint32_t,\
    \ 29, 1> oddfrm;\n      BitFieldModel<uint32_t, 30, 1> chdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> chena;\n    };\n  };\n\npublic:\n  using otg_hs_hcchar11 = Otg_hs_hcchar11Reg<BaseAddress\
    \ + 0x0260>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcsplt0Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using prtaddr\
    \ = FieldModel<uint32_t, address, 0, 7>;\n    using hubaddr = FieldModel<uint32_t,\
    \ address, 7, 7>;\n    using xactpos = FieldModel<uint32_t, address, 14, 2>;\n\
    \    using complsplt = FieldModel<uint32_t, address, 16, 1>;\n    using spliten\
    \ = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 7> prtaddr;\n      BitFieldModel<uint32_t,\
    \ 7, 7> hubaddr;\n      BitFieldModel<uint32_t, 14, 2> xactpos;\n      BitFieldModel<uint32_t,\
    \ 16, 1> complsplt;\n      BitFieldModel<uint32_t, 31, 1> spliten;\n    };\n \
    \ };\n\npublic:\n  using otg_hs_hcsplt0 = Otg_hs_hcsplt0Reg<BaseAddress + 0x0104>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcsplt1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using prtaddr = FieldModel<uint32_t,\
    \ address, 0, 7>;\n    using hubaddr = FieldModel<uint32_t, address, 7, 7>;\n\
    \    using xactpos = FieldModel<uint32_t, address, 14, 2>;\n    using complsplt\
    \ = FieldModel<uint32_t, address, 16, 1>;\n    using spliten = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 7> prtaddr;\n      BitFieldModel<uint32_t, 7,\
    \ 7> hubaddr;\n      BitFieldModel<uint32_t, 14, 2> xactpos;\n      BitFieldModel<uint32_t,\
    \ 16, 1> complsplt;\n      BitFieldModel<uint32_t, 31, 1> spliten;\n    };\n \
    \ };\n\npublic:\n  using otg_hs_hcsplt1 = Otg_hs_hcsplt1Reg<BaseAddress + 0x0124>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcsplt2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using prtaddr = FieldModel<uint32_t,\
    \ address, 0, 7>;\n    using hubaddr = FieldModel<uint32_t, address, 7, 7>;\n\
    \    using xactpos = FieldModel<uint32_t, address, 14, 2>;\n    using complsplt\
    \ = FieldModel<uint32_t, address, 16, 1>;\n    using spliten = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 7> prtaddr;\n      BitFieldModel<uint32_t, 7,\
    \ 7> hubaddr;\n      BitFieldModel<uint32_t, 14, 2> xactpos;\n      BitFieldModel<uint32_t,\
    \ 16, 1> complsplt;\n      BitFieldModel<uint32_t, 31, 1> spliten;\n    };\n \
    \ };\n\npublic:\n  using otg_hs_hcsplt2 = Otg_hs_hcsplt2Reg<BaseAddress + 0x0144>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcsplt3Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using prtaddr = FieldModel<uint32_t,\
    \ address, 0, 7>;\n    using hubaddr = FieldModel<uint32_t, address, 7, 7>;\n\
    \    using xactpos = FieldModel<uint32_t, address, 14, 2>;\n    using complsplt\
    \ = FieldModel<uint32_t, address, 16, 1>;\n    using spliten = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 7> prtaddr;\n      BitFieldModel<uint32_t, 7,\
    \ 7> hubaddr;\n      BitFieldModel<uint32_t, 14, 2> xactpos;\n      BitFieldModel<uint32_t,\
    \ 16, 1> complsplt;\n      BitFieldModel<uint32_t, 31, 1> spliten;\n    };\n \
    \ };\n\npublic:\n  using otg_hs_hcsplt3 = Otg_hs_hcsplt3Reg<BaseAddress + 0x0164>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcsplt4Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using prtaddr = FieldModel<uint32_t,\
    \ address, 0, 7>;\n    using hubaddr = FieldModel<uint32_t, address, 7, 7>;\n\
    \    using xactpos = FieldModel<uint32_t, address, 14, 2>;\n    using complsplt\
    \ = FieldModel<uint32_t, address, 16, 1>;\n    using spliten = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 7> prtaddr;\n      BitFieldModel<uint32_t, 7,\
    \ 7> hubaddr;\n      BitFieldModel<uint32_t, 14, 2> xactpos;\n      BitFieldModel<uint32_t,\
    \ 16, 1> complsplt;\n      BitFieldModel<uint32_t, 31, 1> spliten;\n    };\n \
    \ };\n\npublic:\n  using otg_hs_hcsplt4 = Otg_hs_hcsplt4Reg<BaseAddress + 0x0184>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcsplt5Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using prtaddr = FieldModel<uint32_t,\
    \ address, 0, 7>;\n    using hubaddr = FieldModel<uint32_t, address, 7, 7>;\n\
    \    using xactpos = FieldModel<uint32_t, address, 14, 2>;\n    using complsplt\
    \ = FieldModel<uint32_t, address, 16, 1>;\n    using spliten = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 7> prtaddr;\n      BitFieldModel<uint32_t, 7,\
    \ 7> hubaddr;\n      BitFieldModel<uint32_t, 14, 2> xactpos;\n      BitFieldModel<uint32_t,\
    \ 16, 1> complsplt;\n      BitFieldModel<uint32_t, 31, 1> spliten;\n    };\n \
    \ };\n\npublic:\n  using otg_hs_hcsplt5 = Otg_hs_hcsplt5Reg<BaseAddress + 0x01A4>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcsplt6Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using prtaddr = FieldModel<uint32_t,\
    \ address, 0, 7>;\n    using hubaddr = FieldModel<uint32_t, address, 7, 7>;\n\
    \    using xactpos = FieldModel<uint32_t, address, 14, 2>;\n    using complsplt\
    \ = FieldModel<uint32_t, address, 16, 1>;\n    using spliten = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 7> prtaddr;\n      BitFieldModel<uint32_t, 7,\
    \ 7> hubaddr;\n      BitFieldModel<uint32_t, 14, 2> xactpos;\n      BitFieldModel<uint32_t,\
    \ 16, 1> complsplt;\n      BitFieldModel<uint32_t, 31, 1> spliten;\n    };\n \
    \ };\n\npublic:\n  using otg_hs_hcsplt6 = Otg_hs_hcsplt6Reg<BaseAddress + 0x01C4>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcsplt7Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using prtaddr = FieldModel<uint32_t,\
    \ address, 0, 7>;\n    using hubaddr = FieldModel<uint32_t, address, 7, 7>;\n\
    \    using xactpos = FieldModel<uint32_t, address, 14, 2>;\n    using complsplt\
    \ = FieldModel<uint32_t, address, 16, 1>;\n    using spliten = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 7> prtaddr;\n      BitFieldModel<uint32_t, 7,\
    \ 7> hubaddr;\n      BitFieldModel<uint32_t, 14, 2> xactpos;\n      BitFieldModel<uint32_t,\
    \ 16, 1> complsplt;\n      BitFieldModel<uint32_t, 31, 1> spliten;\n    };\n \
    \ };\n\npublic:\n  using otg_hs_hcsplt7 = Otg_hs_hcsplt7Reg<BaseAddress + 0x01E4>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcsplt8Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using prtaddr = FieldModel<uint32_t,\
    \ address, 0, 7>;\n    using hubaddr = FieldModel<uint32_t, address, 7, 7>;\n\
    \    using xactpos = FieldModel<uint32_t, address, 14, 2>;\n    using complsplt\
    \ = FieldModel<uint32_t, address, 16, 1>;\n    using spliten = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 7> prtaddr;\n      BitFieldModel<uint32_t, 7,\
    \ 7> hubaddr;\n      BitFieldModel<uint32_t, 14, 2> xactpos;\n      BitFieldModel<uint32_t,\
    \ 16, 1> complsplt;\n      BitFieldModel<uint32_t, 31, 1> spliten;\n    };\n \
    \ };\n\npublic:\n  using otg_hs_hcsplt8 = Otg_hs_hcsplt8Reg<BaseAddress + 0x0204>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcsplt9Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using prtaddr = FieldModel<uint32_t,\
    \ address, 0, 7>;\n    using hubaddr = FieldModel<uint32_t, address, 7, 7>;\n\
    \    using xactpos = FieldModel<uint32_t, address, 14, 2>;\n    using complsplt\
    \ = FieldModel<uint32_t, address, 16, 1>;\n    using spliten = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 7> prtaddr;\n      BitFieldModel<uint32_t, 7,\
    \ 7> hubaddr;\n      BitFieldModel<uint32_t, 14, 2> xactpos;\n      BitFieldModel<uint32_t,\
    \ 16, 1> complsplt;\n      BitFieldModel<uint32_t, 31, 1> spliten;\n    };\n \
    \ };\n\npublic:\n  using otg_hs_hcsplt9 = Otg_hs_hcsplt9Reg<BaseAddress + 0x0224>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcsplt10Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using prtaddr = FieldModel<uint32_t,\
    \ address, 0, 7>;\n    using hubaddr = FieldModel<uint32_t, address, 7, 7>;\n\
    \    using xactpos = FieldModel<uint32_t, address, 14, 2>;\n    using complsplt\
    \ = FieldModel<uint32_t, address, 16, 1>;\n    using spliten = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 7> prtaddr;\n      BitFieldModel<uint32_t, 7,\
    \ 7> hubaddr;\n      BitFieldModel<uint32_t, 14, 2> xactpos;\n      BitFieldModel<uint32_t,\
    \ 16, 1> complsplt;\n      BitFieldModel<uint32_t, 31, 1> spliten;\n    };\n \
    \ };\n\npublic:\n  using otg_hs_hcsplt10 = Otg_hs_hcsplt10Reg<BaseAddress + 0x0244>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcsplt11Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using prtaddr = FieldModel<uint32_t,\
    \ address, 0, 7>;\n    using hubaddr = FieldModel<uint32_t, address, 7, 7>;\n\
    \    using xactpos = FieldModel<uint32_t, address, 14, 2>;\n    using complsplt\
    \ = FieldModel<uint32_t, address, 16, 1>;\n    using spliten = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 7> prtaddr;\n      BitFieldModel<uint32_t, 7,\
    \ 7> hubaddr;\n      BitFieldModel<uint32_t, 14, 2> xactpos;\n      BitFieldModel<uint32_t,\
    \ 16, 1> complsplt;\n      BitFieldModel<uint32_t, 31, 1> spliten;\n    };\n \
    \ };\n\npublic:\n  using otg_hs_hcsplt11 = Otg_hs_hcsplt11Reg<BaseAddress + 0x0264>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcint0Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using chh = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ ahberr = FieldModel<uint32_t, address, 2, 1>;\n    using stall = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using nak = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ ack = FieldModel<uint32_t, address, 5, 1>;\n    using nyet = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using txerr = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using bberr = FieldModel<uint32_t, address, 8, 1>;\n    using frmor = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dterr = FieldModel<uint32_t, address, 10, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1> chh;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ahberr;\n      BitFieldModel<uint32_t, 3, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nak;\n      BitFieldModel<uint32_t, 5, 1> ack;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nyet;\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberr;\n      BitFieldModel<uint32_t, 9, 1> frmor;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterr;\n    };\n  };\n\npublic:\n  using otg_hs_hcint0 = Otg_hs_hcint0Reg<BaseAddress\
    \ + 0x0108>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcint1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chh = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    using ahberr = FieldModel<uint32_t, address, 2, 1>;\n    using stall\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using nak = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ack = FieldModel<uint32_t, address, 5, 1>;\n    using\
    \ nyet = FieldModel<uint32_t, address, 6, 1>;\n    using txerr = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bberr = FieldModel<uint32_t, address, 8, 1>;\n  \
    \  using frmor = FieldModel<uint32_t, address, 9, 1>;\n    using dterr = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1>\
    \ chh;\n      BitFieldModel<uint32_t, 2, 1> ahberr;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stall;\n      BitFieldModel<uint32_t, 4, 1> nak;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerr;\n      BitFieldModel<uint32_t, 8, 1> bberr;\n      BitFieldModel<uint32_t,\
    \ 9, 1> frmor;\n      BitFieldModel<uint32_t, 10, 1> dterr;\n    };\n  };\n\n\
    public:\n  using otg_hs_hcint1 = Otg_hs_hcint1Reg<BaseAddress + 0x0128>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_hcint2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using chh = FieldModel<uint32_t, address, 1, 1>;\n    using ahberr\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    using stall = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using nak = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ ack = FieldModel<uint32_t, address, 5, 1>;\n    using nyet = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using txerr = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using bberr = FieldModel<uint32_t, address, 8, 1>;\n    using frmor = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dterr = FieldModel<uint32_t, address, 10, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1> chh;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ahberr;\n      BitFieldModel<uint32_t, 3, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nak;\n      BitFieldModel<uint32_t, 5, 1> ack;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nyet;\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberr;\n      BitFieldModel<uint32_t, 9, 1> frmor;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterr;\n    };\n  };\n\npublic:\n  using otg_hs_hcint2 = Otg_hs_hcint2Reg<BaseAddress\
    \ + 0x0148>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcint3Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chh = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    using ahberr = FieldModel<uint32_t, address, 2, 1>;\n    using stall\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using nak = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ack = FieldModel<uint32_t, address, 5, 1>;\n    using\
    \ nyet = FieldModel<uint32_t, address, 6, 1>;\n    using txerr = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bberr = FieldModel<uint32_t, address, 8, 1>;\n  \
    \  using frmor = FieldModel<uint32_t, address, 9, 1>;\n    using dterr = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1>\
    \ chh;\n      BitFieldModel<uint32_t, 2, 1> ahberr;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stall;\n      BitFieldModel<uint32_t, 4, 1> nak;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerr;\n      BitFieldModel<uint32_t, 8, 1> bberr;\n      BitFieldModel<uint32_t,\
    \ 9, 1> frmor;\n      BitFieldModel<uint32_t, 10, 1> dterr;\n    };\n  };\n\n\
    public:\n  using otg_hs_hcint3 = Otg_hs_hcint3Reg<BaseAddress + 0x0168>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_hcint4Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using chh = FieldModel<uint32_t, address, 1, 1>;\n    using ahberr\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    using stall = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using nak = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ ack = FieldModel<uint32_t, address, 5, 1>;\n    using nyet = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using txerr = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using bberr = FieldModel<uint32_t, address, 8, 1>;\n    using frmor = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dterr = FieldModel<uint32_t, address, 10, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1> chh;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ahberr;\n      BitFieldModel<uint32_t, 3, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nak;\n      BitFieldModel<uint32_t, 5, 1> ack;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nyet;\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberr;\n      BitFieldModel<uint32_t, 9, 1> frmor;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterr;\n    };\n  };\n\npublic:\n  using otg_hs_hcint4 = Otg_hs_hcint4Reg<BaseAddress\
    \ + 0x0188>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcint5Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chh = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    using ahberr = FieldModel<uint32_t, address, 2, 1>;\n    using stall\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using nak = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ack = FieldModel<uint32_t, address, 5, 1>;\n    using\
    \ nyet = FieldModel<uint32_t, address, 6, 1>;\n    using txerr = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bberr = FieldModel<uint32_t, address, 8, 1>;\n  \
    \  using frmor = FieldModel<uint32_t, address, 9, 1>;\n    using dterr = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1>\
    \ chh;\n      BitFieldModel<uint32_t, 2, 1> ahberr;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stall;\n      BitFieldModel<uint32_t, 4, 1> nak;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerr;\n      BitFieldModel<uint32_t, 8, 1> bberr;\n      BitFieldModel<uint32_t,\
    \ 9, 1> frmor;\n      BitFieldModel<uint32_t, 10, 1> dterr;\n    };\n  };\n\n\
    public:\n  using otg_hs_hcint5 = Otg_hs_hcint5Reg<BaseAddress + 0x01A8>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_hcint6Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using chh = FieldModel<uint32_t, address, 1, 1>;\n    using ahberr\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    using stall = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using nak = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ ack = FieldModel<uint32_t, address, 5, 1>;\n    using nyet = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using txerr = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using bberr = FieldModel<uint32_t, address, 8, 1>;\n    using frmor = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dterr = FieldModel<uint32_t, address, 10, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1> chh;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ahberr;\n      BitFieldModel<uint32_t, 3, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nak;\n      BitFieldModel<uint32_t, 5, 1> ack;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nyet;\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberr;\n      BitFieldModel<uint32_t, 9, 1> frmor;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterr;\n    };\n  };\n\npublic:\n  using otg_hs_hcint6 = Otg_hs_hcint6Reg<BaseAddress\
    \ + 0x01C8>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcint7Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chh = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    using ahberr = FieldModel<uint32_t, address, 2, 1>;\n    using stall\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using nak = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ack = FieldModel<uint32_t, address, 5, 1>;\n    using\
    \ nyet = FieldModel<uint32_t, address, 6, 1>;\n    using txerr = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bberr = FieldModel<uint32_t, address, 8, 1>;\n  \
    \  using frmor = FieldModel<uint32_t, address, 9, 1>;\n    using dterr = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1>\
    \ chh;\n      BitFieldModel<uint32_t, 2, 1> ahberr;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stall;\n      BitFieldModel<uint32_t, 4, 1> nak;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerr;\n      BitFieldModel<uint32_t, 8, 1> bberr;\n      BitFieldModel<uint32_t,\
    \ 9, 1> frmor;\n      BitFieldModel<uint32_t, 10, 1> dterr;\n    };\n  };\n\n\
    public:\n  using otg_hs_hcint7 = Otg_hs_hcint7Reg<BaseAddress + 0x01E8>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_hcint8Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using chh = FieldModel<uint32_t, address, 1, 1>;\n    using ahberr\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    using stall = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using nak = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ ack = FieldModel<uint32_t, address, 5, 1>;\n    using nyet = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using txerr = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using bberr = FieldModel<uint32_t, address, 8, 1>;\n    using frmor = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dterr = FieldModel<uint32_t, address, 10, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1> chh;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ahberr;\n      BitFieldModel<uint32_t, 3, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nak;\n      BitFieldModel<uint32_t, 5, 1> ack;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nyet;\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberr;\n      BitFieldModel<uint32_t, 9, 1> frmor;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterr;\n    };\n  };\n\npublic:\n  using otg_hs_hcint8 = Otg_hs_hcint8Reg<BaseAddress\
    \ + 0x0208>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcint9Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chh = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    using ahberr = FieldModel<uint32_t, address, 2, 1>;\n    using stall\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using nak = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ack = FieldModel<uint32_t, address, 5, 1>;\n    using\
    \ nyet = FieldModel<uint32_t, address, 6, 1>;\n    using txerr = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bberr = FieldModel<uint32_t, address, 8, 1>;\n  \
    \  using frmor = FieldModel<uint32_t, address, 9, 1>;\n    using dterr = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1>\
    \ chh;\n      BitFieldModel<uint32_t, 2, 1> ahberr;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stall;\n      BitFieldModel<uint32_t, 4, 1> nak;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerr;\n      BitFieldModel<uint32_t, 8, 1> bberr;\n      BitFieldModel<uint32_t,\
    \ 9, 1> frmor;\n      BitFieldModel<uint32_t, 10, 1> dterr;\n    };\n  };\n\n\
    public:\n  using otg_hs_hcint9 = Otg_hs_hcint9Reg<BaseAddress + 0x0228>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_hcint10Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using chh = FieldModel<uint32_t, address, 1, 1>;\n    using ahberr\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    using stall = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using nak = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ ack = FieldModel<uint32_t, address, 5, 1>;\n    using nyet = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using txerr = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  using bberr = FieldModel<uint32_t, address, 8, 1>;\n    using frmor = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dterr = FieldModel<uint32_t, address, 10, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1> chh;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ahberr;\n      BitFieldModel<uint32_t, 3, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nak;\n      BitFieldModel<uint32_t, 5, 1> ack;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nyet;\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberr;\n      BitFieldModel<uint32_t, 9, 1> frmor;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterr;\n    };\n  };\n\npublic:\n  using otg_hs_hcint10 = Otg_hs_hcint10Reg<BaseAddress\
    \ + 0x0248>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcint11Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chh = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    using ahberr = FieldModel<uint32_t, address, 2, 1>;\n    using stall\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using nak = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ack = FieldModel<uint32_t, address, 5, 1>;\n    using\
    \ nyet = FieldModel<uint32_t, address, 6, 1>;\n    using txerr = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bberr = FieldModel<uint32_t, address, 8, 1>;\n  \
    \  using frmor = FieldModel<uint32_t, address, 9, 1>;\n    using dterr = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1>\
    \ chh;\n      BitFieldModel<uint32_t, 2, 1> ahberr;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stall;\n      BitFieldModel<uint32_t, 4, 1> nak;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerr;\n      BitFieldModel<uint32_t, 8, 1> bberr;\n      BitFieldModel<uint32_t,\
    \ 9, 1> frmor;\n      BitFieldModel<uint32_t, 10, 1> dterr;\n    };\n  };\n\n\
    public:\n  using otg_hs_hcint11 = Otg_hs_hcint11Reg<BaseAddress + 0x0268>;\n\n\
    private:\n  template<unsigned int address>\n  class Otg_hs_hcintmsk0Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrcm = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using chhm = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using ahberr = FieldModel<uint32_t, address, 2, 1>;\n    using stallm = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using nakm = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ using ackm = FieldModel<uint32_t, address, 5, 1>;\n    using nyet = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using txerrm = FieldModel<uint32_t, address, 7, 1>;\n \
    \   using bberrm = FieldModel<uint32_t, address, 8, 1>;\n    using frmorm = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dterrm = FieldModel<uint32_t, address, 10, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrcm;\n      BitFieldModel<uint32_t, 1, 1> chhm;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ahberr;\n      BitFieldModel<uint32_t, 3, 1> stallm;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nakm;\n      BitFieldModel<uint32_t, 5, 1> ackm;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nyet;\n      BitFieldModel<uint32_t, 7, 1> txerrm;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberrm;\n      BitFieldModel<uint32_t, 9, 1> frmorm;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterrm;\n    };\n  };\n\npublic:\n  using otg_hs_hcintmsk0 = Otg_hs_hcintmsk0Reg<BaseAddress\
    \ + 0x010C>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcintmsk1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrcm =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chhm = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ahberr = FieldModel<uint32_t, address, 2, 1>;\n \
    \   using stallm = FieldModel<uint32_t, address, 3, 1>;\n    using nakm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ackm = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using nyet = FieldModel<uint32_t, address, 6, 1>;\n    using txerrm = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bberrm = FieldModel<uint32_t, address, 8, 1>;\n \
    \   using frmorm = FieldModel<uint32_t, address, 9, 1>;\n    using dterrm = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      BitFieldModel<uint32_t, 1,\
    \ 1> chhm;\n      BitFieldModel<uint32_t, 2, 1> ahberr;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stallm;\n      BitFieldModel<uint32_t, 4, 1> nakm;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ackm;\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerrm;\n      BitFieldModel<uint32_t, 8, 1> bberrm;\n      BitFieldModel<uint32_t,\
    \ 9, 1> frmorm;\n      BitFieldModel<uint32_t, 10, 1> dterrm;\n    };\n  };\n\n\
    public:\n  using otg_hs_hcintmsk1 = Otg_hs_hcintmsk1Reg<BaseAddress + 0x012C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcintmsk2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrcm = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using chhm = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using ahberr = FieldModel<uint32_t, address, 2, 1>;\n    using stallm = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using nakm = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ using ackm = FieldModel<uint32_t, address, 5, 1>;\n    using nyet = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using txerrm = FieldModel<uint32_t, address, 7, 1>;\n \
    \   using bberrm = FieldModel<uint32_t, address, 8, 1>;\n    using frmorm = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dterrm = FieldModel<uint32_t, address, 10, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrcm;\n      BitFieldModel<uint32_t, 1, 1> chhm;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ahberr;\n      BitFieldModel<uint32_t, 3, 1> stallm;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nakm;\n      BitFieldModel<uint32_t, 5, 1> ackm;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nyet;\n      BitFieldModel<uint32_t, 7, 1> txerrm;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberrm;\n      BitFieldModel<uint32_t, 9, 1> frmorm;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterrm;\n    };\n  };\n\npublic:\n  using otg_hs_hcintmsk2 = Otg_hs_hcintmsk2Reg<BaseAddress\
    \ + 0x014C>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcintmsk3Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrcm =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chhm = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ahberr = FieldModel<uint32_t, address, 2, 1>;\n \
    \   using stallm = FieldModel<uint32_t, address, 3, 1>;\n    using nakm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ackm = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using nyet = FieldModel<uint32_t, address, 6, 1>;\n    using txerrm = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bberrm = FieldModel<uint32_t, address, 8, 1>;\n \
    \   using frmorm = FieldModel<uint32_t, address, 9, 1>;\n    using dterrm = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      BitFieldModel<uint32_t, 1,\
    \ 1> chhm;\n      BitFieldModel<uint32_t, 2, 1> ahberr;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stallm;\n      BitFieldModel<uint32_t, 4, 1> nakm;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ackm;\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerrm;\n      BitFieldModel<uint32_t, 8, 1> bberrm;\n      BitFieldModel<uint32_t,\
    \ 9, 1> frmorm;\n      BitFieldModel<uint32_t, 10, 1> dterrm;\n    };\n  };\n\n\
    public:\n  using otg_hs_hcintmsk3 = Otg_hs_hcintmsk3Reg<BaseAddress + 0x016C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcintmsk4Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrcm = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using chhm = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using ahberr = FieldModel<uint32_t, address, 2, 1>;\n    using stallm = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using nakm = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ using ackm = FieldModel<uint32_t, address, 5, 1>;\n    using nyet = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using txerrm = FieldModel<uint32_t, address, 7, 1>;\n \
    \   using bberrm = FieldModel<uint32_t, address, 8, 1>;\n    using frmorm = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dterrm = FieldModel<uint32_t, address, 10, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrcm;\n      BitFieldModel<uint32_t, 1, 1> chhm;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ahberr;\n      BitFieldModel<uint32_t, 3, 1> stallm;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nakm;\n      BitFieldModel<uint32_t, 5, 1> ackm;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nyet;\n      BitFieldModel<uint32_t, 7, 1> txerrm;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberrm;\n      BitFieldModel<uint32_t, 9, 1> frmorm;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterrm;\n    };\n  };\n\npublic:\n  using otg_hs_hcintmsk4 = Otg_hs_hcintmsk4Reg<BaseAddress\
    \ + 0x018C>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcintmsk5Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrcm =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chhm = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ahberr = FieldModel<uint32_t, address, 2, 1>;\n \
    \   using stallm = FieldModel<uint32_t, address, 3, 1>;\n    using nakm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ackm = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using nyet = FieldModel<uint32_t, address, 6, 1>;\n    using txerrm = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bberrm = FieldModel<uint32_t, address, 8, 1>;\n \
    \   using frmorm = FieldModel<uint32_t, address, 9, 1>;\n    using dterrm = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      BitFieldModel<uint32_t, 1,\
    \ 1> chhm;\n      BitFieldModel<uint32_t, 2, 1> ahberr;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stallm;\n      BitFieldModel<uint32_t, 4, 1> nakm;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ackm;\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerrm;\n      BitFieldModel<uint32_t, 8, 1> bberrm;\n      BitFieldModel<uint32_t,\
    \ 9, 1> frmorm;\n      BitFieldModel<uint32_t, 10, 1> dterrm;\n    };\n  };\n\n\
    public:\n  using otg_hs_hcintmsk5 = Otg_hs_hcintmsk5Reg<BaseAddress + 0x01AC>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcintmsk6Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrcm = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using chhm = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using ahberr = FieldModel<uint32_t, address, 2, 1>;\n    using stallm = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using nakm = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ using ackm = FieldModel<uint32_t, address, 5, 1>;\n    using nyet = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using txerrm = FieldModel<uint32_t, address, 7, 1>;\n \
    \   using bberrm = FieldModel<uint32_t, address, 8, 1>;\n    using frmorm = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dterrm = FieldModel<uint32_t, address, 10, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrcm;\n      BitFieldModel<uint32_t, 1, 1> chhm;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ahberr;\n      BitFieldModel<uint32_t, 3, 1> stallm;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nakm;\n      BitFieldModel<uint32_t, 5, 1> ackm;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nyet;\n      BitFieldModel<uint32_t, 7, 1> txerrm;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberrm;\n      BitFieldModel<uint32_t, 9, 1> frmorm;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterrm;\n    };\n  };\n\npublic:\n  using otg_hs_hcintmsk6 = Otg_hs_hcintmsk6Reg<BaseAddress\
    \ + 0x01CC>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcintmsk7Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrcm =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chhm = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ahberr = FieldModel<uint32_t, address, 2, 1>;\n \
    \   using stallm = FieldModel<uint32_t, address, 3, 1>;\n    using nakm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ackm = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using nyet = FieldModel<uint32_t, address, 6, 1>;\n    using txerrm = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bberrm = FieldModel<uint32_t, address, 8, 1>;\n \
    \   using frmorm = FieldModel<uint32_t, address, 9, 1>;\n    using dterrm = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      BitFieldModel<uint32_t, 1,\
    \ 1> chhm;\n      BitFieldModel<uint32_t, 2, 1> ahberr;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stallm;\n      BitFieldModel<uint32_t, 4, 1> nakm;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ackm;\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerrm;\n      BitFieldModel<uint32_t, 8, 1> bberrm;\n      BitFieldModel<uint32_t,\
    \ 9, 1> frmorm;\n      BitFieldModel<uint32_t, 10, 1> dterrm;\n    };\n  };\n\n\
    public:\n  using otg_hs_hcintmsk7 = Otg_hs_hcintmsk7Reg<BaseAddress + 0x01EC>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcintmsk8Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrcm = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using chhm = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using ahberr = FieldModel<uint32_t, address, 2, 1>;\n    using stallm = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using nakm = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ using ackm = FieldModel<uint32_t, address, 5, 1>;\n    using nyet = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using txerrm = FieldModel<uint32_t, address, 7, 1>;\n \
    \   using bberrm = FieldModel<uint32_t, address, 8, 1>;\n    using frmorm = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dterrm = FieldModel<uint32_t, address, 10, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrcm;\n      BitFieldModel<uint32_t, 1, 1> chhm;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ahberr;\n      BitFieldModel<uint32_t, 3, 1> stallm;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nakm;\n      BitFieldModel<uint32_t, 5, 1> ackm;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nyet;\n      BitFieldModel<uint32_t, 7, 1> txerrm;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberrm;\n      BitFieldModel<uint32_t, 9, 1> frmorm;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterrm;\n    };\n  };\n\npublic:\n  using otg_hs_hcintmsk8 = Otg_hs_hcintmsk8Reg<BaseAddress\
    \ + 0x020C>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcintmsk9Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrcm =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chhm = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ahberr = FieldModel<uint32_t, address, 2, 1>;\n \
    \   using stallm = FieldModel<uint32_t, address, 3, 1>;\n    using nakm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ackm = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using nyet = FieldModel<uint32_t, address, 6, 1>;\n    using txerrm = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bberrm = FieldModel<uint32_t, address, 8, 1>;\n \
    \   using frmorm = FieldModel<uint32_t, address, 9, 1>;\n    using dterrm = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      BitFieldModel<uint32_t, 1,\
    \ 1> chhm;\n      BitFieldModel<uint32_t, 2, 1> ahberr;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stallm;\n      BitFieldModel<uint32_t, 4, 1> nakm;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ackm;\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerrm;\n      BitFieldModel<uint32_t, 8, 1> bberrm;\n      BitFieldModel<uint32_t,\
    \ 9, 1> frmorm;\n      BitFieldModel<uint32_t, 10, 1> dterrm;\n    };\n  };\n\n\
    public:\n  using otg_hs_hcintmsk9 = Otg_hs_hcintmsk9Reg<BaseAddress + 0x022C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcintmsk10Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrcm = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using chhm = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using ahberr = FieldModel<uint32_t, address, 2, 1>;\n    using stallm = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using nakm = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ using ackm = FieldModel<uint32_t, address, 5, 1>;\n    using nyet = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using txerrm = FieldModel<uint32_t, address, 7, 1>;\n \
    \   using bberrm = FieldModel<uint32_t, address, 8, 1>;\n    using frmorm = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using dterrm = FieldModel<uint32_t, address, 10, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrcm;\n      BitFieldModel<uint32_t, 1, 1> chhm;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ahberr;\n      BitFieldModel<uint32_t, 3, 1> stallm;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nakm;\n      BitFieldModel<uint32_t, 5, 1> ackm;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nyet;\n      BitFieldModel<uint32_t, 7, 1> txerrm;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberrm;\n      BitFieldModel<uint32_t, 9, 1> frmorm;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterrm;\n    };\n  };\n\npublic:\n  using otg_hs_hcintmsk10 = Otg_hs_hcintmsk10Reg<BaseAddress\
    \ + 0x024C>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcintmsk11Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrcm =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using chhm = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ahberr = FieldModel<uint32_t, address, 2, 1>;\n \
    \   using stallm = FieldModel<uint32_t, address, 3, 1>;\n    using nakm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using ackm = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using nyet = FieldModel<uint32_t, address, 6, 1>;\n    using txerrm = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using bberrm = FieldModel<uint32_t, address, 8, 1>;\n \
    \   using frmorm = FieldModel<uint32_t, address, 9, 1>;\n    using dterrm = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      BitFieldModel<uint32_t, 1,\
    \ 1> chhm;\n      BitFieldModel<uint32_t, 2, 1> ahberr;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stallm;\n      BitFieldModel<uint32_t, 4, 1> nakm;\n      BitFieldModel<uint32_t,\
    \ 5, 1> ackm;\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerrm;\n      BitFieldModel<uint32_t, 8, 1> bberrm;\n      BitFieldModel<uint32_t,\
    \ 9, 1> frmorm;\n      BitFieldModel<uint32_t, 10, 1> dterrm;\n    };\n  };\n\n\
    public:\n  using otg_hs_hcintmsk11 = Otg_hs_hcintmsk11Reg<BaseAddress + 0x026C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hctsiz0Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz = FieldModel<uint32_t,\
    \ address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t, address, 19, 10>;\n\
    \    using dpid = FieldModel<uint32_t, address, 29, 2>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 19> xfrsiz;\n\
    \      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  using otg_hs_hctsiz0 = Otg_hs_hctsiz0Reg<BaseAddress\
    \ + 0x0110>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hctsiz1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using dpid = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  using otg_hs_hctsiz1 = Otg_hs_hctsiz1Reg<BaseAddress\
    \ + 0x0130>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hctsiz2Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using dpid = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  using otg_hs_hctsiz2 = Otg_hs_hctsiz2Reg<BaseAddress\
    \ + 0x0150>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hctsiz3Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using dpid = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  using otg_hs_hctsiz3 = Otg_hs_hctsiz3Reg<BaseAddress\
    \ + 0x0170>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hctsiz4Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using dpid = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  using otg_hs_hctsiz4 = Otg_hs_hctsiz4Reg<BaseAddress\
    \ + 0x0190>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hctsiz5Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using dpid = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  using otg_hs_hctsiz5 = Otg_hs_hctsiz5Reg<BaseAddress\
    \ + 0x01B0>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hctsiz6Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using dpid = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  using otg_hs_hctsiz6 = Otg_hs_hctsiz6Reg<BaseAddress\
    \ + 0x01D0>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hctsiz7Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using dpid = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  using otg_hs_hctsiz7 = Otg_hs_hctsiz7Reg<BaseAddress\
    \ + 0x01F0>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hctsiz8Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using dpid = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  using otg_hs_hctsiz8 = Otg_hs_hctsiz8Reg<BaseAddress\
    \ + 0x0210>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hctsiz9Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using dpid = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  using otg_hs_hctsiz9 = Otg_hs_hctsiz9Reg<BaseAddress\
    \ + 0x0230>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hctsiz10Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using dpid = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  using otg_hs_hctsiz10 = Otg_hs_hctsiz10Reg<BaseAddress\
    \ + 0x0250>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hctsiz11Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using dpid = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  using otg_hs_hctsiz11 = Otg_hs_hctsiz11Reg<BaseAddress\
    \ + 0x0270>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcdma0Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using dmaaddr\
    \ = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> dmaaddr;\n    };\n\
    \  };\n\npublic:\n  using otg_hs_hcdma0 = Otg_hs_hcdma0Reg<BaseAddress + 0x0114>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcdma1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using dmaaddr = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> dmaaddr;\n    };\n  };\n\npublic:\n  using\
    \ otg_hs_hcdma1 = Otg_hs_hcdma1Reg<BaseAddress + 0x0134>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Otg_hs_hcdma2Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using dmaaddr = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> dmaaddr;\n    };\n  };\n\npublic:\n  using otg_hs_hcdma2 = Otg_hs_hcdma2Reg<BaseAddress\
    \ + 0x0154>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcdma3Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using dmaaddr\
    \ = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> dmaaddr;\n    };\n\
    \  };\n\npublic:\n  using otg_hs_hcdma3 = Otg_hs_hcdma3Reg<BaseAddress + 0x0174>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcdma4Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using dmaaddr = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> dmaaddr;\n    };\n  };\n\npublic:\n  using\
    \ otg_hs_hcdma4 = Otg_hs_hcdma4Reg<BaseAddress + 0x0194>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Otg_hs_hcdma5Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using dmaaddr = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> dmaaddr;\n    };\n  };\n\npublic:\n  using otg_hs_hcdma5 = Otg_hs_hcdma5Reg<BaseAddress\
    \ + 0x01B4>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcdma6Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using dmaaddr\
    \ = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> dmaaddr;\n    };\n\
    \  };\n\npublic:\n  using otg_hs_hcdma6 = Otg_hs_hcdma6Reg<BaseAddress + 0x01D4>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcdma7Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using dmaaddr = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> dmaaddr;\n    };\n  };\n\npublic:\n  using\
    \ otg_hs_hcdma7 = Otg_hs_hcdma7Reg<BaseAddress + 0x01F4>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Otg_hs_hcdma8Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using dmaaddr = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> dmaaddr;\n    };\n  };\n\npublic:\n  using otg_hs_hcdma8 = Otg_hs_hcdma8Reg<BaseAddress\
    \ + 0x0214>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcdma9Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using dmaaddr\
    \ = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> dmaaddr;\n    };\n\
    \  };\n\npublic:\n  using otg_hs_hcdma9 = Otg_hs_hcdma9Reg<BaseAddress + 0x0234>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_hcdma10Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using dmaaddr = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> dmaaddr;\n    };\n  };\n\npublic:\n  using\
    \ otg_hs_hcdma10 = Otg_hs_hcdma10Reg<BaseAddress + 0x0254>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Otg_hs_hcdma11Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using dmaaddr = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> dmaaddr;\n    };\n  };\n\npublic:\n  using otg_hs_hcdma11 = Otg_hs_hcdma11Reg<BaseAddress\
    \ + 0x0274>;\n\nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n\
    \  class Otg_hs_hccharxBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n\
    \  {\n  public:\n    using mpsiz = FieldModel<uint32_t, address, 0, 11, bankOffset>;\n\
    \    using epnum = FieldModel<uint32_t, address, 11, 4, bankOffset>;\n    using\
    \ epdir = FieldModel<uint32_t, address, 15, 1, bankOffset>;\n    using lsdev =\
    \ FieldModel<uint32_t, address, 17, 1, bankOffset>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2, bankOffset>;\n    using mc = FieldModel<uint32_t, address, 20,\
    \ 2, bankOffset>;\n    using dad = FieldModel<uint32_t, address, 22, 7, bankOffset>;\n\
    \    using oddfrm = FieldModel<uint32_t, address, 29, 1, bankOffset>;\n    using\
    \ chdis = FieldModel<uint32_t, address, 30, 1, bankOffset>;\n    using chena =\
    \ FieldModel<uint32_t, address, 31, 1, bankOffset>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n \
    \     BitFieldModel<uint32_t, 11, 4> epnum;\n      BitFieldModel<uint32_t, 15,\
    \ 1> epdir;\n      BitFieldModel<uint32_t, 17, 1> lsdev;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 20, 2> mc;\n      BitFieldModel<uint32_t,\
    \ 22, 7> dad;\n      BitFieldModel<uint32_t, 29, 1> oddfrm;\n      BitFieldModel<uint32_t,\
    \ 30, 1> chdis;\n      BitFieldModel<uint32_t, 31, 1> chena;\n    };\n  };\n\n\
    public:\n  using otg_hs_hccharx = Otg_hs_hccharxBankReg<BaseAddress + 0x0100,\
    \ 0x0020>;\n\nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n\
    \  class Otg_hs_hcspltxBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n\
    \  {\n  public:\n    using prtaddr = FieldModel<uint32_t, address, 0, 7, bankOffset>;\n\
    \    using hubaddr = FieldModel<uint32_t, address, 7, 7, bankOffset>;\n    using\
    \ xactpos = FieldModel<uint32_t, address, 14, 2, bankOffset>;\n    using complsplt\
    \ = FieldModel<uint32_t, address, 16, 1, bankOffset>;\n    using spliten = FieldModel<uint32_t,\
    \ address, 31, 1, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      BitFieldModel<uint32_t, 0, 7> prtaddr;\n      BitFieldModel<uint32_t,\
    \ 7, 7> hubaddr;\n      BitFieldModel<uint32_t, 14, 2> xactpos;\n      BitFieldModel<uint32_t,\
    \ 16, 1> complsplt;\n      BitFieldModel<uint32_t, 31, 1> spliten;\n    };\n \
    \ };\n\npublic:\n  using otg_hs_hcspltx = Otg_hs_hcspltxBankReg<BaseAddress +\
    \ 0x0104, 0x0020>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class Otg_hs_hcintxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1, bankOffset>;\n    using chh = FieldModel<uint32_t, address, 1,\
    \ 1, bankOffset>;\n    using ahberr = FieldModel<uint32_t, address, 2, 1, bankOffset>;\n\
    \    using stall = FieldModel<uint32_t, address, 3, 1, bankOffset>;\n    using\
    \ nak = FieldModel<uint32_t, address, 4, 1, bankOffset>;\n    using ack = FieldModel<uint32_t,\
    \ address, 5, 1, bankOffset>;\n    using nyet = FieldModel<uint32_t, address,\
    \ 6, 1, bankOffset>;\n    using txerr = FieldModel<uint32_t, address, 7, 1, bankOffset>;\n\
    \    using bberr = FieldModel<uint32_t, address, 8, 1, bankOffset>;\n    using\
    \ frmor = FieldModel<uint32_t, address, 9, 1, bankOffset>;\n    using dterr =\
    \ FieldModel<uint32_t, address, 10, 1, bankOffset>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n   \
    \   BitFieldModel<uint32_t, 1, 1> chh;\n      BitFieldModel<uint32_t, 2, 1> ahberr;\n\
    \      BitFieldModel<uint32_t, 3, 1> stall;\n      BitFieldModel<uint32_t, 4,\
    \ 1> nak;\n      BitFieldModel<uint32_t, 5, 1> ack;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nyet;\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberr;\n      BitFieldModel<uint32_t, 9, 1> frmor;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterr;\n    };\n  };\n\npublic:\n  using otg_hs_hcintx = Otg_hs_hcintxBankReg<BaseAddress\
    \ + 0x0108, 0x0020>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class Otg_hs_hcintmskxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using xfrcm = FieldModel<uint32_t,\
    \ address, 0, 1, bankOffset>;\n    using chhm = FieldModel<uint32_t, address,\
    \ 1, 1, bankOffset>;\n    using ahberr = FieldModel<uint32_t, address, 2, 1, bankOffset>;\n\
    \    using stallm = FieldModel<uint32_t, address, 3, 1, bankOffset>;\n    using\
    \ nakm = FieldModel<uint32_t, address, 4, 1, bankOffset>;\n    using ackm = FieldModel<uint32_t,\
    \ address, 5, 1, bankOffset>;\n    using nyet = FieldModel<uint32_t, address,\
    \ 6, 1, bankOffset>;\n    using txerrm = FieldModel<uint32_t, address, 7, 1, bankOffset>;\n\
    \    using bberrm = FieldModel<uint32_t, address, 8, 1, bankOffset>;\n    using\
    \ frmorm = FieldModel<uint32_t, address, 9, 1, bankOffset>;\n    using dterrm\
    \ = FieldModel<uint32_t, address, 10, 1, bankOffset>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> xfrcm;\n\
    \      BitFieldModel<uint32_t, 1, 1> chhm;\n      BitFieldModel<uint32_t, 2, 1>\
    \ ahberr;\n      BitFieldModel<uint32_t, 3, 1> stallm;\n      BitFieldModel<uint32_t,\
    \ 4, 1> nakm;\n      BitFieldModel<uint32_t, 5, 1> ackm;\n      BitFieldModel<uint32_t,\
    \ 6, 1> nyet;\n      BitFieldModel<uint32_t, 7, 1> txerrm;\n      BitFieldModel<uint32_t,\
    \ 8, 1> bberrm;\n      BitFieldModel<uint32_t, 9, 1> frmorm;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterrm;\n    };\n  };\n\npublic:\n  using otg_hs_hcintmskx = Otg_hs_hcintmskxBankReg<BaseAddress\
    \ + 0x010C, 0x0020>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class Otg_hs_hctsizxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using xfrsiz = FieldModel<uint32_t,\
    \ address, 0, 19, bankOffset>;\n    using pktcnt = FieldModel<uint32_t, address,\
    \ 19, 10, bankOffset>;\n    using dpid = FieldModel<uint32_t, address, 29, 2,\
    \ bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n   \
    \   BitFieldModel<uint32_t, 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19,\
    \ 10> pktcnt;\n      BitFieldModel<uint32_t, 29, 2> dpid;\n    };\n  };\n\npublic:\n\
    \  using otg_hs_hctsizx = Otg_hs_hctsizxBankReg<BaseAddress + 0x0110, 0x0020>;\n\
    \nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n  class\
    \ Otg_hs_hcdmaxBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n\
    \  {\n  public:\n    using dmaaddr = FieldModel<uint32_t, address, 0, 32, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> dmaaddr;\n    };\n  };\n\npublic:\n  using otg_hs_hcdmax = Otg_hs_hcdmaxBankReg<BaseAddress\
    \ + 0x0114, 0x0020>;\n};\n\n}\n\n#endif /* DRAL_STM32F446_OTG_HS_HOST_H */\n"
  name: OTG_HS_HOST
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_OTG_HS_DEVICE_H\n#define DRAL_STM32F446_OTG_HS_DEVICE_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass otg_hs_device\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40040800;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_dcfgReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dspd = FieldModel<uint32_t, address, 0,\
    \ 2>;\n    using nzlsohsk = FieldModel<uint32_t, address, 2, 1>;\n    using dad\
    \ = FieldModel<uint32_t, address, 4, 7>;\n    using pfivl = FieldModel<uint32_t,\
    \ address, 11, 2>;\n    using perschivl = FieldModel<uint32_t, address, 24, 2>;\n\
    \    using xcvrdly = FieldModel<uint32_t, address, 14, 1>;\n    using erratim\
    \ = FieldModel<uint32_t, address, 15, 1>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 2> dspd;\n      BitFieldModel<uint32_t,\
    \ 2, 1> nzlsohsk;\n      BitFieldModel<uint32_t, 4, 7> dad;\n      BitFieldModel<uint32_t,\
    \ 11, 2> pfivl;\n      BitFieldModel<uint32_t, 24, 2> perschivl;\n      BitFieldModel<uint32_t,\
    \ 14, 1> xcvrdly;\n      BitFieldModel<uint32_t, 15, 1> erratim;\n    };\n  };\n\
    \npublic:\n  using otg_hs_dcfg = Otg_hs_dcfgReg<BaseAddress + 0x0000>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_dctlReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using rwusig = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using sdis = FieldModel<uint32_t, address, 1, 1>;\n    using ginsts\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    using gonsts = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using tctl = FieldModel<uint32_t, address, 4, 3>;\n   \
    \ using sginak = FieldModel<uint32_t, address, 7, 1>;\n    using cginak = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using sgonak = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using cgonak = FieldModel<uint32_t, address, 10, 1>;\n    using poprgdne =\
    \ FieldModel<uint32_t, address, 11, 1>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> rwusig;\n      BitFieldModel<uint32_t,\
    \ 1, 1> sdis;\n      BitFieldModel<uint32_t, 2, 1> ginsts;\n      BitFieldModel<uint32_t,\
    \ 3, 1> gonsts;\n      BitFieldModel<uint32_t, 4, 3> tctl;\n      BitFieldModel<uint32_t,\
    \ 7, 1> sginak;\n      BitFieldModel<uint32_t, 8, 1> cginak;\n      BitFieldModel<uint32_t,\
    \ 9, 1> sgonak;\n      BitFieldModel<uint32_t, 10, 1> cgonak;\n      BitFieldModel<uint32_t,\
    \ 11, 1> poprgdne;\n    };\n  };\n\npublic:\n  using otg_hs_dctl = Otg_hs_dctlReg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_dstsReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using suspsts\
    \ = FieldModel<uint32_t, address, 0, 1>;\n    using enumspd = FieldModel<uint32_t,\
    \ address, 1, 2>;\n    using eerr = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using fnsof = FieldModel<uint32_t, address, 8, 14>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> suspsts;\n\
    \      BitFieldModel<uint32_t, 1, 2> enumspd;\n      BitFieldModel<uint32_t, 3,\
    \ 1> eerr;\n      BitFieldModel<uint32_t, 8, 14> fnsof;\n    };\n  };\n\npublic:\n\
    \  using otg_hs_dsts = Otg_hs_dstsReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Otg_hs_diepmskReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using xfrcm = FieldModel<uint32_t, address, 0, 1>;\n    using\
    \ epdm = FieldModel<uint32_t, address, 1, 1>;\n    using tom = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using ittxfemsk = FieldModel<uint32_t, address, 4, 1>;\n\
    \    using inepnmm = FieldModel<uint32_t, address, 5, 1>;\n    using inepnem =\
    \ FieldModel<uint32_t, address, 6, 1>;\n    using txfurm = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using bim = FieldModel<uint32_t, address, 9, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 1> xfrcm;\n      BitFieldModel<uint32_t, 1, 1> epdm;\n      BitFieldModel<uint32_t,\
    \ 3, 1> tom;\n      BitFieldModel<uint32_t, 4, 1> ittxfemsk;\n      BitFieldModel<uint32_t,\
    \ 5, 1> inepnmm;\n      BitFieldModel<uint32_t, 6, 1> inepnem;\n      BitFieldModel<uint32_t,\
    \ 8, 1> txfurm;\n      BitFieldModel<uint32_t, 9, 1> bim;\n    };\n  };\n\npublic:\n\
    \  using otg_hs_diepmsk = Otg_hs_diepmskReg<BaseAddress + 0x0010>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_doepmskReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using xfrcm = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using epdm = FieldModel<uint32_t, address, 1, 1>;\n    using stupm\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using otepdm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using b2bstup = FieldModel<uint32_t, address, 6, 1>;\n\
    \    using opem = FieldModel<uint32_t, address, 8, 1>;\n    using boim = FieldModel<uint32_t,\
    \ address, 9, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      BitFieldModel<uint32_t, 1,\
    \ 1> epdm;\n      BitFieldModel<uint32_t, 3, 1> stupm;\n      BitFieldModel<uint32_t,\
    \ 4, 1> otepdm;\n      BitFieldModel<uint32_t, 6, 1> b2bstup;\n      BitFieldModel<uint32_t,\
    \ 8, 1> opem;\n      BitFieldModel<uint32_t, 9, 1> boim;\n    };\n  };\n\npublic:\n\
    \  using otg_hs_doepmsk = Otg_hs_doepmskReg<BaseAddress + 0x0014>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_daintReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using iepint = FieldModel<uint32_t, address, 0,\
    \ 16>;\n    using oepint = FieldModel<uint32_t, address, 16, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> iepint;\n      BitFieldModel<uint32_t, 16, 16> oepint;\n    };\n  };\n\n\
    public:\n  using otg_hs_daint = Otg_hs_daintReg<BaseAddress + 0x0018>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_daintmskReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using iepm = FieldModel<uint32_t, address, 0,\
    \ 16>;\n    using oepm = FieldModel<uint32_t, address, 16, 16>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 16> iepm;\n      BitFieldModel<uint32_t, 16, 16> oepm;\n    };\n  };\n\npublic:\n\
    \  using otg_hs_daintmsk = Otg_hs_daintmskReg<BaseAddress + 0x001C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_dvbusdisReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using vbusdt = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> vbusdt;\n    };\n  };\n\npublic:\n  using otg_hs_dvbusdis = Otg_hs_dvbusdisReg<BaseAddress\
    \ + 0x0028>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_dvbuspulseReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using dvbusp\
    \ = FieldModel<uint32_t, address, 0, 12>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 12> dvbusp;\n    };\n\
    \  };\n\npublic:\n  using otg_hs_dvbuspulse = Otg_hs_dvbuspulseReg<BaseAddress\
    \ + 0x002C>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_dthrctlReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using nonisothren\
    \ = FieldModel<uint32_t, address, 0, 1>;\n    using isothren = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using txthrlen = FieldModel<uint32_t, address, 2, 9>;\n\
    \    using rxthren = FieldModel<uint32_t, address, 16, 1>;\n    using rxthrlen\
    \ = FieldModel<uint32_t, address, 17, 9>;\n    using arpen = FieldModel<uint32_t,\
    \ address, 27, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> nonisothren;\n      BitFieldModel<uint32_t,\
    \ 1, 1> isothren;\n      BitFieldModel<uint32_t, 2, 9> txthrlen;\n      BitFieldModel<uint32_t,\
    \ 16, 1> rxthren;\n      BitFieldModel<uint32_t, 17, 9> rxthrlen;\n      BitFieldModel<uint32_t,\
    \ 27, 1> arpen;\n    };\n  };\n\npublic:\n  using otg_hs_dthrctl = Otg_hs_dthrctlReg<BaseAddress\
    \ + 0x0030>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_diepempmskReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ineptxfem\
    \ = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 16> ineptxfem;\n    };\n\
    \  };\n\npublic:\n  using otg_hs_diepempmsk = Otg_hs_diepempmskReg<BaseAddress\
    \ + 0x0034>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_deachintReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using iep1int\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using oep1int = FieldModel<uint32_t,\
    \ address, 17, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 1, 1> iep1int;\n      BitFieldModel<uint32_t, 17,\
    \ 1> oep1int;\n    };\n  };\n\npublic:\n  using otg_hs_deachint = Otg_hs_deachintReg<BaseAddress\
    \ + 0x0038>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_deachintmskReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using iep1intm\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using oep1intm = FieldModel<uint32_t,\
    \ address, 17, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 1, 1> iep1intm;\n      BitFieldModel<uint32_t,\
    \ 17, 1> oep1intm;\n    };\n  };\n\npublic:\n  using otg_hs_deachintmsk = Otg_hs_deachintmskReg<BaseAddress\
    \ + 0x003C>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_diepeachmsk1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrcm =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using epdm = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using tom = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ ittxfemsk = FieldModel<uint32_t, address, 4, 1>;\n    using inepnmm = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using inepnem = FieldModel<uint32_t, address, 6, 1>;\n\
    \    using txfurm = FieldModel<uint32_t, address, 8, 1>;\n    using bim = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using nakm = FieldModel<uint32_t, address, 13, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrcm;\n      BitFieldModel<uint32_t, 1, 1> epdm;\n      BitFieldModel<uint32_t,\
    \ 3, 1> tom;\n      BitFieldModel<uint32_t, 4, 1> ittxfemsk;\n      BitFieldModel<uint32_t,\
    \ 5, 1> inepnmm;\n      BitFieldModel<uint32_t, 6, 1> inepnem;\n      BitFieldModel<uint32_t,\
    \ 8, 1> txfurm;\n      BitFieldModel<uint32_t, 9, 1> bim;\n      BitFieldModel<uint32_t,\
    \ 13, 1> nakm;\n    };\n  };\n\npublic:\n  using otg_hs_diepeachmsk1 = Otg_hs_diepeachmsk1Reg<BaseAddress\
    \ + 0x0044>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_doepeachmsk1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrcm =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using epdm = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using tom = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ ittxfemsk = FieldModel<uint32_t, address, 4, 1>;\n    using inepnmm = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using inepnem = FieldModel<uint32_t, address, 6, 1>;\n\
    \    using txfurm = FieldModel<uint32_t, address, 8, 1>;\n    using bim = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using berrm = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using nakm = FieldModel<uint32_t, address, 13, 1>;\n    using nyetm = FieldModel<uint32_t,\
    \ address, 14, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      BitFieldModel<uint32_t, 1,\
    \ 1> epdm;\n      BitFieldModel<uint32_t, 3, 1> tom;\n      BitFieldModel<uint32_t,\
    \ 4, 1> ittxfemsk;\n      BitFieldModel<uint32_t, 5, 1> inepnmm;\n      BitFieldModel<uint32_t,\
    \ 6, 1> inepnem;\n      BitFieldModel<uint32_t, 8, 1> txfurm;\n      BitFieldModel<uint32_t,\
    \ 9, 1> bim;\n      BitFieldModel<uint32_t, 12, 1> berrm;\n      BitFieldModel<uint32_t,\
    \ 13, 1> nakm;\n      BitFieldModel<uint32_t, 14, 1> nyetm;\n    };\n  };\n\n\
    public:\n  using otg_hs_doepeachmsk1 = Otg_hs_doepeachmsk1Reg<BaseAddress + 0x0084>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_diepctl0Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz = FieldModel<uint32_t,\
    \ address, 0, 11>;\n    using usbaep = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using eonum_dpid = FieldModel<uint32_t, address, 16, 1>;\n    using naksts\
    \ = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using stall = FieldModel<uint32_t, address, 21, 1>;\n\
    \    using txfnum = FieldModel<uint32_t, address, 22, 4>;\n    using cnak = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using snak = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using sd0pid_sevnfrm = FieldModel<uint32_t, address, 28, 1>;\n    using soddfrm\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using epdis = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    using epena = FieldModel<uint32_t, address, 31, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 11> mpsiz;\n      BitFieldModel<uint32_t, 15, 1> usbaep;\n      BitFieldModel<uint32_t,\
    \ 16, 1> eonum_dpid;\n      BitFieldModel<uint32_t, 17, 1> naksts;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 21, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 22, 4> txfnum;\n      BitFieldModel<uint32_t, 26, 1> cnak;\n      BitFieldModel<uint32_t,\
    \ 27, 1> snak;\n      BitFieldModel<uint32_t, 28, 1> sd0pid_sevnfrm;\n      BitFieldModel<uint32_t,\
    \ 29, 1> soddfrm;\n      BitFieldModel<uint32_t, 30, 1> epdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> epena;\n    };\n  };\n\npublic:\n  using otg_hs_diepctl0 = Otg_hs_diepctl0Reg<BaseAddress\
    \ + 0x0100>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_diepctl1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    using usbaep = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using eonum_dpid = FieldModel<uint32_t, address, 16, 1>;\n\
    \    using naksts = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using stall = FieldModel<uint32_t, address, 21, 1>;\n\
    \    using txfnum = FieldModel<uint32_t, address, 22, 4>;\n    using cnak = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using snak = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using sd0pid_sevnfrm = FieldModel<uint32_t, address, 28, 1>;\n    using soddfrm\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using epdis = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    using epena = FieldModel<uint32_t, address, 31, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 11> mpsiz;\n      BitFieldModel<uint32_t, 15, 1> usbaep;\n      BitFieldModel<uint32_t,\
    \ 16, 1> eonum_dpid;\n      BitFieldModel<uint32_t, 17, 1> naksts;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 21, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 22, 4> txfnum;\n      BitFieldModel<uint32_t, 26, 1> cnak;\n      BitFieldModel<uint32_t,\
    \ 27, 1> snak;\n      BitFieldModel<uint32_t, 28, 1> sd0pid_sevnfrm;\n      BitFieldModel<uint32_t,\
    \ 29, 1> soddfrm;\n      BitFieldModel<uint32_t, 30, 1> epdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> epena;\n    };\n  };\n\npublic:\n  using otg_hs_diepctl1 = Otg_hs_diepctl1Reg<BaseAddress\
    \ + 0x0120>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_diepctl2Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    using usbaep = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using eonum_dpid = FieldModel<uint32_t, address, 16, 1>;\n\
    \    using naksts = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using stall = FieldModel<uint32_t, address, 21, 1>;\n\
    \    using txfnum = FieldModel<uint32_t, address, 22, 4>;\n    using cnak = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using snak = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using sd0pid_sevnfrm = FieldModel<uint32_t, address, 28, 1>;\n    using soddfrm\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using epdis = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    using epena = FieldModel<uint32_t, address, 31, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 11> mpsiz;\n      BitFieldModel<uint32_t, 15, 1> usbaep;\n      BitFieldModel<uint32_t,\
    \ 16, 1> eonum_dpid;\n      BitFieldModel<uint32_t, 17, 1> naksts;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 21, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 22, 4> txfnum;\n      BitFieldModel<uint32_t, 26, 1> cnak;\n      BitFieldModel<uint32_t,\
    \ 27, 1> snak;\n      BitFieldModel<uint32_t, 28, 1> sd0pid_sevnfrm;\n      BitFieldModel<uint32_t,\
    \ 29, 1> soddfrm;\n      BitFieldModel<uint32_t, 30, 1> epdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> epena;\n    };\n  };\n\npublic:\n  using otg_hs_diepctl2 = Otg_hs_diepctl2Reg<BaseAddress\
    \ + 0x0140>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_diepctl3Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    using usbaep = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using eonum_dpid = FieldModel<uint32_t, address, 16, 1>;\n\
    \    using naksts = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using stall = FieldModel<uint32_t, address, 21, 1>;\n\
    \    using txfnum = FieldModel<uint32_t, address, 22, 4>;\n    using cnak = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using snak = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using sd0pid_sevnfrm = FieldModel<uint32_t, address, 28, 1>;\n    using soddfrm\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using epdis = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    using epena = FieldModel<uint32_t, address, 31, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 11> mpsiz;\n      BitFieldModel<uint32_t, 15, 1> usbaep;\n      BitFieldModel<uint32_t,\
    \ 16, 1> eonum_dpid;\n      BitFieldModel<uint32_t, 17, 1> naksts;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 21, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 22, 4> txfnum;\n      BitFieldModel<uint32_t, 26, 1> cnak;\n      BitFieldModel<uint32_t,\
    \ 27, 1> snak;\n      BitFieldModel<uint32_t, 28, 1> sd0pid_sevnfrm;\n      BitFieldModel<uint32_t,\
    \ 29, 1> soddfrm;\n      BitFieldModel<uint32_t, 30, 1> epdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> epena;\n    };\n  };\n\npublic:\n  using otg_hs_diepctl3 = Otg_hs_diepctl3Reg<BaseAddress\
    \ + 0x0160>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_diepctl4Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    using usbaep = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using eonum_dpid = FieldModel<uint32_t, address, 16, 1>;\n\
    \    using naksts = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using stall = FieldModel<uint32_t, address, 21, 1>;\n\
    \    using txfnum = FieldModel<uint32_t, address, 22, 4>;\n    using cnak = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using snak = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using sd0pid_sevnfrm = FieldModel<uint32_t, address, 28, 1>;\n    using soddfrm\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using epdis = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    using epena = FieldModel<uint32_t, address, 31, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 11> mpsiz;\n      BitFieldModel<uint32_t, 15, 1> usbaep;\n      BitFieldModel<uint32_t,\
    \ 16, 1> eonum_dpid;\n      BitFieldModel<uint32_t, 17, 1> naksts;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 21, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 22, 4> txfnum;\n      BitFieldModel<uint32_t, 26, 1> cnak;\n      BitFieldModel<uint32_t,\
    \ 27, 1> snak;\n      BitFieldModel<uint32_t, 28, 1> sd0pid_sevnfrm;\n      BitFieldModel<uint32_t,\
    \ 29, 1> soddfrm;\n      BitFieldModel<uint32_t, 30, 1> epdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> epena;\n    };\n  };\n\npublic:\n  using otg_hs_diepctl4 = Otg_hs_diepctl4Reg<BaseAddress\
    \ + 0x0180>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_diepctl5Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    using usbaep = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using eonum_dpid = FieldModel<uint32_t, address, 16, 1>;\n\
    \    using naksts = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using stall = FieldModel<uint32_t, address, 21, 1>;\n\
    \    using txfnum = FieldModel<uint32_t, address, 22, 4>;\n    using cnak = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using snak = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using sd0pid_sevnfrm = FieldModel<uint32_t, address, 28, 1>;\n    using soddfrm\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using epdis = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    using epena = FieldModel<uint32_t, address, 31, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 11> mpsiz;\n      BitFieldModel<uint32_t, 15, 1> usbaep;\n      BitFieldModel<uint32_t,\
    \ 16, 1> eonum_dpid;\n      BitFieldModel<uint32_t, 17, 1> naksts;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 21, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 22, 4> txfnum;\n      BitFieldModel<uint32_t, 26, 1> cnak;\n      BitFieldModel<uint32_t,\
    \ 27, 1> snak;\n      BitFieldModel<uint32_t, 28, 1> sd0pid_sevnfrm;\n      BitFieldModel<uint32_t,\
    \ 29, 1> soddfrm;\n      BitFieldModel<uint32_t, 30, 1> epdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> epena;\n    };\n  };\n\npublic:\n  using otg_hs_diepctl5 = Otg_hs_diepctl5Reg<BaseAddress\
    \ + 0x01A0>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_diepctl6Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    using usbaep = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using eonum_dpid = FieldModel<uint32_t, address, 16, 1>;\n\
    \    using naksts = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using stall = FieldModel<uint32_t, address, 21, 1>;\n\
    \    using txfnum = FieldModel<uint32_t, address, 22, 4>;\n    using cnak = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using snak = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using sd0pid_sevnfrm = FieldModel<uint32_t, address, 28, 1>;\n    using soddfrm\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using epdis = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    using epena = FieldModel<uint32_t, address, 31, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 11> mpsiz;\n      BitFieldModel<uint32_t, 15, 1> usbaep;\n      BitFieldModel<uint32_t,\
    \ 16, 1> eonum_dpid;\n      BitFieldModel<uint32_t, 17, 1> naksts;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 21, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 22, 4> txfnum;\n      BitFieldModel<uint32_t, 26, 1> cnak;\n      BitFieldModel<uint32_t,\
    \ 27, 1> snak;\n      BitFieldModel<uint32_t, 28, 1> sd0pid_sevnfrm;\n      BitFieldModel<uint32_t,\
    \ 29, 1> soddfrm;\n      BitFieldModel<uint32_t, 30, 1> epdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> epena;\n    };\n  };\n\npublic:\n  using otg_hs_diepctl6 = Otg_hs_diepctl6Reg<BaseAddress\
    \ + 0x01C0>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_diepctl7Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    using usbaep = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using eonum_dpid = FieldModel<uint32_t, address, 16, 1>;\n\
    \    using naksts = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using stall = FieldModel<uint32_t, address, 21, 1>;\n\
    \    using txfnum = FieldModel<uint32_t, address, 22, 4>;\n    using cnak = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using snak = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using sd0pid_sevnfrm = FieldModel<uint32_t, address, 28, 1>;\n    using soddfrm\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using epdis = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    using epena = FieldModel<uint32_t, address, 31, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 11> mpsiz;\n      BitFieldModel<uint32_t, 15, 1> usbaep;\n      BitFieldModel<uint32_t,\
    \ 16, 1> eonum_dpid;\n      BitFieldModel<uint32_t, 17, 1> naksts;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 21, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 22, 4> txfnum;\n      BitFieldModel<uint32_t, 26, 1> cnak;\n      BitFieldModel<uint32_t,\
    \ 27, 1> snak;\n      BitFieldModel<uint32_t, 28, 1> sd0pid_sevnfrm;\n      BitFieldModel<uint32_t,\
    \ 29, 1> soddfrm;\n      BitFieldModel<uint32_t, 30, 1> epdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> epena;\n    };\n  };\n\npublic:\n  using otg_hs_diepctl7 = Otg_hs_diepctl7Reg<BaseAddress\
    \ + 0x01E0>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_diepint0Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using epdisd = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using toc = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ ittxfe = FieldModel<uint32_t, address, 4, 1>;\n    using inepne = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using txfe = FieldModel<uint32_t, address, 7, 1>;\n   \
    \ using txfifoudrn = FieldModel<uint32_t, address, 8, 1>;\n    using bna = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using pktdrpsts = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using berr = FieldModel<uint32_t, address, 12, 1>;\n    using nak = FieldModel<uint32_t,\
    \ address, 13, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1>\
    \ epdisd;\n      BitFieldModel<uint32_t, 3, 1> toc;\n      BitFieldModel<uint32_t,\
    \ 4, 1> ittxfe;\n      BitFieldModel<uint32_t, 6, 1> inepne;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txfe;\n      BitFieldModel<uint32_t, 8, 1> txfifoudrn;\n      BitFieldModel<uint32_t,\
    \ 9, 1> bna;\n      BitFieldModel<uint32_t, 11, 1> pktdrpsts;\n      BitFieldModel<uint32_t,\
    \ 12, 1> berr;\n      BitFieldModel<uint32_t, 13, 1> nak;\n    };\n  };\n\npublic:\n\
    \  using otg_hs_diepint0 = Otg_hs_diepint0Reg<BaseAddress + 0x0108>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_diepint1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n    using toc\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using ittxfe = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using inepne = FieldModel<uint32_t, address, 6, 1>;\n \
    \   using txfe = FieldModel<uint32_t, address, 7, 1>;\n    using txfifoudrn =\
    \ FieldModel<uint32_t, address, 8, 1>;\n    using bna = FieldModel<uint32_t, address,\
    \ 9, 1>;\n    using pktdrpsts = FieldModel<uint32_t, address, 11, 1>;\n    using\
    \ berr = FieldModel<uint32_t, address, 12, 1>;\n    using nak = FieldModel<uint32_t,\
    \ address, 13, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1>\
    \ epdisd;\n      BitFieldModel<uint32_t, 3, 1> toc;\n      BitFieldModel<uint32_t,\
    \ 4, 1> ittxfe;\n      BitFieldModel<uint32_t, 6, 1> inepne;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txfe;\n      BitFieldModel<uint32_t, 8, 1> txfifoudrn;\n      BitFieldModel<uint32_t,\
    \ 9, 1> bna;\n      BitFieldModel<uint32_t, 11, 1> pktdrpsts;\n      BitFieldModel<uint32_t,\
    \ 12, 1> berr;\n      BitFieldModel<uint32_t, 13, 1> nak;\n    };\n  };\n\npublic:\n\
    \  using otg_hs_diepint1 = Otg_hs_diepint1Reg<BaseAddress + 0x0128>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_diepint2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n    using toc\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using ittxfe = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using inepne = FieldModel<uint32_t, address, 6, 1>;\n \
    \   using txfe = FieldModel<uint32_t, address, 7, 1>;\n    using txfifoudrn =\
    \ FieldModel<uint32_t, address, 8, 1>;\n    using bna = FieldModel<uint32_t, address,\
    \ 9, 1>;\n    using pktdrpsts = FieldModel<uint32_t, address, 11, 1>;\n    using\
    \ berr = FieldModel<uint32_t, address, 12, 1>;\n    using nak = FieldModel<uint32_t,\
    \ address, 13, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1>\
    \ epdisd;\n      BitFieldModel<uint32_t, 3, 1> toc;\n      BitFieldModel<uint32_t,\
    \ 4, 1> ittxfe;\n      BitFieldModel<uint32_t, 6, 1> inepne;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txfe;\n      BitFieldModel<uint32_t, 8, 1> txfifoudrn;\n      BitFieldModel<uint32_t,\
    \ 9, 1> bna;\n      BitFieldModel<uint32_t, 11, 1> pktdrpsts;\n      BitFieldModel<uint32_t,\
    \ 12, 1> berr;\n      BitFieldModel<uint32_t, 13, 1> nak;\n    };\n  };\n\npublic:\n\
    \  using otg_hs_diepint2 = Otg_hs_diepint2Reg<BaseAddress + 0x0148>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_diepint3Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n    using toc\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using ittxfe = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using inepne = FieldModel<uint32_t, address, 6, 1>;\n \
    \   using txfe = FieldModel<uint32_t, address, 7, 1>;\n    using txfifoudrn =\
    \ FieldModel<uint32_t, address, 8, 1>;\n    using bna = FieldModel<uint32_t, address,\
    \ 9, 1>;\n    using pktdrpsts = FieldModel<uint32_t, address, 11, 1>;\n    using\
    \ berr = FieldModel<uint32_t, address, 12, 1>;\n    using nak = FieldModel<uint32_t,\
    \ address, 13, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1>\
    \ epdisd;\n      BitFieldModel<uint32_t, 3, 1> toc;\n      BitFieldModel<uint32_t,\
    \ 4, 1> ittxfe;\n      BitFieldModel<uint32_t, 6, 1> inepne;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txfe;\n      BitFieldModel<uint32_t, 8, 1> txfifoudrn;\n      BitFieldModel<uint32_t,\
    \ 9, 1> bna;\n      BitFieldModel<uint32_t, 11, 1> pktdrpsts;\n      BitFieldModel<uint32_t,\
    \ 12, 1> berr;\n      BitFieldModel<uint32_t, 13, 1> nak;\n    };\n  };\n\npublic:\n\
    \  using otg_hs_diepint3 = Otg_hs_diepint3Reg<BaseAddress + 0x0168>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_diepint4Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n    using toc\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using ittxfe = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using inepne = FieldModel<uint32_t, address, 6, 1>;\n \
    \   using txfe = FieldModel<uint32_t, address, 7, 1>;\n    using txfifoudrn =\
    \ FieldModel<uint32_t, address, 8, 1>;\n    using bna = FieldModel<uint32_t, address,\
    \ 9, 1>;\n    using pktdrpsts = FieldModel<uint32_t, address, 11, 1>;\n    using\
    \ berr = FieldModel<uint32_t, address, 12, 1>;\n    using nak = FieldModel<uint32_t,\
    \ address, 13, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1>\
    \ epdisd;\n      BitFieldModel<uint32_t, 3, 1> toc;\n      BitFieldModel<uint32_t,\
    \ 4, 1> ittxfe;\n      BitFieldModel<uint32_t, 6, 1> inepne;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txfe;\n      BitFieldModel<uint32_t, 8, 1> txfifoudrn;\n      BitFieldModel<uint32_t,\
    \ 9, 1> bna;\n      BitFieldModel<uint32_t, 11, 1> pktdrpsts;\n      BitFieldModel<uint32_t,\
    \ 12, 1> berr;\n      BitFieldModel<uint32_t, 13, 1> nak;\n    };\n  };\n\npublic:\n\
    \  using otg_hs_diepint4 = Otg_hs_diepint4Reg<BaseAddress + 0x0188>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_diepint5Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n    using toc\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using ittxfe = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using inepne = FieldModel<uint32_t, address, 6, 1>;\n \
    \   using txfe = FieldModel<uint32_t, address, 7, 1>;\n    using txfifoudrn =\
    \ FieldModel<uint32_t, address, 8, 1>;\n    using bna = FieldModel<uint32_t, address,\
    \ 9, 1>;\n    using pktdrpsts = FieldModel<uint32_t, address, 11, 1>;\n    using\
    \ berr = FieldModel<uint32_t, address, 12, 1>;\n    using nak = FieldModel<uint32_t,\
    \ address, 13, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1>\
    \ epdisd;\n      BitFieldModel<uint32_t, 3, 1> toc;\n      BitFieldModel<uint32_t,\
    \ 4, 1> ittxfe;\n      BitFieldModel<uint32_t, 6, 1> inepne;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txfe;\n      BitFieldModel<uint32_t, 8, 1> txfifoudrn;\n      BitFieldModel<uint32_t,\
    \ 9, 1> bna;\n      BitFieldModel<uint32_t, 11, 1> pktdrpsts;\n      BitFieldModel<uint32_t,\
    \ 12, 1> berr;\n      BitFieldModel<uint32_t, 13, 1> nak;\n    };\n  };\n\npublic:\n\
    \  using otg_hs_diepint5 = Otg_hs_diepint5Reg<BaseAddress + 0x01A8>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_diepint6Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n    using toc\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using ittxfe = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using inepne = FieldModel<uint32_t, address, 6, 1>;\n \
    \   using txfe = FieldModel<uint32_t, address, 7, 1>;\n    using txfifoudrn =\
    \ FieldModel<uint32_t, address, 8, 1>;\n    using bna = FieldModel<uint32_t, address,\
    \ 9, 1>;\n    using pktdrpsts = FieldModel<uint32_t, address, 11, 1>;\n    using\
    \ berr = FieldModel<uint32_t, address, 12, 1>;\n    using nak = FieldModel<uint32_t,\
    \ address, 13, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1>\
    \ epdisd;\n      BitFieldModel<uint32_t, 3, 1> toc;\n      BitFieldModel<uint32_t,\
    \ 4, 1> ittxfe;\n      BitFieldModel<uint32_t, 6, 1> inepne;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txfe;\n      BitFieldModel<uint32_t, 8, 1> txfifoudrn;\n      BitFieldModel<uint32_t,\
    \ 9, 1> bna;\n      BitFieldModel<uint32_t, 11, 1> pktdrpsts;\n      BitFieldModel<uint32_t,\
    \ 12, 1> berr;\n      BitFieldModel<uint32_t, 13, 1> nak;\n    };\n  };\n\npublic:\n\
    \  using otg_hs_diepint6 = Otg_hs_diepint6Reg<BaseAddress + 0x01C8>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_diepint7Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n    using toc\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using ittxfe = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using inepne = FieldModel<uint32_t, address, 6, 1>;\n \
    \   using txfe = FieldModel<uint32_t, address, 7, 1>;\n    using txfifoudrn =\
    \ FieldModel<uint32_t, address, 8, 1>;\n    using bna = FieldModel<uint32_t, address,\
    \ 9, 1>;\n    using pktdrpsts = FieldModel<uint32_t, address, 11, 1>;\n    using\
    \ berr = FieldModel<uint32_t, address, 12, 1>;\n    using nak = FieldModel<uint32_t,\
    \ address, 13, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1>\
    \ epdisd;\n      BitFieldModel<uint32_t, 3, 1> toc;\n      BitFieldModel<uint32_t,\
    \ 4, 1> ittxfe;\n      BitFieldModel<uint32_t, 6, 1> inepne;\n      BitFieldModel<uint32_t,\
    \ 7, 1> txfe;\n      BitFieldModel<uint32_t, 8, 1> txfifoudrn;\n      BitFieldModel<uint32_t,\
    \ 9, 1> bna;\n      BitFieldModel<uint32_t, 11, 1> pktdrpsts;\n      BitFieldModel<uint32_t,\
    \ 12, 1> berr;\n      BitFieldModel<uint32_t, 13, 1> nak;\n    };\n  };\n\npublic:\n\
    \  using otg_hs_diepint7 = Otg_hs_diepint7Reg<BaseAddress + 0x01E8>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_dieptsiz0Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using xfrsiz = FieldModel<uint32_t, address, 0,\
    \ 7>;\n    using pktcnt = FieldModel<uint32_t, address, 19, 2>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 7> xfrsiz;\n      BitFieldModel<uint32_t, 19, 2> pktcnt;\n    };\n  };\n\npublic:\n\
    \  using otg_hs_dieptsiz0 = Otg_hs_dieptsiz0Reg<BaseAddress + 0x0110>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_diepdma1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dmaaddr = FieldModel<uint32_t, address,\
    \ 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> dmaaddr;\n    };\n  };\n\npublic:\n  using otg_hs_diepdma1 = Otg_hs_diepdma1Reg<BaseAddress\
    \ + 0x0114>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_diepdma2Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using dmaaddr\
    \ = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> dmaaddr;\n    };\n\
    \  };\n\npublic:\n  using otg_hs_diepdma2 = Otg_hs_diepdma2Reg<BaseAddress + 0x0134>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_diepdma3Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using dmaaddr = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> dmaaddr;\n    };\n  };\n\npublic:\n  using\
    \ otg_hs_diepdma3 = Otg_hs_diepdma3Reg<BaseAddress + 0x0154>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Otg_hs_diepdma4Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using dmaaddr = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> dmaaddr;\n    };\n  };\n\npublic:\n  using otg_hs_diepdma4 = Otg_hs_diepdma4Reg<BaseAddress\
    \ + 0x0174>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_diepdma5Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using dmaaddr\
    \ = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> dmaaddr;\n    };\n\
    \  };\n\npublic:\n  using otg_hs_diepdma5 = Otg_hs_diepdma5Reg<BaseAddress + 0x0194>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_dtxfsts0Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using ineptfsav = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> ineptfsav;\n    };\n  };\n\npublic:\n  using\
    \ otg_hs_dtxfsts0 = Otg_hs_dtxfsts0Reg<BaseAddress + 0x0118>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Otg_hs_dtxfsts1Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ineptfsav = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ineptfsav;\n    };\n  };\n\npublic:\n  using otg_hs_dtxfsts1 = Otg_hs_dtxfsts1Reg<BaseAddress\
    \ + 0x0138>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_dtxfsts2Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ineptfsav\
    \ = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 16> ineptfsav;\n    };\n\
    \  };\n\npublic:\n  using otg_hs_dtxfsts2 = Otg_hs_dtxfsts2Reg<BaseAddress + 0x0158>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_dtxfsts3Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using ineptfsav = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> ineptfsav;\n    };\n  };\n\npublic:\n  using\
    \ otg_hs_dtxfsts3 = Otg_hs_dtxfsts3Reg<BaseAddress + 0x0178>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Otg_hs_dtxfsts4Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using ineptfsav = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ineptfsav;\n    };\n  };\n\npublic:\n  using otg_hs_dtxfsts4 = Otg_hs_dtxfsts4Reg<BaseAddress\
    \ + 0x0198>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_dtxfsts5Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using ineptfsav\
    \ = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 16> ineptfsav;\n    };\n\
    \  };\n\npublic:\n  using otg_hs_dtxfsts5 = Otg_hs_dtxfsts5Reg<BaseAddress + 0x01B8>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_dieptsiz1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz = FieldModel<uint32_t,\
    \ address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t, address, 19, 10>;\n\
    \    using mcnt = FieldModel<uint32_t, address, 29, 2>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 19> xfrsiz;\n\
    \      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> mcnt;\n    };\n  };\n\npublic:\n  using otg_hs_dieptsiz1 = Otg_hs_dieptsiz1Reg<BaseAddress\
    \ + 0x0130>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_dieptsiz2Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using mcnt = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> mcnt;\n    };\n  };\n\npublic:\n  using otg_hs_dieptsiz2 = Otg_hs_dieptsiz2Reg<BaseAddress\
    \ + 0x0150>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_dieptsiz3Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using mcnt = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> mcnt;\n    };\n  };\n\npublic:\n  using otg_hs_dieptsiz3 = Otg_hs_dieptsiz3Reg<BaseAddress\
    \ + 0x0170>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_dieptsiz4Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using mcnt = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> mcnt;\n    };\n  };\n\npublic:\n  using otg_hs_dieptsiz4 = Otg_hs_dieptsiz4Reg<BaseAddress\
    \ + 0x0190>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_dieptsiz5Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using mcnt = FieldModel<uint32_t, address, 29, 2>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> mcnt;\n    };\n  };\n\npublic:\n  using otg_hs_dieptsiz5 = Otg_hs_dieptsiz5Reg<BaseAddress\
    \ + 0x01B0>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_doepctl0Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 2>;\n    using usbaep = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using naksts = FieldModel<uint32_t, address, 17, 1>;\n\
    \    using eptyp = FieldModel<uint32_t, address, 18, 2>;\n    using snpm = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using stall = FieldModel<uint32_t, address, 21, 1>;\n\
    \    using cnak = FieldModel<uint32_t, address, 26, 1>;\n    using snak = FieldModel<uint32_t,\
    \ address, 27, 1>;\n    using epdis = FieldModel<uint32_t, address, 30, 1>;\n\
    \    using epena = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 2> mpsiz;\n\
    \      BitFieldModel<uint32_t, 15, 1> usbaep;\n      BitFieldModel<uint32_t, 17,\
    \ 1> naksts;\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      BitFieldModel<uint32_t,\
    \ 20, 1> snpm;\n      BitFieldModel<uint32_t, 21, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 26, 1> cnak;\n      BitFieldModel<uint32_t, 27, 1> snak;\n      BitFieldModel<uint32_t,\
    \ 30, 1> epdis;\n      BitFieldModel<uint32_t, 31, 1> epena;\n    };\n  };\n\n\
    public:\n  using otg_hs_doepctl0 = Otg_hs_doepctl0Reg<BaseAddress + 0x0300>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_doepctl1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz = FieldModel<uint32_t,\
    \ address, 0, 11>;\n    using usbaep = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using eonum_dpid = FieldModel<uint32_t, address, 16, 1>;\n    using naksts\
    \ = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using snpm = FieldModel<uint32_t, address, 20, 1>;\n \
    \   using stall = FieldModel<uint32_t, address, 21, 1>;\n    using cnak = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using snak = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using sd0pid_sevnfrm = FieldModel<uint32_t, address, 28, 1>;\n    using soddfrm\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using epdis = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    using epena = FieldModel<uint32_t, address, 31, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 11> mpsiz;\n      BitFieldModel<uint32_t, 15, 1> usbaep;\n      BitFieldModel<uint32_t,\
    \ 16, 1> eonum_dpid;\n      BitFieldModel<uint32_t, 17, 1> naksts;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 20, 1> snpm;\n      BitFieldModel<uint32_t,\
    \ 21, 1> stall;\n      BitFieldModel<uint32_t, 26, 1> cnak;\n      BitFieldModel<uint32_t,\
    \ 27, 1> snak;\n      BitFieldModel<uint32_t, 28, 1> sd0pid_sevnfrm;\n      BitFieldModel<uint32_t,\
    \ 29, 1> soddfrm;\n      BitFieldModel<uint32_t, 30, 1> epdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> epena;\n    };\n  };\n\npublic:\n  using otg_hs_doepctl1 = Otg_hs_doepctl1Reg<BaseAddress\
    \ + 0x0320>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_doepctl2Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    using usbaep = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using eonum_dpid = FieldModel<uint32_t, address, 16, 1>;\n\
    \    using naksts = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using snpm = FieldModel<uint32_t, address, 20, 1>;\n \
    \   using stall = FieldModel<uint32_t, address, 21, 1>;\n    using cnak = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using snak = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using sd0pid_sevnfrm = FieldModel<uint32_t, address, 28, 1>;\n    using soddfrm\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using epdis = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    using epena = FieldModel<uint32_t, address, 31, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 11> mpsiz;\n      BitFieldModel<uint32_t, 15, 1> usbaep;\n      BitFieldModel<uint32_t,\
    \ 16, 1> eonum_dpid;\n      BitFieldModel<uint32_t, 17, 1> naksts;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 20, 1> snpm;\n      BitFieldModel<uint32_t,\
    \ 21, 1> stall;\n      BitFieldModel<uint32_t, 26, 1> cnak;\n      BitFieldModel<uint32_t,\
    \ 27, 1> snak;\n      BitFieldModel<uint32_t, 28, 1> sd0pid_sevnfrm;\n      BitFieldModel<uint32_t,\
    \ 29, 1> soddfrm;\n      BitFieldModel<uint32_t, 30, 1> epdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> epena;\n    };\n  };\n\npublic:\n  using otg_hs_doepctl2 = Otg_hs_doepctl2Reg<BaseAddress\
    \ + 0x0340>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_doepctl3Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    using usbaep = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using eonum_dpid = FieldModel<uint32_t, address, 16, 1>;\n\
    \    using naksts = FieldModel<uint32_t, address, 17, 1>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    using snpm = FieldModel<uint32_t, address, 20, 1>;\n \
    \   using stall = FieldModel<uint32_t, address, 21, 1>;\n    using cnak = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using snak = FieldModel<uint32_t, address, 27, 1>;\n \
    \   using sd0pid_sevnfrm = FieldModel<uint32_t, address, 28, 1>;\n    using soddfrm\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    using epdis = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    using epena = FieldModel<uint32_t, address, 31, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 11> mpsiz;\n      BitFieldModel<uint32_t, 15, 1> usbaep;\n      BitFieldModel<uint32_t,\
    \ 16, 1> eonum_dpid;\n      BitFieldModel<uint32_t, 17, 1> naksts;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 20, 1> snpm;\n      BitFieldModel<uint32_t,\
    \ 21, 1> stall;\n      BitFieldModel<uint32_t, 26, 1> cnak;\n      BitFieldModel<uint32_t,\
    \ 27, 1> snak;\n      BitFieldModel<uint32_t, 28, 1> sd0pid_sevnfrm;\n      BitFieldModel<uint32_t,\
    \ 29, 1> soddfrm;\n      BitFieldModel<uint32_t, 30, 1> epdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> epena;\n    };\n  };\n\npublic:\n  using otg_hs_doepctl3 = Otg_hs_doepctl3Reg<BaseAddress\
    \ + 0x0360>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_doepint0Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using epdisd = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using stup = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using otepdis = FieldModel<uint32_t, address, 4, 1>;\n    using b2bstup = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using nyet = FieldModel<uint32_t, address, 14, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1> epdisd;\n      BitFieldModel<uint32_t,\
    \ 3, 1> stup;\n      BitFieldModel<uint32_t, 4, 1> otepdis;\n      BitFieldModel<uint32_t,\
    \ 6, 1> b2bstup;\n      BitFieldModel<uint32_t, 14, 1> nyet;\n    };\n  };\n\n\
    public:\n  using otg_hs_doepint0 = Otg_hs_doepint0Reg<BaseAddress + 0x0308>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_doepint1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n \
    \   using stup = FieldModel<uint32_t, address, 3, 1>;\n    using otepdis = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using b2bstup = FieldModel<uint32_t, address, 6, 1>;\n\
    \    using nyet = FieldModel<uint32_t, address, 14, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n\
    \      BitFieldModel<uint32_t, 1, 1> epdisd;\n      BitFieldModel<uint32_t, 3,\
    \ 1> stup;\n      BitFieldModel<uint32_t, 4, 1> otepdis;\n      BitFieldModel<uint32_t,\
    \ 6, 1> b2bstup;\n      BitFieldModel<uint32_t, 14, 1> nyet;\n    };\n  };\n\n\
    public:\n  using otg_hs_doepint1 = Otg_hs_doepint1Reg<BaseAddress + 0x0328>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_doepint2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n \
    \   using stup = FieldModel<uint32_t, address, 3, 1>;\n    using otepdis = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using b2bstup = FieldModel<uint32_t, address, 6, 1>;\n\
    \    using nyet = FieldModel<uint32_t, address, 14, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n\
    \      BitFieldModel<uint32_t, 1, 1> epdisd;\n      BitFieldModel<uint32_t, 3,\
    \ 1> stup;\n      BitFieldModel<uint32_t, 4, 1> otepdis;\n      BitFieldModel<uint32_t,\
    \ 6, 1> b2bstup;\n      BitFieldModel<uint32_t, 14, 1> nyet;\n    };\n  };\n\n\
    public:\n  using otg_hs_doepint2 = Otg_hs_doepint2Reg<BaseAddress + 0x0348>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_doepint3Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n \
    \   using stup = FieldModel<uint32_t, address, 3, 1>;\n    using otepdis = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using b2bstup = FieldModel<uint32_t, address, 6, 1>;\n\
    \    using nyet = FieldModel<uint32_t, address, 14, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n\
    \      BitFieldModel<uint32_t, 1, 1> epdisd;\n      BitFieldModel<uint32_t, 3,\
    \ 1> stup;\n      BitFieldModel<uint32_t, 4, 1> otepdis;\n      BitFieldModel<uint32_t,\
    \ 6, 1> b2bstup;\n      BitFieldModel<uint32_t, 14, 1> nyet;\n    };\n  };\n\n\
    public:\n  using otg_hs_doepint3 = Otg_hs_doepint3Reg<BaseAddress + 0x0368>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_doepint4Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n \
    \   using stup = FieldModel<uint32_t, address, 3, 1>;\n    using otepdis = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using b2bstup = FieldModel<uint32_t, address, 6, 1>;\n\
    \    using nyet = FieldModel<uint32_t, address, 14, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n\
    \      BitFieldModel<uint32_t, 1, 1> epdisd;\n      BitFieldModel<uint32_t, 3,\
    \ 1> stup;\n      BitFieldModel<uint32_t, 4, 1> otepdis;\n      BitFieldModel<uint32_t,\
    \ 6, 1> b2bstup;\n      BitFieldModel<uint32_t, 14, 1> nyet;\n    };\n  };\n\n\
    public:\n  using otg_hs_doepint4 = Otg_hs_doepint4Reg<BaseAddress + 0x0388>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_doepint5Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n \
    \   using stup = FieldModel<uint32_t, address, 3, 1>;\n    using otepdis = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using b2bstup = FieldModel<uint32_t, address, 6, 1>;\n\
    \    using nyet = FieldModel<uint32_t, address, 14, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n\
    \      BitFieldModel<uint32_t, 1, 1> epdisd;\n      BitFieldModel<uint32_t, 3,\
    \ 1> stup;\n      BitFieldModel<uint32_t, 4, 1> otepdis;\n      BitFieldModel<uint32_t,\
    \ 6, 1> b2bstup;\n      BitFieldModel<uint32_t, 14, 1> nyet;\n    };\n  };\n\n\
    public:\n  using otg_hs_doepint5 = Otg_hs_doepint5Reg<BaseAddress + 0x03A8>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_doepint6Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n \
    \   using stup = FieldModel<uint32_t, address, 3, 1>;\n    using otepdis = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using b2bstup = FieldModel<uint32_t, address, 6, 1>;\n\
    \    using nyet = FieldModel<uint32_t, address, 14, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n\
    \      BitFieldModel<uint32_t, 1, 1> epdisd;\n      BitFieldModel<uint32_t, 3,\
    \ 1> stup;\n      BitFieldModel<uint32_t, 4, 1> otepdis;\n      BitFieldModel<uint32_t,\
    \ 6, 1> b2bstup;\n      BitFieldModel<uint32_t, 14, 1> nyet;\n    };\n  };\n\n\
    public:\n  using otg_hs_doepint6 = Otg_hs_doepint6Reg<BaseAddress + 0x03C8>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_doepint7Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n \
    \   using stup = FieldModel<uint32_t, address, 3, 1>;\n    using otepdis = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using b2bstup = FieldModel<uint32_t, address, 6, 1>;\n\
    \    using nyet = FieldModel<uint32_t, address, 14, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n\
    \      BitFieldModel<uint32_t, 1, 1> epdisd;\n      BitFieldModel<uint32_t, 3,\
    \ 1> stup;\n      BitFieldModel<uint32_t, 4, 1> otepdis;\n      BitFieldModel<uint32_t,\
    \ 6, 1> b2bstup;\n      BitFieldModel<uint32_t, 14, 1> nyet;\n    };\n  };\n\n\
    public:\n  using otg_hs_doepint7 = Otg_hs_doepint7Reg<BaseAddress + 0x03E8>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Otg_hs_doeptsiz0Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz = FieldModel<uint32_t,\
    \ address, 0, 7>;\n    using pktcnt = FieldModel<uint32_t, address, 19, 1>;\n\
    \    using stupcnt = FieldModel<uint32_t, address, 29, 2>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 7> xfrsiz;\n\
    \      BitFieldModel<uint32_t, 19, 1> pktcnt;\n      BitFieldModel<uint32_t, 29,\
    \ 2> stupcnt;\n    };\n  };\n\npublic:\n  using otg_hs_doeptsiz0 = Otg_hs_doeptsiz0Reg<BaseAddress\
    \ + 0x0310>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_doeptsiz1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using rxdpid_stupcnt = FieldModel<uint32_t, address,\
    \ 29, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> rxdpid_stupcnt;\n    };\n  };\n\npublic:\n  using otg_hs_doeptsiz1 =\
    \ Otg_hs_doeptsiz1Reg<BaseAddress + 0x0330>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Otg_hs_doeptsiz2Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using xfrsiz = FieldModel<uint32_t, address, 0, 19>;\n  \
    \  using pktcnt = FieldModel<uint32_t, address, 19, 10>;\n    using rxdpid_stupcnt\
    \ = FieldModel<uint32_t, address, 29, 2>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 19> xfrsiz;\n      BitFieldModel<uint32_t,\
    \ 19, 10> pktcnt;\n      BitFieldModel<uint32_t, 29, 2> rxdpid_stupcnt;\n    };\n\
    \  };\n\npublic:\n  using otg_hs_doeptsiz2 = Otg_hs_doeptsiz2Reg<BaseAddress +\
    \ 0x0350>;\n\nprivate:\n  template<unsigned int address>\n  class Otg_hs_doeptsiz3Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using xfrsiz\
    \ = FieldModel<uint32_t, address, 0, 19>;\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    using rxdpid_stupcnt = FieldModel<uint32_t, address,\
    \ 29, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      BitFieldModel<uint32_t,\
    \ 29, 2> rxdpid_stupcnt;\n    };\n  };\n\npublic:\n  using otg_hs_doeptsiz3 =\
    \ Otg_hs_doeptsiz3Reg<BaseAddress + 0x0370>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Otg_hs_doeptsiz4Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using xfrsiz = FieldModel<uint32_t, address, 0, 19>;\n  \
    \  using pktcnt = FieldModel<uint32_t, address, 19, 10>;\n    using rxdpid_stupcnt\
    \ = FieldModel<uint32_t, address, 29, 2>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 19> xfrsiz;\n      BitFieldModel<uint32_t,\
    \ 19, 10> pktcnt;\n      BitFieldModel<uint32_t, 29, 2> rxdpid_stupcnt;\n    };\n\
    \  };\n\npublic:\n  using otg_hs_doeptsiz4 = Otg_hs_doeptsiz4Reg<BaseAddress +\
    \ 0x0390>;\n\nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n\
    \  class Otg_hs_diepctlxBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using mpsiz = FieldModel<uint32_t, address,\
    \ 0, 11, bankOffset>;\n    using usbaep = FieldModel<uint32_t, address, 15, 1,\
    \ bankOffset>;\n    using eonum_dpid = FieldModel<uint32_t, address, 16, 1, bankOffset>;\n\
    \    using naksts = FieldModel<uint32_t, address, 17, 1, bankOffset>;\n    using\
    \ eptyp = FieldModel<uint32_t, address, 18, 2, bankOffset>;\n    using stall =\
    \ FieldModel<uint32_t, address, 21, 1, bankOffset>;\n    using txfnum = FieldModel<uint32_t,\
    \ address, 22, 4, bankOffset>;\n    using cnak = FieldModel<uint32_t, address,\
    \ 26, 1, bankOffset>;\n    using snak = FieldModel<uint32_t, address, 27, 1, bankOffset>;\n\
    \    using sd0pid_sevnfrm = FieldModel<uint32_t, address, 28, 1, bankOffset>;\n\
    \    using soddfrm = FieldModel<uint32_t, address, 29, 1, bankOffset>;\n    using\
    \ epdis = FieldModel<uint32_t, address, 30, 1, bankOffset>;\n    using epena =\
    \ FieldModel<uint32_t, address, 31, 1, bankOffset>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n \
    \     BitFieldModel<uint32_t, 15, 1> usbaep;\n      BitFieldModel<uint32_t, 16,\
    \ 1> eonum_dpid;\n      BitFieldModel<uint32_t, 17, 1> naksts;\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      BitFieldModel<uint32_t, 21, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 22, 4> txfnum;\n      BitFieldModel<uint32_t, 26, 1> cnak;\n      BitFieldModel<uint32_t,\
    \ 27, 1> snak;\n      BitFieldModel<uint32_t, 28, 1> sd0pid_sevnfrm;\n      BitFieldModel<uint32_t,\
    \ 29, 1> soddfrm;\n      BitFieldModel<uint32_t, 30, 1> epdis;\n      BitFieldModel<uint32_t,\
    \ 31, 1> epena;\n    };\n  };\n\npublic:\n  using otg_hs_diepctlx = Otg_hs_diepctlxBankReg<BaseAddress\
    \ + 0x0100, 0x0020>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class Otg_hs_diepintxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1, bankOffset>;\n    using epdisd = FieldModel<uint32_t, address,\
    \ 1, 1, bankOffset>;\n    using toc = FieldModel<uint32_t, address, 3, 1, bankOffset>;\n\
    \    using ittxfe = FieldModel<uint32_t, address, 4, 1, bankOffset>;\n    using\
    \ inepne = FieldModel<uint32_t, address, 6, 1, bankOffset>;\n    using txfe =\
    \ FieldModel<uint32_t, address, 7, 1, bankOffset>;\n    using txfifoudrn = FieldModel<uint32_t,\
    \ address, 8, 1, bankOffset>;\n    using bna = FieldModel<uint32_t, address, 9,\
    \ 1, bankOffset>;\n    using pktdrpsts = FieldModel<uint32_t, address, 11, 1,\
    \ bankOffset>;\n    using berr = FieldModel<uint32_t, address, 12, 1, bankOffset>;\n\
    \    using nak = FieldModel<uint32_t, address, 13, 1, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 1> xfrc;\n      BitFieldModel<uint32_t, 1, 1> epdisd;\n      BitFieldModel<uint32_t,\
    \ 3, 1> toc;\n      BitFieldModel<uint32_t, 4, 1> ittxfe;\n      BitFieldModel<uint32_t,\
    \ 6, 1> inepne;\n      BitFieldModel<uint32_t, 7, 1> txfe;\n      BitFieldModel<uint32_t,\
    \ 8, 1> txfifoudrn;\n      BitFieldModel<uint32_t, 9, 1> bna;\n      BitFieldModel<uint32_t,\
    \ 11, 1> pktdrpsts;\n      BitFieldModel<uint32_t, 12, 1> berr;\n      BitFieldModel<uint32_t,\
    \ 13, 1> nak;\n    };\n  };\n\npublic:\n  using otg_hs_diepintx = Otg_hs_diepintxBankReg<BaseAddress\
    \ + 0x0108, 0x0020>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class Otg_hs_diepdmaxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using dmaaddr = FieldModel<uint32_t,\
    \ address, 0, 32, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      BitFieldModel<uint32_t, 0, 32> dmaaddr;\n    };\n  };\n\npublic:\n\
    \  using otg_hs_diepdmax = Otg_hs_diepdmaxBankReg<BaseAddress + 0x0114, 0x0020>;\n\
    \nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n  class\
    \ Otg_hs_dtxfstsxBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n\
    \  {\n  public:\n    using ineptfsav = FieldModel<uint32_t, address, 0, 16, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 16> ineptfsav;\n    };\n  };\n\npublic:\n  using otg_hs_dtxfstsx = Otg_hs_dtxfstsxBankReg<BaseAddress\
    \ + 0x0118, 0x0020>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class Otg_hs_dieptsizxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using xfrsiz = FieldModel<uint32_t,\
    \ address, 0, 19, bankOffset>;\n    using pktcnt = FieldModel<uint32_t, address,\
    \ 19, 10, bankOffset>;\n    using mcnt = FieldModel<uint32_t, address, 29, 2,\
    \ bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n   \
    \   BitFieldModel<uint32_t, 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19,\
    \ 10> pktcnt;\n      BitFieldModel<uint32_t, 29, 2> mcnt;\n    };\n  };\n\npublic:\n\
    \  using otg_hs_dieptsizx = Otg_hs_dieptsizxBankReg<BaseAddress + 0x0130, 0x0020>;\n\
    \nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n  class\
    \ Otg_hs_doepctlxBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n\
    \  {\n  public:\n    using mpsiz = FieldModel<uint32_t, address, 0, 11, bankOffset>;\n\
    \    using usbaep = FieldModel<uint32_t, address, 15, 1, bankOffset>;\n    using\
    \ eonum_dpid = FieldModel<uint32_t, address, 16, 1, bankOffset>;\n    using naksts\
    \ = FieldModel<uint32_t, address, 17, 1, bankOffset>;\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2, bankOffset>;\n    using snpm = FieldModel<uint32_t, address,\
    \ 20, 1, bankOffset>;\n    using stall = FieldModel<uint32_t, address, 21, 1,\
    \ bankOffset>;\n    using cnak = FieldModel<uint32_t, address, 26, 1, bankOffset>;\n\
    \    using snak = FieldModel<uint32_t, address, 27, 1, bankOffset>;\n    using\
    \ sd0pid_sevnfrm = FieldModel<uint32_t, address, 28, 1, bankOffset>;\n    using\
    \ soddfrm = FieldModel<uint32_t, address, 29, 1, bankOffset>;\n    using epdis\
    \ = FieldModel<uint32_t, address, 30, 1, bankOffset>;\n    using epena = FieldModel<uint32_t,\
    \ address, 31, 1, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n      BitFieldModel<uint32_t,\
    \ 15, 1> usbaep;\n      BitFieldModel<uint32_t, 16, 1> eonum_dpid;\n      BitFieldModel<uint32_t,\
    \ 17, 1> naksts;\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      BitFieldModel<uint32_t,\
    \ 20, 1> snpm;\n      BitFieldModel<uint32_t, 21, 1> stall;\n      BitFieldModel<uint32_t,\
    \ 26, 1> cnak;\n      BitFieldModel<uint32_t, 27, 1> snak;\n      BitFieldModel<uint32_t,\
    \ 28, 1> sd0pid_sevnfrm;\n      BitFieldModel<uint32_t, 29, 1> soddfrm;\n    \
    \  BitFieldModel<uint32_t, 30, 1> epdis;\n      BitFieldModel<uint32_t, 31, 1>\
    \ epena;\n    };\n  };\n\npublic:\n  using otg_hs_doepctlx = Otg_hs_doepctlxBankReg<BaseAddress\
    \ + 0x0320, 0x0020>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class Otg_hs_doepintxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1, bankOffset>;\n    using epdisd = FieldModel<uint32_t, address,\
    \ 1, 1, bankOffset>;\n    using stup = FieldModel<uint32_t, address, 3, 1, bankOffset>;\n\
    \    using otepdis = FieldModel<uint32_t, address, 4, 1, bankOffset>;\n    using\
    \ b2bstup = FieldModel<uint32_t, address, 6, 1, bankOffset>;\n    using nyet =\
    \ FieldModel<uint32_t, address, 14, 1, bankOffset>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n   \
    \   BitFieldModel<uint32_t, 1, 1> epdisd;\n      BitFieldModel<uint32_t, 3, 1>\
    \ stup;\n      BitFieldModel<uint32_t, 4, 1> otepdis;\n      BitFieldModel<uint32_t,\
    \ 6, 1> b2bstup;\n      BitFieldModel<uint32_t, 14, 1> nyet;\n    };\n  };\n\n\
    public:\n  using otg_hs_doepintx = Otg_hs_doepintxBankReg<BaseAddress + 0x0308,\
    \ 0x0020>;\n\nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n\
    \  class Otg_hs_doeptsizxBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using xfrsiz = FieldModel<uint32_t, address,\
    \ 0, 19, bankOffset>;\n    using pktcnt = FieldModel<uint32_t, address, 19, 10,\
    \ bankOffset>;\n    using rxdpid_stupcnt = FieldModel<uint32_t, address, 29, 2,\
    \ bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n   \
    \   BitFieldModel<uint32_t, 0, 19> xfrsiz;\n      BitFieldModel<uint32_t, 19,\
    \ 10> pktcnt;\n      BitFieldModel<uint32_t, 29, 2> rxdpid_stupcnt;\n    };\n\
    \  };\n\npublic:\n  using otg_hs_doeptsizx = Otg_hs_doeptsizxBankReg<BaseAddress\
    \ + 0x0330, 0x0020>;\n};\n\n}\n\n#endif /* DRAL_STM32F446_OTG_HS_DEVICE_H */\n"
  name: OTG_HS_DEVICE
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_OTG_HS_PWRCLK_H\n#define DRAL_STM32F446_OTG_HS_PWRCLK_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass otg_hs_pwrclk\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40040E00;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Otg_hs_pcgcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using stppclk = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    using gatehclk = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ physusp = FieldModel<uint32_t, address, 4, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> stppclk;\n\
    \      BitFieldModel<uint32_t, 1, 1> gatehclk;\n      BitFieldModel<uint32_t,\
    \ 4, 1> physusp;\n    };\n  };\n\npublic:\n  using otg_hs_pcgcr = Otg_hs_pcgcrReg<BaseAddress\
    \ + 0x0000>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_OTG_HS_PWRCLK_H */\n"
  name: OTG_HS_PWRCLK
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_SAI1_H\n#define DRAL_STM32F446_SAI1_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass sai1\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40015800;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Bcr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using mcjdiv = FieldModel<uint32_t, address, 20,\
    \ 4>;\n    using nodiv = FieldModel<uint32_t, address, 19, 1>;\n    using dmaen\
    \ = FieldModel<uint32_t, address, 17, 1>;\n    using saiben = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using outdri = FieldModel<uint32_t, address, 13, 1>;\n\
    \    using mono = FieldModel<uint32_t, address, 12, 1>;\n    using syncen = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    using ckstr = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using lsbfirst = FieldModel<uint32_t, address, 8, 1>;\n    using ds = FieldModel<uint32_t,\
    \ address, 5, 3>;\n    using prtcfg = FieldModel<uint32_t, address, 2, 2>;\n \
    \   using mode = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 20, 4> mcjdiv;\n\
    \      BitFieldModel<uint32_t, 19, 1> nodiv;\n      BitFieldModel<uint32_t, 17,\
    \ 1> dmaen;\n      BitFieldModel<uint32_t, 16, 1> saiben;\n      BitFieldModel<uint32_t,\
    \ 13, 1> outdri;\n      BitFieldModel<uint32_t, 12, 1> mono;\n      BitFieldModel<uint32_t,\
    \ 10, 2> syncen;\n      BitFieldModel<uint32_t, 9, 1> ckstr;\n      BitFieldModel<uint32_t,\
    \ 8, 1> lsbfirst;\n      BitFieldModel<uint32_t, 5, 3> ds;\n      BitFieldModel<uint32_t,\
    \ 2, 2> prtcfg;\n      BitFieldModel<uint32_t, 0, 2> mode;\n    };\n  };\n\npublic:\n\
    \  using bcr1 = Bcr1Reg<BaseAddress + 0x0024>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Bcr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using comp = FieldModel<uint32_t, address, 14, 2>;\n    using\
    \ cpl = FieldModel<uint32_t, address, 13, 1>;\n    using mutecn = FieldModel<uint32_t,\
    \ address, 7, 6>;\n    using muteval = FieldModel<uint32_t, address, 6, 1>;\n\
    \    using mute = FieldModel<uint32_t, address, 5, 1>;\n    using tris = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using fflus = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using fth = FieldModel<uint32_t, address, 0, 3>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 14, 2> comp;\n  \
    \    BitFieldModel<uint32_t, 13, 1> cpl;\n      BitFieldModel<uint32_t, 7, 6>\
    \ mutecn;\n      BitFieldModel<uint32_t, 6, 1> muteval;\n      BitFieldModel<uint32_t,\
    \ 5, 1> mute;\n      BitFieldModel<uint32_t, 4, 1> tris;\n      BitFieldModel<uint32_t,\
    \ 3, 1> fflus;\n      BitFieldModel<uint32_t, 0, 3> fth;\n    };\n  };\n\npublic:\n\
    \  using bcr2 = Bcr2Reg<BaseAddress + 0x0028>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class BfrcrReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fsoff = FieldModel<uint32_t, address, 18, 1>;\n    using\
    \ fspol = FieldModel<uint32_t, address, 17, 1>;\n    using fsdef = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using fsall = FieldModel<uint32_t, address, 8, 7>;\n \
    \   using frl = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 18, 1> fsoff;\n \
    \     BitFieldModel<uint32_t, 17, 1> fspol;\n      BitFieldModel<uint32_t, 16,\
    \ 1> fsdef;\n      BitFieldModel<uint32_t, 8, 7> fsall;\n      BitFieldModel<uint32_t,\
    \ 0, 8> frl;\n    };\n  };\n\npublic:\n  using bfrcr = BfrcrReg<BaseAddress +\
    \ 0x002C>;\n\nprivate:\n  template<unsigned int address>\n  class BslotrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using sloten =\
    \ FieldModel<uint32_t, address, 16, 16>;\n    using nbslot = FieldModel<uint32_t,\
    \ address, 8, 4>;\n    using slotsz = FieldModel<uint32_t, address, 6, 2>;\n \
    \   using fboff = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16, 16> sloten;\n\
    \      BitFieldModel<uint32_t, 8, 4> nbslot;\n      BitFieldModel<uint32_t, 6,\
    \ 2> slotsz;\n      BitFieldModel<uint32_t, 0, 5> fboff;\n    };\n  };\n\npublic:\n\
    \  using bslotr = BslotrReg<BaseAddress + 0x0030>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class BimReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using lfsdetie = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ afsdetie = FieldModel<uint32_t, address, 5, 1>;\n    using cnrdyie = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using freqie = FieldModel<uint32_t, address, 3, 1>;\n \
    \   using wckcfg = FieldModel<uint32_t, address, 2, 1>;\n    using mutedet = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ovrudrie = FieldModel<uint32_t, address, 0, 1>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 6, 1> lfsdetie;\n      BitFieldModel<uint32_t, 5, 1> afsdetie;\n      BitFieldModel<uint32_t,\
    \ 4, 1> cnrdyie;\n      BitFieldModel<uint32_t, 3, 1> freqie;\n      BitFieldModel<uint32_t,\
    \ 2, 1> wckcfg;\n      BitFieldModel<uint32_t, 1, 1> mutedet;\n      BitFieldModel<uint32_t,\
    \ 0, 1> ovrudrie;\n    };\n  };\n\npublic:\n  using bim = BimReg<BaseAddress +\
    \ 0x0034>;\n\nprivate:\n  template<unsigned int address>\n  class BsrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using flvl = FieldModel<uint32_t,\
    \ address, 16, 3>;\n    using lfsdet = FieldModel<uint32_t, address, 6, 1>;\n\
    \    using afsdet = FieldModel<uint32_t, address, 5, 1>;\n    using cnrdy = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using freq = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using wckcfg = FieldModel<uint32_t, address, 2, 1>;\n    using mutedet = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ovrudr = FieldModel<uint32_t, address, 0, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 16, 3> flvl;\n      BitFieldModel<uint32_t, 6, 1> lfsdet;\n      BitFieldModel<uint32_t,\
    \ 5, 1> afsdet;\n      BitFieldModel<uint32_t, 4, 1> cnrdy;\n      BitFieldModel<uint32_t,\
    \ 3, 1> freq;\n      BitFieldModel<uint32_t, 2, 1> wckcfg;\n      BitFieldModel<uint32_t,\
    \ 1, 1> mutedet;\n      BitFieldModel<uint32_t, 0, 1> ovrudr;\n    };\n  };\n\n\
    public:\n  using bsr = BsrReg<BaseAddress + 0x0038>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class BclrfrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using lfsdet = FieldModel<uint32_t, address, 6, 1>;\n   \
    \ using cafsdet = FieldModel<uint32_t, address, 5, 1>;\n    using cnrdy = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using wckcfg = FieldModel<uint32_t, address, 2, 1>;\n \
    \   using mutedet = FieldModel<uint32_t, address, 1, 1>;\n    using ovrudr = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 6, 1> lfsdet;\n      BitFieldModel<uint32_t, 5,\
    \ 1> cafsdet;\n      BitFieldModel<uint32_t, 4, 1> cnrdy;\n      BitFieldModel<uint32_t,\
    \ 2, 1> wckcfg;\n      BitFieldModel<uint32_t, 1, 1> mutedet;\n      BitFieldModel<uint32_t,\
    \ 0, 1> ovrudr;\n    };\n  };\n\npublic:\n  using bclrfr = BclrfrReg<BaseAddress\
    \ + 0x003C>;\n\nprivate:\n  template<unsigned int address>\n  class BdrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using data = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> data;\n    };\n  };\n\npublic:\n  using\
    \ bdr = BdrReg<BaseAddress + 0x0040>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Acr1Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   using mcjdiv = FieldModel<uint32_t, address, 20, 4>;\n    using nodiv = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using dmaen = FieldModel<uint32_t, address, 17, 1>;\n\
    \    using saiaen = FieldModel<uint32_t, address, 16, 1>;\n    using outdri =\
    \ FieldModel<uint32_t, address, 13, 1>;\n    using mono = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using syncen = FieldModel<uint32_t, address, 10, 2>;\n\
    \    using ckstr = FieldModel<uint32_t, address, 9, 1>;\n    using lsbfirst =\
    \ FieldModel<uint32_t, address, 8, 1>;\n    using ds = FieldModel<uint32_t, address,\
    \ 5, 3>;\n    using prtcfg = FieldModel<uint32_t, address, 2, 2>;\n    using mode\
    \ = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 20, 4> mcjdiv;\n      BitFieldModel<uint32_t,\
    \ 19, 1> nodiv;\n      BitFieldModel<uint32_t, 17, 1> dmaen;\n      BitFieldModel<uint32_t,\
    \ 16, 1> saiaen;\n      BitFieldModel<uint32_t, 13, 1> outdri;\n      BitFieldModel<uint32_t,\
    \ 12, 1> mono;\n      BitFieldModel<uint32_t, 10, 2> syncen;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ckstr;\n      BitFieldModel<uint32_t, 8, 1> lsbfirst;\n      BitFieldModel<uint32_t,\
    \ 5, 3> ds;\n      BitFieldModel<uint32_t, 2, 2> prtcfg;\n      BitFieldModel<uint32_t,\
    \ 0, 2> mode;\n    };\n  };\n\npublic:\n  using acr1 = Acr1Reg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Acr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using comp = FieldModel<uint32_t, address, 14,\
    \ 2>;\n    using cpl = FieldModel<uint32_t, address, 13, 1>;\n    using mutecn\
    \ = FieldModel<uint32_t, address, 7, 6>;\n    using muteval = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using mute = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using tris = FieldModel<uint32_t, address, 4, 1>;\n    using fflus = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using fth = FieldModel<uint32_t, address, 0, 3>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 14,\
    \ 2> comp;\n      BitFieldModel<uint32_t, 13, 1> cpl;\n      BitFieldModel<uint32_t,\
    \ 7, 6> mutecn;\n      BitFieldModel<uint32_t, 6, 1> muteval;\n      BitFieldModel<uint32_t,\
    \ 5, 1> mute;\n      BitFieldModel<uint32_t, 4, 1> tris;\n      BitFieldModel<uint32_t,\
    \ 3, 1> fflus;\n      BitFieldModel<uint32_t, 0, 3> fth;\n    };\n  };\n\npublic:\n\
    \  using acr2 = Acr2Reg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class AfrcrReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fsoff = FieldModel<uint32_t, address, 18, 1>;\n    using\
    \ fspol = FieldModel<uint32_t, address, 17, 1>;\n    using fsdef = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using fsall = FieldModel<uint32_t, address, 8, 7>;\n \
    \   using frl = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 18, 1> fsoff;\n \
    \     BitFieldModel<uint32_t, 17, 1> fspol;\n      BitFieldModel<uint32_t, 16,\
    \ 1> fsdef;\n      BitFieldModel<uint32_t, 8, 7> fsall;\n      BitFieldModel<uint32_t,\
    \ 0, 8> frl;\n    };\n  };\n\npublic:\n  using afrcr = AfrcrReg<BaseAddress +\
    \ 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class AslotrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using sloten =\
    \ FieldModel<uint32_t, address, 16, 16>;\n    using nbslot = FieldModel<uint32_t,\
    \ address, 8, 4>;\n    using slotsz = FieldModel<uint32_t, address, 6, 2>;\n \
    \   using fboff = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16, 16> sloten;\n\
    \      BitFieldModel<uint32_t, 8, 4> nbslot;\n      BitFieldModel<uint32_t, 6,\
    \ 2> slotsz;\n      BitFieldModel<uint32_t, 0, 5> fboff;\n    };\n  };\n\npublic:\n\
    \  using aslotr = AslotrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class AimReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using lfsdet = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ afsdetie = FieldModel<uint32_t, address, 5, 1>;\n    using cnrdyie = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using freqie = FieldModel<uint32_t, address, 3, 1>;\n \
    \   using wckcfg = FieldModel<uint32_t, address, 2, 1>;\n    using mutedet = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ovrudrie = FieldModel<uint32_t, address, 0, 1>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 6, 1> lfsdet;\n      BitFieldModel<uint32_t, 5, 1> afsdetie;\n      BitFieldModel<uint32_t,\
    \ 4, 1> cnrdyie;\n      BitFieldModel<uint32_t, 3, 1> freqie;\n      BitFieldModel<uint32_t,\
    \ 2, 1> wckcfg;\n      BitFieldModel<uint32_t, 1, 1> mutedet;\n      BitFieldModel<uint32_t,\
    \ 0, 1> ovrudrie;\n    };\n  };\n\npublic:\n  using aim = AimReg<BaseAddress +\
    \ 0x0014>;\n\nprivate:\n  template<unsigned int address>\n  class AsrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using flvl = FieldModel<uint32_t,\
    \ address, 16, 3>;\n    using lfsdet = FieldModel<uint32_t, address, 6, 1>;\n\
    \    using afsdet = FieldModel<uint32_t, address, 5, 1>;\n    using cnrdy = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using freq = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using wckcfg = FieldModel<uint32_t, address, 2, 1>;\n    using mutedet = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ovrudr = FieldModel<uint32_t, address, 0, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 16, 3> flvl;\n      BitFieldModel<uint32_t, 6, 1> lfsdet;\n      BitFieldModel<uint32_t,\
    \ 5, 1> afsdet;\n      BitFieldModel<uint32_t, 4, 1> cnrdy;\n      BitFieldModel<uint32_t,\
    \ 3, 1> freq;\n      BitFieldModel<uint32_t, 2, 1> wckcfg;\n      BitFieldModel<uint32_t,\
    \ 1, 1> mutedet;\n      BitFieldModel<uint32_t, 0, 1> ovrudr;\n    };\n  };\n\n\
    public:\n  using asr = AsrReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class AclrfrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using lfsdet = FieldModel<uint32_t, address, 6, 1>;\n   \
    \ using cafsdet = FieldModel<uint32_t, address, 5, 1>;\n    using cnrdy = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using wckcfg = FieldModel<uint32_t, address, 2, 1>;\n \
    \   using mutedet = FieldModel<uint32_t, address, 1, 1>;\n    using ovrudr = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 6, 1> lfsdet;\n      BitFieldModel<uint32_t, 5,\
    \ 1> cafsdet;\n      BitFieldModel<uint32_t, 4, 1> cnrdy;\n      BitFieldModel<uint32_t,\
    \ 2, 1> wckcfg;\n      BitFieldModel<uint32_t, 1, 1> mutedet;\n      BitFieldModel<uint32_t,\
    \ 0, 1> ovrudr;\n    };\n  };\n\npublic:\n  using aclrfr = AclrfrReg<BaseAddress\
    \ + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class AdrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using data = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> data;\n    };\n  };\n\npublic:\n  using\
    \ adr = AdrReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class GcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  using syncin = FieldModel<uint32_t, address, 0, 2>;\n    using syncout = FieldModel<uint32_t,\
    \ address, 4, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 2> syncin;\n      BitFieldModel<uint32_t, 4,\
    \ 2> syncout;\n    };\n  };\n\npublic:\n  using gcr = GcrReg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n  class\
    \ Xcr2BankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n\
    \  public:\n    using comp = FieldModel<uint32_t, address, 14, 2, bankOffset>;\n\
    \    using cpl = FieldModel<uint32_t, address, 13, 1, bankOffset>;\n    using\
    \ mutecn = FieldModel<uint32_t, address, 7, 6, bankOffset>;\n    using muteval\
    \ = FieldModel<uint32_t, address, 6, 1, bankOffset>;\n    using mute = FieldModel<uint32_t,\
    \ address, 5, 1, bankOffset>;\n    using tris = FieldModel<uint32_t, address,\
    \ 4, 1, bankOffset>;\n    using fflus = FieldModel<uint32_t, address, 3, 1, bankOffset>;\n\
    \    using fth = FieldModel<uint32_t, address, 0, 3, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 14,\
    \ 2> comp;\n      BitFieldModel<uint32_t, 13, 1> cpl;\n      BitFieldModel<uint32_t,\
    \ 7, 6> mutecn;\n      BitFieldModel<uint32_t, 6, 1> muteval;\n      BitFieldModel<uint32_t,\
    \ 5, 1> mute;\n      BitFieldModel<uint32_t, 4, 1> tris;\n      BitFieldModel<uint32_t,\
    \ 3, 1> fflus;\n      BitFieldModel<uint32_t, 0, 3> fth;\n    };\n  };\n\npublic:\n\
    \  using xcr2 = Xcr2BankReg<BaseAddress + 0x0008, 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class XfrcrBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using fsoff = FieldModel<uint32_t,\
    \ address, 18, 1, bankOffset>;\n    using fspol = FieldModel<uint32_t, address,\
    \ 17, 1, bankOffset>;\n    using fsdef = FieldModel<uint32_t, address, 16, 1,\
    \ bankOffset>;\n    using fsall = FieldModel<uint32_t, address, 8, 7, bankOffset>;\n\
    \    using frl = FieldModel<uint32_t, address, 0, 8, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 18,\
    \ 1> fsoff;\n      BitFieldModel<uint32_t, 17, 1> fspol;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fsdef;\n      BitFieldModel<uint32_t, 8, 7> fsall;\n      BitFieldModel<uint32_t,\
    \ 0, 8> frl;\n    };\n  };\n\npublic:\n  using xfrcr = XfrcrBankReg<BaseAddress\
    \ + 0x000C, 0x0020>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class XslotrBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using sloten = FieldModel<uint32_t, address,\
    \ 16, 16, bankOffset>;\n    using nbslot = FieldModel<uint32_t, address, 8, 4,\
    \ bankOffset>;\n    using slotsz = FieldModel<uint32_t, address, 6, 2, bankOffset>;\n\
    \    using fboff = FieldModel<uint32_t, address, 0, 5, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16,\
    \ 16> sloten;\n      BitFieldModel<uint32_t, 8, 4> nbslot;\n      BitFieldModel<uint32_t,\
    \ 6, 2> slotsz;\n      BitFieldModel<uint32_t, 0, 5> fboff;\n    };\n  };\n\n\
    public:\n  using xslotr = XslotrBankReg<BaseAddress + 0x0010, 0x0020>;\n\nprivate:\n\
    \  template<unsigned int address, unsigned int bankOffset>\n  class XsrBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    using flvl = FieldModel<uint32_t, address, 16, 3, bankOffset>;\n    using\
    \ lfsdet = FieldModel<uint32_t, address, 6, 1, bankOffset>;\n    using afsdet\
    \ = FieldModel<uint32_t, address, 5, 1, bankOffset>;\n    using cnrdy = FieldModel<uint32_t,\
    \ address, 4, 1, bankOffset>;\n    using freq = FieldModel<uint32_t, address,\
    \ 3, 1, bankOffset>;\n    using wckcfg = FieldModel<uint32_t, address, 2, 1, bankOffset>;\n\
    \    using mutedet = FieldModel<uint32_t, address, 1, 1, bankOffset>;\n    using\
    \ ovrudr = FieldModel<uint32_t, address, 0, 1, bankOffset>;\n\n  public:\n   \
    \ union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16, 3>\
    \ flvl;\n      BitFieldModel<uint32_t, 6, 1> lfsdet;\n      BitFieldModel<uint32_t,\
    \ 5, 1> afsdet;\n      BitFieldModel<uint32_t, 4, 1> cnrdy;\n      BitFieldModel<uint32_t,\
    \ 3, 1> freq;\n      BitFieldModel<uint32_t, 2, 1> wckcfg;\n      BitFieldModel<uint32_t,\
    \ 1, 1> mutedet;\n      BitFieldModel<uint32_t, 0, 1> ovrudr;\n    };\n  };\n\n\
    public:\n  using xsr = XsrBankReg<BaseAddress + 0x0018, 0x0020>;\n\nprivate:\n\
    \  template<unsigned int address, unsigned int bankOffset>\n  class XclrfrBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    using lfsdet = FieldModel<uint32_t, address, 6, 1, bankOffset>;\n    using\
    \ cafsdet = FieldModel<uint32_t, address, 5, 1, bankOffset>;\n    using cnrdy\
    \ = FieldModel<uint32_t, address, 4, 1, bankOffset>;\n    using wckcfg = FieldModel<uint32_t,\
    \ address, 2, 1, bankOffset>;\n    using mutedet = FieldModel<uint32_t, address,\
    \ 1, 1, bankOffset>;\n    using ovrudr = FieldModel<uint32_t, address, 0, 1, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 6, 1> lfsdet;\n      BitFieldModel<uint32_t, 5, 1> cafsdet;\n      BitFieldModel<uint32_t,\
    \ 4, 1> cnrdy;\n      BitFieldModel<uint32_t, 2, 1> wckcfg;\n      BitFieldModel<uint32_t,\
    \ 1, 1> mutedet;\n      BitFieldModel<uint32_t, 0, 1> ovrudr;\n    };\n  };\n\n\
    public:\n  using xclrfr = XclrfrBankReg<BaseAddress + 0x001C, 0x0020>;\n\nprivate:\n\
    \  template<unsigned int address, unsigned int bankOffset>\n  class XdrBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    using data = FieldModel<uint32_t, address, 0, 32, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 32> data;\n    };\n  };\n\npublic:\n  using xdr = XdrBankReg<BaseAddress + 0x0020,\
    \ 0x0020>;\n};\n\n}\n\n#endif /* DRAL_STM32F446_SAI1_H */\n"
  name: SAI1
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_SAI2_H\n#define DRAL_STM32F446_SAI2_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass sai2\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40015C00;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Bcr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using mcjdiv = FieldModel<uint32_t, address, 20,\
    \ 4>;\n    using nodiv = FieldModel<uint32_t, address, 19, 1>;\n    using dmaen\
    \ = FieldModel<uint32_t, address, 17, 1>;\n    using saiben = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using outdri = FieldModel<uint32_t, address, 13, 1>;\n\
    \    using mono = FieldModel<uint32_t, address, 12, 1>;\n    using syncen = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    using ckstr = FieldModel<uint32_t, address, 9, 1>;\n \
    \   using lsbfirst = FieldModel<uint32_t, address, 8, 1>;\n    using ds = FieldModel<uint32_t,\
    \ address, 5, 3>;\n    using prtcfg = FieldModel<uint32_t, address, 2, 2>;\n \
    \   using mode = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 20, 4> mcjdiv;\n\
    \      BitFieldModel<uint32_t, 19, 1> nodiv;\n      BitFieldModel<uint32_t, 17,\
    \ 1> dmaen;\n      BitFieldModel<uint32_t, 16, 1> saiben;\n      BitFieldModel<uint32_t,\
    \ 13, 1> outdri;\n      BitFieldModel<uint32_t, 12, 1> mono;\n      BitFieldModel<uint32_t,\
    \ 10, 2> syncen;\n      BitFieldModel<uint32_t, 9, 1> ckstr;\n      BitFieldModel<uint32_t,\
    \ 8, 1> lsbfirst;\n      BitFieldModel<uint32_t, 5, 3> ds;\n      BitFieldModel<uint32_t,\
    \ 2, 2> prtcfg;\n      BitFieldModel<uint32_t, 0, 2> mode;\n    };\n  };\n\npublic:\n\
    \  using bcr1 = Bcr1Reg<BaseAddress + 0x0024>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Bcr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using comp = FieldModel<uint32_t, address, 14, 2>;\n    using\
    \ cpl = FieldModel<uint32_t, address, 13, 1>;\n    using mutecn = FieldModel<uint32_t,\
    \ address, 7, 6>;\n    using muteval = FieldModel<uint32_t, address, 6, 1>;\n\
    \    using mute = FieldModel<uint32_t, address, 5, 1>;\n    using tris = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using fflus = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using fth = FieldModel<uint32_t, address, 0, 3>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 14, 2> comp;\n  \
    \    BitFieldModel<uint32_t, 13, 1> cpl;\n      BitFieldModel<uint32_t, 7, 6>\
    \ mutecn;\n      BitFieldModel<uint32_t, 6, 1> muteval;\n      BitFieldModel<uint32_t,\
    \ 5, 1> mute;\n      BitFieldModel<uint32_t, 4, 1> tris;\n      BitFieldModel<uint32_t,\
    \ 3, 1> fflus;\n      BitFieldModel<uint32_t, 0, 3> fth;\n    };\n  };\n\npublic:\n\
    \  using bcr2 = Bcr2Reg<BaseAddress + 0x0028>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class BfrcrReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fsoff = FieldModel<uint32_t, address, 18, 1>;\n    using\
    \ fspol = FieldModel<uint32_t, address, 17, 1>;\n    using fsdef = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using fsall = FieldModel<uint32_t, address, 8, 7>;\n \
    \   using frl = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 18, 1> fsoff;\n \
    \     BitFieldModel<uint32_t, 17, 1> fspol;\n      BitFieldModel<uint32_t, 16,\
    \ 1> fsdef;\n      BitFieldModel<uint32_t, 8, 7> fsall;\n      BitFieldModel<uint32_t,\
    \ 0, 8> frl;\n    };\n  };\n\npublic:\n  using bfrcr = BfrcrReg<BaseAddress +\
    \ 0x002C>;\n\nprivate:\n  template<unsigned int address>\n  class BslotrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using sloten =\
    \ FieldModel<uint32_t, address, 16, 16>;\n    using nbslot = FieldModel<uint32_t,\
    \ address, 8, 4>;\n    using slotsz = FieldModel<uint32_t, address, 6, 2>;\n \
    \   using fboff = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16, 16> sloten;\n\
    \      BitFieldModel<uint32_t, 8, 4> nbslot;\n      BitFieldModel<uint32_t, 6,\
    \ 2> slotsz;\n      BitFieldModel<uint32_t, 0, 5> fboff;\n    };\n  };\n\npublic:\n\
    \  using bslotr = BslotrReg<BaseAddress + 0x0030>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class BimReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using lfsdetie = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ afsdetie = FieldModel<uint32_t, address, 5, 1>;\n    using cnrdyie = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using freqie = FieldModel<uint32_t, address, 3, 1>;\n \
    \   using wckcfg = FieldModel<uint32_t, address, 2, 1>;\n    using mutedet = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ovrudrie = FieldModel<uint32_t, address, 0, 1>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 6, 1> lfsdetie;\n      BitFieldModel<uint32_t, 5, 1> afsdetie;\n      BitFieldModel<uint32_t,\
    \ 4, 1> cnrdyie;\n      BitFieldModel<uint32_t, 3, 1> freqie;\n      BitFieldModel<uint32_t,\
    \ 2, 1> wckcfg;\n      BitFieldModel<uint32_t, 1, 1> mutedet;\n      BitFieldModel<uint32_t,\
    \ 0, 1> ovrudrie;\n    };\n  };\n\npublic:\n  using bim = BimReg<BaseAddress +\
    \ 0x0034>;\n\nprivate:\n  template<unsigned int address>\n  class BsrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using flvl = FieldModel<uint32_t,\
    \ address, 16, 3>;\n    using lfsdet = FieldModel<uint32_t, address, 6, 1>;\n\
    \    using afsdet = FieldModel<uint32_t, address, 5, 1>;\n    using cnrdy = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using freq = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using wckcfg = FieldModel<uint32_t, address, 2, 1>;\n    using mutedet = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ovrudr = FieldModel<uint32_t, address, 0, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 16, 3> flvl;\n      BitFieldModel<uint32_t, 6, 1> lfsdet;\n      BitFieldModel<uint32_t,\
    \ 5, 1> afsdet;\n      BitFieldModel<uint32_t, 4, 1> cnrdy;\n      BitFieldModel<uint32_t,\
    \ 3, 1> freq;\n      BitFieldModel<uint32_t, 2, 1> wckcfg;\n      BitFieldModel<uint32_t,\
    \ 1, 1> mutedet;\n      BitFieldModel<uint32_t, 0, 1> ovrudr;\n    };\n  };\n\n\
    public:\n  using bsr = BsrReg<BaseAddress + 0x0038>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class BclrfrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using lfsdet = FieldModel<uint32_t, address, 6, 1>;\n   \
    \ using cafsdet = FieldModel<uint32_t, address, 5, 1>;\n    using cnrdy = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using wckcfg = FieldModel<uint32_t, address, 2, 1>;\n \
    \   using mutedet = FieldModel<uint32_t, address, 1, 1>;\n    using ovrudr = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 6, 1> lfsdet;\n      BitFieldModel<uint32_t, 5,\
    \ 1> cafsdet;\n      BitFieldModel<uint32_t, 4, 1> cnrdy;\n      BitFieldModel<uint32_t,\
    \ 2, 1> wckcfg;\n      BitFieldModel<uint32_t, 1, 1> mutedet;\n      BitFieldModel<uint32_t,\
    \ 0, 1> ovrudr;\n    };\n  };\n\npublic:\n  using bclrfr = BclrfrReg<BaseAddress\
    \ + 0x003C>;\n\nprivate:\n  template<unsigned int address>\n  class BdrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using data = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> data;\n    };\n  };\n\npublic:\n  using\
    \ bdr = BdrReg<BaseAddress + 0x0040>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Acr1Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   using mcjdiv = FieldModel<uint32_t, address, 20, 4>;\n    using nodiv = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using dmaen = FieldModel<uint32_t, address, 17, 1>;\n\
    \    using saiaen = FieldModel<uint32_t, address, 16, 1>;\n    using outdri =\
    \ FieldModel<uint32_t, address, 13, 1>;\n    using mono = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using syncen = FieldModel<uint32_t, address, 10, 2>;\n\
    \    using ckstr = FieldModel<uint32_t, address, 9, 1>;\n    using lsbfirst =\
    \ FieldModel<uint32_t, address, 8, 1>;\n    using ds = FieldModel<uint32_t, address,\
    \ 5, 3>;\n    using prtcfg = FieldModel<uint32_t, address, 2, 2>;\n    using mode\
    \ = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 20, 4> mcjdiv;\n      BitFieldModel<uint32_t,\
    \ 19, 1> nodiv;\n      BitFieldModel<uint32_t, 17, 1> dmaen;\n      BitFieldModel<uint32_t,\
    \ 16, 1> saiaen;\n      BitFieldModel<uint32_t, 13, 1> outdri;\n      BitFieldModel<uint32_t,\
    \ 12, 1> mono;\n      BitFieldModel<uint32_t, 10, 2> syncen;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ckstr;\n      BitFieldModel<uint32_t, 8, 1> lsbfirst;\n      BitFieldModel<uint32_t,\
    \ 5, 3> ds;\n      BitFieldModel<uint32_t, 2, 2> prtcfg;\n      BitFieldModel<uint32_t,\
    \ 0, 2> mode;\n    };\n  };\n\npublic:\n  using acr1 = Acr1Reg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Acr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using comp = FieldModel<uint32_t, address, 14,\
    \ 2>;\n    using cpl = FieldModel<uint32_t, address, 13, 1>;\n    using mutecn\
    \ = FieldModel<uint32_t, address, 7, 6>;\n    using muteval = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using mute = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using tris = FieldModel<uint32_t, address, 4, 1>;\n    using fflus = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using fth = FieldModel<uint32_t, address, 0, 3>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 14,\
    \ 2> comp;\n      BitFieldModel<uint32_t, 13, 1> cpl;\n      BitFieldModel<uint32_t,\
    \ 7, 6> mutecn;\n      BitFieldModel<uint32_t, 6, 1> muteval;\n      BitFieldModel<uint32_t,\
    \ 5, 1> mute;\n      BitFieldModel<uint32_t, 4, 1> tris;\n      BitFieldModel<uint32_t,\
    \ 3, 1> fflus;\n      BitFieldModel<uint32_t, 0, 3> fth;\n    };\n  };\n\npublic:\n\
    \  using acr2 = Acr2Reg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class AfrcrReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using fsoff = FieldModel<uint32_t, address, 18, 1>;\n    using\
    \ fspol = FieldModel<uint32_t, address, 17, 1>;\n    using fsdef = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using fsall = FieldModel<uint32_t, address, 8, 7>;\n \
    \   using frl = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 18, 1> fsoff;\n \
    \     BitFieldModel<uint32_t, 17, 1> fspol;\n      BitFieldModel<uint32_t, 16,\
    \ 1> fsdef;\n      BitFieldModel<uint32_t, 8, 7> fsall;\n      BitFieldModel<uint32_t,\
    \ 0, 8> frl;\n    };\n  };\n\npublic:\n  using afrcr = AfrcrReg<BaseAddress +\
    \ 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class AslotrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using sloten =\
    \ FieldModel<uint32_t, address, 16, 16>;\n    using nbslot = FieldModel<uint32_t,\
    \ address, 8, 4>;\n    using slotsz = FieldModel<uint32_t, address, 6, 2>;\n \
    \   using fboff = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16, 16> sloten;\n\
    \      BitFieldModel<uint32_t, 8, 4> nbslot;\n      BitFieldModel<uint32_t, 6,\
    \ 2> slotsz;\n      BitFieldModel<uint32_t, 0, 5> fboff;\n    };\n  };\n\npublic:\n\
    \  using aslotr = AslotrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class AimReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using lfsdet = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ afsdetie = FieldModel<uint32_t, address, 5, 1>;\n    using cnrdyie = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using freqie = FieldModel<uint32_t, address, 3, 1>;\n \
    \   using wckcfg = FieldModel<uint32_t, address, 2, 1>;\n    using mutedet = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ovrudrie = FieldModel<uint32_t, address, 0, 1>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 6, 1> lfsdet;\n      BitFieldModel<uint32_t, 5, 1> afsdetie;\n      BitFieldModel<uint32_t,\
    \ 4, 1> cnrdyie;\n      BitFieldModel<uint32_t, 3, 1> freqie;\n      BitFieldModel<uint32_t,\
    \ 2, 1> wckcfg;\n      BitFieldModel<uint32_t, 1, 1> mutedet;\n      BitFieldModel<uint32_t,\
    \ 0, 1> ovrudrie;\n    };\n  };\n\npublic:\n  using aim = AimReg<BaseAddress +\
    \ 0x0014>;\n\nprivate:\n  template<unsigned int address>\n  class AsrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using flvl = FieldModel<uint32_t,\
    \ address, 16, 3>;\n    using lfsdet = FieldModel<uint32_t, address, 6, 1>;\n\
    \    using afsdet = FieldModel<uint32_t, address, 5, 1>;\n    using cnrdy = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using freq = FieldModel<uint32_t, address, 3, 1>;\n   \
    \ using wckcfg = FieldModel<uint32_t, address, 2, 1>;\n    using mutedet = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using ovrudr = FieldModel<uint32_t, address, 0, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 16, 3> flvl;\n      BitFieldModel<uint32_t, 6, 1> lfsdet;\n      BitFieldModel<uint32_t,\
    \ 5, 1> afsdet;\n      BitFieldModel<uint32_t, 4, 1> cnrdy;\n      BitFieldModel<uint32_t,\
    \ 3, 1> freq;\n      BitFieldModel<uint32_t, 2, 1> wckcfg;\n      BitFieldModel<uint32_t,\
    \ 1, 1> mutedet;\n      BitFieldModel<uint32_t, 0, 1> ovrudr;\n    };\n  };\n\n\
    public:\n  using asr = AsrReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class AclrfrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using lfsdet = FieldModel<uint32_t, address, 6, 1>;\n   \
    \ using cafsdet = FieldModel<uint32_t, address, 5, 1>;\n    using cnrdy = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using wckcfg = FieldModel<uint32_t, address, 2, 1>;\n \
    \   using mutedet = FieldModel<uint32_t, address, 1, 1>;\n    using ovrudr = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 6, 1> lfsdet;\n      BitFieldModel<uint32_t, 5,\
    \ 1> cafsdet;\n      BitFieldModel<uint32_t, 4, 1> cnrdy;\n      BitFieldModel<uint32_t,\
    \ 2, 1> wckcfg;\n      BitFieldModel<uint32_t, 1, 1> mutedet;\n      BitFieldModel<uint32_t,\
    \ 0, 1> ovrudr;\n    };\n  };\n\npublic:\n  using aclrfr = AclrfrReg<BaseAddress\
    \ + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class AdrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using data = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> data;\n    };\n  };\n\npublic:\n  using\
    \ adr = AdrReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class GcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  using syncin = FieldModel<uint32_t, address, 0, 2>;\n    using syncout = FieldModel<uint32_t,\
    \ address, 4, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 2> syncin;\n      BitFieldModel<uint32_t, 4,\
    \ 2> syncout;\n    };\n  };\n\npublic:\n  using gcr = GcrReg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n  class\
    \ Xcr2BankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n\
    \  public:\n    using comp = FieldModel<uint32_t, address, 14, 2, bankOffset>;\n\
    \    using cpl = FieldModel<uint32_t, address, 13, 1, bankOffset>;\n    using\
    \ mutecn = FieldModel<uint32_t, address, 7, 6, bankOffset>;\n    using muteval\
    \ = FieldModel<uint32_t, address, 6, 1, bankOffset>;\n    using mute = FieldModel<uint32_t,\
    \ address, 5, 1, bankOffset>;\n    using tris = FieldModel<uint32_t, address,\
    \ 4, 1, bankOffset>;\n    using fflus = FieldModel<uint32_t, address, 3, 1, bankOffset>;\n\
    \    using fth = FieldModel<uint32_t, address, 0, 3, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 14,\
    \ 2> comp;\n      BitFieldModel<uint32_t, 13, 1> cpl;\n      BitFieldModel<uint32_t,\
    \ 7, 6> mutecn;\n      BitFieldModel<uint32_t, 6, 1> muteval;\n      BitFieldModel<uint32_t,\
    \ 5, 1> mute;\n      BitFieldModel<uint32_t, 4, 1> tris;\n      BitFieldModel<uint32_t,\
    \ 3, 1> fflus;\n      BitFieldModel<uint32_t, 0, 3> fth;\n    };\n  };\n\npublic:\n\
    \  using xcr2 = Xcr2BankReg<BaseAddress + 0x0008, 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class XfrcrBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    using fsoff = FieldModel<uint32_t,\
    \ address, 18, 1, bankOffset>;\n    using fspol = FieldModel<uint32_t, address,\
    \ 17, 1, bankOffset>;\n    using fsdef = FieldModel<uint32_t, address, 16, 1,\
    \ bankOffset>;\n    using fsall = FieldModel<uint32_t, address, 8, 7, bankOffset>;\n\
    \    using frl = FieldModel<uint32_t, address, 0, 8, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 18,\
    \ 1> fsoff;\n      BitFieldModel<uint32_t, 17, 1> fspol;\n      BitFieldModel<uint32_t,\
    \ 16, 1> fsdef;\n      BitFieldModel<uint32_t, 8, 7> fsall;\n      BitFieldModel<uint32_t,\
    \ 0, 8> frl;\n    };\n  };\n\npublic:\n  using xfrcr = XfrcrBankReg<BaseAddress\
    \ + 0x000C, 0x0020>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class XslotrBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    using sloten = FieldModel<uint32_t, address,\
    \ 16, 16, bankOffset>;\n    using nbslot = FieldModel<uint32_t, address, 8, 4,\
    \ bankOffset>;\n    using slotsz = FieldModel<uint32_t, address, 6, 2, bankOffset>;\n\
    \    using fboff = FieldModel<uint32_t, address, 0, 5, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16,\
    \ 16> sloten;\n      BitFieldModel<uint32_t, 8, 4> nbslot;\n      BitFieldModel<uint32_t,\
    \ 6, 2> slotsz;\n      BitFieldModel<uint32_t, 0, 5> fboff;\n    };\n  };\n\n\
    public:\n  using xslotr = XslotrBankReg<BaseAddress + 0x0010, 0x0020>;\n\nprivate:\n\
    \  template<unsigned int address, unsigned int bankOffset>\n  class XsrBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    using flvl = FieldModel<uint32_t, address, 16, 3, bankOffset>;\n    using\
    \ lfsdet = FieldModel<uint32_t, address, 6, 1, bankOffset>;\n    using afsdet\
    \ = FieldModel<uint32_t, address, 5, 1, bankOffset>;\n    using cnrdy = FieldModel<uint32_t,\
    \ address, 4, 1, bankOffset>;\n    using freq = FieldModel<uint32_t, address,\
    \ 3, 1, bankOffset>;\n    using wckcfg = FieldModel<uint32_t, address, 2, 1, bankOffset>;\n\
    \    using mutedet = FieldModel<uint32_t, address, 1, 1, bankOffset>;\n    using\
    \ ovrudr = FieldModel<uint32_t, address, 0, 1, bankOffset>;\n\n  public:\n   \
    \ union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 16, 3>\
    \ flvl;\n      BitFieldModel<uint32_t, 6, 1> lfsdet;\n      BitFieldModel<uint32_t,\
    \ 5, 1> afsdet;\n      BitFieldModel<uint32_t, 4, 1> cnrdy;\n      BitFieldModel<uint32_t,\
    \ 3, 1> freq;\n      BitFieldModel<uint32_t, 2, 1> wckcfg;\n      BitFieldModel<uint32_t,\
    \ 1, 1> mutedet;\n      BitFieldModel<uint32_t, 0, 1> ovrudr;\n    };\n  };\n\n\
    public:\n  using xsr = XsrBankReg<BaseAddress + 0x0018, 0x0020>;\n\nprivate:\n\
    \  template<unsigned int address, unsigned int bankOffset>\n  class XclrfrBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    using lfsdet = FieldModel<uint32_t, address, 6, 1, bankOffset>;\n    using\
    \ cafsdet = FieldModel<uint32_t, address, 5, 1, bankOffset>;\n    using cnrdy\
    \ = FieldModel<uint32_t, address, 4, 1, bankOffset>;\n    using wckcfg = FieldModel<uint32_t,\
    \ address, 2, 1, bankOffset>;\n    using mutedet = FieldModel<uint32_t, address,\
    \ 1, 1, bankOffset>;\n    using ovrudr = FieldModel<uint32_t, address, 0, 1, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 6, 1> lfsdet;\n      BitFieldModel<uint32_t, 5, 1> cafsdet;\n      BitFieldModel<uint32_t,\
    \ 4, 1> cnrdy;\n      BitFieldModel<uint32_t, 2, 1> wckcfg;\n      BitFieldModel<uint32_t,\
    \ 1, 1> mutedet;\n      BitFieldModel<uint32_t, 0, 1> ovrudr;\n    };\n  };\n\n\
    public:\n  using xclrfr = XclrfrBankReg<BaseAddress + 0x001C, 0x0020>;\n\nprivate:\n\
    \  template<unsigned int address, unsigned int bankOffset>\n  class XdrBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    using data = FieldModel<uint32_t, address, 0, 32, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 32> data;\n    };\n  };\n\npublic:\n  using xdr = XdrBankReg<BaseAddress + 0x0020,\
    \ 0x0020>;\n};\n\n}\n\n#endif /* DRAL_STM32F446_SAI2_H */\n"
  name: SAI2
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_PWR_H\n#define DRAL_STM32F446_PWR_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass pwr\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40007000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class CrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using lpds = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using pdds = FieldModel<uint32_t, address, 1, 1>;\n    using cwuf =\
    \ FieldModel<uint32_t, address, 2, 1>;\n    using csbf = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using pvde = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ using pls = FieldModel<uint32_t, address, 5, 3>;\n    using dbp = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using fpds = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ using lplvds = FieldModel<uint32_t, address, 10, 1>;\n    using mrlvds = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using adcdc1 = FieldModel<uint32_t, address, 13, 1>;\n\
    \    using vos = FieldModel<uint32_t, address, 14, 2>;\n    using oden = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using odswen = FieldModel<uint32_t, address, 17, 1>;\n\
    \    using uden = FieldModel<uint32_t, address, 18, 2>;\n    using fmssr = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using fissr = FieldModel<uint32_t, address, 21, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> lpds;\n      BitFieldModel<uint32_t, 1, 1> pdds;\n      BitFieldModel<uint32_t,\
    \ 2, 1> cwuf;\n      BitFieldModel<uint32_t, 3, 1> csbf;\n      BitFieldModel<uint32_t,\
    \ 4, 1> pvde;\n      BitFieldModel<uint32_t, 5, 3> pls;\n      BitFieldModel<uint32_t,\
    \ 8, 1> dbp;\n      BitFieldModel<uint32_t, 9, 1> fpds;\n      BitFieldModel<uint32_t,\
    \ 10, 1> lplvds;\n      BitFieldModel<uint32_t, 11, 1> mrlvds;\n      BitFieldModel<uint32_t,\
    \ 13, 1> adcdc1;\n      BitFieldModel<uint32_t, 14, 2> vos;\n      BitFieldModel<uint32_t,\
    \ 16, 1> oden;\n      BitFieldModel<uint32_t, 17, 1> odswen;\n      BitFieldModel<uint32_t,\
    \ 18, 2> uden;\n      BitFieldModel<uint32_t, 20, 1> fmssr;\n      BitFieldModel<uint32_t,\
    \ 21, 1> fissr;\n    };\n  };\n\npublic:\n  using cr = CrReg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CsrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using wuf = FieldModel<uint32_t, address, 0, 1>;\n\
    \    using sbf = FieldModel<uint32_t, address, 1, 1>;\n    using pvdo = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using brr = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ ewup2 = FieldModel<uint32_t, address, 7, 1>;\n    using ewup = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using bre = FieldModel<uint32_t, address, 9, 1>;\n    using\
    \ vosrdy = FieldModel<uint32_t, address, 14, 1>;\n    using odrdy = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using odswrdy = FieldModel<uint32_t, address, 17, 1>;\n\
    \    using udrdy = FieldModel<uint32_t, address, 18, 2>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> wuf;\n\
    \      BitFieldModel<uint32_t, 1, 1> sbf;\n      BitFieldModel<uint32_t, 2, 1>\
    \ pvdo;\n      BitFieldModel<uint32_t, 3, 1> brr;\n      BitFieldModel<uint32_t,\
    \ 7, 1> ewup2;\n      BitFieldModel<uint32_t, 8, 1> ewup;\n      BitFieldModel<uint32_t,\
    \ 9, 1> bre;\n      BitFieldModel<uint32_t, 14, 1> vosrdy;\n      BitFieldModel<uint32_t,\
    \ 16, 1> odrdy;\n      BitFieldModel<uint32_t, 17, 1> odswrdy;\n      BitFieldModel<uint32_t,\
    \ 18, 2> udrdy;\n    };\n  };\n\npublic:\n  using csr = CsrReg<BaseAddress + 0x0004>;\n\
    \n\n};\n\n}\n\n#endif /* DRAL_STM32F446_PWR_H */\n"
  name: PWR
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_QUADSPI_H\n#define DRAL_STM32F446_QUADSPI_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass quadspi\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0xA0001000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class CrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using prescaler = FieldModel<uint32_t, address,\
    \ 24, 8>;\n    using pmm = FieldModel<uint32_t, address, 23, 1>;\n    using apms\
    \ = FieldModel<uint32_t, address, 22, 1>;\n    using toie = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using smie = FieldModel<uint32_t, address, 19, 1>;\n \
    \   using ftie = FieldModel<uint32_t, address, 18, 1>;\n    using tcie = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    using teie = FieldModel<uint32_t, address, 16, 1>;\n \
    \   using fthres = FieldModel<uint32_t, address, 8, 5>;\n    using fsel = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using dfm = FieldModel<uint32_t, address, 6, 1>;\n    using\
    \ sshift = FieldModel<uint32_t, address, 4, 1>;\n    using tcen = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using dmaen = FieldModel<uint32_t, address, 2, 1>;\n  \
    \  using abort = FieldModel<uint32_t, address, 1, 1>;\n    using en = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 24, 8> prescaler;\n      BitFieldModel<uint32_t,\
    \ 23, 1> pmm;\n      BitFieldModel<uint32_t, 22, 1> apms;\n      BitFieldModel<uint32_t,\
    \ 20, 1> toie;\n      BitFieldModel<uint32_t, 19, 1> smie;\n      BitFieldModel<uint32_t,\
    \ 18, 1> ftie;\n      BitFieldModel<uint32_t, 17, 1> tcie;\n      BitFieldModel<uint32_t,\
    \ 16, 1> teie;\n      BitFieldModel<uint32_t, 8, 5> fthres;\n      BitFieldModel<uint32_t,\
    \ 7, 1> fsel;\n      BitFieldModel<uint32_t, 6, 1> dfm;\n      BitFieldModel<uint32_t,\
    \ 4, 1> sshift;\n      BitFieldModel<uint32_t, 3, 1> tcen;\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmaen;\n      BitFieldModel<uint32_t, 1, 1> abort;\n      BitFieldModel<uint32_t,\
    \ 0, 1> en;\n    };\n  };\n\npublic:\n  using cr = CrReg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using fsize = FieldModel<uint32_t, address, 16,\
    \ 5>;\n    using csht = FieldModel<uint32_t, address, 8, 3>;\n    using ckmode\
    \ = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 16, 5> fsize;\n      BitFieldModel<uint32_t,\
    \ 8, 3> csht;\n      BitFieldModel<uint32_t, 0, 1> ckmode;\n    };\n  };\n\npublic:\n\
    \  using dcr = DcrReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class SrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using flevel = FieldModel<uint32_t, address, 8, 7>;\n    using\
    \ busy = FieldModel<uint32_t, address, 5, 1>;\n    using tof = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using smf = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ ftf = FieldModel<uint32_t, address, 2, 1>;\n    using tcf = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using tef = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 8,\
    \ 7> flevel;\n      BitFieldModel<uint32_t, 5, 1> busy;\n      BitFieldModel<uint32_t,\
    \ 4, 1> tof;\n      BitFieldModel<uint32_t, 3, 1> smf;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ftf;\n      BitFieldModel<uint32_t, 1, 1> tcf;\n      BitFieldModel<uint32_t,\
    \ 0, 1> tef;\n    };\n  };\n\npublic:\n  using sr = SrReg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class FcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ctof = FieldModel<uint32_t, address, 4,\
    \ 1>;\n    using csmf = FieldModel<uint32_t, address, 3, 1>;\n    using ctcf =\
    \ FieldModel<uint32_t, address, 1, 1>;\n    using ctef = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 4, 1> ctof;\n      BitFieldModel<uint32_t, 3, 1>\
    \ csmf;\n      BitFieldModel<uint32_t, 1, 1> ctcf;\n      BitFieldModel<uint32_t,\
    \ 0, 1> ctef;\n    };\n  };\n\npublic:\n  using fcr = FcrReg<BaseAddress + 0x000C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DlrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dl = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> dl;\n    };\n  };\n\npublic:\n  using dlr = DlrReg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ddrm = FieldModel<uint32_t, address, 31,\
    \ 1>;\n    using dhhc = FieldModel<uint32_t, address, 30, 1>;\n    using sioo\
    \ = FieldModel<uint32_t, address, 28, 1>;\n    using fmode = FieldModel<uint32_t,\
    \ address, 26, 2>;\n    using dmode = FieldModel<uint32_t, address, 24, 2>;\n\
    \    using dcyc = FieldModel<uint32_t, address, 18, 5>;\n    using absize = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    using abmode = FieldModel<uint32_t, address, 14, 2>;\n\
    \    using adsize = FieldModel<uint32_t, address, 12, 2>;\n    using admode =\
    \ FieldModel<uint32_t, address, 10, 2>;\n    using imode = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    using instruction = FieldModel<uint32_t, address, 0, 8>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 31, 1> ddrm;\n      BitFieldModel<uint32_t, 30, 1> dhhc;\n      BitFieldModel<uint32_t,\
    \ 28, 1> sioo;\n      BitFieldModel<uint32_t, 26, 2> fmode;\n      BitFieldModel<uint32_t,\
    \ 24, 2> dmode;\n      BitFieldModel<uint32_t, 18, 5> dcyc;\n      BitFieldModel<uint32_t,\
    \ 16, 2> absize;\n      BitFieldModel<uint32_t, 14, 2> abmode;\n      BitFieldModel<uint32_t,\
    \ 12, 2> adsize;\n      BitFieldModel<uint32_t, 10, 2> admode;\n      BitFieldModel<uint32_t,\
    \ 8, 2> imode;\n      BitFieldModel<uint32_t, 0, 8> instruction;\n    };\n  };\n\
    \npublic:\n  using ccr = CcrReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class ArReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using address = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 32> address;\n    };\n  };\n\npublic:\n  using ar = ArReg<BaseAddress + 0x0018>;\n\
    \nprivate:\n  template<unsigned int address>\n  class AbrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using alternate = FieldModel<uint32_t, address,\
    \ 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> alternate;\n    };\n  };\n\npublic:\n  using abr = AbrReg<BaseAddress\
    \ + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class DrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using data = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> data;\n    };\n  };\n\npublic:\n  using\
    \ dr = DrReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class PsmkrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using mask = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> mask;\n\
    \    };\n  };\n\npublic:\n  using psmkr = PsmkrReg<BaseAddress + 0x0024>;\n\n\
    private:\n  template<unsigned int address>\n  class PsmarReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using match = FieldModel<uint32_t, address, 0,\
    \ 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> match;\n    };\n  };\n\npublic:\n  using psmar = PsmarReg<BaseAddress\
    \ + 0x0028>;\n\nprivate:\n  template<unsigned int address>\n  class PirReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using interval = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> interval;\n    };\n  };\n\npublic:\n  using\
    \ pir = PirReg<BaseAddress + 0x002C>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class LptrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   using timeout = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 16> timeout;\n\
    \    };\n  };\n\npublic:\n  using lptr = LptrReg<BaseAddress + 0x0030>;\n\n\n\
    };\n\n}\n\n#endif /* DRAL_STM32F446_QUADSPI_H */\n"
  name: QUADSPI
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_SPDIF_RX_H\n#define DRAL_STM32F446_SPDIF_RX_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass spdif_rx\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40004000;\n\nprivate:\n\
    \  template<unsigned int address>\n  class CrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using spdifen = FieldModel<uint32_t, address,\
    \ 0, 2>;\n    using rxdmaen = FieldModel<uint32_t, address, 2, 1>;\n    using\
    \ rxsteo = FieldModel<uint32_t, address, 3, 1>;\n    using drfmt = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    using pmsk = FieldModel<uint32_t, address, 6, 1>;\n   \
    \ using vmsk = FieldModel<uint32_t, address, 7, 1>;\n    using cumsk = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using ptmsk = FieldModel<uint32_t, address, 9, 1>;\n  \
    \  using cbdmaen = FieldModel<uint32_t, address, 10, 1>;\n    using chsel = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using nbtr = FieldModel<uint32_t, address, 12, 2>;\n \
    \   using wfa = FieldModel<uint32_t, address, 14, 1>;\n    using insel = FieldModel<uint32_t,\
    \ address, 16, 3>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 2> spdifen;\n      BitFieldModel<uint32_t, 2,\
    \ 1> rxdmaen;\n      BitFieldModel<uint32_t, 3, 1> rxsteo;\n      BitFieldModel<uint32_t,\
    \ 4, 2> drfmt;\n      BitFieldModel<uint32_t, 6, 1> pmsk;\n      BitFieldModel<uint32_t,\
    \ 7, 1> vmsk;\n      BitFieldModel<uint32_t, 8, 1> cumsk;\n      BitFieldModel<uint32_t,\
    \ 9, 1> ptmsk;\n      BitFieldModel<uint32_t, 10, 1> cbdmaen;\n      BitFieldModel<uint32_t,\
    \ 11, 1> chsel;\n      BitFieldModel<uint32_t, 12, 2> nbtr;\n      BitFieldModel<uint32_t,\
    \ 14, 1> wfa;\n      BitFieldModel<uint32_t, 16, 3> insel;\n    };\n  };\n\npublic:\n\
    \  using cr = CrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class ImrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using rxneie = FieldModel<uint32_t, address, 0, 1>;\n    using csrneie =\
    \ FieldModel<uint32_t, address, 1, 1>;\n    using perrie = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using ovrie = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using sblkie = FieldModel<uint32_t, address, 4, 1>;\n    using syncdie = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using ifeie = FieldModel<uint32_t, address, 6, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> rxneie;\n      BitFieldModel<uint32_t, 1, 1> csrneie;\n      BitFieldModel<uint32_t,\
    \ 2, 1> perrie;\n      BitFieldModel<uint32_t, 3, 1> ovrie;\n      BitFieldModel<uint32_t,\
    \ 4, 1> sblkie;\n      BitFieldModel<uint32_t, 5, 1> syncdie;\n      BitFieldModel<uint32_t,\
    \ 6, 1> ifeie;\n    };\n  };\n\npublic:\n  using imr = ImrReg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using rxne = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using csrne = FieldModel<uint32_t, address, 1, 1>;\n    using perr\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    using ovr = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using sbd = FieldModel<uint32_t, address, 4, 1>;\n    using\
    \ syncd = FieldModel<uint32_t, address, 5, 1>;\n    using ferr = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using serr = FieldModel<uint32_t, address, 7, 1>;\n   \
    \ using terr = FieldModel<uint32_t, address, 8, 1>;\n    using width5 = FieldModel<uint32_t,\
    \ address, 16, 15>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> rxne;\n      BitFieldModel<uint32_t, 1, 1>\
    \ csrne;\n      BitFieldModel<uint32_t, 2, 1> perr;\n      BitFieldModel<uint32_t,\
    \ 3, 1> ovr;\n      BitFieldModel<uint32_t, 4, 1> sbd;\n      BitFieldModel<uint32_t,\
    \ 5, 1> syncd;\n      BitFieldModel<uint32_t, 6, 1> ferr;\n      BitFieldModel<uint32_t,\
    \ 7, 1> serr;\n      BitFieldModel<uint32_t, 8, 1> terr;\n      BitFieldModel<uint32_t,\
    \ 16, 15> width5;\n    };\n  };\n\npublic:\n  using sr = SrReg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class IfcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using perrcf = FieldModel<uint32_t, address, 2,\
    \ 1>;\n    using ovrcf = FieldModel<uint32_t, address, 3, 1>;\n    using sbdcf\
    \ = FieldModel<uint32_t, address, 4, 1>;\n    using syncdcf = FieldModel<uint32_t,\
    \ address, 5, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 2, 1> perrcf;\n      BitFieldModel<uint32_t, 3,\
    \ 1> ovrcf;\n      BitFieldModel<uint32_t, 4, 1> sbdcf;\n      BitFieldModel<uint32_t,\
    \ 5, 1> syncdcf;\n    };\n  };\n\npublic:\n  using ifcr = IfcrReg<BaseAddress\
    \ + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class DrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using dr = FieldModel<uint32_t,\
    \ address, 0, 24>;\n    using pe = FieldModel<uint32_t, address, 24, 1>;\n   \
    \ using v = FieldModel<uint32_t, address, 25, 1>;\n    using u = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using c = FieldModel<uint32_t, address, 27, 1>;\n    using\
    \ pt = FieldModel<uint32_t, address, 28, 2>;\n\n  public:\n    union reg\n   \
    \ {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 24> dr;\n      BitFieldModel<uint32_t,\
    \ 24, 1> pe;\n      BitFieldModel<uint32_t, 25, 1> v;\n      BitFieldModel<uint32_t,\
    \ 26, 1> u;\n      BitFieldModel<uint32_t, 27, 1> c;\n      BitFieldModel<uint32_t,\
    \ 28, 2> pt;\n    };\n  };\n\npublic:\n  using dr = DrReg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CsrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using usr = FieldModel<uint32_t, address, 0, 16>;\n\
    \    using cs = FieldModel<uint32_t, address, 16, 8>;\n    using sob = FieldModel<uint32_t,\
    \ address, 24, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 16> usr;\n      BitFieldModel<uint32_t, 16,\
    \ 8> cs;\n      BitFieldModel<uint32_t, 24, 1> sob;\n    };\n  };\n\npublic:\n\
    \  using csr = CsrReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DirReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using thi = FieldModel<uint32_t, address, 0, 13>;\n    using tlo\
    \ = FieldModel<uint32_t, address, 16, 13>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 13> thi;\n      BitFieldModel<uint32_t,\
    \ 16, 13> tlo;\n    };\n  };\n\npublic:\n  using dir = DirReg<BaseAddress + 0x0018>;\n\
    \n\n};\n\n}\n\n#endif /* DRAL_STM32F446_SPDIF_RX_H */\n"
  name: SPDIF_RX
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_HDMI_CEC_H\n#define DRAL_STM32F446_HDMI_CEC_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass hdmi_cec\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40006C00;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cec_crReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using txeom = FieldModel<uint32_t, address, 2,\
    \ 1>;\n    using txsom = FieldModel<uint32_t, address, 1, 1>;\n    using cecen\
    \ = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 2, 1> txeom;\n      BitFieldModel<uint32_t,\
    \ 1, 1> txsom;\n      BitFieldModel<uint32_t, 0, 1> cecen;\n    };\n  };\n\npublic:\n\
    \  using cec_cr = Cec_crReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cec_cfgrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using lstn = FieldModel<uint32_t, address, 31, 1>;\n    using\
    \ oar = FieldModel<uint32_t, address, 16, 15>;\n    using sftop = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using brdnogen = FieldModel<uint32_t, address, 7, 1>;\n\
    \    using lbpegen = FieldModel<uint32_t, address, 6, 1>;\n    using bregen =\
    \ FieldModel<uint32_t, address, 5, 1>;\n    using brestp = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using rxtol = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  using sft = FieldModel<uint32_t, address, 0, 3>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 31, 1> lstn;\n  \
    \    BitFieldModel<uint32_t, 16, 15> oar;\n      BitFieldModel<uint32_t, 8, 1>\
    \ sftop;\n      BitFieldModel<uint32_t, 7, 1> brdnogen;\n      BitFieldModel<uint32_t,\
    \ 6, 1> lbpegen;\n      BitFieldModel<uint32_t, 5, 1> bregen;\n      BitFieldModel<uint32_t,\
    \ 4, 1> brestp;\n      BitFieldModel<uint32_t, 3, 1> rxtol;\n      BitFieldModel<uint32_t,\
    \ 0, 3> sft;\n    };\n  };\n\npublic:\n  using cec_cfgr = Cec_cfgrReg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class Cec_txdrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using txd = FieldModel<uint32_t,\
    \ address, 0, 8>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 8> txd;\n    };\n  };\n\npublic:\n  using cec_txdr\
    \ = Cec_txdrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Cec_rxdrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    using rxd = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 8> rxd;\n\
    \    };\n  };\n\npublic:\n  using cec_rxdr = Cec_rxdrReg<BaseAddress + 0x000C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Cec_isrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using txacke = FieldModel<uint32_t, address, 12,\
    \ 1>;\n    using txerr = FieldModel<uint32_t, address, 11, 1>;\n    using txudr\
    \ = FieldModel<uint32_t, address, 10, 1>;\n    using txend = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using txbr = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ using arblst = FieldModel<uint32_t, address, 7, 1>;\n    using rxacke = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    using lbpe = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ using sbpe = FieldModel<uint32_t, address, 4, 1>;\n    using bre = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    using rxovr = FieldModel<uint32_t, address, 2, 1>;\n  \
    \  using rxend = FieldModel<uint32_t, address, 1, 1>;\n    using rxbr = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 12, 1> txacke;\n      BitFieldModel<uint32_t, 11,\
    \ 1> txerr;\n      BitFieldModel<uint32_t, 10, 1> txudr;\n      BitFieldModel<uint32_t,\
    \ 9, 1> txend;\n      BitFieldModel<uint32_t, 8, 1> txbr;\n      BitFieldModel<uint32_t,\
    \ 7, 1> arblst;\n      BitFieldModel<uint32_t, 6, 1> rxacke;\n      BitFieldModel<uint32_t,\
    \ 5, 1> lbpe;\n      BitFieldModel<uint32_t, 4, 1> sbpe;\n      BitFieldModel<uint32_t,\
    \ 3, 1> bre;\n      BitFieldModel<uint32_t, 2, 1> rxovr;\n      BitFieldModel<uint32_t,\
    \ 1, 1> rxend;\n      BitFieldModel<uint32_t, 0, 1> rxbr;\n    };\n  };\n\npublic:\n\
    \  using cec_isr = Cec_isrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cec_ierReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using txackie = FieldModel<uint32_t, address, 12, 1>;\n \
    \   using txerrie = FieldModel<uint32_t, address, 11, 1>;\n    using txudrie =\
    \ FieldModel<uint32_t, address, 10, 1>;\n    using txendie = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using txbrie = FieldModel<uint32_t, address, 8, 1>;\n \
    \   using arblstie = FieldModel<uint32_t, address, 7, 1>;\n    using rxackie =\
    \ FieldModel<uint32_t, address, 6, 1>;\n    using lbpeie = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using sbpeie = FieldModel<uint32_t, address, 4, 1>;\n \
    \   using breie = FieldModel<uint32_t, address, 3, 1>;\n    using rxovrie = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using rxendie = FieldModel<uint32_t, address, 1, 1>;\n\
    \    using rxbrie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 12, 1> txackie;\n\
    \      BitFieldModel<uint32_t, 11, 1> txerrie;\n      BitFieldModel<uint32_t,\
    \ 10, 1> txudrie;\n      BitFieldModel<uint32_t, 9, 1> txendie;\n      BitFieldModel<uint32_t,\
    \ 8, 1> txbrie;\n      BitFieldModel<uint32_t, 7, 1> arblstie;\n      BitFieldModel<uint32_t,\
    \ 6, 1> rxackie;\n      BitFieldModel<uint32_t, 5, 1> lbpeie;\n      BitFieldModel<uint32_t,\
    \ 4, 1> sbpeie;\n      BitFieldModel<uint32_t, 3, 1> breie;\n      BitFieldModel<uint32_t,\
    \ 2, 1> rxovrie;\n      BitFieldModel<uint32_t, 1, 1> rxendie;\n      BitFieldModel<uint32_t,\
    \ 0, 1> rxbrie;\n    };\n  };\n\npublic:\n  using cec_ier = Cec_ierReg<BaseAddress\
    \ + 0x0014>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_HDMI_CEC_H */\n"
  name: HDMI_CEC
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_FPU_H\n#define DRAL_STM32F446_FPU_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass fpu\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0xE000EF34;\n\nprivate:\n\
    \  template<unsigned int address>\n  class FpccrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using lspact = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using user = FieldModel<uint32_t, address, 1, 1>;\n    using thread\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    using hfrdy = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using mmrdy = FieldModel<uint32_t, address, 5, 1>;\n  \
    \  using bfrdy = FieldModel<uint32_t, address, 6, 1>;\n    using monrdy = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using lspen = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using aspen = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> lspact;\n\
    \      BitFieldModel<uint32_t, 1, 1> user;\n      BitFieldModel<uint32_t, 3, 1>\
    \ thread;\n      BitFieldModel<uint32_t, 4, 1> hfrdy;\n      BitFieldModel<uint32_t,\
    \ 5, 1> mmrdy;\n      BitFieldModel<uint32_t, 6, 1> bfrdy;\n      BitFieldModel<uint32_t,\
    \ 8, 1> monrdy;\n      BitFieldModel<uint32_t, 30, 1> lspen;\n      BitFieldModel<uint32_t,\
    \ 31, 1> aspen;\n    };\n  };\n\npublic:\n  using fpccr = FpccrReg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class FpcarReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using address =\
    \ FieldModel<uint32_t, address, 3, 29>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 3, 29> address;\n    };\n\
    \  };\n\npublic:\n  using fpcar = FpcarReg<BaseAddress + 0x0004>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class FpscrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ioc = FieldModel<uint32_t, address, 0, 1>;\n\
    \    using dzc = FieldModel<uint32_t, address, 1, 1>;\n    using ofc = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using ufc = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ ixc = FieldModel<uint32_t, address, 4, 1>;\n    using idc = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    using rmode = FieldModel<uint32_t, address, 22, 2>;\n \
    \   using fz = FieldModel<uint32_t, address, 24, 1>;\n    using dn = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    using ahp = FieldModel<uint32_t, address, 26, 1>;\n  \
    \  using v = FieldModel<uint32_t, address, 28, 1>;\n    using c = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    using z = FieldModel<uint32_t, address, 30, 1>;\n    using\
    \ n = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> ioc;\n      BitFieldModel<uint32_t,\
    \ 1, 1> dzc;\n      BitFieldModel<uint32_t, 2, 1> ofc;\n      BitFieldModel<uint32_t,\
    \ 3, 1> ufc;\n      BitFieldModel<uint32_t, 4, 1> ixc;\n      BitFieldModel<uint32_t,\
    \ 7, 1> idc;\n      BitFieldModel<uint32_t, 22, 2> rmode;\n      BitFieldModel<uint32_t,\
    \ 24, 1> fz;\n      BitFieldModel<uint32_t, 25, 1> dn;\n      BitFieldModel<uint32_t,\
    \ 26, 1> ahp;\n      BitFieldModel<uint32_t, 28, 1> v;\n      BitFieldModel<uint32_t,\
    \ 29, 1> c;\n      BitFieldModel<uint32_t, 30, 1> z;\n      BitFieldModel<uint32_t,\
    \ 31, 1> n;\n    };\n  };\n\npublic:\n  using fpscr = FpscrReg<BaseAddress + 0x0008>;\n\
    \n\n};\n\n}\n\n#endif /* DRAL_STM32F446_FPU_H */\n"
  name: FPU
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_MPU_H\n#define DRAL_STM32F446_MPU_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass mpu\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0xE000ED90;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Mpu_typerReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using separate = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    using dregion = FieldModel<uint32_t, address, 8, 8>;\n    using\
    \ iregion = FieldModel<uint32_t, address, 16, 8>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 1> separate;\n\
    \      BitFieldModel<uint32_t, 8, 8> dregion;\n      BitFieldModel<uint32_t, 16,\
    \ 8> iregion;\n    };\n  };\n\npublic:\n  using mpu_typer = Mpu_typerReg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class Mpu_ctrlReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using enable\
    \ = FieldModel<uint32_t, address, 0, 1>;\n    using hfnmiena = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using privdefena = FieldModel<uint32_t, address, 2, 1>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> enable;\n      BitFieldModel<uint32_t, 1, 1> hfnmiena;\n      BitFieldModel<uint32_t,\
    \ 2, 1> privdefena;\n    };\n  };\n\npublic:\n  using mpu_ctrl = Mpu_ctrlReg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class Mpu_rnrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using region\
    \ = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 8> region;\n    };\n\
    \  };\n\npublic:\n  using mpu_rnr = Mpu_rnrReg<BaseAddress + 0x0008>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Mpu_rbarReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using region = FieldModel<uint32_t, address, 0,\
    \ 4>;\n    using valid = FieldModel<uint32_t, address, 4, 1>;\n    using addr\
    \ = FieldModel<uint32_t, address, 5, 27>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 4> region;\n      BitFieldModel<uint32_t,\
    \ 4, 1> valid;\n      BitFieldModel<uint32_t, 5, 27> addr;\n    };\n  };\n\npublic:\n\
    \  using mpu_rbar = Mpu_rbarReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Mpu_rasrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    using enable = FieldModel<uint32_t, address, 0, 1>;\n   \
    \ using size = FieldModel<uint32_t, address, 1, 5>;\n    using srd = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    using b = FieldModel<uint32_t, address, 16, 1>;\n    using\
    \ c = FieldModel<uint32_t, address, 17, 1>;\n    using s = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    using tex = FieldModel<uint32_t, address, 19, 3>;\n  \
    \  using ap = FieldModel<uint32_t, address, 24, 3>;\n    using xn = FieldModel<uint32_t,\
    \ address, 28, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> enable;\n      BitFieldModel<uint32_t, 1,\
    \ 5> size;\n      BitFieldModel<uint32_t, 8, 8> srd;\n      BitFieldModel<uint32_t,\
    \ 16, 1> b;\n      BitFieldModel<uint32_t, 17, 1> c;\n      BitFieldModel<uint32_t,\
    \ 18, 1> s;\n      BitFieldModel<uint32_t, 19, 3> tex;\n      BitFieldModel<uint32_t,\
    \ 24, 3> ap;\n      BitFieldModel<uint32_t, 28, 1> xn;\n    };\n  };\n\npublic:\n\
    \  using mpu_rasr = Mpu_rasrReg<BaseAddress + 0x0010>;\n\n\n};\n\n}\n\n#endif\
    \ /* DRAL_STM32F446_MPU_H */\n"
  name: MPU
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_STK_H\n#define DRAL_STM32F446_STK_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass stk\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0xE000E010;\n\nprivate:\n\
    \  template<unsigned int address>\n  class CtrlReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using enable = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    using tickint = FieldModel<uint32_t, address, 1, 1>;\n    using clksource\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    using countflag = FieldModel<uint32_t,\
    \ address, 16, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> enable;\n      BitFieldModel<uint32_t, 1,\
    \ 1> tickint;\n      BitFieldModel<uint32_t, 2, 1> clksource;\n      BitFieldModel<uint32_t,\
    \ 16, 1> countflag;\n    };\n  };\n\npublic:\n  using ctrl = CtrlReg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class LoadReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using reload =\
    \ FieldModel<uint32_t, address, 0, 24>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 0, 24> reload;\n    };\n\
    \  };\n\npublic:\n  using load = LoadReg<BaseAddress + 0x0004>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class ValReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using current = FieldModel<uint32_t, address,\
    \ 0, 24>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 24> current;\n    };\n  };\n\npublic:\n  using val = ValReg<BaseAddress +\
    \ 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class CalibReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using tenms = FieldModel<uint32_t,\
    \ address, 0, 24>;\n    using skew = FieldModel<uint32_t, address, 30, 1>;\n \
    \   using noref = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0, 24> tenms;\n\
    \      BitFieldModel<uint32_t, 30, 1> skew;\n      BitFieldModel<uint32_t, 31,\
    \ 1> noref;\n    };\n  };\n\npublic:\n  using calib = CalibReg<BaseAddress + 0x000C>;\n\
    \n\n};\n\n}\n\n#endif /* DRAL_STM32F446_STK_H */\n"
  name: STK
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_SCB_H\n#define DRAL_STM32F446_SCB_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass scb\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0xE000ED00;\n\nprivate:\n\
    \  template<unsigned int address>\n  class CpuidReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using revision = FieldModel<uint32_t, address,\
    \ 0, 4>;\n    using partno = FieldModel<uint32_t, address, 4, 12>;\n    using\
    \ constant = FieldModel<uint32_t, address, 16, 4>;\n    using variant = FieldModel<uint32_t,\
    \ address, 20, 4>;\n    using implementer = FieldModel<uint32_t, address, 24,\
    \ 8>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 4> revision;\n      BitFieldModel<uint32_t, 4, 12> partno;\n      BitFieldModel<uint32_t,\
    \ 16, 4> constant;\n      BitFieldModel<uint32_t, 20, 4> variant;\n      BitFieldModel<uint32_t,\
    \ 24, 8> implementer;\n    };\n  };\n\npublic:\n  using cpuid = CpuidReg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class IcsrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using vectactive\
    \ = FieldModel<uint32_t, address, 0, 9>;\n    using rettobase = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    using vectpending = FieldModel<uint32_t, address, 12,\
    \ 7>;\n    using isrpending = FieldModel<uint32_t, address, 22, 1>;\n    using\
    \ pendstclr = FieldModel<uint32_t, address, 25, 1>;\n    using pendstset = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    using pendsvclr = FieldModel<uint32_t, address, 27, 1>;\n\
    \    using pendsvset = FieldModel<uint32_t, address, 28, 1>;\n    using nmipendset\
    \ = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 9> vectactive;\n    \
    \  BitFieldModel<uint32_t, 11, 1> rettobase;\n      BitFieldModel<uint32_t, 12,\
    \ 7> vectpending;\n      BitFieldModel<uint32_t, 22, 1> isrpending;\n      BitFieldModel<uint32_t,\
    \ 25, 1> pendstclr;\n      BitFieldModel<uint32_t, 26, 1> pendstset;\n      BitFieldModel<uint32_t,\
    \ 27, 1> pendsvclr;\n      BitFieldModel<uint32_t, 28, 1> pendsvset;\n      BitFieldModel<uint32_t,\
    \ 31, 1> nmipendset;\n    };\n  };\n\npublic:\n  using icsr = IcsrReg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class VtorReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using tbloff =\
    \ FieldModel<uint32_t, address, 9, 21>;\n\n  public:\n    union reg\n    {\n \
    \     uint32_t value;\n      BitFieldModel<uint32_t, 9, 21> tbloff;\n    };\n\
    \  };\n\npublic:\n  using vtor = VtorReg<BaseAddress + 0x0008>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class AircrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using vectreset = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    using vectclractive = FieldModel<uint32_t, address, 1, 1>;\n   \
    \ using sysresetreq = FieldModel<uint32_t, address, 2, 1>;\n    using prigroup\
    \ = FieldModel<uint32_t, address, 8, 3>;\n    using endianess = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using vectkeystat = FieldModel<uint32_t, address, 16,\
    \ 16>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> vectreset;\n      BitFieldModel<uint32_t, 1, 1> vectclractive;\n     \
    \ BitFieldModel<uint32_t, 2, 1> sysresetreq;\n      BitFieldModel<uint32_t, 8,\
    \ 3> prigroup;\n      BitFieldModel<uint32_t, 15, 1> endianess;\n      BitFieldModel<uint32_t,\
    \ 16, 16> vectkeystat;\n    };\n  };\n\npublic:\n  using aircr = AircrReg<BaseAddress\
    \ + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class ScrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using sleeponexit = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using sleepdeep = FieldModel<uint32_t, address, 2, 1>;\n\
    \    using seveonpend = FieldModel<uint32_t, address, 4, 1>;\n\n  public:\n  \
    \  union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 1, 1>\
    \ sleeponexit;\n      BitFieldModel<uint32_t, 2, 1> sleepdeep;\n      BitFieldModel<uint32_t,\
    \ 4, 1> seveonpend;\n    };\n  };\n\npublic:\n  using scr = ScrReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class CcrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using nonbasethrdena =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    using usersetmpend = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    using unalign__trp = FieldModel<uint32_t, address, 3, 1>;\n\
    \    using div_0_trp = FieldModel<uint32_t, address, 4, 1>;\n    using bfhfnmign\
    \ = FieldModel<uint32_t, address, 8, 1>;\n    using stkalign = FieldModel<uint32_t,\
    \ address, 9, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> nonbasethrdena;\n      BitFieldModel<uint32_t,\
    \ 1, 1> usersetmpend;\n      BitFieldModel<uint32_t, 3, 1> unalign__trp;\n   \
    \   BitFieldModel<uint32_t, 4, 1> div_0_trp;\n      BitFieldModel<uint32_t, 8,\
    \ 1> bfhfnmign;\n      BitFieldModel<uint32_t, 9, 1> stkalign;\n    };\n  };\n\
    \npublic:\n  using ccr = CcrReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Shpr1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using pri_4 = FieldModel<uint32_t, address, 0, 8>;\n    using\
    \ pri_5 = FieldModel<uint32_t, address, 8, 8>;\n    using pri_6 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 8> pri_4;\n      BitFieldModel<uint32_t, 8,\
    \ 8> pri_5;\n      BitFieldModel<uint32_t, 16, 8> pri_6;\n    };\n  };\n\npublic:\n\
    \  using shpr1 = Shpr1Reg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Shpr2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    using pri_11 = FieldModel<uint32_t, address, 24, 8>;\n\n \
    \ public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 24, 8> pri_11;\n    };\n  };\n\npublic:\n  using shpr2 = Shpr2Reg<BaseAddress\
    \ + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class Shpr3Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using pri_14 =\
    \ FieldModel<uint32_t, address, 16, 8>;\n    using pri_15 = FieldModel<uint32_t,\
    \ address, 24, 8>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 16, 8> pri_14;\n      BitFieldModel<uint32_t, 24,\
    \ 8> pri_15;\n    };\n  };\n\npublic:\n  using shpr3 = Shpr3Reg<BaseAddress +\
    \ 0x0020>;\n\nprivate:\n  template<unsigned int address>\n  class ShcsrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using memfaultact = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    using busfaultact = FieldModel<uint32_t, address, 1, 1>;\n\
    \    using usgfaultact = FieldModel<uint32_t, address, 3, 1>;\n    using svcallact\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    using monitoract = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using pendsvact = FieldModel<uint32_t, address, 10, 1>;\n\
    \    using systickact = FieldModel<uint32_t, address, 11, 1>;\n    using usgfaultpended\
    \ = FieldModel<uint32_t, address, 12, 1>;\n    using memfaultpended = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using busfaultpended = FieldModel<uint32_t, address, 14,\
    \ 1>;\n    using svcallpended = FieldModel<uint32_t, address, 15, 1>;\n    using\
    \ memfaultena = FieldModel<uint32_t, address, 16, 1>;\n    using busfaultena =\
    \ FieldModel<uint32_t, address, 17, 1>;\n    using usgfaultena = FieldModel<uint32_t,\
    \ address, 18, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 1> memfaultact;\n      BitFieldModel<uint32_t,\
    \ 1, 1> busfaultact;\n      BitFieldModel<uint32_t, 3, 1> usgfaultact;\n     \
    \ BitFieldModel<uint32_t, 7, 1> svcallact;\n      BitFieldModel<uint32_t, 8, 1>\
    \ monitoract;\n      BitFieldModel<uint32_t, 10, 1> pendsvact;\n      BitFieldModel<uint32_t,\
    \ 11, 1> systickact;\n      BitFieldModel<uint32_t, 12, 1> usgfaultpended;\n \
    \     BitFieldModel<uint32_t, 13, 1> memfaultpended;\n      BitFieldModel<uint32_t,\
    \ 14, 1> busfaultpended;\n      BitFieldModel<uint32_t, 15, 1> svcallpended;\n\
    \      BitFieldModel<uint32_t, 16, 1> memfaultena;\n      BitFieldModel<uint32_t,\
    \ 17, 1> busfaultena;\n      BitFieldModel<uint32_t, 18, 1> usgfaultena;\n   \
    \ };\n  };\n\npublic:\n  using shcsr = ShcsrReg<BaseAddress + 0x0024>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Cfsr_ufsr_bfsr_mmfsrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using iaccviol = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    using munstkerr = FieldModel<uint32_t, address, 3, 1>;\n    using\
    \ mstkerr = FieldModel<uint32_t, address, 4, 1>;\n    using mlsperr = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    using mmarvalid = FieldModel<uint32_t, address, 7, 1>;\n\
    \    using ibuserr = FieldModel<uint32_t, address, 8, 1>;\n    using preciserr\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    using impreciserr = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    using unstkerr = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using stkerr = FieldModel<uint32_t, address, 12, 1>;\n    using lsperr =\
    \ FieldModel<uint32_t, address, 13, 1>;\n    using bfarvalid = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    using undefinstr = FieldModel<uint32_t, address, 16, 1>;\n\
    \    using invstate = FieldModel<uint32_t, address, 17, 1>;\n    using invpc =\
    \ FieldModel<uint32_t, address, 18, 1>;\n    using nocp = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    using unaligned = FieldModel<uint32_t, address, 24, 1>;\n\
    \    using divbyzero = FieldModel<uint32_t, address, 25, 1>;\n\n  public:\n  \
    \  union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 1, 1>\
    \ iaccviol;\n      BitFieldModel<uint32_t, 3, 1> munstkerr;\n      BitFieldModel<uint32_t,\
    \ 4, 1> mstkerr;\n      BitFieldModel<uint32_t, 5, 1> mlsperr;\n      BitFieldModel<uint32_t,\
    \ 7, 1> mmarvalid;\n      BitFieldModel<uint32_t, 8, 1> ibuserr;\n      BitFieldModel<uint32_t,\
    \ 9, 1> preciserr;\n      BitFieldModel<uint32_t, 10, 1> impreciserr;\n      BitFieldModel<uint32_t,\
    \ 11, 1> unstkerr;\n      BitFieldModel<uint32_t, 12, 1> stkerr;\n      BitFieldModel<uint32_t,\
    \ 13, 1> lsperr;\n      BitFieldModel<uint32_t, 15, 1> bfarvalid;\n      BitFieldModel<uint32_t,\
    \ 16, 1> undefinstr;\n      BitFieldModel<uint32_t, 17, 1> invstate;\n      BitFieldModel<uint32_t,\
    \ 18, 1> invpc;\n      BitFieldModel<uint32_t, 19, 1> nocp;\n      BitFieldModel<uint32_t,\
    \ 24, 1> unaligned;\n      BitFieldModel<uint32_t, 25, 1> divbyzero;\n    };\n\
    \  };\n\npublic:\n  using cfsr_ufsr_bfsr_mmfsr = Cfsr_ufsr_bfsr_mmfsrReg<BaseAddress\
    \ + 0x0028>;\n\nprivate:\n  template<unsigned int address>\n  class HfsrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using vecttbl =\
    \ FieldModel<uint32_t, address, 1, 1>;\n    using forced = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    using debug_vt = FieldModel<uint32_t, address, 31, 1>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 1, 1> vecttbl;\n      BitFieldModel<uint32_t, 30, 1> forced;\n      BitFieldModel<uint32_t,\
    \ 31, 1> debug_vt;\n    };\n  };\n\npublic:\n  using hfsr = HfsrReg<BaseAddress\
    \ + 0x002C>;\n\nprivate:\n  template<unsigned int address>\n  class MmfarReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using mmfar = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> mmfar;\n    };\n  };\n\npublic:\n  using\
    \ mmfar = MmfarReg<BaseAddress + 0x0034>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class BfarReg : public RegisterModel<uint32_t, address>\n  {\n \
    \ public:\n    using bfar = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 0,\
    \ 32> bfar;\n    };\n  };\n\npublic:\n  using bfar = BfarReg<BaseAddress + 0x0038>;\n\
    \nprivate:\n  template<unsigned int address>\n  class AfsrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using impdef = FieldModel<uint32_t, address, 0,\
    \ 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> impdef;\n    };\n  };\n\npublic:\n  using afsr = AfsrReg<BaseAddress\
    \ + 0x003C>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_SCB_H */\n"
  name: SCB
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_NVIC_STIR_H\n#define DRAL_STM32F446_NVIC_STIR_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass nvic_stir\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0xE000EF00;\n\nprivate:\n\
    \  template<unsigned int address>\n  class StirReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using intid = FieldModel<uint32_t, address, 0,\
    \ 9>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 9> intid;\n    };\n  };\n\npublic:\n  using stir = StirReg<BaseAddress +\
    \ 0x0000>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_NVIC_STIR_H */\n"
  name: NVIC_STIR
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_FPU_CPACR_H\n#define DRAL_STM32F446_FPU_CPACR_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass fpu_cpacr\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0xE000ED88;\n\nprivate:\n\
    \  template<unsigned int address>\n  class CpacrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cp = FieldModel<uint32_t, address, 20, 4>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 20, 4> cp;\n    };\n  };\n\npublic:\n  using cpacr = CpacrReg<BaseAddress +\
    \ 0x0000>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_FPU_CPACR_H */\n"
  name: FPU_CPACR
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_SCB_ACTRL_H\n#define DRAL_STM32F446_SCB_ACTRL_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass scb_actrl\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0xE000E008;\n\nprivate:\n\
    \  template<unsigned int address>\n  class ActrlReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using dismcycint = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    using disdefwbuf = FieldModel<uint32_t, address, 1, 1>;\n    using\
    \ disfold = FieldModel<uint32_t, address, 2, 1>;\n    using disfpca = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using disoofp = FieldModel<uint32_t, address, 9, 1>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 1> dismcycint;\n      BitFieldModel<uint32_t, 1, 1> disdefwbuf;\n      BitFieldModel<uint32_t,\
    \ 2, 1> disfold;\n      BitFieldModel<uint32_t, 8, 1> disfpca;\n      BitFieldModel<uint32_t,\
    \ 9, 1> disoofp;\n    };\n  };\n\npublic:\n  using actrl = ActrlReg<BaseAddress\
    \ + 0x0000>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_SCB_ACTRL_H */\n"
  name: SCB_ACTRL
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F446_SDIO_H\n#define DRAL_STM32F446_SDIO_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f446 {\n\nclass sdio\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40012C00;\n\nprivate:\n\
    \  template<unsigned int address>\n  class PowerReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using pwrctrl = FieldModel<uint32_t, address,\
    \ 0, 2>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 2> pwrctrl;\n    };\n  };\n\npublic:\n  using power = PowerReg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class ClkcrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using hwfc_en =\
    \ FieldModel<uint32_t, address, 14, 1>;\n    using negedge = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using widbus = FieldModel<uint32_t, address, 11, 2>;\n\
    \    using bypass = FieldModel<uint32_t, address, 10, 1>;\n    using pwrsav =\
    \ FieldModel<uint32_t, address, 9, 1>;\n    using clken = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using clkdiv = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 14, 1> hwfc_en;\n      BitFieldModel<uint32_t, 13, 1> negedge;\n      BitFieldModel<uint32_t,\
    \ 11, 2> widbus;\n      BitFieldModel<uint32_t, 10, 1> bypass;\n      BitFieldModel<uint32_t,\
    \ 9, 1> pwrsav;\n      BitFieldModel<uint32_t, 8, 1> clken;\n      BitFieldModel<uint32_t,\
    \ 0, 8> clkdiv;\n    };\n  };\n\npublic:\n  using clkcr = ClkcrReg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class ArgReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using cmdarg = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 0, 32> cmdarg;\n    };\n  };\n\npublic:\n  using\
    \ arg = ArgReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class CmdReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  using ce_atacmd = FieldModel<uint32_t, address, 14, 1>;\n    using nien = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    using encmdcompl = FieldModel<uint32_t, address, 12, 1>;\n\
    \    using sdiosuspend = FieldModel<uint32_t, address, 11, 1>;\n    using cpsmen\
    \ = FieldModel<uint32_t, address, 10, 1>;\n    using waitpend = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    using waitint = FieldModel<uint32_t, address, 8, 1>;\n\
    \    using waitresp = FieldModel<uint32_t, address, 6, 2>;\n    using cmdindex\
    \ = FieldModel<uint32_t, address, 0, 6>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 14, 1> ce_atacmd;\n    \
    \  BitFieldModel<uint32_t, 13, 1> nien;\n      BitFieldModel<uint32_t, 12, 1>\
    \ encmdcompl;\n      BitFieldModel<uint32_t, 11, 1> sdiosuspend;\n      BitFieldModel<uint32_t,\
    \ 10, 1> cpsmen;\n      BitFieldModel<uint32_t, 9, 1> waitpend;\n      BitFieldModel<uint32_t,\
    \ 8, 1> waitint;\n      BitFieldModel<uint32_t, 6, 2> waitresp;\n      BitFieldModel<uint32_t,\
    \ 0, 6> cmdindex;\n    };\n  };\n\npublic:\n  using cmd = CmdReg<BaseAddress +\
    \ 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class RespcmdReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using respcmd =\
    \ FieldModel<uint32_t, address, 0, 6>;\n\n  public:\n    union reg\n    {\n  \
    \    uint32_t value;\n      BitFieldModel<uint32_t, 0, 6> respcmd;\n    };\n \
    \ };\n\npublic:\n  using respcmd = RespcmdReg<BaseAddress + 0x0010>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Resp1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cardstatus1 = FieldModel<uint32_t, address,\
    \ 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> cardstatus1;\n    };\n  };\n\npublic:\n  using resp1 = Resp1Reg<BaseAddress\
    \ + 0x0014>;\n\nprivate:\n  template<unsigned int address>\n  class Resp2Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using cardstatus2\
    \ = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> cardstatus2;\n  \
    \  };\n  };\n\npublic:\n  using resp2 = Resp2Reg<BaseAddress + 0x0018>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Resp3Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using cardstatus3 = FieldModel<uint32_t, address,\
    \ 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> cardstatus3;\n    };\n  };\n\npublic:\n  using resp3 = Resp3Reg<BaseAddress\
    \ + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class Resp4Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using cardstatus4\
    \ = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 32> cardstatus4;\n  \
    \  };\n  };\n\npublic:\n  using resp4 = Resp4Reg<BaseAddress + 0x0020>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class DtimerReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using datatime = FieldModel<uint32_t, address,\
    \ 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> datatime;\n    };\n  };\n\npublic:\n  using dtimer = DtimerReg<BaseAddress\
    \ + 0x0024>;\n\nprivate:\n  template<unsigned int address>\n  class DlenReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using datalength\
    \ = FieldModel<uint32_t, address, 0, 25>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 25> datalength;\n   \
    \ };\n  };\n\npublic:\n  using dlen = DlenReg<BaseAddress + 0x0028>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class DctrlReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using sdioen = FieldModel<uint32_t, address, 11,\
    \ 1>;\n    using rwmod = FieldModel<uint32_t, address, 10, 1>;\n    using rwstop\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    using rwstart = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using dblocksize = FieldModel<uint32_t, address, 4, 4>;\n\
    \    using dmaen = FieldModel<uint32_t, address, 3, 1>;\n    using dtmode = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    using dtdir = FieldModel<uint32_t, address, 1, 1>;\n  \
    \  using dten = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      BitFieldModel<uint32_t, 11, 1> sdioen;\n\
    \      BitFieldModel<uint32_t, 10, 1> rwmod;\n      BitFieldModel<uint32_t, 9,\
    \ 1> rwstop;\n      BitFieldModel<uint32_t, 8, 1> rwstart;\n      BitFieldModel<uint32_t,\
    \ 4, 4> dblocksize;\n      BitFieldModel<uint32_t, 3, 1> dmaen;\n      BitFieldModel<uint32_t,\
    \ 2, 1> dtmode;\n      BitFieldModel<uint32_t, 1, 1> dtdir;\n      BitFieldModel<uint32_t,\
    \ 0, 1> dten;\n    };\n  };\n\npublic:\n  using dctrl = DctrlReg<BaseAddress +\
    \ 0x002C>;\n\nprivate:\n  template<unsigned int address>\n  class DcountReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    using datacount\
    \ = FieldModel<uint32_t, address, 0, 25>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 25> datacount;\n    };\n\
    \  };\n\npublic:\n  using dcount = DcountReg<BaseAddress + 0x0030>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class StaReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using ceataend = FieldModel<uint32_t, address,\
    \ 23, 1>;\n    using sdioit = FieldModel<uint32_t, address, 22, 1>;\n    using\
    \ rxdavl = FieldModel<uint32_t, address, 21, 1>;\n    using txdavl = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using rxfifoe = FieldModel<uint32_t, address, 19, 1>;\n\
    \    using txfifoe = FieldModel<uint32_t, address, 18, 1>;\n    using rxfifof\
    \ = FieldModel<uint32_t, address, 17, 1>;\n    using txfifof = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using rxfifohf = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using txfifohe = FieldModel<uint32_t, address, 14, 1>;\n    using rxact =\
    \ FieldModel<uint32_t, address, 13, 1>;\n    using txact = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using cmdact = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using dbckend = FieldModel<uint32_t, address, 10, 1>;\n    using stbiterr\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    using dataend = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using cmdsent = FieldModel<uint32_t, address, 7, 1>;\n\
    \    using cmdrend = FieldModel<uint32_t, address, 6, 1>;\n    using rxoverr =\
    \ FieldModel<uint32_t, address, 5, 1>;\n    using txunderr = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using dtimeout = FieldModel<uint32_t, address, 3, 1>;\n\
    \    using ctimeout = FieldModel<uint32_t, address, 2, 1>;\n    using dcrcfail\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using ccrcfail = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 23, 1> ceataend;\n      BitFieldModel<uint32_t,\
    \ 22, 1> sdioit;\n      BitFieldModel<uint32_t, 21, 1> rxdavl;\n      BitFieldModel<uint32_t,\
    \ 20, 1> txdavl;\n      BitFieldModel<uint32_t, 19, 1> rxfifoe;\n      BitFieldModel<uint32_t,\
    \ 18, 1> txfifoe;\n      BitFieldModel<uint32_t, 17, 1> rxfifof;\n      BitFieldModel<uint32_t,\
    \ 16, 1> txfifof;\n      BitFieldModel<uint32_t, 15, 1> rxfifohf;\n      BitFieldModel<uint32_t,\
    \ 14, 1> txfifohe;\n      BitFieldModel<uint32_t, 13, 1> rxact;\n      BitFieldModel<uint32_t,\
    \ 12, 1> txact;\n      BitFieldModel<uint32_t, 11, 1> cmdact;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dbckend;\n      BitFieldModel<uint32_t, 9, 1> stbiterr;\n      BitFieldModel<uint32_t,\
    \ 8, 1> dataend;\n      BitFieldModel<uint32_t, 7, 1> cmdsent;\n      BitFieldModel<uint32_t,\
    \ 6, 1> cmdrend;\n      BitFieldModel<uint32_t, 5, 1> rxoverr;\n      BitFieldModel<uint32_t,\
    \ 4, 1> txunderr;\n      BitFieldModel<uint32_t, 3, 1> dtimeout;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ctimeout;\n      BitFieldModel<uint32_t, 1, 1> dcrcfail;\n      BitFieldModel<uint32_t,\
    \ 0, 1> ccrcfail;\n    };\n  };\n\npublic:\n  using sta = StaReg<BaseAddress +\
    \ 0x0034>;\n\nprivate:\n  template<unsigned int address>\n  class IcrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    using ceataendc = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    using sdioitc = FieldModel<uint32_t, address, 22, 1>;\n\
    \    using dbckendc = FieldModel<uint32_t, address, 10, 1>;\n    using stbiterrc\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    using dataendc = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using cmdsentc = FieldModel<uint32_t, address, 7, 1>;\n\
    \    using cmdrendc = FieldModel<uint32_t, address, 6, 1>;\n    using rxoverrc\
    \ = FieldModel<uint32_t, address, 5, 1>;\n    using txunderrc = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using dtimeoutc = FieldModel<uint32_t, address, 3, 1>;\n\
    \    using ctimeoutc = FieldModel<uint32_t, address, 2, 1>;\n    using dcrcfailc\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using ccrcfailc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 23, 1> ceataendc;\n      BitFieldModel<uint32_t,\
    \ 22, 1> sdioitc;\n      BitFieldModel<uint32_t, 10, 1> dbckendc;\n      BitFieldModel<uint32_t,\
    \ 9, 1> stbiterrc;\n      BitFieldModel<uint32_t, 8, 1> dataendc;\n      BitFieldModel<uint32_t,\
    \ 7, 1> cmdsentc;\n      BitFieldModel<uint32_t, 6, 1> cmdrendc;\n      BitFieldModel<uint32_t,\
    \ 5, 1> rxoverrc;\n      BitFieldModel<uint32_t, 4, 1> txunderrc;\n      BitFieldModel<uint32_t,\
    \ 3, 1> dtimeoutc;\n      BitFieldModel<uint32_t, 2, 1> ctimeoutc;\n      BitFieldModel<uint32_t,\
    \ 1, 1> dcrcfailc;\n      BitFieldModel<uint32_t, 0, 1> ccrcfailc;\n    };\n \
    \ };\n\npublic:\n  using icr = IcrReg<BaseAddress + 0x0038>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class MaskReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    using ceataendie = FieldModel<uint32_t, address, 23, 1>;\n   \
    \ using sdioitie = FieldModel<uint32_t, address, 22, 1>;\n    using rxdavlie =\
    \ FieldModel<uint32_t, address, 21, 1>;\n    using txdavlie = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    using rxfifoeie = FieldModel<uint32_t, address, 19, 1>;\n\
    \    using txfifoeie = FieldModel<uint32_t, address, 18, 1>;\n    using rxfifofie\
    \ = FieldModel<uint32_t, address, 17, 1>;\n    using txfifofie = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    using rxfifohfie = FieldModel<uint32_t, address, 15, 1>;\n\
    \    using txfifoheie = FieldModel<uint32_t, address, 14, 1>;\n    using rxactie\
    \ = FieldModel<uint32_t, address, 13, 1>;\n    using txactie = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    using cmdactie = FieldModel<uint32_t, address, 11, 1>;\n\
    \    using dbckendie = FieldModel<uint32_t, address, 10, 1>;\n    using stbiterrie\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    using dataendie = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    using cmdsentie = FieldModel<uint32_t, address, 7, 1>;\n\
    \    using cmdrendie = FieldModel<uint32_t, address, 6, 1>;\n    using rxoverrie\
    \ = FieldModel<uint32_t, address, 5, 1>;\n    using txunderrie = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    using dtimeoutie = FieldModel<uint32_t, address, 3, 1>;\n\
    \    using ctimeoutie = FieldModel<uint32_t, address, 2, 1>;\n    using dcrcfailie\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    using ccrcfailie = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      BitFieldModel<uint32_t, 23, 1> ceataendie;\n      BitFieldModel<uint32_t,\
    \ 22, 1> sdioitie;\n      BitFieldModel<uint32_t, 21, 1> rxdavlie;\n      BitFieldModel<uint32_t,\
    \ 20, 1> txdavlie;\n      BitFieldModel<uint32_t, 19, 1> rxfifoeie;\n      BitFieldModel<uint32_t,\
    \ 18, 1> txfifoeie;\n      BitFieldModel<uint32_t, 17, 1> rxfifofie;\n      BitFieldModel<uint32_t,\
    \ 16, 1> txfifofie;\n      BitFieldModel<uint32_t, 15, 1> rxfifohfie;\n      BitFieldModel<uint32_t,\
    \ 14, 1> txfifoheie;\n      BitFieldModel<uint32_t, 13, 1> rxactie;\n      BitFieldModel<uint32_t,\
    \ 12, 1> txactie;\n      BitFieldModel<uint32_t, 11, 1> cmdactie;\n      BitFieldModel<uint32_t,\
    \ 10, 1> dbckendie;\n      BitFieldModel<uint32_t, 9, 1> stbiterrie;\n      BitFieldModel<uint32_t,\
    \ 8, 1> dataendie;\n      BitFieldModel<uint32_t, 7, 1> cmdsentie;\n      BitFieldModel<uint32_t,\
    \ 6, 1> cmdrendie;\n      BitFieldModel<uint32_t, 5, 1> rxoverrie;\n      BitFieldModel<uint32_t,\
    \ 4, 1> txunderrie;\n      BitFieldModel<uint32_t, 3, 1> dtimeoutie;\n      BitFieldModel<uint32_t,\
    \ 2, 1> ctimeoutie;\n      BitFieldModel<uint32_t, 1, 1> dcrcfailie;\n      BitFieldModel<uint32_t,\
    \ 0, 1> ccrcfailie;\n    };\n  };\n\npublic:\n  using mask = MaskReg<BaseAddress\
    \ + 0x003C>;\n\nprivate:\n  template<unsigned int address>\n  class FifocntReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    using fifocount\
    \ = FieldModel<uint32_t, address, 0, 24>;\n\n  public:\n    union reg\n    {\n\
    \      uint32_t value;\n      BitFieldModel<uint32_t, 0, 24> fifocount;\n    };\n\
    \  };\n\npublic:\n  using fifocnt = FifocntReg<BaseAddress + 0x0048>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class FifoReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    using fifodata = FieldModel<uint32_t, address,\
    \ 0, 32>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n      BitFieldModel<uint32_t,\
    \ 0, 32> fifodata;\n    };\n  };\n\npublic:\n  using fifo = FifoReg<BaseAddress\
    \ + 0x0080>;\n\n\n};\n\n}\n\n#endif /* DRAL_STM32F446_SDIO_H */\n"
  name: SDIO
