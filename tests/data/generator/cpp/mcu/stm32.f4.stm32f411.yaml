- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_ADC_COMMON_H\n#define DRAL_STM32F411_ADC_COMMON_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ ADC_COMMON peripheral\n *\n * ADC common registers\n */\nclass adc_common\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40012300; /**< Peripheral\
    \ base address */\n\nprivate:\n  template<unsigned int address>\n  class CsrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ OVR3 field\n     *\n     * Overrun flag of ADC3\n     */\n    using ovr3 = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    /**\n     * @brief STRT3 field\n     *\n     * Regular\
    \ channel Start flag of ADC\n     *               3\n     */\n    using strt3\
    \ = FieldModel<uint32_t, address, 20, 1>;\n    /**\n     * @brief JSTRT3 field\n\
    \     *\n     * Injected channel Start flag of ADC\n     *               3\n \
    \    */\n    using jstrt3 = FieldModel<uint32_t, address, 19, 1>;\n    /**\n \
    \    * @brief JEOC3 field\n     *\n     * Injected channel end of conversion of\n\
    \     *               ADC 3\n     */\n    using jeoc3 = FieldModel<uint32_t, address,\
    \ 18, 1>;\n    /**\n     * @brief EOC3 field\n     *\n     * End of conversion\
    \ of ADC 3\n     */\n    using eoc3 = FieldModel<uint32_t, address, 17, 1>;\n\
    \    /**\n     * @brief AWD3 field\n     *\n     * Analog watchdog flag of ADC\n\
    \     *               3\n     */\n    using awd3 = FieldModel<uint32_t, address,\
    \ 16, 1>;\n    /**\n     * @brief OVR2 field\n     *\n     * Overrun flag of ADC\
    \ 2\n     */\n    using ovr2 = FieldModel<uint32_t, address, 13, 1>;\n    /**\n\
    \     * @brief STRT2 field\n     *\n     * Regular channel Start flag of ADC\n\
    \     *               2\n     */\n    using strt2 = FieldModel<uint32_t, address,\
    \ 12, 1>;\n    /**\n     * @brief JSTRT2 field\n     *\n     * Injected channel\
    \ Start flag of ADC\n     *               2\n     */\n    using jstrt2 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief JEOC2 field\n     *\n     * Injected\
    \ channel end of conversion of\n     *               ADC 2\n     */\n    using\
    \ jeoc2 = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief EOC2 field\n\
    \     *\n     * End of conversion of ADC 2\n     */\n    using eoc2 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief AWD2 field\n     *\n     * Analog watchdog\
    \ flag of ADC\n     *               2\n     */\n    using awd2 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief OVR1 field\n     *\n     * Overrun flag\
    \ of ADC 1\n     */\n    using ovr1 = FieldModel<uint32_t, address, 5, 1>;\n \
    \   /**\n     * @brief STRT1 field\n     *\n     * Regular channel Start flag\
    \ of ADC\n     *               1\n     */\n    using strt1 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief JSTRT1 field\n     *\n     * Injected\
    \ channel Start flag of ADC\n     *               1\n     */\n    using jstrt1\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief JEOC1 field\n\
    \     *\n     * Injected channel end of conversion of\n     *               ADC\
    \ 1\n     */\n    using jeoc1 = FieldModel<uint32_t, address, 2, 1>;\n    /**\n\
    \     * @brief EOC1 field\n     *\n     * End of conversion of ADC 1\n     */\n\
    \    using eoc1 = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief\
    \ AWD1 field\n     *\n     * Analog watchdog flag of ADC\n     *             \
    \  1\n     */\n    using awd1 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief OVR3 field\n       *\n       * Overrun flag of ADC3\n       */\n\
    \      BitFieldModel<uint32_t, 21, 1> ovr3;\n      /**\n       * @brief STRT3\
    \ field\n       *\n       * Regular channel Start flag of ADC\n       *      \
    \         3\n       */\n      BitFieldModel<uint32_t, 20, 1> strt3;\n      /**\n\
    \       * @brief JSTRT3 field\n       *\n       * Injected channel Start flag\
    \ of ADC\n       *               3\n       */\n      BitFieldModel<uint32_t, 19,\
    \ 1> jstrt3;\n      /**\n       * @brief JEOC3 field\n       *\n       * Injected\
    \ channel end of conversion of\n       *               ADC 3\n       */\n    \
    \  BitFieldModel<uint32_t, 18, 1> jeoc3;\n      /**\n       * @brief EOC3 field\n\
    \       *\n       * End of conversion of ADC 3\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> eoc3;\n      /**\n       * @brief AWD3 field\n       *\n       * Analog\
    \ watchdog flag of ADC\n       *               3\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> awd3;\n      /**\n       * @brief OVR2 field\n       *\n       * Overrun\
    \ flag of ADC 2\n       */\n      BitFieldModel<uint32_t, 13, 1> ovr2;\n     \
    \ /**\n       * @brief STRT2 field\n       *\n       * Regular channel Start flag\
    \ of ADC\n       *               2\n       */\n      BitFieldModel<uint32_t, 12,\
    \ 1> strt2;\n      /**\n       * @brief JSTRT2 field\n       *\n       * Injected\
    \ channel Start flag of ADC\n       *               2\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> jstrt2;\n      /**\n       * @brief JEOC2 field\n       *\n       * Injected\
    \ channel end of conversion of\n       *               ADC 2\n       */\n    \
    \  BitFieldModel<uint32_t, 10, 1> jeoc2;\n      /**\n       * @brief EOC2 field\n\
    \       *\n       * End of conversion of ADC 2\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> eoc2;\n      /**\n       * @brief AWD2 field\n       *\n       * Analog\
    \ watchdog flag of ADC\n       *               2\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> awd2;\n      /**\n       * @brief OVR1 field\n       *\n       * Overrun\
    \ flag of ADC 1\n       */\n      BitFieldModel<uint32_t, 5, 1> ovr1;\n      /**\n\
    \       * @brief STRT1 field\n       *\n       * Regular channel Start flag of\
    \ ADC\n       *               1\n       */\n      BitFieldModel<uint32_t, 4, 1>\
    \ strt1;\n      /**\n       * @brief JSTRT1 field\n       *\n       * Injected\
    \ channel Start flag of ADC\n       *               1\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> jstrt1;\n      /**\n       * @brief JEOC1 field\n       *\n       * Injected\
    \ channel end of conversion of\n       *               ADC 1\n       */\n    \
    \  BitFieldModel<uint32_t, 2, 1> jeoc1;\n      /**\n       * @brief EOC1 field\n\
    \       *\n       * End of conversion of ADC 1\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> eoc1;\n      /**\n       * @brief AWD1 field\n       *\n       * Analog\
    \ watchdog flag of ADC\n       *               1\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> awd1;\n    };\n  };\n\npublic:\n  /**\n   * @brief CSR register\n   *\n\
    \   * ADC Common status register\n   */\n  using csr = CsrReg<BaseAddress + 0x0000>;\n\
    \nprivate:\n  template<unsigned int address>\n  class CcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief TSVREFE field\n     *\n   \
    \  * Temperature sensor and VREFINT\n     *               enable\n     */\n  \
    \  using tsvrefe = FieldModel<uint32_t, address, 23, 1>;\n    /**\n     * @brief\
    \ VBATE field\n     *\n     * VBAT enable\n     */\n    using vbate = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    /**\n     * @brief ADCPRE field\n     *\n     * ADC prescaler\n\
    \     */\n    using adcpre = FieldModel<uint32_t, address, 16, 2>;\n    /**\n\
    \     * @brief DMA field\n     *\n     * Direct memory access mode for multi ADC\n\
    \     *               mode\n     */\n    using dma = FieldModel<uint32_t, address,\
    \ 14, 2>;\n    /**\n     * @brief DDS field\n     *\n     * DMA disable selection\
    \ for multi-ADC\n     *               mode\n     */\n    using dds = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief DELAY field\n     *\n     * Delay between\
    \ 2 sampling\n     *               phases\n     */\n    using delay = FieldModel<uint32_t,\
    \ address, 8, 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief TSVREFE field\n       *\n\
    \       * Temperature sensor and VREFINT\n       *               enable\n    \
    \   */\n      BitFieldModel<uint32_t, 23, 1> tsvrefe;\n      /**\n       * @brief\
    \ VBATE field\n       *\n       * VBAT enable\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> vbate;\n      /**\n       * @brief ADCPRE field\n       *\n       * ADC\
    \ prescaler\n       */\n      BitFieldModel<uint32_t, 16, 2> adcpre;\n      /**\n\
    \       * @brief DMA field\n       *\n       * Direct memory access mode for multi\
    \ ADC\n       *               mode\n       */\n      BitFieldModel<uint32_t, 14,\
    \ 2> dma;\n      /**\n       * @brief DDS field\n       *\n       * DMA disable\
    \ selection for multi-ADC\n       *               mode\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> dds;\n      /**\n       * @brief DELAY field\n       *\n       * Delay\
    \ between 2 sampling\n       *               phases\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 4> delay;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCR register\n   *\n\
    \   * ADC common control register\n   */\n  using ccr = CcrReg<BaseAddress + 0x0004>;\n\
    \n};\n\n}\n\n#endif /* DRAL_STM32F411_ADC_COMMON_H */"
  name: ADC_Common
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_ADC1_H\n#define DRAL_STM32F411_ADC1_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ ADC1 peripheral\n *\n * Analog-to-digital converter\n */\nclass adc1\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40012000; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class SrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief OVR\
    \ field\n     *\n     * Overrun\n     */\n    using ovr = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief STRT field\n     *\n     * Regular channel\
    \ start flag\n     */\n    using strt = FieldModel<uint32_t, address, 4, 1>;\n\
    \    /**\n     * @brief JSTRT field\n     *\n     * Injected channel start\n \
    \    *               flag\n     */\n    using jstrt = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief JEOC field\n     *\n     * Injected channel end\
    \ of\n     *               conversion\n     */\n    using jeoc = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief EOC field\n     *\n     * Regular channel\
    \ end of\n     *               conversion\n     */\n    using eoc = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief AWD field\n     *\n     * Analog watchdog\
    \ flag\n     */\n    using awd = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief OVR field\n       *\n       * Overrun\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> ovr;\n      /**\n       * @brief STRT field\n       *\n       * Regular\
    \ channel start flag\n       */\n      BitFieldModel<uint32_t, 4, 1> strt;\n \
    \     /**\n       * @brief JSTRT field\n       *\n       * Injected channel start\n\
    \       *               flag\n       */\n      BitFieldModel<uint32_t, 3, 1> jstrt;\n\
    \      /**\n       * @brief JEOC field\n       *\n       * Injected channel end\
    \ of\n       *               conversion\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> jeoc;\n      /**\n       * @brief EOC field\n       *\n       * Regular\
    \ channel end of\n       *               conversion\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> eoc;\n      /**\n       * @brief AWD field\n       *\n       * Analog\
    \ watchdog flag\n       */\n      BitFieldModel<uint32_t, 0, 1> awd;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief SR register\n   *\n   * status register\n\
    \   */\n  using sr = SrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief OVRIE field\n     *\n     * Overrun interrupt\
    \ enable\n     */\n    using ovrie = FieldModel<uint32_t, address, 26, 1>;\n \
    \   /**\n     * @brief RES field\n     *\n     * Resolution\n     */\n    using\
    \ res = FieldModel<uint32_t, address, 24, 2>;\n    /**\n     * @brief AWDEN field\n\
    \     *\n     * Analog watchdog enable on regular\n     *               channels\n\
    \     */\n    using awden = FieldModel<uint32_t, address, 23, 1>;\n    /**\n \
    \    * @brief JAWDEN field\n     *\n     * Analog watchdog enable on injected\n\
    \     *               channels\n     */\n    using jawden = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    /**\n     * @brief DISCNUM field\n     *\n     * Discontinuous\
    \ mode channel\n     *               count\n     */\n    using discnum = FieldModel<uint32_t,\
    \ address, 13, 3>;\n    /**\n     * @brief JDISCEN field\n     *\n     * Discontinuous\
    \ mode on injected\n     *               channels\n     */\n    using jdiscen\
    \ = FieldModel<uint32_t, address, 12, 1>;\n    /**\n     * @brief DISCEN field\n\
    \     *\n     * Discontinuous mode on regular\n     *               channels\n\
    \     */\n    using discen = FieldModel<uint32_t, address, 11, 1>;\n    /**\n\
    \     * @brief JAUTO field\n     *\n     * Automatic injected group\n     *  \
    \             conversion\n     */\n    using jauto = FieldModel<uint32_t, address,\
    \ 10, 1>;\n    /**\n     * @brief AWDSGL field\n     *\n     * Enable the watchdog\
    \ on a single channel\n     *               in scan mode\n     */\n    using awdsgl\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief SCAN field\n\
    \     *\n     * Scan mode\n     */\n    using scan = FieldModel<uint32_t, address,\
    \ 8, 1>;\n    /**\n     * @brief JEOCIE field\n     *\n     * Interrupt enable\
    \ for injected\n     *               channels\n     */\n    using jeocie = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief AWDIE field\n     *\n     * Analog watchdog\
    \ interrupt\n     *               enable\n     */\n    using awdie = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief EOCIE field\n     *\n     * Interrupt\
    \ enable for EOC\n     */\n    using eocie = FieldModel<uint32_t, address, 5,\
    \ 1>;\n    /**\n     * @brief AWDCH field\n     *\n     * Analog watchdog channel\
    \ select\n     *               bits\n     */\n    using awdch = FieldModel<uint32_t,\
    \ address, 0, 5>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OVRIE field\n       *\n\
    \       * Overrun interrupt enable\n       */\n      BitFieldModel<uint32_t, 26,\
    \ 1> ovrie;\n      /**\n       * @brief RES field\n       *\n       * Resolution\n\
    \       */\n      BitFieldModel<uint32_t, 24, 2> res;\n      /**\n       * @brief\
    \ AWDEN field\n       *\n       * Analog watchdog enable on regular\n       *\
    \               channels\n       */\n      BitFieldModel<uint32_t, 23, 1> awden;\n\
    \      /**\n       * @brief JAWDEN field\n       *\n       * Analog watchdog enable\
    \ on injected\n       *               channels\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> jawden;\n      /**\n       * @brief DISCNUM field\n       *\n       *\
    \ Discontinuous mode channel\n       *               count\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 3> discnum;\n      /**\n       * @brief JDISCEN field\n       *\n      \
    \ * Discontinuous mode on injected\n       *               channels\n       */\n\
    \      BitFieldModel<uint32_t, 12, 1> jdiscen;\n      /**\n       * @brief DISCEN\
    \ field\n       *\n       * Discontinuous mode on regular\n       *          \
    \     channels\n       */\n      BitFieldModel<uint32_t, 11, 1> discen;\n    \
    \  /**\n       * @brief JAUTO field\n       *\n       * Automatic injected group\n\
    \       *               conversion\n       */\n      BitFieldModel<uint32_t, 10,\
    \ 1> jauto;\n      /**\n       * @brief AWDSGL field\n       *\n       * Enable\
    \ the watchdog on a single channel\n       *               in scan mode\n    \
    \   */\n      BitFieldModel<uint32_t, 9, 1> awdsgl;\n      /**\n       * @brief\
    \ SCAN field\n       *\n       * Scan mode\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> scan;\n      /**\n       * @brief JEOCIE field\n       *\n       * Interrupt\
    \ enable for injected\n       *               channels\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> jeocie;\n      /**\n       * @brief AWDIE field\n       *\n       * Analog\
    \ watchdog interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> awdie;\n      /**\n       * @brief EOCIE field\n       *\n       * Interrupt\
    \ enable for EOC\n       */\n      BitFieldModel<uint32_t, 5, 1> eocie;\n    \
    \  /**\n       * @brief AWDCH field\n       *\n       * Analog watchdog channel\
    \ select\n       *               bits\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 5> awdch;\n    };\n  };\n\npublic:\n  /**\n   * @brief CR1 register\n   *\n\
    \   * control register 1\n   */\n  using cr1 = Cr1Reg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Cr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief SWSTART field\n     *\n   \
    \  * Start conversion of regular\n     *               channels\n     */\n   \
    \ using swstart = FieldModel<uint32_t, address, 30, 1>;\n    /**\n     * @brief\
    \ EXTEN field\n     *\n     * External trigger enable for regular\n     *    \
    \           channels\n     */\n    using exten = FieldModel<uint32_t, address,\
    \ 28, 2>;\n    /**\n     * @brief EXTSEL field\n     *\n     * External event\
    \ select for regular\n     *               group\n     */\n    using extsel =\
    \ FieldModel<uint32_t, address, 24, 4>;\n    /**\n     * @brief JSWSTART field\n\
    \     *\n     * Start conversion of injected\n     *               channels\n\
    \     */\n    using jswstart = FieldModel<uint32_t, address, 22, 1>;\n    /**\n\
    \     * @brief JEXTEN field\n     *\n     * External trigger enable for injected\n\
    \     *               channels\n     */\n    using jexten = FieldModel<uint32_t,\
    \ address, 20, 2>;\n    /**\n     * @brief JEXTSEL field\n     *\n     * External\
    \ event select for injected\n     *               group\n     */\n    using jextsel\
    \ = FieldModel<uint32_t, address, 16, 4>;\n    /**\n     * @brief ALIGN field\n\
    \     *\n     * Data alignment\n     */\n    using align = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief EOCS field\n     *\n     * End of conversion\n\
    \     *               selection\n     */\n    using eocs = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief DDS field\n     *\n     * DMA disable\
    \ selection (for single ADC\n     *               mode)\n     */\n    using dds\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief DMA field\n \
    \    *\n     * Direct memory access mode (for single\n     *               ADC\
    \ mode)\n     */\n    using dma = FieldModel<uint32_t, address, 8, 1>;\n    /**\n\
    \     * @brief CONT field\n     *\n     * Continuous conversion\n     */\n   \
    \ using cont = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief ADON\
    \ field\n     *\n     * A/D Converter ON / OFF\n     */\n    using adon = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief SWSTART field\n       *\n\
    \       * Start conversion of regular\n       *               channels\n     \
    \  */\n      BitFieldModel<uint32_t, 30, 1> swstart;\n      /**\n       * @brief\
    \ EXTEN field\n       *\n       * External trigger enable for regular\n      \
    \ *               channels\n       */\n      BitFieldModel<uint32_t, 28, 2> exten;\n\
    \      /**\n       * @brief EXTSEL field\n       *\n       * External event select\
    \ for regular\n       *               group\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 4> extsel;\n      /**\n       * @brief JSWSTART field\n       *\n      \
    \ * Start conversion of injected\n       *               channels\n       */\n\
    \      BitFieldModel<uint32_t, 22, 1> jswstart;\n      /**\n       * @brief JEXTEN\
    \ field\n       *\n       * External trigger enable for injected\n       *   \
    \            channels\n       */\n      BitFieldModel<uint32_t, 20, 2> jexten;\n\
    \      /**\n       * @brief JEXTSEL field\n       *\n       * External event select\
    \ for injected\n       *               group\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 4> jextsel;\n      /**\n       * @brief ALIGN field\n       *\n       *\
    \ Data alignment\n       */\n      BitFieldModel<uint32_t, 11, 1> align;\n   \
    \   /**\n       * @brief EOCS field\n       *\n       * End of conversion\n  \
    \     *               selection\n       */\n      BitFieldModel<uint32_t, 10,\
    \ 1> eocs;\n      /**\n       * @brief DDS field\n       *\n       * DMA disable\
    \ selection (for single ADC\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> dds;\n      /**\n       * @brief DMA field\n       *\n       * Direct\
    \ memory access mode (for single\n       *               ADC mode)\n       */\n\
    \      BitFieldModel<uint32_t, 8, 1> dma;\n      /**\n       * @brief CONT field\n\
    \       *\n       * Continuous conversion\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cont;\n      /**\n       * @brief ADON field\n       *\n       * A/D Converter\
    \ ON / OFF\n       */\n      BitFieldModel<uint32_t, 0, 1> adon;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief CR2 register\n   *\n   * control register 2\n  \
    \ */\n  using cr2 = Cr2Reg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Smpr1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief SMPX_X field\n     *\n     * Sample time\
    \ bits\n     */\n    using smpx_x = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief SMPX_X field\n       *\n       * Sample time\
    \ bits\n       */\n      BitFieldModel<uint32_t, 0, 32> smpx_x;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief SMPR1 register\n   *\n   * sample time register\
    \ 1\n   */\n  using smpr1 = Smpr1Reg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Smpr2Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief SMPX_X field\n     *\n     * Sample time\
    \ bits\n     */\n    using smpx_x = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief SMPX_X field\n       *\n       * Sample time\
    \ bits\n       */\n      BitFieldModel<uint32_t, 0, 32> smpx_x;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief SMPR2 register\n   *\n   * sample time register\
    \ 2\n   */\n  using smpr2 = Smpr2Reg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Jofr1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief JOFFSET1 field\n     *\n     * Data offset\
    \ for injected channel\n     *               x\n     */\n    using joffset1 =\
    \ FieldModel<uint32_t, address, 0, 12>;\n\n  public:\n    /**\n     * @brief Register\
    \ union\n     *\n     * Can be used to create a local register variable for easy\
    \ bit manipulation.\n     * Useful for read-modify-write operations.\n     */\n\
    \    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief JOFFSET1\
    \ field\n       *\n       * Data offset for injected channel\n       *       \
    \        x\n       */\n      BitFieldModel<uint32_t, 0, 12> joffset1;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief JOFR1 register\n   *\n   * injected channel\
    \ data offset register\n   *           x\n   */\n  using jofr1 = Jofr1Reg<BaseAddress\
    \ + 0x0014>;\n\nprivate:\n  template<unsigned int address>\n  class Jofr2Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ JOFFSET2 field\n     *\n     * Data offset for injected channel\n     *    \
    \           x\n     */\n    using joffset2 = FieldModel<uint32_t, address, 0,\
    \ 12>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief JOFFSET2 field\n       *\n\
    \       * Data offset for injected channel\n       *               x\n       */\n\
    \      BitFieldModel<uint32_t, 0, 12> joffset2;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief JOFR2 register\n   *\n   * injected channel data offset register\n\
    \   *           x\n   */\n  using jofr2 = Jofr2Reg<BaseAddress + 0x0018>;\n\n\
    private:\n  template<unsigned int address>\n  class Jofr3Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief JOFFSET3 field\n     *\n  \
    \   * Data offset for injected channel\n     *               x\n     */\n    using\
    \ joffset3 = FieldModel<uint32_t, address, 0, 12>;\n\n  public:\n    /**\n   \
    \  * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ JOFFSET3 field\n       *\n       * Data offset for injected channel\n      \
    \ *               x\n       */\n      BitFieldModel<uint32_t, 0, 12> joffset3;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief JOFR3 register\n   *\n   * injected\
    \ channel data offset register\n   *           x\n   */\n  using jofr3 = Jofr3Reg<BaseAddress\
    \ + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class Jofr4Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ JOFFSET4 field\n     *\n     * Data offset for injected channel\n     *    \
    \           x\n     */\n    using joffset4 = FieldModel<uint32_t, address, 0,\
    \ 12>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief JOFFSET4 field\n       *\n\
    \       * Data offset for injected channel\n       *               x\n       */\n\
    \      BitFieldModel<uint32_t, 0, 12> joffset4;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief JOFR4 register\n   *\n   * injected channel data offset register\n\
    \   *           x\n   */\n  using jofr4 = Jofr4Reg<BaseAddress + 0x0020>;\n\n\
    private:\n  template<unsigned int address>\n  class HtrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief HT field\n     *\n     * Analog\
    \ watchdog higher\n     *               threshold\n     */\n    using ht = FieldModel<uint32_t,\
    \ address, 0, 12>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief HT field\n       *\n  \
    \     * Analog watchdog higher\n       *               threshold\n       */\n\
    \      BitFieldModel<uint32_t, 0, 12> ht;\n    };\n  };\n\npublic:\n  /**\n  \
    \ * @brief HTR register\n   *\n   * watchdog higher threshold\n   *          \
    \ register\n   */\n  using htr = HtrReg<BaseAddress + 0x0024>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class LtrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief LT field\n     *\n     * Analog\
    \ watchdog lower\n     *               threshold\n     */\n    using lt = FieldModel<uint32_t,\
    \ address, 0, 12>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief LT field\n       *\n  \
    \     * Analog watchdog lower\n       *               threshold\n       */\n \
    \     BitFieldModel<uint32_t, 0, 12> lt;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief LTR register\n   *\n   * watchdog lower threshold\n   *           register\n\
    \   */\n  using ltr = LtrReg<BaseAddress + 0x0028>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Sqr1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief L field\n     *\n     * Regular channel sequence\n\
    \     *               length\n     */\n    using l = FieldModel<uint32_t, address,\
    \ 20, 4>;\n    /**\n     * @brief SQ16 field\n     *\n     * 16th conversion in\
    \ regular\n     *               sequence\n     */\n    using sq16 = FieldModel<uint32_t,\
    \ address, 15, 5>;\n    /**\n     * @brief SQ15 field\n     *\n     * 15th conversion\
    \ in regular\n     *               sequence\n     */\n    using sq15 = FieldModel<uint32_t,\
    \ address, 10, 5>;\n    /**\n     * @brief SQ14 field\n     *\n     * 14th conversion\
    \ in regular\n     *               sequence\n     */\n    using sq14 = FieldModel<uint32_t,\
    \ address, 5, 5>;\n    /**\n     * @brief SQ13 field\n     *\n     * 13th conversion\
    \ in regular\n     *               sequence\n     */\n    using sq13 = FieldModel<uint32_t,\
    \ address, 0, 5>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief L field\n       *\n   \
    \    * Regular channel sequence\n       *               length\n       */\n  \
    \    BitFieldModel<uint32_t, 20, 4> l;\n      /**\n       * @brief SQ16 field\n\
    \       *\n       * 16th conversion in regular\n       *               sequence\n\
    \       */\n      BitFieldModel<uint32_t, 15, 5> sq16;\n      /**\n       * @brief\
    \ SQ15 field\n       *\n       * 15th conversion in regular\n       *        \
    \       sequence\n       */\n      BitFieldModel<uint32_t, 10, 5> sq15;\n    \
    \  /**\n       * @brief SQ14 field\n       *\n       * 14th conversion in regular\n\
    \       *               sequence\n       */\n      BitFieldModel<uint32_t, 5,\
    \ 5> sq14;\n      /**\n       * @brief SQ13 field\n       *\n       * 13th conversion\
    \ in regular\n       *               sequence\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 5> sq13;\n    };\n  };\n\npublic:\n  /**\n   * @brief SQR1 register\n   *\n\
    \   * regular sequence register 1\n   */\n  using sqr1 = Sqr1Reg<BaseAddress +\
    \ 0x002C>;\n\nprivate:\n  template<unsigned int address>\n  class Sqr2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief SQ12\
    \ field\n     *\n     * 12th conversion in regular\n     *               sequence\n\
    \     */\n    using sq12 = FieldModel<uint32_t, address, 25, 5>;\n    /**\n  \
    \   * @brief SQ11 field\n     *\n     * 11th conversion in regular\n     *   \
    \            sequence\n     */\n    using sq11 = FieldModel<uint32_t, address,\
    \ 20, 5>;\n    /**\n     * @brief SQ10 field\n     *\n     * 10th conversion in\
    \ regular\n     *               sequence\n     */\n    using sq10 = FieldModel<uint32_t,\
    \ address, 15, 5>;\n    /**\n     * @brief SQ9 field\n     *\n     * 9th conversion\
    \ in regular\n     *               sequence\n     */\n    using sq9 = FieldModel<uint32_t,\
    \ address, 10, 5>;\n    /**\n     * @brief SQ8 field\n     *\n     * 8th conversion\
    \ in regular\n     *               sequence\n     */\n    using sq8 = FieldModel<uint32_t,\
    \ address, 5, 5>;\n    /**\n     * @brief SQ7 field\n     *\n     * 7th conversion\
    \ in regular\n     *               sequence\n     */\n    using sq7 = FieldModel<uint32_t,\
    \ address, 0, 5>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief SQ12 field\n       *\n\
    \       * 12th conversion in regular\n       *               sequence\n      \
    \ */\n      BitFieldModel<uint32_t, 25, 5> sq12;\n      /**\n       * @brief SQ11\
    \ field\n       *\n       * 11th conversion in regular\n       *             \
    \  sequence\n       */\n      BitFieldModel<uint32_t, 20, 5> sq11;\n      /**\n\
    \       * @brief SQ10 field\n       *\n       * 10th conversion in regular\n \
    \      *               sequence\n       */\n      BitFieldModel<uint32_t, 15,\
    \ 5> sq10;\n      /**\n       * @brief SQ9 field\n       *\n       * 9th conversion\
    \ in regular\n       *               sequence\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 5> sq9;\n      /**\n       * @brief SQ8 field\n       *\n       * 8th conversion\
    \ in regular\n       *               sequence\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 5> sq8;\n      /**\n       * @brief SQ7 field\n       *\n       * 7th conversion\
    \ in regular\n       *               sequence\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 5> sq7;\n    };\n  };\n\npublic:\n  /**\n   * @brief SQR2 register\n   *\n\
    \   * regular sequence register 2\n   */\n  using sqr2 = Sqr2Reg<BaseAddress +\
    \ 0x0030>;\n\nprivate:\n  template<unsigned int address>\n  class Sqr3Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief SQ6\
    \ field\n     *\n     * 6th conversion in regular\n     *               sequence\n\
    \     */\n    using sq6 = FieldModel<uint32_t, address, 25, 5>;\n    /**\n   \
    \  * @brief SQ5 field\n     *\n     * 5th conversion in regular\n     *      \
    \         sequence\n     */\n    using sq5 = FieldModel<uint32_t, address, 20,\
    \ 5>;\n    /**\n     * @brief SQ4 field\n     *\n     * 4th conversion in regular\n\
    \     *               sequence\n     */\n    using sq4 = FieldModel<uint32_t,\
    \ address, 15, 5>;\n    /**\n     * @brief SQ3 field\n     *\n     * 3rd conversion\
    \ in regular\n     *               sequence\n     */\n    using sq3 = FieldModel<uint32_t,\
    \ address, 10, 5>;\n    /**\n     * @brief SQ2 field\n     *\n     * 2nd conversion\
    \ in regular\n     *               sequence\n     */\n    using sq2 = FieldModel<uint32_t,\
    \ address, 5, 5>;\n    /**\n     * @brief SQ1 field\n     *\n     * 1st conversion\
    \ in regular\n     *               sequence\n     */\n    using sq1 = FieldModel<uint32_t,\
    \ address, 0, 5>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief SQ6 field\n       *\n \
    \      * 6th conversion in regular\n       *               sequence\n       */\n\
    \      BitFieldModel<uint32_t, 25, 5> sq6;\n      /**\n       * @brief SQ5 field\n\
    \       *\n       * 5th conversion in regular\n       *               sequence\n\
    \       */\n      BitFieldModel<uint32_t, 20, 5> sq5;\n      /**\n       * @brief\
    \ SQ4 field\n       *\n       * 4th conversion in regular\n       *          \
    \     sequence\n       */\n      BitFieldModel<uint32_t, 15, 5> sq4;\n      /**\n\
    \       * @brief SQ3 field\n       *\n       * 3rd conversion in regular\n   \
    \    *               sequence\n       */\n      BitFieldModel<uint32_t, 10, 5>\
    \ sq3;\n      /**\n       * @brief SQ2 field\n       *\n       * 2nd conversion\
    \ in regular\n       *               sequence\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 5> sq2;\n      /**\n       * @brief SQ1 field\n       *\n       * 1st conversion\
    \ in regular\n       *               sequence\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 5> sq1;\n    };\n  };\n\npublic:\n  /**\n   * @brief SQR3 register\n   *\n\
    \   * regular sequence register 3\n   */\n  using sqr3 = Sqr3Reg<BaseAddress +\
    \ 0x0034>;\n\nprivate:\n  template<unsigned int address>\n  class JsqrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief JL\
    \ field\n     *\n     * Injected sequence length\n     */\n    using jl = FieldModel<uint32_t,\
    \ address, 20, 2>;\n    /**\n     * @brief JSQ4 field\n     *\n     * 4th conversion\
    \ in injected\n     *               sequence\n     */\n    using jsq4 = FieldModel<uint32_t,\
    \ address, 15, 5>;\n    /**\n     * @brief JSQ3 field\n     *\n     * 3rd conversion\
    \ in injected\n     *               sequence\n     */\n    using jsq3 = FieldModel<uint32_t,\
    \ address, 10, 5>;\n    /**\n     * @brief JSQ2 field\n     *\n     * 2nd conversion\
    \ in injected\n     *               sequence\n     */\n    using jsq2 = FieldModel<uint32_t,\
    \ address, 5, 5>;\n    /**\n     * @brief JSQ1 field\n     *\n     * 1st conversion\
    \ in injected\n     *               sequence\n     */\n    using jsq1 = FieldModel<uint32_t,\
    \ address, 0, 5>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief JL field\n       *\n  \
    \     * Injected sequence length\n       */\n      BitFieldModel<uint32_t, 20,\
    \ 2> jl;\n      /**\n       * @brief JSQ4 field\n       *\n       * 4th conversion\
    \ in injected\n       *               sequence\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 5> jsq4;\n      /**\n       * @brief JSQ3 field\n       *\n       * 3rd\
    \ conversion in injected\n       *               sequence\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 5> jsq3;\n      /**\n       * @brief JSQ2 field\n       *\n       * 2nd\
    \ conversion in injected\n       *               sequence\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 5> jsq2;\n      /**\n       * @brief JSQ1 field\n       *\n       * 1st conversion\
    \ in injected\n       *               sequence\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 5> jsq1;\n    };\n  };\n\npublic:\n  /**\n   * @brief JSQR register\n   *\n\
    \   * injected sequence register\n   */\n  using jsqr = JsqrReg<BaseAddress +\
    \ 0x0038>;\n\nprivate:\n  template<unsigned int address>\n  class Jdr1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief JDATA\
    \ field\n     *\n     * Injected data\n     */\n    using jdata = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief JDATA field\n       *\n\
    \       * Injected data\n       */\n      BitFieldModel<uint32_t, 0, 16> jdata;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief JDR1 register\n   *\n   * injected\
    \ data register x\n   */\n  using jdr1 = Jdr1Reg<BaseAddress + 0x003C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Jdr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief JDATA field\n     *\n     *\
    \ Injected data\n     */\n    using jdata = FieldModel<uint32_t, address, 0, 16>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief JDATA field\n       *\n       * Injected\
    \ data\n       */\n      BitFieldModel<uint32_t, 0, 16> jdata;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief JDR2 register\n   *\n   * injected data register\
    \ x\n   */\n  using jdr2 = Jdr2Reg<BaseAddress + 0x0040>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Jdr3Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief JDATA field\n     *\n     * Injected data\n\
    \     */\n    using jdata = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief JDATA field\n       *\n       * Injected data\n       */\n  \
    \    BitFieldModel<uint32_t, 0, 16> jdata;\n    };\n  };\n\npublic:\n  /**\n \
    \  * @brief JDR3 register\n   *\n   * injected data register x\n   */\n  using\
    \ jdr3 = Jdr3Reg<BaseAddress + 0x0044>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Jdr4Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief JDATA field\n     *\n     * Injected data\n     */\n  \
    \  using jdata = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ JDATA field\n       *\n       * Injected data\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> jdata;\n    };\n  };\n\npublic:\n  /**\n   * @brief JDR4 register\n \
    \  *\n   * injected data register x\n   */\n  using jdr4 = Jdr4Reg<BaseAddress\
    \ + 0x0048>;\n\nprivate:\n  template<unsigned int address>\n  class DrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief DATA\
    \ field\n     *\n     * Regular data\n     */\n    using data = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief DATA field\n       *\n\
    \       * Regular data\n       */\n      BitFieldModel<uint32_t, 0, 16> data;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief DR register\n   *\n   * regular data\
    \ register\n   */\n  using dr = DrReg<BaseAddress + 0x004C>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class SmprxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    /**\n     * @brief SMPX_X field\n\
    \     *\n     * Sample time bits\n     */\n    using smpx_x = FieldModel<uint32_t,\
    \ address, 0, 32, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief SMPX_X field\n       *\n       * Sample time\
    \ bits\n       */\n      BitFieldModel<uint32_t, 0, 32> smpx_x;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief SMPRX register bank\n   *\n   * sample time register\
    \ 1\n   */\n  using smprx = SmprxBankReg<BaseAddress + 0x000C, 0x0004>;\n\nprivate:\n\
    \  template<unsigned int address, unsigned int bankOffset>\n  class JdrxBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    /**\n     * @brief JDATA field\n     *\n     * Injected data\n     */\n \
    \   using jdata = FieldModel<uint32_t, address, 0, 16, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief JDATA\
    \ field\n       *\n       * Injected data\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> jdata;\n    };\n  };\n\npublic:\n  /**\n   * @brief JDRX register bank\n\
    \   *\n   * injected data register x\n   */\n  using jdrx = JdrxBankReg<BaseAddress\
    \ + 0x003C, 0x0004>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_ADC1_H */"
  name: ADC1
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_CRC_H\n#define DRAL_STM32F411_CRC_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ CRC peripheral\n *\n * Cryptographic processor\n */\nclass crc\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40023000; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class DrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief DR\
    \ field\n     *\n     * Data Register\n     */\n    using dr = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief DR field\n       *\n  \
    \     * Data Register\n       */\n      BitFieldModel<uint32_t, 0, 32> dr;\n \
    \   };\n  };\n\npublic:\n  /**\n   * @brief DR register\n   *\n   * Data register\n\
    \   */\n  using dr = DrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class IdrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief IDR field\n     *\n     * Independent Data\
    \ register\n     */\n    using idr = FieldModel<uint32_t, address, 0, 8>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief IDR field\n       *\n       * Independent\
    \ Data register\n       */\n      BitFieldModel<uint32_t, 0, 8> idr;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief IDR register\n   *\n   * Independent Data\
    \ register\n   */\n  using idr = IdrReg<BaseAddress + 0x0004>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class CrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CR field\n     *\n     * Control\
    \ regidter\n     */\n    using cr = FieldModel<uint32_t, address, 0, 1>;\n\n \
    \ public:\n    /**\n     * @brief Register union\n     *\n     * Can be used to\
    \ create a local register variable for easy bit manipulation.\n     * Useful for\
    \ read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief CR field\n       *\n       * Control regidter\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> cr;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR register\n   *\n   * Control register\n   */\n  using cr\
    \ = CrReg<BaseAddress + 0x0008>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_CRC_H\
    \ */"
  name: CRC
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_DBG_H\n#define DRAL_STM32F411_DBG_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ DBG peripheral\n *\n * Debug support\n */\nclass dbg\n{\npublic:\n  static constexpr\
    \ unsigned int BaseAddress = 0xE0042000; /**< Peripheral base address */\n\nprivate:\n\
    \  template<unsigned int address>\n  class Dbgmcu_idcodeReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief DEV_ID field\n     *\n    \
    \ * DEV_ID\n     */\n    using dev_id = FieldModel<uint32_t, address, 0, 12>;\n\
    \    /**\n     * @brief REV_ID field\n     *\n     * REV_ID\n     */\n    using\
    \ rev_id = FieldModel<uint32_t, address, 16, 16>;\n\n  public:\n    /**\n    \
    \ * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ DEV_ID field\n       *\n       * DEV_ID\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 12> dev_id;\n      /**\n       * @brief REV_ID field\n       *\n       *\
    \ REV_ID\n       */\n      BitFieldModel<uint32_t, 16, 16> rev_id;\n    };\n \
    \ };\n\npublic:\n  /**\n   * @brief DBGMCU_IDCODE register\n   *\n   * IDCODE\n\
    \   */\n  using dbgmcu_idcode = Dbgmcu_idcodeReg<BaseAddress + 0x0000>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Dbgmcu_crReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief DBG_SLEEP field\n     *\n \
    \    * DBG_SLEEP\n     */\n    using dbg_sleep = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    /**\n     * @brief DBG_STOP field\n     *\n     * DBG_STOP\n   \
    \  */\n    using dbg_stop = FieldModel<uint32_t, address, 1, 1>;\n    /**\n  \
    \   * @brief DBG_STANDBY field\n     *\n     * DBG_STANDBY\n     */\n    using\
    \ dbg_standby = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief TRACE_IOEN\
    \ field\n     *\n     * TRACE_IOEN\n     */\n    using trace_ioen = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief TRACE_MODE field\n     *\n     * TRACE_MODE\n\
    \     */\n    using trace_mode = FieldModel<uint32_t, address, 6, 2>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief DBG_SLEEP field\n       *\n       * DBG_SLEEP\n       */\n  \
    \    BitFieldModel<uint32_t, 0, 1> dbg_sleep;\n      /**\n       * @brief DBG_STOP\
    \ field\n       *\n       * DBG_STOP\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dbg_stop;\n      /**\n       * @brief DBG_STANDBY field\n       *\n  \
    \     * DBG_STANDBY\n       */\n      BitFieldModel<uint32_t, 2, 1> dbg_standby;\n\
    \      /**\n       * @brief TRACE_IOEN field\n       *\n       * TRACE_IOEN\n\
    \       */\n      BitFieldModel<uint32_t, 5, 1> trace_ioen;\n      /**\n     \
    \  * @brief TRACE_MODE field\n       *\n       * TRACE_MODE\n       */\n     \
    \ BitFieldModel<uint32_t, 6, 2> trace_mode;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief DBGMCU_CR register\n   *\n   * Control Register\n   */\n  using dbgmcu_cr\
    \ = Dbgmcu_crReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Dbgmcu_apb1_fzReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief DBG_TIM2_STOP field\n     *\n     * DBG_TIM2_STOP\n  \
    \   */\n    using dbg_tim2_stop = FieldModel<uint32_t, address, 0, 1>;\n    /**\n\
    \     * @brief DBG_TIM3_STOP field\n     *\n     * DBG_TIM3 _STOP\n     */\n \
    \   using dbg_tim3_stop = FieldModel<uint32_t, address, 1, 1>;\n    /**\n    \
    \ * @brief DBG_TIM4_STOP field\n     *\n     * DBG_TIM4_STOP\n     */\n    using\
    \ dbg_tim4_stop = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief\
    \ DBG_TIM5_STOP field\n     *\n     * DBG_TIM5_STOP\n     */\n    using dbg_tim5_stop\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief DBG_RTC_STOP\
    \ field\n     *\n     * RTC stopped when Core is\n     *               halted\n\
    \     */\n    using dbg_rtc_stop = FieldModel<uint32_t, address, 10, 1>;\n   \
    \ /**\n     * @brief DBG_WWDG_STOP field\n     *\n     * DBG_WWDG_STOP\n     */\n\
    \    using dbg_wwdg_stop = FieldModel<uint32_t, address, 11, 1>;\n    /**\n  \
    \   * @brief DBG_IWDEG_STOP field\n     *\n     * DBG_IWDEG_STOP\n     */\n  \
    \  using dbg_iwdeg_stop = FieldModel<uint32_t, address, 12, 1>;\n    /**\n   \
    \  * @brief DBG_I2C1_SMBUS_TIMEOUT field\n     *\n     * DBG_J2C1_SMBUS_TIMEOUT\n\
    \     */\n    using dbg_i2c1_smbus_timeout = FieldModel<uint32_t, address, 21,\
    \ 1>;\n    /**\n     * @brief DBG_I2C2_SMBUS_TIMEOUT field\n     *\n     * DBG_J2C2_SMBUS_TIMEOUT\n\
    \     */\n    using dbg_i2c2_smbus_timeout = FieldModel<uint32_t, address, 22,\
    \ 1>;\n    /**\n     * @brief DBG_I2C3SMBUS_TIMEOUT field\n     *\n     * DBG_J2C3SMBUS_TIMEOUT\n\
    \     */\n    using dbg_i2c3smbus_timeout = FieldModel<uint32_t, address, 23,\
    \ 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief DBG_TIM2_STOP field\n     \
    \  *\n       * DBG_TIM2_STOP\n       */\n      BitFieldModel<uint32_t, 0, 1> dbg_tim2_stop;\n\
    \      /**\n       * @brief DBG_TIM3_STOP field\n       *\n       * DBG_TIM3 _STOP\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> dbg_tim3_stop;\n      /**\n  \
    \     * @brief DBG_TIM4_STOP field\n       *\n       * DBG_TIM4_STOP\n       */\n\
    \      BitFieldModel<uint32_t, 2, 1> dbg_tim4_stop;\n      /**\n       * @brief\
    \ DBG_TIM5_STOP field\n       *\n       * DBG_TIM5_STOP\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> dbg_tim5_stop;\n      /**\n       * @brief DBG_RTC_STOP field\n      \
    \ *\n       * RTC stopped when Core is\n       *               halted\n      \
    \ */\n      BitFieldModel<uint32_t, 10, 1> dbg_rtc_stop;\n      /**\n       *\
    \ @brief DBG_WWDG_STOP field\n       *\n       * DBG_WWDG_STOP\n       */\n  \
    \    BitFieldModel<uint32_t, 11, 1> dbg_wwdg_stop;\n      /**\n       * @brief\
    \ DBG_IWDEG_STOP field\n       *\n       * DBG_IWDEG_STOP\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> dbg_iwdeg_stop;\n      /**\n       * @brief DBG_I2C1_SMBUS_TIMEOUT field\n\
    \       *\n       * DBG_J2C1_SMBUS_TIMEOUT\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 1> dbg_i2c1_smbus_timeout;\n      /**\n       * @brief DBG_I2C2_SMBUS_TIMEOUT\
    \ field\n       *\n       * DBG_J2C2_SMBUS_TIMEOUT\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> dbg_i2c2_smbus_timeout;\n      /**\n       * @brief DBG_I2C3SMBUS_TIMEOUT\
    \ field\n       *\n       * DBG_J2C3SMBUS_TIMEOUT\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 1> dbg_i2c3smbus_timeout;\n    };\n  };\n\npublic:\n  /**\n   * @brief DBGMCU_APB1_FZ\
    \ register\n   *\n   * Debug MCU APB1 Freeze registe\n   */\n  using dbgmcu_apb1_fz\
    \ = Dbgmcu_apb1_fzReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Dbgmcu_apb2_fzReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief DBG_TIM1_STOP field\n     *\n     * TIM1\
    \ counter stopped when core is\n     *               halted\n     */\n    using\
    \ dbg_tim1_stop = FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief\
    \ DBG_TIM9_STOP field\n     *\n     * TIM9 counter stopped when core is\n    \
    \ *               halted\n     */\n    using dbg_tim9_stop = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    /**\n     * @brief DBG_TIM10_STOP field\n     *\n    \
    \ * TIM10 counter stopped when core is\n     *               halted\n     */\n\
    \    using dbg_tim10_stop = FieldModel<uint32_t, address, 17, 1>;\n    /**\n \
    \    * @brief DBG_TIM11_STOP field\n     *\n     * TIM11 counter stopped when\
    \ core is\n     *               halted\n     */\n    using dbg_tim11_stop = FieldModel<uint32_t,\
    \ address, 18, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief DBG_TIM1_STOP field\n \
    \      *\n       * TIM1 counter stopped when core is\n       *               halted\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> dbg_tim1_stop;\n      /**\n  \
    \     * @brief DBG_TIM9_STOP field\n       *\n       * TIM9 counter stopped when\
    \ core is\n       *               halted\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> dbg_tim9_stop;\n      /**\n       * @brief DBG_TIM10_STOP field\n   \
    \    *\n       * TIM10 counter stopped when core is\n       *               halted\n\
    \       */\n      BitFieldModel<uint32_t, 17, 1> dbg_tim10_stop;\n      /**\n\
    \       * @brief DBG_TIM11_STOP field\n       *\n       * TIM11 counter stopped\
    \ when core is\n       *               halted\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 1> dbg_tim11_stop;\n    };\n  };\n\npublic:\n  /**\n   * @brief DBGMCU_APB2_FZ\
    \ register\n   *\n   * Debug MCU APB2 Freeze registe\n   */\n  using dbgmcu_apb2_fz\
    \ = Dbgmcu_apb2_fzReg<BaseAddress + 0x000C>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_DBG_H\
    \ */"
  name: DBG
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_EXTI_H\n#define DRAL_STM32F411_EXTI_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ EXTI peripheral\n *\n * External interrupt/event\n *       controller\n */\n\
    class exti\n{\npublic:\n  static constexpr unsigned int BaseAddress = 0x40013C00;\
    \ /**< Peripheral base address */\n\nprivate:\n  template<unsigned int address>\n\
    \  class ImrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief MR0 field\n     *\n     * Interrupt Mask on line 0\n   \
    \  */\n    using mr0 = FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief\
    \ MR1 field\n     *\n     * Interrupt Mask on line 1\n     */\n    using mr1 =\
    \ FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief MR2 field\n   \
    \  *\n     * Interrupt Mask on line 2\n     */\n    using mr2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief MR3 field\n     *\n     * Interrupt\
    \ Mask on line 3\n     */\n    using mr3 = FieldModel<uint32_t, address, 3, 1>;\n\
    \    /**\n     * @brief MR4 field\n     *\n     * Interrupt Mask on line 4\n \
    \    */\n    using mr4 = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     *\
    \ @brief MR5 field\n     *\n     * Interrupt Mask on line 5\n     */\n    using\
    \ mr5 = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief MR6 field\n\
    \     *\n     * Interrupt Mask on line 6\n     */\n    using mr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief MR7 field\n     *\n     * Interrupt\
    \ Mask on line 7\n     */\n    using mr7 = FieldModel<uint32_t, address, 7, 1>;\n\
    \    /**\n     * @brief MR8 field\n     *\n     * Interrupt Mask on line 8\n \
    \    */\n    using mr8 = FieldModel<uint32_t, address, 8, 1>;\n    /**\n     *\
    \ @brief MR9 field\n     *\n     * Interrupt Mask on line 9\n     */\n    using\
    \ mr9 = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief MR10 field\n\
    \     *\n     * Interrupt Mask on line 10\n     */\n    using mr10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief MR11 field\n     *\n     * Interrupt\
    \ Mask on line 11\n     */\n    using mr11 = FieldModel<uint32_t, address, 11,\
    \ 1>;\n    /**\n     * @brief MR12 field\n     *\n     * Interrupt Mask on line\
    \ 12\n     */\n    using mr12 = FieldModel<uint32_t, address, 12, 1>;\n    /**\n\
    \     * @brief MR13 field\n     *\n     * Interrupt Mask on line 13\n     */\n\
    \    using mr13 = FieldModel<uint32_t, address, 13, 1>;\n    /**\n     * @brief\
    \ MR14 field\n     *\n     * Interrupt Mask on line 14\n     */\n    using mr14\
    \ = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief MR15 field\n\
    \     *\n     * Interrupt Mask on line 15\n     */\n    using mr15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief MR16 field\n     *\n     * Interrupt\
    \ Mask on line 16\n     */\n    using mr16 = FieldModel<uint32_t, address, 16,\
    \ 1>;\n    /**\n     * @brief MR17 field\n     *\n     * Interrupt Mask on line\
    \ 17\n     */\n    using mr17 = FieldModel<uint32_t, address, 17, 1>;\n    /**\n\
    \     * @brief MR18 field\n     *\n     * Interrupt Mask on line 18\n     */\n\
    \    using mr18 = FieldModel<uint32_t, address, 18, 1>;\n    /**\n     * @brief\
    \ MR19 field\n     *\n     * Interrupt Mask on line 19\n     */\n    using mr19\
    \ = FieldModel<uint32_t, address, 19, 1>;\n    /**\n     * @brief MR20 field\n\
    \     *\n     * Interrupt Mask on line 20\n     */\n    using mr20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief MR21 field\n     *\n     * Interrupt\
    \ Mask on line 21\n     */\n    using mr21 = FieldModel<uint32_t, address, 21,\
    \ 1>;\n    /**\n     * @brief MR22 field\n     *\n     * Interrupt Mask on line\
    \ 22\n     */\n    using mr22 = FieldModel<uint32_t, address, 22, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief MR0 field\n       *\n       * Interrupt Mask on line 0\n    \
    \   */\n      BitFieldModel<uint32_t, 0, 1> mr0;\n      /**\n       * @brief MR1\
    \ field\n       *\n       * Interrupt Mask on line 1\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> mr1;\n      /**\n       * @brief MR2 field\n       *\n       * Interrupt\
    \ Mask on line 2\n       */\n      BitFieldModel<uint32_t, 2, 1> mr2;\n      /**\n\
    \       * @brief MR3 field\n       *\n       * Interrupt Mask on line 3\n    \
    \   */\n      BitFieldModel<uint32_t, 3, 1> mr3;\n      /**\n       * @brief MR4\
    \ field\n       *\n       * Interrupt Mask on line 4\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> mr4;\n      /**\n       * @brief MR5 field\n       *\n       * Interrupt\
    \ Mask on line 5\n       */\n      BitFieldModel<uint32_t, 5, 1> mr5;\n      /**\n\
    \       * @brief MR6 field\n       *\n       * Interrupt Mask on line 6\n    \
    \   */\n      BitFieldModel<uint32_t, 6, 1> mr6;\n      /**\n       * @brief MR7\
    \ field\n       *\n       * Interrupt Mask on line 7\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> mr7;\n      /**\n       * @brief MR8 field\n       *\n       * Interrupt\
    \ Mask on line 8\n       */\n      BitFieldModel<uint32_t, 8, 1> mr8;\n      /**\n\
    \       * @brief MR9 field\n       *\n       * Interrupt Mask on line 9\n    \
    \   */\n      BitFieldModel<uint32_t, 9, 1> mr9;\n      /**\n       * @brief MR10\
    \ field\n       *\n       * Interrupt Mask on line 10\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> mr10;\n      /**\n       * @brief MR11 field\n       *\n       * Interrupt\
    \ Mask on line 11\n       */\n      BitFieldModel<uint32_t, 11, 1> mr11;\n   \
    \   /**\n       * @brief MR12 field\n       *\n       * Interrupt Mask on line\
    \ 12\n       */\n      BitFieldModel<uint32_t, 12, 1> mr12;\n      /**\n     \
    \  * @brief MR13 field\n       *\n       * Interrupt Mask on line 13\n       */\n\
    \      BitFieldModel<uint32_t, 13, 1> mr13;\n      /**\n       * @brief MR14 field\n\
    \       *\n       * Interrupt Mask on line 14\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> mr14;\n      /**\n       * @brief MR15 field\n       *\n       * Interrupt\
    \ Mask on line 15\n       */\n      BitFieldModel<uint32_t, 15, 1> mr15;\n   \
    \   /**\n       * @brief MR16 field\n       *\n       * Interrupt Mask on line\
    \ 16\n       */\n      BitFieldModel<uint32_t, 16, 1> mr16;\n      /**\n     \
    \  * @brief MR17 field\n       *\n       * Interrupt Mask on line 17\n       */\n\
    \      BitFieldModel<uint32_t, 17, 1> mr17;\n      /**\n       * @brief MR18 field\n\
    \       *\n       * Interrupt Mask on line 18\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 1> mr18;\n      /**\n       * @brief MR19 field\n       *\n       * Interrupt\
    \ Mask on line 19\n       */\n      BitFieldModel<uint32_t, 19, 1> mr19;\n   \
    \   /**\n       * @brief MR20 field\n       *\n       * Interrupt Mask on line\
    \ 20\n       */\n      BitFieldModel<uint32_t, 20, 1> mr20;\n      /**\n     \
    \  * @brief MR21 field\n       *\n       * Interrupt Mask on line 21\n       */\n\
    \      BitFieldModel<uint32_t, 21, 1> mr21;\n      /**\n       * @brief MR22 field\n\
    \       *\n       * Interrupt Mask on line 22\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> mr22;\n    };\n  };\n\npublic:\n  /**\n   * @brief IMR register\n   *\n\
    \   * Interrupt mask register\n   *           (EXTI_IMR)\n   */\n  using imr =\
    \ ImrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class EmrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief MR0 field\n     *\n     * Event Mask on line 0\n     */\n\
    \    using mr0 = FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief\
    \ MR1 field\n     *\n     * Event Mask on line 1\n     */\n    using mr1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief MR2 field\n     *\n     * Event Mask\
    \ on line 2\n     */\n    using mr2 = FieldModel<uint32_t, address, 2, 1>;\n \
    \   /**\n     * @brief MR3 field\n     *\n     * Event Mask on line 3\n     */\n\
    \    using mr3 = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief\
    \ MR4 field\n     *\n     * Event Mask on line 4\n     */\n    using mr4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief MR5 field\n     *\n     * Event Mask\
    \ on line 5\n     */\n    using mr5 = FieldModel<uint32_t, address, 5, 1>;\n \
    \   /**\n     * @brief MR6 field\n     *\n     * Event Mask on line 6\n     */\n\
    \    using mr6 = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief\
    \ MR7 field\n     *\n     * Event Mask on line 7\n     */\n    using mr7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief MR8 field\n     *\n     * Event Mask\
    \ on line 8\n     */\n    using mr8 = FieldModel<uint32_t, address, 8, 1>;\n \
    \   /**\n     * @brief MR9 field\n     *\n     * Event Mask on line 9\n     */\n\
    \    using mr9 = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief\
    \ MR10 field\n     *\n     * Event Mask on line 10\n     */\n    using mr10 =\
    \ FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief MR11 field\n \
    \    *\n     * Event Mask on line 11\n     */\n    using mr11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief MR12 field\n     *\n     * Event Mask\
    \ on line 12\n     */\n    using mr12 = FieldModel<uint32_t, address, 12, 1>;\n\
    \    /**\n     * @brief MR13 field\n     *\n     * Event Mask on line 13\n   \
    \  */\n    using mr13 = FieldModel<uint32_t, address, 13, 1>;\n    /**\n     *\
    \ @brief MR14 field\n     *\n     * Event Mask on line 14\n     */\n    using\
    \ mr14 = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief MR15 field\n\
    \     *\n     * Event Mask on line 15\n     */\n    using mr15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief MR16 field\n     *\n     * Event Mask\
    \ on line 16\n     */\n    using mr16 = FieldModel<uint32_t, address, 16, 1>;\n\
    \    /**\n     * @brief MR17 field\n     *\n     * Event Mask on line 17\n   \
    \  */\n    using mr17 = FieldModel<uint32_t, address, 17, 1>;\n    /**\n     *\
    \ @brief MR18 field\n     *\n     * Event Mask on line 18\n     */\n    using\
    \ mr18 = FieldModel<uint32_t, address, 18, 1>;\n    /**\n     * @brief MR19 field\n\
    \     *\n     * Event Mask on line 19\n     */\n    using mr19 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief MR20 field\n     *\n     * Event Mask\
    \ on line 20\n     */\n    using mr20 = FieldModel<uint32_t, address, 20, 1>;\n\
    \    /**\n     * @brief MR21 field\n     *\n     * Event Mask on line 21\n   \
    \  */\n    using mr21 = FieldModel<uint32_t, address, 21, 1>;\n    /**\n     *\
    \ @brief MR22 field\n     *\n     * Event Mask on line 22\n     */\n    using\
    \ mr22 = FieldModel<uint32_t, address, 22, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ MR0 field\n       *\n       * Event Mask on line 0\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> mr0;\n      /**\n       * @brief MR1 field\n       *\n       * Event Mask\
    \ on line 1\n       */\n      BitFieldModel<uint32_t, 1, 1> mr1;\n      /**\n\
    \       * @brief MR2 field\n       *\n       * Event Mask on line 2\n       */\n\
    \      BitFieldModel<uint32_t, 2, 1> mr2;\n      /**\n       * @brief MR3 field\n\
    \       *\n       * Event Mask on line 3\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> mr3;\n      /**\n       * @brief MR4 field\n       *\n       * Event Mask\
    \ on line 4\n       */\n      BitFieldModel<uint32_t, 4, 1> mr4;\n      /**\n\
    \       * @brief MR5 field\n       *\n       * Event Mask on line 5\n       */\n\
    \      BitFieldModel<uint32_t, 5, 1> mr5;\n      /**\n       * @brief MR6 field\n\
    \       *\n       * Event Mask on line 6\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> mr6;\n      /**\n       * @brief MR7 field\n       *\n       * Event Mask\
    \ on line 7\n       */\n      BitFieldModel<uint32_t, 7, 1> mr7;\n      /**\n\
    \       * @brief MR8 field\n       *\n       * Event Mask on line 8\n       */\n\
    \      BitFieldModel<uint32_t, 8, 1> mr8;\n      /**\n       * @brief MR9 field\n\
    \       *\n       * Event Mask on line 9\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> mr9;\n      /**\n       * @brief MR10 field\n       *\n       * Event\
    \ Mask on line 10\n       */\n      BitFieldModel<uint32_t, 10, 1> mr10;\n   \
    \   /**\n       * @brief MR11 field\n       *\n       * Event Mask on line 11\n\
    \       */\n      BitFieldModel<uint32_t, 11, 1> mr11;\n      /**\n       * @brief\
    \ MR12 field\n       *\n       * Event Mask on line 12\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> mr12;\n      /**\n       * @brief MR13 field\n       *\n       * Event\
    \ Mask on line 13\n       */\n      BitFieldModel<uint32_t, 13, 1> mr13;\n   \
    \   /**\n       * @brief MR14 field\n       *\n       * Event Mask on line 14\n\
    \       */\n      BitFieldModel<uint32_t, 14, 1> mr14;\n      /**\n       * @brief\
    \ MR15 field\n       *\n       * Event Mask on line 15\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> mr15;\n      /**\n       * @brief MR16 field\n       *\n       * Event\
    \ Mask on line 16\n       */\n      BitFieldModel<uint32_t, 16, 1> mr16;\n   \
    \   /**\n       * @brief MR17 field\n       *\n       * Event Mask on line 17\n\
    \       */\n      BitFieldModel<uint32_t, 17, 1> mr17;\n      /**\n       * @brief\
    \ MR18 field\n       *\n       * Event Mask on line 18\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 1> mr18;\n      /**\n       * @brief MR19 field\n       *\n       * Event\
    \ Mask on line 19\n       */\n      BitFieldModel<uint32_t, 19, 1> mr19;\n   \
    \   /**\n       * @brief MR20 field\n       *\n       * Event Mask on line 20\n\
    \       */\n      BitFieldModel<uint32_t, 20, 1> mr20;\n      /**\n       * @brief\
    \ MR21 field\n       *\n       * Event Mask on line 21\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 1> mr21;\n      /**\n       * @brief MR22 field\n       *\n       * Event\
    \ Mask on line 22\n       */\n      BitFieldModel<uint32_t, 22, 1> mr22;\n   \
    \ };\n  };\n\npublic:\n  /**\n   * @brief EMR register\n   *\n   * Event mask\
    \ register (EXTI_EMR)\n   */\n  using emr = EmrReg<BaseAddress + 0x0004>;\n\n\
    private:\n  template<unsigned int address>\n  class RtsrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief TR0 field\n     *\n     * Rising\
    \ trigger event configuration of\n     *               line 0\n     */\n    using\
    \ tr0 = FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief TR1 field\n\
    \     *\n     * Rising trigger event configuration of\n     *               line\
    \ 1\n     */\n    using tr1 = FieldModel<uint32_t, address, 1, 1>;\n    /**\n\
    \     * @brief TR2 field\n     *\n     * Rising trigger event configuration of\n\
    \     *               line 2\n     */\n    using tr2 = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief TR3 field\n     *\n     * Rising trigger event\
    \ configuration of\n     *               line 3\n     */\n    using tr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief TR4 field\n     *\n     * Rising trigger\
    \ event configuration of\n     *               line 4\n     */\n    using tr4\
    \ = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief TR5 field\n \
    \    *\n     * Rising trigger event configuration of\n     *               line\
    \ 5\n     */\n    using tr5 = FieldModel<uint32_t, address, 5, 1>;\n    /**\n\
    \     * @brief TR6 field\n     *\n     * Rising trigger event configuration of\n\
    \     *               line 6\n     */\n    using tr6 = FieldModel<uint32_t, address,\
    \ 6, 1>;\n    /**\n     * @brief TR7 field\n     *\n     * Rising trigger event\
    \ configuration of\n     *               line 7\n     */\n    using tr7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief TR8 field\n     *\n     * Rising trigger\
    \ event configuration of\n     *               line 8\n     */\n    using tr8\
    \ = FieldModel<uint32_t, address, 8, 1>;\n    /**\n     * @brief TR9 field\n \
    \    *\n     * Rising trigger event configuration of\n     *               line\
    \ 9\n     */\n    using tr9 = FieldModel<uint32_t, address, 9, 1>;\n    /**\n\
    \     * @brief TR10 field\n     *\n     * Rising trigger event configuration of\n\
    \     *               line 10\n     */\n    using tr10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief TR11 field\n     *\n     * Rising trigger\
    \ event configuration of\n     *               line 11\n     */\n    using tr11\
    \ = FieldModel<uint32_t, address, 11, 1>;\n    /**\n     * @brief TR12 field\n\
    \     *\n     * Rising trigger event configuration of\n     *               line\
    \ 12\n     */\n    using tr12 = FieldModel<uint32_t, address, 12, 1>;\n    /**\n\
    \     * @brief TR13 field\n     *\n     * Rising trigger event configuration of\n\
    \     *               line 13\n     */\n    using tr13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief TR14 field\n     *\n     * Rising trigger\
    \ event configuration of\n     *               line 14\n     */\n    using tr14\
    \ = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief TR15 field\n\
    \     *\n     * Rising trigger event configuration of\n     *               line\
    \ 15\n     */\n    using tr15 = FieldModel<uint32_t, address, 15, 1>;\n    /**\n\
    \     * @brief TR16 field\n     *\n     * Rising trigger event configuration of\n\
    \     *               line 16\n     */\n    using tr16 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    /**\n     * @brief TR17 field\n     *\n     * Rising trigger\
    \ event configuration of\n     *               line 17\n     */\n    using tr17\
    \ = FieldModel<uint32_t, address, 17, 1>;\n    /**\n     * @brief TR18 field\n\
    \     *\n     * Rising trigger event configuration of\n     *               line\
    \ 18\n     */\n    using tr18 = FieldModel<uint32_t, address, 18, 1>;\n    /**\n\
    \     * @brief TR19 field\n     *\n     * Rising trigger event configuration of\n\
    \     *               line 19\n     */\n    using tr19 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief TR20 field\n     *\n     * Rising trigger\
    \ event configuration of\n     *               line 20\n     */\n    using tr20\
    \ = FieldModel<uint32_t, address, 20, 1>;\n    /**\n     * @brief TR21 field\n\
    \     *\n     * Rising trigger event configuration of\n     *               line\
    \ 21\n     */\n    using tr21 = FieldModel<uint32_t, address, 21, 1>;\n    /**\n\
    \     * @brief TR22 field\n     *\n     * Rising trigger event configuration of\n\
    \     *               line 22\n     */\n    using tr22 = FieldModel<uint32_t,\
    \ address, 22, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief TR0 field\n       *\n \
    \      * Rising trigger event configuration of\n       *               line 0\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> tr0;\n      /**\n       * @brief\
    \ TR1 field\n       *\n       * Rising trigger event configuration of\n      \
    \ *               line 1\n       */\n      BitFieldModel<uint32_t, 1, 1> tr1;\n\
    \      /**\n       * @brief TR2 field\n       *\n       * Rising trigger event\
    \ configuration of\n       *               line 2\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> tr2;\n      /**\n       * @brief TR3 field\n       *\n       * Rising\
    \ trigger event configuration of\n       *               line 3\n       */\n \
    \     BitFieldModel<uint32_t, 3, 1> tr3;\n      /**\n       * @brief TR4 field\n\
    \       *\n       * Rising trigger event configuration of\n       *          \
    \     line 4\n       */\n      BitFieldModel<uint32_t, 4, 1> tr4;\n      /**\n\
    \       * @brief TR5 field\n       *\n       * Rising trigger event configuration\
    \ of\n       *               line 5\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> tr5;\n      /**\n       * @brief TR6 field\n       *\n       * Rising\
    \ trigger event configuration of\n       *               line 6\n       */\n \
    \     BitFieldModel<uint32_t, 6, 1> tr6;\n      /**\n       * @brief TR7 field\n\
    \       *\n       * Rising trigger event configuration of\n       *          \
    \     line 7\n       */\n      BitFieldModel<uint32_t, 7, 1> tr7;\n      /**\n\
    \       * @brief TR8 field\n       *\n       * Rising trigger event configuration\
    \ of\n       *               line 8\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> tr8;\n      /**\n       * @brief TR9 field\n       *\n       * Rising\
    \ trigger event configuration of\n       *               line 9\n       */\n \
    \     BitFieldModel<uint32_t, 9, 1> tr9;\n      /**\n       * @brief TR10 field\n\
    \       *\n       * Rising trigger event configuration of\n       *          \
    \     line 10\n       */\n      BitFieldModel<uint32_t, 10, 1> tr10;\n      /**\n\
    \       * @brief TR11 field\n       *\n       * Rising trigger event configuration\
    \ of\n       *               line 11\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> tr11;\n      /**\n       * @brief TR12 field\n       *\n       * Rising\
    \ trigger event configuration of\n       *               line 12\n       */\n\
    \      BitFieldModel<uint32_t, 12, 1> tr12;\n      /**\n       * @brief TR13 field\n\
    \       *\n       * Rising trigger event configuration of\n       *          \
    \     line 13\n       */\n      BitFieldModel<uint32_t, 13, 1> tr13;\n      /**\n\
    \       * @brief TR14 field\n       *\n       * Rising trigger event configuration\
    \ of\n       *               line 14\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> tr14;\n      /**\n       * @brief TR15 field\n       *\n       * Rising\
    \ trigger event configuration of\n       *               line 15\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> tr15;\n      /**\n       * @brief TR16 field\n\
    \       *\n       * Rising trigger event configuration of\n       *          \
    \     line 16\n       */\n      BitFieldModel<uint32_t, 16, 1> tr16;\n      /**\n\
    \       * @brief TR17 field\n       *\n       * Rising trigger event configuration\
    \ of\n       *               line 17\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> tr17;\n      /**\n       * @brief TR18 field\n       *\n       * Rising\
    \ trigger event configuration of\n       *               line 18\n       */\n\
    \      BitFieldModel<uint32_t, 18, 1> tr18;\n      /**\n       * @brief TR19 field\n\
    \       *\n       * Rising trigger event configuration of\n       *          \
    \     line 19\n       */\n      BitFieldModel<uint32_t, 19, 1> tr19;\n      /**\n\
    \       * @brief TR20 field\n       *\n       * Rising trigger event configuration\
    \ of\n       *               line 20\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 1> tr20;\n      /**\n       * @brief TR21 field\n       *\n       * Rising\
    \ trigger event configuration of\n       *               line 21\n       */\n\
    \      BitFieldModel<uint32_t, 21, 1> tr21;\n      /**\n       * @brief TR22 field\n\
    \       *\n       * Rising trigger event configuration of\n       *          \
    \     line 22\n       */\n      BitFieldModel<uint32_t, 22, 1> tr22;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief RTSR register\n   *\n   * Rising Trigger\
    \ selection register\n   *           (EXTI_RTSR)\n   */\n  using rtsr = RtsrReg<BaseAddress\
    \ + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class FtsrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ TR0 field\n     *\n     * Falling trigger event configuration of\n     *   \
    \            line 0\n     */\n    using tr0 = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    /**\n     * @brief TR1 field\n     *\n     * Falling trigger event\
    \ configuration of\n     *               line 1\n     */\n    using tr1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief TR2 field\n     *\n     * Falling trigger\
    \ event configuration of\n     *               line 2\n     */\n    using tr2\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief TR3 field\n \
    \    *\n     * Falling trigger event configuration of\n     *               line\
    \ 3\n     */\n    using tr3 = FieldModel<uint32_t, address, 3, 1>;\n    /**\n\
    \     * @brief TR4 field\n     *\n     * Falling trigger event configuration of\n\
    \     *               line 4\n     */\n    using tr4 = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief TR5 field\n     *\n     * Falling trigger event\
    \ configuration of\n     *               line 5\n     */\n    using tr5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief TR6 field\n     *\n     * Falling trigger\
    \ event configuration of\n     *               line 6\n     */\n    using tr6\
    \ = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief TR7 field\n \
    \    *\n     * Falling trigger event configuration of\n     *               line\
    \ 7\n     */\n    using tr7 = FieldModel<uint32_t, address, 7, 1>;\n    /**\n\
    \     * @brief TR8 field\n     *\n     * Falling trigger event configuration of\n\
    \     *               line 8\n     */\n    using tr8 = FieldModel<uint32_t, address,\
    \ 8, 1>;\n    /**\n     * @brief TR9 field\n     *\n     * Falling trigger event\
    \ configuration of\n     *               line 9\n     */\n    using tr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief TR10 field\n     *\n     * Falling trigger\
    \ event configuration of\n     *               line 10\n     */\n    using tr10\
    \ = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief TR11 field\n\
    \     *\n     * Falling trigger event configuration of\n     *               line\
    \ 11\n     */\n    using tr11 = FieldModel<uint32_t, address, 11, 1>;\n    /**\n\
    \     * @brief TR12 field\n     *\n     * Falling trigger event configuration\
    \ of\n     *               line 12\n     */\n    using tr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief TR13 field\n     *\n     * Falling\
    \ trigger event configuration of\n     *               line 13\n     */\n    using\
    \ tr13 = FieldModel<uint32_t, address, 13, 1>;\n    /**\n     * @brief TR14 field\n\
    \     *\n     * Falling trigger event configuration of\n     *               line\
    \ 14\n     */\n    using tr14 = FieldModel<uint32_t, address, 14, 1>;\n    /**\n\
    \     * @brief TR15 field\n     *\n     * Falling trigger event configuration\
    \ of\n     *               line 15\n     */\n    using tr15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief TR16 field\n     *\n     * Falling\
    \ trigger event configuration of\n     *               line 16\n     */\n    using\
    \ tr16 = FieldModel<uint32_t, address, 16, 1>;\n    /**\n     * @brief TR17 field\n\
    \     *\n     * Falling trigger event configuration of\n     *               line\
    \ 17\n     */\n    using tr17 = FieldModel<uint32_t, address, 17, 1>;\n    /**\n\
    \     * @brief TR18 field\n     *\n     * Falling trigger event configuration\
    \ of\n     *               line 18\n     */\n    using tr18 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    /**\n     * @brief TR19 field\n     *\n     * Falling\
    \ trigger event configuration of\n     *               line 19\n     */\n    using\
    \ tr19 = FieldModel<uint32_t, address, 19, 1>;\n    /**\n     * @brief TR20 field\n\
    \     *\n     * Falling trigger event configuration of\n     *               line\
    \ 20\n     */\n    using tr20 = FieldModel<uint32_t, address, 20, 1>;\n    /**\n\
    \     * @brief TR21 field\n     *\n     * Falling trigger event configuration\
    \ of\n     *               line 21\n     */\n    using tr21 = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    /**\n     * @brief TR22 field\n     *\n     * Falling\
    \ trigger event configuration of\n     *               line 22\n     */\n    using\
    \ tr22 = FieldModel<uint32_t, address, 22, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ TR0 field\n       *\n       * Falling trigger event configuration of\n     \
    \  *               line 0\n       */\n      BitFieldModel<uint32_t, 0, 1> tr0;\n\
    \      /**\n       * @brief TR1 field\n       *\n       * Falling trigger event\
    \ configuration of\n       *               line 1\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> tr1;\n      /**\n       * @brief TR2 field\n       *\n       * Falling\
    \ trigger event configuration of\n       *               line 2\n       */\n \
    \     BitFieldModel<uint32_t, 2, 1> tr2;\n      /**\n       * @brief TR3 field\n\
    \       *\n       * Falling trigger event configuration of\n       *         \
    \      line 3\n       */\n      BitFieldModel<uint32_t, 3, 1> tr3;\n      /**\n\
    \       * @brief TR4 field\n       *\n       * Falling trigger event configuration\
    \ of\n       *               line 4\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> tr4;\n      /**\n       * @brief TR5 field\n       *\n       * Falling\
    \ trigger event configuration of\n       *               line 5\n       */\n \
    \     BitFieldModel<uint32_t, 5, 1> tr5;\n      /**\n       * @brief TR6 field\n\
    \       *\n       * Falling trigger event configuration of\n       *         \
    \      line 6\n       */\n      BitFieldModel<uint32_t, 6, 1> tr6;\n      /**\n\
    \       * @brief TR7 field\n       *\n       * Falling trigger event configuration\
    \ of\n       *               line 7\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> tr7;\n      /**\n       * @brief TR8 field\n       *\n       * Falling\
    \ trigger event configuration of\n       *               line 8\n       */\n \
    \     BitFieldModel<uint32_t, 8, 1> tr8;\n      /**\n       * @brief TR9 field\n\
    \       *\n       * Falling trigger event configuration of\n       *         \
    \      line 9\n       */\n      BitFieldModel<uint32_t, 9, 1> tr9;\n      /**\n\
    \       * @brief TR10 field\n       *\n       * Falling trigger event configuration\
    \ of\n       *               line 10\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> tr10;\n      /**\n       * @brief TR11 field\n       *\n       * Falling\
    \ trigger event configuration of\n       *               line 11\n       */\n\
    \      BitFieldModel<uint32_t, 11, 1> tr11;\n      /**\n       * @brief TR12 field\n\
    \       *\n       * Falling trigger event configuration of\n       *         \
    \      line 12\n       */\n      BitFieldModel<uint32_t, 12, 1> tr12;\n      /**\n\
    \       * @brief TR13 field\n       *\n       * Falling trigger event configuration\
    \ of\n       *               line 13\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> tr13;\n      /**\n       * @brief TR14 field\n       *\n       * Falling\
    \ trigger event configuration of\n       *               line 14\n       */\n\
    \      BitFieldModel<uint32_t, 14, 1> tr14;\n      /**\n       * @brief TR15 field\n\
    \       *\n       * Falling trigger event configuration of\n       *         \
    \      line 15\n       */\n      BitFieldModel<uint32_t, 15, 1> tr15;\n      /**\n\
    \       * @brief TR16 field\n       *\n       * Falling trigger event configuration\
    \ of\n       *               line 16\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> tr16;\n      /**\n       * @brief TR17 field\n       *\n       * Falling\
    \ trigger event configuration of\n       *               line 17\n       */\n\
    \      BitFieldModel<uint32_t, 17, 1> tr17;\n      /**\n       * @brief TR18 field\n\
    \       *\n       * Falling trigger event configuration of\n       *         \
    \      line 18\n       */\n      BitFieldModel<uint32_t, 18, 1> tr18;\n      /**\n\
    \       * @brief TR19 field\n       *\n       * Falling trigger event configuration\
    \ of\n       *               line 19\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> tr19;\n      /**\n       * @brief TR20 field\n       *\n       * Falling\
    \ trigger event configuration of\n       *               line 20\n       */\n\
    \      BitFieldModel<uint32_t, 20, 1> tr20;\n      /**\n       * @brief TR21 field\n\
    \       *\n       * Falling trigger event configuration of\n       *         \
    \      line 21\n       */\n      BitFieldModel<uint32_t, 21, 1> tr21;\n      /**\n\
    \       * @brief TR22 field\n       *\n       * Falling trigger event configuration\
    \ of\n       *               line 22\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> tr22;\n    };\n  };\n\npublic:\n  /**\n   * @brief FTSR register\n  \
    \ *\n   * Falling Trigger selection register\n   *           (EXTI_FTSR)\n   */\n\
    \  using ftsr = FtsrReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class SwierReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief SWIER0 field\n     *\n     * Software Interrupt\
    \ on line\n     *               0\n     */\n    using swier0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    /**\n     * @brief SWIER1 field\n     *\n     * Software\
    \ Interrupt on line\n     *               1\n     */\n    using swier1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief SWIER2 field\n     *\n     * Software\
    \ Interrupt on line\n     *               2\n     */\n    using swier2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief SWIER3 field\n     *\n     * Software\
    \ Interrupt on line\n     *               3\n     */\n    using swier3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief SWIER4 field\n     *\n     * Software\
    \ Interrupt on line\n     *               4\n     */\n    using swier4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief SWIER5 field\n     *\n     * Software\
    \ Interrupt on line\n     *               5\n     */\n    using swier5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief SWIER6 field\n     *\n     * Software\
    \ Interrupt on line\n     *               6\n     */\n    using swier6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief SWIER7 field\n     *\n     * Software\
    \ Interrupt on line\n     *               7\n     */\n    using swier7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief SWIER8 field\n     *\n     * Software\
    \ Interrupt on line\n     *               8\n     */\n    using swier8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief SWIER9 field\n     *\n     * Software\
    \ Interrupt on line\n     *               9\n     */\n    using swier9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief SWIER10 field\n     *\n     * Software\
    \ Interrupt on line\n     *               10\n     */\n    using swier10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief SWIER11 field\n     *\n     * Software\
    \ Interrupt on line\n     *               11\n     */\n    using swier11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief SWIER12 field\n     *\n     * Software\
    \ Interrupt on line\n     *               12\n     */\n    using swier12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief SWIER13 field\n     *\n     * Software\
    \ Interrupt on line\n     *               13\n     */\n    using swier13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief SWIER14 field\n     *\n     * Software\
    \ Interrupt on line\n     *               14\n     */\n    using swier14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief SWIER15 field\n     *\n     * Software\
    \ Interrupt on line\n     *               15\n     */\n    using swier15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief SWIER16 field\n     *\n     * Software\
    \ Interrupt on line\n     *               16\n     */\n    using swier16 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    /**\n     * @brief SWIER17 field\n     *\n     * Software\
    \ Interrupt on line\n     *               17\n     */\n    using swier17 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    /**\n     * @brief SWIER18 field\n     *\n     * Software\
    \ Interrupt on line\n     *               18\n     */\n    using swier18 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    /**\n     * @brief SWIER19 field\n     *\n     * Software\
    \ Interrupt on line\n     *               19\n     */\n    using swier19 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief SWIER20 field\n     *\n     * Software\
    \ Interrupt on line\n     *               20\n     */\n    using swier20 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief SWIER21 field\n     *\n     * Software\
    \ Interrupt on line\n     *               21\n     */\n    using swier21 = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    /**\n     * @brief SWIER22 field\n     *\n     * Software\
    \ Interrupt on line\n     *               22\n     */\n    using swier22 = FieldModel<uint32_t,\
    \ address, 22, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief SWIER0 field\n       *\n\
    \       * Software Interrupt on line\n       *               0\n       */\n  \
    \    BitFieldModel<uint32_t, 0, 1> swier0;\n      /**\n       * @brief SWIER1\
    \ field\n       *\n       * Software Interrupt on line\n       *             \
    \  1\n       */\n      BitFieldModel<uint32_t, 1, 1> swier1;\n      /**\n    \
    \   * @brief SWIER2 field\n       *\n       * Software Interrupt on line\n   \
    \    *               2\n       */\n      BitFieldModel<uint32_t, 2, 1> swier2;\n\
    \      /**\n       * @brief SWIER3 field\n       *\n       * Software Interrupt\
    \ on line\n       *               3\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> swier3;\n      /**\n       * @brief SWIER4 field\n       *\n       * Software\
    \ Interrupt on line\n       *               4\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> swier4;\n      /**\n       * @brief SWIER5 field\n       *\n       * Software\
    \ Interrupt on line\n       *               5\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> swier5;\n      /**\n       * @brief SWIER6 field\n       *\n       * Software\
    \ Interrupt on line\n       *               6\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> swier6;\n      /**\n       * @brief SWIER7 field\n       *\n       * Software\
    \ Interrupt on line\n       *               7\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> swier7;\n      /**\n       * @brief SWIER8 field\n       *\n       * Software\
    \ Interrupt on line\n       *               8\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> swier8;\n      /**\n       * @brief SWIER9 field\n       *\n       * Software\
    \ Interrupt on line\n       *               9\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> swier9;\n      /**\n       * @brief SWIER10 field\n       *\n       *\
    \ Software Interrupt on line\n       *               10\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> swier10;\n      /**\n       * @brief SWIER11 field\n       *\n      \
    \ * Software Interrupt on line\n       *               11\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> swier11;\n      /**\n       * @brief SWIER12 field\n       *\n      \
    \ * Software Interrupt on line\n       *               12\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> swier12;\n      /**\n       * @brief SWIER13 field\n       *\n      \
    \ * Software Interrupt on line\n       *               13\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> swier13;\n      /**\n       * @brief SWIER14 field\n       *\n      \
    \ * Software Interrupt on line\n       *               14\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> swier14;\n      /**\n       * @brief SWIER15 field\n       *\n      \
    \ * Software Interrupt on line\n       *               15\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> swier15;\n      /**\n       * @brief SWIER16 field\n       *\n      \
    \ * Software Interrupt on line\n       *               16\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> swier16;\n      /**\n       * @brief SWIER17 field\n       *\n      \
    \ * Software Interrupt on line\n       *               17\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> swier17;\n      /**\n       * @brief SWIER18 field\n       *\n      \
    \ * Software Interrupt on line\n       *               18\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 1> swier18;\n      /**\n       * @brief SWIER19 field\n       *\n      \
    \ * Software Interrupt on line\n       *               19\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> swier19;\n      /**\n       * @brief SWIER20 field\n       *\n      \
    \ * Software Interrupt on line\n       *               20\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 1> swier20;\n      /**\n       * @brief SWIER21 field\n       *\n      \
    \ * Software Interrupt on line\n       *               21\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 1> swier21;\n      /**\n       * @brief SWIER22 field\n       *\n      \
    \ * Software Interrupt on line\n       *               22\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> swier22;\n    };\n  };\n\npublic:\n  /**\n   * @brief SWIER register\n\
    \   *\n   * Software interrupt event register\n   *           (EXTI_SWIER)\n \
    \  */\n  using swier = SwierReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class PrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief PR0 field\n     *\n     * Pending bit 0\n \
    \    */\n    using pr0 = FieldModel<uint32_t, address, 0, 1>;\n    /**\n     *\
    \ @brief PR1 field\n     *\n     * Pending bit 1\n     */\n    using pr1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief PR2 field\n     *\n     * Pending bit\
    \ 2\n     */\n    using pr2 = FieldModel<uint32_t, address, 2, 1>;\n    /**\n\
    \     * @brief PR3 field\n     *\n     * Pending bit 3\n     */\n    using pr3\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief PR4 field\n \
    \    *\n     * Pending bit 4\n     */\n    using pr4 = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief PR5 field\n     *\n     * Pending bit 5\n   \
    \  */\n    using pr5 = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief\
    \ PR6 field\n     *\n     * Pending bit 6\n     */\n    using pr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief PR7 field\n     *\n     * Pending bit\
    \ 7\n     */\n    using pr7 = FieldModel<uint32_t, address, 7, 1>;\n    /**\n\
    \     * @brief PR8 field\n     *\n     * Pending bit 8\n     */\n    using pr8\
    \ = FieldModel<uint32_t, address, 8, 1>;\n    /**\n     * @brief PR9 field\n \
    \    *\n     * Pending bit 9\n     */\n    using pr9 = FieldModel<uint32_t, address,\
    \ 9, 1>;\n    /**\n     * @brief PR10 field\n     *\n     * Pending bit 10\n \
    \    */\n    using pr10 = FieldModel<uint32_t, address, 10, 1>;\n    /**\n   \
    \  * @brief PR11 field\n     *\n     * Pending bit 11\n     */\n    using pr11\
    \ = FieldModel<uint32_t, address, 11, 1>;\n    /**\n     * @brief PR12 field\n\
    \     *\n     * Pending bit 12\n     */\n    using pr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief PR13 field\n     *\n     * Pending\
    \ bit 13\n     */\n    using pr13 = FieldModel<uint32_t, address, 13, 1>;\n  \
    \  /**\n     * @brief PR14 field\n     *\n     * Pending bit 14\n     */\n   \
    \ using pr14 = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief PR15\
    \ field\n     *\n     * Pending bit 15\n     */\n    using pr15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief PR16 field\n     *\n     * Pending\
    \ bit 16\n     */\n    using pr16 = FieldModel<uint32_t, address, 16, 1>;\n  \
    \  /**\n     * @brief PR17 field\n     *\n     * Pending bit 17\n     */\n   \
    \ using pr17 = FieldModel<uint32_t, address, 17, 1>;\n    /**\n     * @brief PR18\
    \ field\n     *\n     * Pending bit 18\n     */\n    using pr18 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    /**\n     * @brief PR19 field\n     *\n     * Pending\
    \ bit 19\n     */\n    using pr19 = FieldModel<uint32_t, address, 19, 1>;\n  \
    \  /**\n     * @brief PR20 field\n     *\n     * Pending bit 20\n     */\n   \
    \ using pr20 = FieldModel<uint32_t, address, 20, 1>;\n    /**\n     * @brief PR21\
    \ field\n     *\n     * Pending bit 21\n     */\n    using pr21 = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    /**\n     * @brief PR22 field\n     *\n     * Pending\
    \ bit 22\n     */\n    using pr22 = FieldModel<uint32_t, address, 22, 1>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief PR0 field\n       *\n       * Pending bit\
    \ 0\n       */\n      BitFieldModel<uint32_t, 0, 1> pr0;\n      /**\n       *\
    \ @brief PR1 field\n       *\n       * Pending bit 1\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> pr1;\n      /**\n       * @brief PR2 field\n       *\n       * Pending\
    \ bit 2\n       */\n      BitFieldModel<uint32_t, 2, 1> pr2;\n      /**\n    \
    \   * @brief PR3 field\n       *\n       * Pending bit 3\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> pr3;\n      /**\n       * @brief PR4 field\n       *\n       * Pending\
    \ bit 4\n       */\n      BitFieldModel<uint32_t, 4, 1> pr4;\n      /**\n    \
    \   * @brief PR5 field\n       *\n       * Pending bit 5\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> pr5;\n      /**\n       * @brief PR6 field\n       *\n       * Pending\
    \ bit 6\n       */\n      BitFieldModel<uint32_t, 6, 1> pr6;\n      /**\n    \
    \   * @brief PR7 field\n       *\n       * Pending bit 7\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> pr7;\n      /**\n       * @brief PR8 field\n       *\n       * Pending\
    \ bit 8\n       */\n      BitFieldModel<uint32_t, 8, 1> pr8;\n      /**\n    \
    \   * @brief PR9 field\n       *\n       * Pending bit 9\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> pr9;\n      /**\n       * @brief PR10 field\n       *\n       * Pending\
    \ bit 10\n       */\n      BitFieldModel<uint32_t, 10, 1> pr10;\n      /**\n \
    \      * @brief PR11 field\n       *\n       * Pending bit 11\n       */\n   \
    \   BitFieldModel<uint32_t, 11, 1> pr11;\n      /**\n       * @brief PR12 field\n\
    \       *\n       * Pending bit 12\n       */\n      BitFieldModel<uint32_t, 12,\
    \ 1> pr12;\n      /**\n       * @brief PR13 field\n       *\n       * Pending\
    \ bit 13\n       */\n      BitFieldModel<uint32_t, 13, 1> pr13;\n      /**\n \
    \      * @brief PR14 field\n       *\n       * Pending bit 14\n       */\n   \
    \   BitFieldModel<uint32_t, 14, 1> pr14;\n      /**\n       * @brief PR15 field\n\
    \       *\n       * Pending bit 15\n       */\n      BitFieldModel<uint32_t, 15,\
    \ 1> pr15;\n      /**\n       * @brief PR16 field\n       *\n       * Pending\
    \ bit 16\n       */\n      BitFieldModel<uint32_t, 16, 1> pr16;\n      /**\n \
    \      * @brief PR17 field\n       *\n       * Pending bit 17\n       */\n   \
    \   BitFieldModel<uint32_t, 17, 1> pr17;\n      /**\n       * @brief PR18 field\n\
    \       *\n       * Pending bit 18\n       */\n      BitFieldModel<uint32_t, 18,\
    \ 1> pr18;\n      /**\n       * @brief PR19 field\n       *\n       * Pending\
    \ bit 19\n       */\n      BitFieldModel<uint32_t, 19, 1> pr19;\n      /**\n \
    \      * @brief PR20 field\n       *\n       * Pending bit 20\n       */\n   \
    \   BitFieldModel<uint32_t, 20, 1> pr20;\n      /**\n       * @brief PR21 field\n\
    \       *\n       * Pending bit 21\n       */\n      BitFieldModel<uint32_t, 21,\
    \ 1> pr21;\n      /**\n       * @brief PR22 field\n       *\n       * Pending\
    \ bit 22\n       */\n      BitFieldModel<uint32_t, 22, 1> pr22;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief PR register\n   *\n   * Pending register (EXTI_PR)\n\
    \   */\n  using pr = PrReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class XmrBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    /**\n     * @brief MR0 field\n   \
    \  *\n     * Interrupt Mask on line 0\n     */\n    using mr0 = FieldModel<uint32_t,\
    \ address, 0, 1, bankOffset>;\n    /**\n     * @brief MR1 field\n     *\n    \
    \ * Interrupt Mask on line 1\n     */\n    using mr1 = FieldModel<uint32_t, address,\
    \ 1, 1, bankOffset>;\n    /**\n     * @brief MR2 field\n     *\n     * Interrupt\
    \ Mask on line 2\n     */\n    using mr2 = FieldModel<uint32_t, address, 2, 1,\
    \ bankOffset>;\n    /**\n     * @brief MR3 field\n     *\n     * Interrupt Mask\
    \ on line 3\n     */\n    using mr3 = FieldModel<uint32_t, address, 3, 1, bankOffset>;\n\
    \    /**\n     * @brief MR4 field\n     *\n     * Interrupt Mask on line 4\n \
    \    */\n    using mr4 = FieldModel<uint32_t, address, 4, 1, bankOffset>;\n  \
    \  /**\n     * @brief MR5 field\n     *\n     * Interrupt Mask on line 5\n   \
    \  */\n    using mr5 = FieldModel<uint32_t, address, 5, 1, bankOffset>;\n    /**\n\
    \     * @brief MR6 field\n     *\n     * Interrupt Mask on line 6\n     */\n \
    \   using mr6 = FieldModel<uint32_t, address, 6, 1, bankOffset>;\n    /**\n  \
    \   * @brief MR7 field\n     *\n     * Interrupt Mask on line 7\n     */\n   \
    \ using mr7 = FieldModel<uint32_t, address, 7, 1, bankOffset>;\n    /**\n    \
    \ * @brief MR8 field\n     *\n     * Interrupt Mask on line 8\n     */\n    using\
    \ mr8 = FieldModel<uint32_t, address, 8, 1, bankOffset>;\n    /**\n     * @brief\
    \ MR9 field\n     *\n     * Interrupt Mask on line 9\n     */\n    using mr9 =\
    \ FieldModel<uint32_t, address, 9, 1, bankOffset>;\n    /**\n     * @brief MR10\
    \ field\n     *\n     * Interrupt Mask on line 10\n     */\n    using mr10 = FieldModel<uint32_t,\
    \ address, 10, 1, bankOffset>;\n    /**\n     * @brief MR11 field\n     *\n  \
    \   * Interrupt Mask on line 11\n     */\n    using mr11 = FieldModel<uint32_t,\
    \ address, 11, 1, bankOffset>;\n    /**\n     * @brief MR12 field\n     *\n  \
    \   * Interrupt Mask on line 12\n     */\n    using mr12 = FieldModel<uint32_t,\
    \ address, 12, 1, bankOffset>;\n    /**\n     * @brief MR13 field\n     *\n  \
    \   * Interrupt Mask on line 13\n     */\n    using mr13 = FieldModel<uint32_t,\
    \ address, 13, 1, bankOffset>;\n    /**\n     * @brief MR14 field\n     *\n  \
    \   * Interrupt Mask on line 14\n     */\n    using mr14 = FieldModel<uint32_t,\
    \ address, 14, 1, bankOffset>;\n    /**\n     * @brief MR15 field\n     *\n  \
    \   * Interrupt Mask on line 15\n     */\n    using mr15 = FieldModel<uint32_t,\
    \ address, 15, 1, bankOffset>;\n    /**\n     * @brief MR16 field\n     *\n  \
    \   * Interrupt Mask on line 16\n     */\n    using mr16 = FieldModel<uint32_t,\
    \ address, 16, 1, bankOffset>;\n    /**\n     * @brief MR17 field\n     *\n  \
    \   * Interrupt Mask on line 17\n     */\n    using mr17 = FieldModel<uint32_t,\
    \ address, 17, 1, bankOffset>;\n    /**\n     * @brief MR18 field\n     *\n  \
    \   * Interrupt Mask on line 18\n     */\n    using mr18 = FieldModel<uint32_t,\
    \ address, 18, 1, bankOffset>;\n    /**\n     * @brief MR19 field\n     *\n  \
    \   * Interrupt Mask on line 19\n     */\n    using mr19 = FieldModel<uint32_t,\
    \ address, 19, 1, bankOffset>;\n    /**\n     * @brief MR20 field\n     *\n  \
    \   * Interrupt Mask on line 20\n     */\n    using mr20 = FieldModel<uint32_t,\
    \ address, 20, 1, bankOffset>;\n    /**\n     * @brief MR21 field\n     *\n  \
    \   * Interrupt Mask on line 21\n     */\n    using mr21 = FieldModel<uint32_t,\
    \ address, 21, 1, bankOffset>;\n    /**\n     * @brief MR22 field\n     *\n  \
    \   * Interrupt Mask on line 22\n     */\n    using mr22 = FieldModel<uint32_t,\
    \ address, 22, 1, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief MR0 field\n       *\n       * Interrupt Mask\
    \ on line 0\n       */\n      BitFieldModel<uint32_t, 0, 1> mr0;\n      /**\n\
    \       * @brief MR1 field\n       *\n       * Interrupt Mask on line 1\n    \
    \   */\n      BitFieldModel<uint32_t, 1, 1> mr1;\n      /**\n       * @brief MR2\
    \ field\n       *\n       * Interrupt Mask on line 2\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> mr2;\n      /**\n       * @brief MR3 field\n       *\n       * Interrupt\
    \ Mask on line 3\n       */\n      BitFieldModel<uint32_t, 3, 1> mr3;\n      /**\n\
    \       * @brief MR4 field\n       *\n       * Interrupt Mask on line 4\n    \
    \   */\n      BitFieldModel<uint32_t, 4, 1> mr4;\n      /**\n       * @brief MR5\
    \ field\n       *\n       * Interrupt Mask on line 5\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> mr5;\n      /**\n       * @brief MR6 field\n       *\n       * Interrupt\
    \ Mask on line 6\n       */\n      BitFieldModel<uint32_t, 6, 1> mr6;\n      /**\n\
    \       * @brief MR7 field\n       *\n       * Interrupt Mask on line 7\n    \
    \   */\n      BitFieldModel<uint32_t, 7, 1> mr7;\n      /**\n       * @brief MR8\
    \ field\n       *\n       * Interrupt Mask on line 8\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> mr8;\n      /**\n       * @brief MR9 field\n       *\n       * Interrupt\
    \ Mask on line 9\n       */\n      BitFieldModel<uint32_t, 9, 1> mr9;\n      /**\n\
    \       * @brief MR10 field\n       *\n       * Interrupt Mask on line 10\n  \
    \     */\n      BitFieldModel<uint32_t, 10, 1> mr10;\n      /**\n       * @brief\
    \ MR11 field\n       *\n       * Interrupt Mask on line 11\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> mr11;\n      /**\n       * @brief MR12 field\n       *\n       * Interrupt\
    \ Mask on line 12\n       */\n      BitFieldModel<uint32_t, 12, 1> mr12;\n   \
    \   /**\n       * @brief MR13 field\n       *\n       * Interrupt Mask on line\
    \ 13\n       */\n      BitFieldModel<uint32_t, 13, 1> mr13;\n      /**\n     \
    \  * @brief MR14 field\n       *\n       * Interrupt Mask on line 14\n       */\n\
    \      BitFieldModel<uint32_t, 14, 1> mr14;\n      /**\n       * @brief MR15 field\n\
    \       *\n       * Interrupt Mask on line 15\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> mr15;\n      /**\n       * @brief MR16 field\n       *\n       * Interrupt\
    \ Mask on line 16\n       */\n      BitFieldModel<uint32_t, 16, 1> mr16;\n   \
    \   /**\n       * @brief MR17 field\n       *\n       * Interrupt Mask on line\
    \ 17\n       */\n      BitFieldModel<uint32_t, 17, 1> mr17;\n      /**\n     \
    \  * @brief MR18 field\n       *\n       * Interrupt Mask on line 18\n       */\n\
    \      BitFieldModel<uint32_t, 18, 1> mr18;\n      /**\n       * @brief MR19 field\n\
    \       *\n       * Interrupt Mask on line 19\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> mr19;\n      /**\n       * @brief MR20 field\n       *\n       * Interrupt\
    \ Mask on line 20\n       */\n      BitFieldModel<uint32_t, 20, 1> mr20;\n   \
    \   /**\n       * @brief MR21 field\n       *\n       * Interrupt Mask on line\
    \ 21\n       */\n      BitFieldModel<uint32_t, 21, 1> mr21;\n      /**\n     \
    \  * @brief MR22 field\n       *\n       * Interrupt Mask on line 22\n       */\n\
    \      BitFieldModel<uint32_t, 22, 1> mr22;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief XMR register bank\n   *\n   * Interrupt mask register\n   *     \
    \      (EXTI_IMR)\n   */\n  using xmr = XmrBankReg<BaseAddress + 0x0000, 0x0004>;\n\
    \nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n  class\
    \ XtsrBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n\
    \  public:\n    /**\n     * @brief TR0 field\n     *\n     * Rising trigger event\
    \ configuration of\n     *               line 0\n     */\n    using tr0 = FieldModel<uint32_t,\
    \ address, 0, 1, bankOffset>;\n    /**\n     * @brief TR1 field\n     *\n    \
    \ * Rising trigger event configuration of\n     *               line 1\n     */\n\
    \    using tr1 = FieldModel<uint32_t, address, 1, 1, bankOffset>;\n    /**\n \
    \    * @brief TR2 field\n     *\n     * Rising trigger event configuration of\n\
    \     *               line 2\n     */\n    using tr2 = FieldModel<uint32_t, address,\
    \ 2, 1, bankOffset>;\n    /**\n     * @brief TR3 field\n     *\n     * Rising\
    \ trigger event configuration of\n     *               line 3\n     */\n    using\
    \ tr3 = FieldModel<uint32_t, address, 3, 1, bankOffset>;\n    /**\n     * @brief\
    \ TR4 field\n     *\n     * Rising trigger event configuration of\n     *    \
    \           line 4\n     */\n    using tr4 = FieldModel<uint32_t, address, 4,\
    \ 1, bankOffset>;\n    /**\n     * @brief TR5 field\n     *\n     * Rising trigger\
    \ event configuration of\n     *               line 5\n     */\n    using tr5\
    \ = FieldModel<uint32_t, address, 5, 1, bankOffset>;\n    /**\n     * @brief TR6\
    \ field\n     *\n     * Rising trigger event configuration of\n     *        \
    \       line 6\n     */\n    using tr6 = FieldModel<uint32_t, address, 6, 1, bankOffset>;\n\
    \    /**\n     * @brief TR7 field\n     *\n     * Rising trigger event configuration\
    \ of\n     *               line 7\n     */\n    using tr7 = FieldModel<uint32_t,\
    \ address, 7, 1, bankOffset>;\n    /**\n     * @brief TR8 field\n     *\n    \
    \ * Rising trigger event configuration of\n     *               line 8\n     */\n\
    \    using tr8 = FieldModel<uint32_t, address, 8, 1, bankOffset>;\n    /**\n \
    \    * @brief TR9 field\n     *\n     * Rising trigger event configuration of\n\
    \     *               line 9\n     */\n    using tr9 = FieldModel<uint32_t, address,\
    \ 9, 1, bankOffset>;\n    /**\n     * @brief TR10 field\n     *\n     * Rising\
    \ trigger event configuration of\n     *               line 10\n     */\n    using\
    \ tr10 = FieldModel<uint32_t, address, 10, 1, bankOffset>;\n    /**\n     * @brief\
    \ TR11 field\n     *\n     * Rising trigger event configuration of\n     *   \
    \            line 11\n     */\n    using tr11 = FieldModel<uint32_t, address,\
    \ 11, 1, bankOffset>;\n    /**\n     * @brief TR12 field\n     *\n     * Rising\
    \ trigger event configuration of\n     *               line 12\n     */\n    using\
    \ tr12 = FieldModel<uint32_t, address, 12, 1, bankOffset>;\n    /**\n     * @brief\
    \ TR13 field\n     *\n     * Rising trigger event configuration of\n     *   \
    \            line 13\n     */\n    using tr13 = FieldModel<uint32_t, address,\
    \ 13, 1, bankOffset>;\n    /**\n     * @brief TR14 field\n     *\n     * Rising\
    \ trigger event configuration of\n     *               line 14\n     */\n    using\
    \ tr14 = FieldModel<uint32_t, address, 14, 1, bankOffset>;\n    /**\n     * @brief\
    \ TR15 field\n     *\n     * Rising trigger event configuration of\n     *   \
    \            line 15\n     */\n    using tr15 = FieldModel<uint32_t, address,\
    \ 15, 1, bankOffset>;\n    /**\n     * @brief TR16 field\n     *\n     * Rising\
    \ trigger event configuration of\n     *               line 16\n     */\n    using\
    \ tr16 = FieldModel<uint32_t, address, 16, 1, bankOffset>;\n    /**\n     * @brief\
    \ TR17 field\n     *\n     * Rising trigger event configuration of\n     *   \
    \            line 17\n     */\n    using tr17 = FieldModel<uint32_t, address,\
    \ 17, 1, bankOffset>;\n    /**\n     * @brief TR18 field\n     *\n     * Rising\
    \ trigger event configuration of\n     *               line 18\n     */\n    using\
    \ tr18 = FieldModel<uint32_t, address, 18, 1, bankOffset>;\n    /**\n     * @brief\
    \ TR19 field\n     *\n     * Rising trigger event configuration of\n     *   \
    \            line 19\n     */\n    using tr19 = FieldModel<uint32_t, address,\
    \ 19, 1, bankOffset>;\n    /**\n     * @brief TR20 field\n     *\n     * Rising\
    \ trigger event configuration of\n     *               line 20\n     */\n    using\
    \ tr20 = FieldModel<uint32_t, address, 20, 1, bankOffset>;\n    /**\n     * @brief\
    \ TR21 field\n     *\n     * Rising trigger event configuration of\n     *   \
    \            line 21\n     */\n    using tr21 = FieldModel<uint32_t, address,\
    \ 21, 1, bankOffset>;\n    /**\n     * @brief TR22 field\n     *\n     * Rising\
    \ trigger event configuration of\n     *               line 22\n     */\n    using\
    \ tr22 = FieldModel<uint32_t, address, 22, 1, bankOffset>;\n\n  public:\n    union\
    \ reg\n    {\n      uint32_t value;\n      /**\n       * @brief TR0 field\n  \
    \     *\n       * Rising trigger event configuration of\n       *            \
    \   line 0\n       */\n      BitFieldModel<uint32_t, 0, 1> tr0;\n      /**\n \
    \      * @brief TR1 field\n       *\n       * Rising trigger event configuration\
    \ of\n       *               line 1\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> tr1;\n      /**\n       * @brief TR2 field\n       *\n       * Rising\
    \ trigger event configuration of\n       *               line 2\n       */\n \
    \     BitFieldModel<uint32_t, 2, 1> tr2;\n      /**\n       * @brief TR3 field\n\
    \       *\n       * Rising trigger event configuration of\n       *          \
    \     line 3\n       */\n      BitFieldModel<uint32_t, 3, 1> tr3;\n      /**\n\
    \       * @brief TR4 field\n       *\n       * Rising trigger event configuration\
    \ of\n       *               line 4\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> tr4;\n      /**\n       * @brief TR5 field\n       *\n       * Rising\
    \ trigger event configuration of\n       *               line 5\n       */\n \
    \     BitFieldModel<uint32_t, 5, 1> tr5;\n      /**\n       * @brief TR6 field\n\
    \       *\n       * Rising trigger event configuration of\n       *          \
    \     line 6\n       */\n      BitFieldModel<uint32_t, 6, 1> tr6;\n      /**\n\
    \       * @brief TR7 field\n       *\n       * Rising trigger event configuration\
    \ of\n       *               line 7\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> tr7;\n      /**\n       * @brief TR8 field\n       *\n       * Rising\
    \ trigger event configuration of\n       *               line 8\n       */\n \
    \     BitFieldModel<uint32_t, 8, 1> tr8;\n      /**\n       * @brief TR9 field\n\
    \       *\n       * Rising trigger event configuration of\n       *          \
    \     line 9\n       */\n      BitFieldModel<uint32_t, 9, 1> tr9;\n      /**\n\
    \       * @brief TR10 field\n       *\n       * Rising trigger event configuration\
    \ of\n       *               line 10\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> tr10;\n      /**\n       * @brief TR11 field\n       *\n       * Rising\
    \ trigger event configuration of\n       *               line 11\n       */\n\
    \      BitFieldModel<uint32_t, 11, 1> tr11;\n      /**\n       * @brief TR12 field\n\
    \       *\n       * Rising trigger event configuration of\n       *          \
    \     line 12\n       */\n      BitFieldModel<uint32_t, 12, 1> tr12;\n      /**\n\
    \       * @brief TR13 field\n       *\n       * Rising trigger event configuration\
    \ of\n       *               line 13\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> tr13;\n      /**\n       * @brief TR14 field\n       *\n       * Rising\
    \ trigger event configuration of\n       *               line 14\n       */\n\
    \      BitFieldModel<uint32_t, 14, 1> tr14;\n      /**\n       * @brief TR15 field\n\
    \       *\n       * Rising trigger event configuration of\n       *          \
    \     line 15\n       */\n      BitFieldModel<uint32_t, 15, 1> tr15;\n      /**\n\
    \       * @brief TR16 field\n       *\n       * Rising trigger event configuration\
    \ of\n       *               line 16\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> tr16;\n      /**\n       * @brief TR17 field\n       *\n       * Rising\
    \ trigger event configuration of\n       *               line 17\n       */\n\
    \      BitFieldModel<uint32_t, 17, 1> tr17;\n      /**\n       * @brief TR18 field\n\
    \       *\n       * Rising trigger event configuration of\n       *          \
    \     line 18\n       */\n      BitFieldModel<uint32_t, 18, 1> tr18;\n      /**\n\
    \       * @brief TR19 field\n       *\n       * Rising trigger event configuration\
    \ of\n       *               line 19\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> tr19;\n      /**\n       * @brief TR20 field\n       *\n       * Rising\
    \ trigger event configuration of\n       *               line 20\n       */\n\
    \      BitFieldModel<uint32_t, 20, 1> tr20;\n      /**\n       * @brief TR21 field\n\
    \       *\n       * Rising trigger event configuration of\n       *          \
    \     line 21\n       */\n      BitFieldModel<uint32_t, 21, 1> tr21;\n      /**\n\
    \       * @brief TR22 field\n       *\n       * Rising trigger event configuration\
    \ of\n       *               line 22\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> tr22;\n    };\n  };\n\npublic:\n  /**\n   * @brief XTSR register bank\n\
    \   *\n   * Rising Trigger selection register\n   *           (EXTI_RTSR)\n  \
    \ */\n  using xtsr = XtsrBankReg<BaseAddress + 0x0008, 0x0004>;\n\n};\n\n}\n\n\
    #endif /* DRAL_STM32F411_EXTI_H */"
  name: EXTI
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_FLASH_H\n#define DRAL_STM32F411_FLASH_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ FLASH peripheral\n *\n * FLASH\n */\nclass flash\n{\npublic:\n  static constexpr\
    \ unsigned int BaseAddress = 0x40023C00; /**< Peripheral base address */\n\nprivate:\n\
    \  template<unsigned int address>\n  class AcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief LATENCY field\n     *\n   \
    \  * Latency\n     */\n    using latency = FieldModel<uint32_t, address, 0, 3>;\n\
    \    /**\n     * @brief PRFTEN field\n     *\n     * Prefetch enable\n     */\n\
    \    using prften = FieldModel<uint32_t, address, 8, 1>;\n    /**\n     * @brief\
    \ ICEN field\n     *\n     * Instruction cache enable\n     */\n    using icen\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief DCEN field\n\
    \     *\n     * Data cache enable\n     */\n    using dcen = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief ICRST field\n     *\n     * Instruction\
    \ cache reset\n     */\n    using icrst = FieldModel<uint32_t, address, 11, 1>;\n\
    \    /**\n     * @brief DCRST field\n     *\n     * Data cache reset\n     */\n\
    \    using dcrst = FieldModel<uint32_t, address, 12, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ LATENCY field\n       *\n       * Latency\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 3> latency;\n      /**\n       * @brief PRFTEN field\n       *\n       *\
    \ Prefetch enable\n       */\n      BitFieldModel<uint32_t, 8, 1> prften;\n  \
    \    /**\n       * @brief ICEN field\n       *\n       * Instruction cache enable\n\
    \       */\n      BitFieldModel<uint32_t, 9, 1> icen;\n      /**\n       * @brief\
    \ DCEN field\n       *\n       * Data cache enable\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> dcen;\n      /**\n       * @brief ICRST field\n       *\n       * Instruction\
    \ cache reset\n       */\n      BitFieldModel<uint32_t, 11, 1> icrst;\n      /**\n\
    \       * @brief DCRST field\n       *\n       * Data cache reset\n       */\n\
    \      BitFieldModel<uint32_t, 12, 1> dcrst;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief ACR register\n   *\n   * Flash access control register\n   */\n \
    \ using acr = AcrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class KeyrReg : public RegisterModel<uint32_t, address>\n  {\n \
    \ public:\n    /**\n     * @brief KEY field\n     *\n     * FPEC key\n     */\n\
    \    using key = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ KEY field\n       *\n       * FPEC key\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> key;\n    };\n  };\n\npublic:\n  /**\n   * @brief KEYR register\n   *\n\
    \   * Flash key register\n   */\n  using keyr = KeyrReg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class OptkeyrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief OPTKEY field\n     *\n    \
    \ * Option byte key\n     */\n    using optkey = FieldModel<uint32_t, address,\
    \ 0, 32>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OPTKEY field\n       *\n\
    \       * Option byte key\n       */\n      BitFieldModel<uint32_t, 0, 32> optkey;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief OPTKEYR register\n   *\n   * Flash\
    \ option key register\n   */\n  using optkeyr = OptkeyrReg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief EOP field\n     *\n     * End\
    \ of operation\n     */\n    using eop = FieldModel<uint32_t, address, 0, 1>;\n\
    \    /**\n     * @brief OPERR field\n     *\n     * Operation error\n     */\n\
    \    using operr = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief\
    \ WRPERR field\n     *\n     * Write protection error\n     */\n    using wrperr\
    \ = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief PGAERR field\n\
    \     *\n     * Programming alignment\n     *               error\n     */\n \
    \   using pgaerr = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief\
    \ PGPERR field\n     *\n     * Programming parallelism\n     *               error\n\
    \     */\n    using pgperr = FieldModel<uint32_t, address, 6, 1>;\n    /**\n \
    \    * @brief PGSERR field\n     *\n     * Programming sequence error\n     */\n\
    \    using pgserr = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief\
    \ BSY field\n     *\n     * Busy\n     */\n    using bsy = FieldModel<uint32_t,\
    \ address, 16, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief EOP field\n       *\n \
    \      * End of operation\n       */\n      BitFieldModel<uint32_t, 0, 1> eop;\n\
    \      /**\n       * @brief OPERR field\n       *\n       * Operation error\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> operr;\n      /**\n       * @brief\
    \ WRPERR field\n       *\n       * Write protection error\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> wrperr;\n      /**\n       * @brief PGAERR field\n       *\n       * Programming\
    \ alignment\n       *               error\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> pgaerr;\n      /**\n       * @brief PGPERR field\n       *\n       * Programming\
    \ parallelism\n       *               error\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> pgperr;\n      /**\n       * @brief PGSERR field\n       *\n       * Programming\
    \ sequence error\n       */\n      BitFieldModel<uint32_t, 7, 1> pgserr;\n   \
    \   /**\n       * @brief BSY field\n       *\n       * Busy\n       */\n     \
    \ BitFieldModel<uint32_t, 16, 1> bsy;\n    };\n  };\n\npublic:\n  /**\n   * @brief\
    \ SR register\n   *\n   * Status register\n   */\n  using sr = SrReg<BaseAddress\
    \ + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class CrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief PG\
    \ field\n     *\n     * Programming\n     */\n    using pg = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    /**\n     * @brief SER field\n     *\n     * Sector Erase\n\
    \     */\n    using ser = FieldModel<uint32_t, address, 1, 1>;\n    /**\n    \
    \ * @brief MER field\n     *\n     * Mass Erase\n     */\n    using mer = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief SNB field\n     *\n     * Sector number\n\
    \     */\n    using snb = FieldModel<uint32_t, address, 3, 4>;\n    /**\n    \
    \ * @brief PSIZE field\n     *\n     * Program size\n     */\n    using psize\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief STRT field\n\
    \     *\n     * Start\n     */\n    using strt = FieldModel<uint32_t, address,\
    \ 16, 1>;\n    /**\n     * @brief EOPIE field\n     *\n     * End of operation\
    \ interrupt\n     *               enable\n     */\n    using eopie = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    /**\n     * @brief ERRIE field\n     *\n     * Error interrupt\
    \ enable\n     */\n    using errie = FieldModel<uint32_t, address, 25, 1>;\n \
    \   /**\n     * @brief LOCK field\n     *\n     * Lock\n     */\n    using lock\
    \ = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ PG field\n       *\n       * Programming\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> pg;\n      /**\n       * @brief SER field\n       *\n       * Sector Erase\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> ser;\n      /**\n       * @brief\
    \ MER field\n       *\n       * Mass Erase\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> mer;\n      /**\n       * @brief SNB field\n       *\n       * Sector\
    \ number\n       */\n      BitFieldModel<uint32_t, 3, 4> snb;\n      /**\n   \
    \    * @brief PSIZE field\n       *\n       * Program size\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 2> psize;\n      /**\n       * @brief STRT field\n       *\n       * Start\n\
    \       */\n      BitFieldModel<uint32_t, 16, 1> strt;\n      /**\n       * @brief\
    \ EOPIE field\n       *\n       * End of operation interrupt\n       *       \
    \        enable\n       */\n      BitFieldModel<uint32_t, 24, 1> eopie;\n    \
    \  /**\n       * @brief ERRIE field\n       *\n       * Error interrupt enable\n\
    \       */\n      BitFieldModel<uint32_t, 25, 1> errie;\n      /**\n       * @brief\
    \ LOCK field\n       *\n       * Lock\n       */\n      BitFieldModel<uint32_t,\
    \ 31, 1> lock;\n    };\n  };\n\npublic:\n  /**\n   * @brief CR register\n   *\n\
    \   * Control register\n   */\n  using cr = CrReg<BaseAddress + 0x0010>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class OptcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief OPTLOCK field\n     *\n   \
    \  * Option lock\n     */\n    using optlock = FieldModel<uint32_t, address, 0,\
    \ 1>;\n    /**\n     * @brief OPTSTRT field\n     *\n     * Option start\n   \
    \  */\n    using optstrt = FieldModel<uint32_t, address, 1, 1>;\n    /**\n   \
    \  * @brief BOR_LEV field\n     *\n     * BOR reset Level\n     */\n    using\
    \ bor_lev = FieldModel<uint32_t, address, 2, 2>;\n    /**\n     * @brief WDG_SW\
    \ field\n     *\n     * WDG_SW User option bytes\n     */\n    using wdg_sw =\
    \ FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief NRST_STOP field\n\
    \     *\n     * nRST_STOP User option\n     *               bytes\n     */\n \
    \   using nrst_stop = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief\
    \ NRST_STDBY field\n     *\n     * nRST_STDBY User option\n     *            \
    \   bytes\n     */\n    using nrst_stdby = FieldModel<uint32_t, address, 7, 1>;\n\
    \    /**\n     * @brief RDP field\n     *\n     * Read protect\n     */\n    using\
    \ rdp = FieldModel<uint32_t, address, 8, 8>;\n    /**\n     * @brief NWRP field\n\
    \     *\n     * Not write protect\n     */\n    using nwrp = FieldModel<uint32_t,\
    \ address, 16, 12>;\n\n  public:\n    /**\n     * @brief Register union\n    \
    \ *\n     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OPTLOCK field\n       *\n\
    \       * Option lock\n       */\n      BitFieldModel<uint32_t, 0, 1> optlock;\n\
    \      /**\n       * @brief OPTSTRT field\n       *\n       * Option start\n \
    \      */\n      BitFieldModel<uint32_t, 1, 1> optstrt;\n      /**\n       * @brief\
    \ BOR_LEV field\n       *\n       * BOR reset Level\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 2> bor_lev;\n      /**\n       * @brief WDG_SW field\n       *\n       *\
    \ WDG_SW User option bytes\n       */\n      BitFieldModel<uint32_t, 5, 1> wdg_sw;\n\
    \      /**\n       * @brief NRST_STOP field\n       *\n       * nRST_STOP User\
    \ option\n       *               bytes\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> nrst_stop;\n      /**\n       * @brief NRST_STDBY field\n       *\n  \
    \     * nRST_STDBY User option\n       *               bytes\n       */\n    \
    \  BitFieldModel<uint32_t, 7, 1> nrst_stdby;\n      /**\n       * @brief RDP field\n\
    \       *\n       * Read protect\n       */\n      BitFieldModel<uint32_t, 8,\
    \ 8> rdp;\n      /**\n       * @brief NWRP field\n       *\n       * Not write\
    \ protect\n       */\n      BitFieldModel<uint32_t, 16, 12> nwrp;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief OPTCR register\n   *\n   * Flash option control\
    \ register\n   */\n  using optcr = OptcrReg<BaseAddress + 0x0014>;\n\n};\n\n}\n\
    \n#endif /* DRAL_STM32F411_FLASH_H */"
  name: FLASH
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_IWDG_H\n#define DRAL_STM32F411_IWDG_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ IWDG peripheral\n *\n * Independent watchdog\n */\nclass iwdg\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40003000; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class KrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief KEY\
    \ field\n     *\n     * Key value\n     */\n    using key = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief KEY field\n       *\n \
    \      * Key value\n       */\n      BitFieldModel<uint32_t, 0, 16> key;\n   \
    \ };\n  };\n\npublic:\n  /**\n   * @brief KR register\n   *\n   * Key register\n\
    \   */\n  using kr = KrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class PrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief PR field\n     *\n     * Prescaler divider\n\
    \     */\n    using pr = FieldModel<uint32_t, address, 0, 3>;\n\n  public:\n \
    \   /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief PR field\n       *\n       * Prescaler divider\n       */\n \
    \     BitFieldModel<uint32_t, 0, 3> pr;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief PR register\n   *\n   * Prescaler register\n   */\n  using pr = PrReg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class RlrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief RL\
    \ field\n     *\n     * Watchdog counter reload\n     *               value\n\
    \     */\n    using rl = FieldModel<uint32_t, address, 0, 12>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief RL field\n       *\n       * Watchdog counter reload\n      \
    \ *               value\n       */\n      BitFieldModel<uint32_t, 0, 12> rl;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief RLR register\n   *\n   * Reload register\n\
    \   */\n  using rlr = RlrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class SrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief RVU field\n     *\n     * Watchdog counter\
    \ reload value\n     *               update\n     */\n    using rvu = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief PVU field\n     *\n     * Watchdog prescaler\
    \ value\n     *               update\n     */\n    using pvu = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief RVU field\n       *\n \
    \      * Watchdog counter reload value\n       *               update\n      \
    \ */\n      BitFieldModel<uint32_t, 1, 1> rvu;\n      /**\n       * @brief PVU\
    \ field\n       *\n       * Watchdog prescaler value\n       *               update\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> pvu;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief SR register\n   *\n   * Status register\n   */\n  using sr\
    \ = SrReg<BaseAddress + 0x000C>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_IWDG_H\
    \ */"
  name: IWDG
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_OTG_FS_DEVICE_H\n#define DRAL_STM32F411_OTG_FS_DEVICE_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ OTG_FS_DEVICE peripheral\n *\n * USB on the go full speed\n */\nclass otg_fs_device\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x50000800; /**< Peripheral\
    \ base address */\n\nprivate:\n  template<unsigned int address>\n  class Fs_dcfgReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ DSPD field\n     *\n     * Device speed\n     */\n    using dspd = FieldModel<uint32_t,\
    \ address, 0, 2>;\n    /**\n     * @brief NZLSOHSK field\n     *\n     * Non-zero-length\
    \ status OUT\n     *               handshake\n     */\n    using nzlsohsk = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief DAD field\n     *\n     * Device address\n\
    \     */\n    using dad = FieldModel<uint32_t, address, 4, 7>;\n    /**\n    \
    \ * @brief PFIVL field\n     *\n     * Periodic frame interval\n     */\n    using\
    \ pfivl = FieldModel<uint32_t, address, 11, 2>;\n\n  public:\n    /**\n     *\
    \ @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ DSPD field\n       *\n       * Device speed\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> dspd;\n      /**\n       * @brief NZLSOHSK field\n       *\n       * Non-zero-length\
    \ status OUT\n       *               handshake\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> nzlsohsk;\n      /**\n       * @brief DAD field\n       *\n       * Device\
    \ address\n       */\n      BitFieldModel<uint32_t, 4, 7> dad;\n      /**\n  \
    \     * @brief PFIVL field\n       *\n       * Periodic frame interval\n     \
    \  */\n      BitFieldModel<uint32_t, 11, 2> pfivl;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief FS_DCFG register\n   *\n   * OTG_FS device configuration register\n\
    \   *           (OTG_FS_DCFG)\n   */\n  using fs_dcfg = Fs_dcfgReg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_dctlReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ RWUSIG field\n     *\n     * Remote wakeup signaling\n     */\n    using rwusig\
    \ = FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief SDIS field\n\
    \     *\n     * Soft disconnect\n     */\n    using sdis = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief GINSTS field\n     *\n     * Global\
    \ IN NAK status\n     */\n    using ginsts = FieldModel<uint32_t, address, 2,\
    \ 1>;\n    /**\n     * @brief GONSTS field\n     *\n     * Global OUT NAK status\n\
    \     */\n    using gonsts = FieldModel<uint32_t, address, 3, 1>;\n    /**\n \
    \    * @brief TCTL field\n     *\n     * Test control\n     */\n    using tctl\
    \ = FieldModel<uint32_t, address, 4, 3>;\n    /**\n     * @brief SGINAK field\n\
    \     *\n     * Set global IN NAK\n     */\n    using sginak = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief CGINAK field\n     *\n     * Clear global\
    \ IN NAK\n     */\n    using cginak = FieldModel<uint32_t, address, 8, 1>;\n \
    \   /**\n     * @brief SGONAK field\n     *\n     * Set global OUT NAK\n     */\n\
    \    using sgonak = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief\
    \ CGONAK field\n     *\n     * Clear global OUT NAK\n     */\n    using cgonak\
    \ = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief POPRGDNE field\n\
    \     *\n     * Power-on programming done\n     */\n    using poprgdne = FieldModel<uint32_t,\
    \ address, 11, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief RWUSIG field\n       *\n\
    \       * Remote wakeup signaling\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 1> rwusig;\n      /**\n       * @brief SDIS field\n       *\n       * Soft disconnect\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> sdis;\n      /**\n       * @brief\
    \ GINSTS field\n       *\n       * Global IN NAK status\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> ginsts;\n      /**\n       * @brief GONSTS field\n       *\n       * Global\
    \ OUT NAK status\n       */\n      BitFieldModel<uint32_t, 3, 1> gonsts;\n   \
    \   /**\n       * @brief TCTL field\n       *\n       * Test control\n       */\n\
    \      BitFieldModel<uint32_t, 4, 3> tctl;\n      /**\n       * @brief SGINAK\
    \ field\n       *\n       * Set global IN NAK\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> sginak;\n      /**\n       * @brief CGINAK field\n       *\n       * Clear\
    \ global IN NAK\n       */\n      BitFieldModel<uint32_t, 8, 1> cginak;\n    \
    \  /**\n       * @brief SGONAK field\n       *\n       * Set global OUT NAK\n\
    \       */\n      BitFieldModel<uint32_t, 9, 1> sgonak;\n      /**\n       * @brief\
    \ CGONAK field\n       *\n       * Clear global OUT NAK\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> cgonak;\n      /**\n       * @brief POPRGDNE field\n       *\n      \
    \ * Power-on programming done\n       */\n      BitFieldModel<uint32_t, 11, 1>\
    \ poprgdne;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_DCTL register\n  \
    \ *\n   * OTG_FS device control register\n   *           (OTG_FS_DCTL)\n   */\n\
    \  using fs_dctl = Fs_dctlReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Fs_dstsReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief SUSPSTS field\n     *\n     * Suspend\
    \ status\n     */\n    using suspsts = FieldModel<uint32_t, address, 0, 1>;\n\
    \    /**\n     * @brief ENUMSPD field\n     *\n     * Enumerated speed\n     */\n\
    \    using enumspd = FieldModel<uint32_t, address, 1, 2>;\n    /**\n     * @brief\
    \ EERR field\n     *\n     * Erratic error\n     */\n    using eerr = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief FNSOF field\n     *\n     * Frame number\
    \ of the received\n     *               SOF\n     */\n    using fnsof = FieldModel<uint32_t,\
    \ address, 8, 14>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief SUSPSTS field\n       *\n\
    \       * Suspend status\n       */\n      BitFieldModel<uint32_t, 0, 1> suspsts;\n\
    \      /**\n       * @brief ENUMSPD field\n       *\n       * Enumerated speed\n\
    \       */\n      BitFieldModel<uint32_t, 1, 2> enumspd;\n      /**\n       *\
    \ @brief EERR field\n       *\n       * Erratic error\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> eerr;\n      /**\n       * @brief FNSOF field\n       *\n       * Frame\
    \ number of the received\n       *               SOF\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 14> fnsof;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_DSTS register\n\
    \   *\n   * OTG_FS device status register\n   *           (OTG_FS_DSTS)\n   */\n\
    \  using fs_dsts = Fs_dstsReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Fs_diepmskReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief XFRCM field\n     *\n     * Transfer completed\
    \ interrupt\n     *               mask\n     */\n    using xfrcm = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    /**\n     * @brief EPDM field\n     *\n     * Endpoint\
    \ disabled interrupt\n     *               mask\n     */\n    using epdm = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief TOM field\n     *\n     * Timeout condition\
    \ mask (Non-isochronous\n     *               endpoints)\n     */\n    using tom\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief ITTXFEMSK field\n\
    \     *\n     * IN token received when TxFIFO empty\n     *               mask\n\
    \     */\n    using ittxfemsk = FieldModel<uint32_t, address, 4, 1>;\n    /**\n\
    \     * @brief INEPNMM field\n     *\n     * IN token received with EP mismatch\n\
    \     *               mask\n     */\n    using inepnmm = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief INEPNEM field\n     *\n     * IN endpoint\
    \ NAK effective\n     *               mask\n     */\n    using inepnem = FieldModel<uint32_t,\
    \ address, 6, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief XFRCM field\n       *\n\
    \       * Transfer completed interrupt\n       *               mask\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      /**\n       * @brief EPDM field\n\
    \       *\n       * Endpoint disabled interrupt\n       *               mask\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> epdm;\n      /**\n       * @brief\
    \ TOM field\n       *\n       * Timeout condition mask (Non-isochronous\n    \
    \   *               endpoints)\n       */\n      BitFieldModel<uint32_t, 3, 1>\
    \ tom;\n      /**\n       * @brief ITTXFEMSK field\n       *\n       * IN token\
    \ received when TxFIFO empty\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> ittxfemsk;\n      /**\n       * @brief INEPNMM field\n       *\n     \
    \  * IN token received with EP mismatch\n       *               mask\n       */\n\
    \      BitFieldModel<uint32_t, 5, 1> inepnmm;\n      /**\n       * @brief INEPNEM\
    \ field\n       *\n       * IN endpoint NAK effective\n       *              \
    \ mask\n       */\n      BitFieldModel<uint32_t, 6, 1> inepnem;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief FS_DIEPMSK register\n   *\n   * OTG_FS device IN\
    \ endpoint common interrupt\n   *           mask register (OTG_FS_DIEPMSK)\n \
    \  */\n  using fs_diepmsk = Fs_diepmskReg<BaseAddress + 0x0010>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_doepmskReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief XFRCM field\n     *\n     *\
    \ Transfer completed interrupt\n     *               mask\n     */\n    using\
    \ xfrcm = FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief EPDM field\n\
    \     *\n     * Endpoint disabled interrupt\n     *               mask\n     */\n\
    \    using epdm = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief\
    \ STUPM field\n     *\n     * SETUP phase done mask\n     */\n    using stupm\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief OTEPDM field\n\
    \     *\n     * OUT token received when endpoint\n     *               disabled\
    \ mask\n     */\n    using otepdm = FieldModel<uint32_t, address, 4, 1>;\n\n \
    \ public:\n    /**\n     * @brief Register union\n     *\n     * Can be used to\
    \ create a local register variable for easy bit manipulation.\n     * Useful for\
    \ read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief XFRCM field\n       *\n       * Transfer\
    \ completed interrupt\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrcm;\n      /**\n       * @brief EPDM field\n       *\n       * Endpoint\
    \ disabled interrupt\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> epdm;\n      /**\n       * @brief STUPM field\n       *\n       * SETUP\
    \ phase done mask\n       */\n      BitFieldModel<uint32_t, 3, 1> stupm;\n   \
    \   /**\n       * @brief OTEPDM field\n       *\n       * OUT token received when\
    \ endpoint\n       *               disabled mask\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> otepdm;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_DOEPMSK register\n\
    \   *\n   * OTG_FS device OUT endpoint common interrupt\n   *           mask register\
    \ (OTG_FS_DOEPMSK)\n   */\n  using fs_doepmsk = Fs_doepmskReg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Fs_daintReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief IEPINT field\n     *\n    \
    \ * IN endpoint interrupt bits\n     */\n    using iepint = FieldModel<uint32_t,\
    \ address, 0, 16>;\n    /**\n     * @brief OEPINT field\n     *\n     * OUT endpoint\
    \ interrupt\n     *               bits\n     */\n    using oepint = FieldModel<uint32_t,\
    \ address, 16, 16>;\n\n  public:\n    /**\n     * @brief Register union\n    \
    \ *\n     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief IEPINT field\n       *\n\
    \       * IN endpoint interrupt bits\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> iepint;\n      /**\n       * @brief OEPINT field\n       *\n       *\
    \ OUT endpoint interrupt\n       *               bits\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 16> oepint;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_DAINT register\n\
    \   *\n   * OTG_FS device all endpoints interrupt\n   *           register (OTG_FS_DAINT)\n\
    \   */\n  using fs_daint = Fs_daintReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Fs_daintmskReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief IEPM field\n     *\n     * IN EP interrupt\
    \ mask bits\n     */\n    using iepm = FieldModel<uint32_t, address, 0, 16>;\n\
    \    /**\n     * @brief OEPM field\n     *\n     * OUT endpoint interrupt\n  \
    \   *               bits\n     */\n    using oepm = FieldModel<uint32_t, address,\
    \ 16, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief IEPM field\n       *\n\
    \       * IN EP interrupt mask bits\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> iepm;\n      /**\n       * @brief OEPM field\n       *\n       * OUT\
    \ endpoint interrupt\n       *               bits\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 16> oepm;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_DAINTMSK register\n\
    \   *\n   * OTG_FS all endpoints interrupt mask register\n   *           (OTG_FS_DAINTMSK)\n\
    \   */\n  using fs_daintmsk = Fs_daintmskReg<BaseAddress + 0x001C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class DvbusdisReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief VBUSDT field\n     *\n    \
    \ * Device VBUS discharge time\n     */\n    using vbusdt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief VBUSDT field\n       *\n\
    \       * Device VBUS discharge time\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> vbusdt;\n    };\n  };\n\npublic:\n  /**\n   * @brief DVBUSDIS register\n\
    \   *\n   * OTG_FS device VBUS discharge time\n   *           register\n   */\n\
    \  using dvbusdis = DvbusdisReg<BaseAddress + 0x0028>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DvbuspulseReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief DVBUSP field\n     *\n     * Device VBUS\
    \ pulsing time\n     */\n    using dvbusp = FieldModel<uint32_t, address, 0, 12>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief DVBUSP field\n       *\n       * Device VBUS\
    \ pulsing time\n       */\n      BitFieldModel<uint32_t, 0, 12> dvbusp;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief DVBUSPULSE register\n   *\n   * OTG_FS device\
    \ VBUS pulsing time\n   *           register\n   */\n  using dvbuspulse = DvbuspulseReg<BaseAddress\
    \ + 0x002C>;\n\nprivate:\n  template<unsigned int address>\n  class DiepempmskReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ INEPTXFEM field\n     *\n     * IN EP Tx FIFO empty interrupt mask\n     * \
    \              bits\n     */\n    using ineptxfem = FieldModel<uint32_t, address,\
    \ 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief INEPTXFEM field\n     \
    \  *\n       * IN EP Tx FIFO empty interrupt mask\n       *               bits\n\
    \       */\n      BitFieldModel<uint32_t, 0, 16> ineptxfem;\n    };\n  };\n\n\
    public:\n  /**\n   * @brief DIEPEMPMSK register\n   *\n   * OTG_FS device IN endpoint\
    \ FIFO empty\n   *           interrupt mask register\n   */\n  using diepempmsk\
    \ = DiepempmskReg<BaseAddress + 0x0034>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class Fs_diepctl0Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief MPSIZ field\n     *\n     * Maximum packet\
    \ size\n     */\n    using mpsiz = FieldModel<uint32_t, address, 0, 2>;\n    /**\n\
    \     * @brief USBAEP field\n     *\n     * USB active endpoint\n     */\n   \
    \ using usbaep = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief\
    \ NAKSTS field\n     *\n     * NAK status\n     */\n    using naksts = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    /**\n     * @brief EPTYP field\n     *\n     * Endpoint\
    \ type\n     */\n    using eptyp = FieldModel<uint32_t, address, 18, 2>;\n   \
    \ /**\n     * @brief STALL field\n     *\n     * STALL handshake\n     */\n  \
    \  using stall = FieldModel<uint32_t, address, 21, 1>;\n    /**\n     * @brief\
    \ TXFNUM field\n     *\n     * TxFIFO number\n     */\n    using txfnum = FieldModel<uint32_t,\
    \ address, 22, 4>;\n    /**\n     * @brief CNAK field\n     *\n     * Clear NAK\n\
    \     */\n    using cnak = FieldModel<uint32_t, address, 26, 1>;\n    /**\n  \
    \   * @brief SNAK field\n     *\n     * Set NAK\n     */\n    using snak = FieldModel<uint32_t,\
    \ address, 27, 1>;\n    /**\n     * @brief EPDIS field\n     *\n     * Endpoint\
    \ disable\n     */\n    using epdis = FieldModel<uint32_t, address, 30, 1>;\n\
    \    /**\n     * @brief EPENA field\n     *\n     * Endpoint enable\n     */\n\
    \    using epena = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ MPSIZ field\n       *\n       * Maximum packet size\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> mpsiz;\n      /**\n       * @brief USBAEP field\n       *\n       * USB\
    \ active endpoint\n       */\n      BitFieldModel<uint32_t, 15, 1> usbaep;\n \
    \     /**\n       * @brief NAKSTS field\n       *\n       * NAK status\n     \
    \  */\n      BitFieldModel<uint32_t, 17, 1> naksts;\n      /**\n       * @brief\
    \ EPTYP field\n       *\n       * Endpoint type\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      /**\n       * @brief STALL field\n       *\n       * STALL\
    \ handshake\n       */\n      BitFieldModel<uint32_t, 21, 1> stall;\n      /**\n\
    \       * @brief TXFNUM field\n       *\n       * TxFIFO number\n       */\n \
    \     BitFieldModel<uint32_t, 22, 4> txfnum;\n      /**\n       * @brief CNAK\
    \ field\n       *\n       * Clear NAK\n       */\n      BitFieldModel<uint32_t,\
    \ 26, 1> cnak;\n      /**\n       * @brief SNAK field\n       *\n       * Set\
    \ NAK\n       */\n      BitFieldModel<uint32_t, 27, 1> snak;\n      /**\n    \
    \   * @brief EPDIS field\n       *\n       * Endpoint disable\n       */\n   \
    \   BitFieldModel<uint32_t, 30, 1> epdis;\n      /**\n       * @brief EPENA field\n\
    \       *\n       * Endpoint enable\n       */\n      BitFieldModel<uint32_t,\
    \ 31, 1> epena;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_DIEPCTL0 register\n\
    \   *\n   * OTG_FS device control IN endpoint 0 control\n   *           register\
    \ (OTG_FS_DIEPCTL0)\n   */\n  using fs_diepctl0 = Fs_diepctl0Reg<BaseAddress +\
    \ 0x0100>;\n\nprivate:\n  template<unsigned int address>\n  class Diepctl1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ EPENA field\n     *\n     * EPENA\n     */\n    using epena = FieldModel<uint32_t,\
    \ address, 31, 1>;\n    /**\n     * @brief EPDIS field\n     *\n     * EPDIS\n\
    \     */\n    using epdis = FieldModel<uint32_t, address, 30, 1>;\n    /**\n \
    \    * @brief SODDFRM_SD1PID field\n     *\n     * SODDFRM/SD1PID\n     */\n \
    \   using soddfrm_sd1pid = FieldModel<uint32_t, address, 29, 1>;\n    /**\n  \
    \   * @brief SEVNFRM_SD0PID field\n     *\n     * SD0PID/SEVNFRM\n     */\n  \
    \  using sevnfrm_sd0pid = FieldModel<uint32_t, address, 28, 1>;\n    /**\n   \
    \  * @brief SNAK field\n     *\n     * SNAK\n     */\n    using snak = FieldModel<uint32_t,\
    \ address, 27, 1>;\n    /**\n     * @brief CNAK field\n     *\n     * CNAK\n \
    \    */\n    using cnak = FieldModel<uint32_t, address, 26, 1>;\n    /**\n   \
    \  * @brief TXFNUM field\n     *\n     * TXFNUM\n     */\n    using txfnum = FieldModel<uint32_t,\
    \ address, 22, 4>;\n    /**\n     * @brief STALL field\n     *\n     * Stall\n\
    \     */\n    using stall = FieldModel<uint32_t, address, 21, 1>;\n    /**\n \
    \    * @brief EPTYP field\n     *\n     * EPTYP\n     */\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    /**\n     * @brief NAKSTS field\n     *\n     * NAKSTS\n\
    \     */\n    using naksts = FieldModel<uint32_t, address, 17, 1>;\n    /**\n\
    \     * @brief EONUM_DPID field\n     *\n     * EONUM/DPID\n     */\n    using\
    \ eonum_dpid = FieldModel<uint32_t, address, 16, 1>;\n    /**\n     * @brief USBAEP\
    \ field\n     *\n     * USBAEP\n     */\n    using usbaep = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief MPSIZ field\n     *\n     * MPSIZ\n\
    \     */\n    using mpsiz = FieldModel<uint32_t, address, 0, 11>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief EPENA field\n       *\n       * EPENA\n       */\n      BitFieldModel<uint32_t,\
    \ 31, 1> epena;\n      /**\n       * @brief EPDIS field\n       *\n       * EPDIS\n\
    \       */\n      BitFieldModel<uint32_t, 30, 1> epdis;\n      /**\n       * @brief\
    \ SODDFRM_SD1PID field\n       *\n       * SODDFRM/SD1PID\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 1> soddfrm_sd1pid;\n      /**\n       * @brief SEVNFRM_SD0PID field\n  \
    \     *\n       * SD0PID/SEVNFRM\n       */\n      BitFieldModel<uint32_t, 28,\
    \ 1> sevnfrm_sd0pid;\n      /**\n       * @brief SNAK field\n       *\n      \
    \ * SNAK\n       */\n      BitFieldModel<uint32_t, 27, 1> snak;\n      /**\n \
    \      * @brief CNAK field\n       *\n       * CNAK\n       */\n      BitFieldModel<uint32_t,\
    \ 26, 1> cnak;\n      /**\n       * @brief TXFNUM field\n       *\n       * TXFNUM\n\
    \       */\n      BitFieldModel<uint32_t, 22, 4> txfnum;\n      /**\n       *\
    \ @brief STALL field\n       *\n       * Stall\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 1> stall;\n      /**\n       * @brief EPTYP field\n       *\n       * EPTYP\n\
    \       */\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      /**\n       * @brief\
    \ NAKSTS field\n       *\n       * NAKSTS\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> naksts;\n      /**\n       * @brief EONUM_DPID field\n       *\n    \
    \   * EONUM/DPID\n       */\n      BitFieldModel<uint32_t, 16, 1> eonum_dpid;\n\
    \      /**\n       * @brief USBAEP field\n       *\n       * USBAEP\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> usbaep;\n      /**\n       * @brief MPSIZ\
    \ field\n       *\n       * MPSIZ\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 11> mpsiz;\n    };\n  };\n\npublic:\n  /**\n   * @brief DIEPCTL1 register\n\
    \   *\n   * OTG device endpoint-1 control\n   *           register\n   */\n  using\
    \ diepctl1 = Diepctl1Reg<BaseAddress + 0x0120>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Diepctl2Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief EPENA field\n     *\n     * EPENA\n  \
    \   */\n    using epena = FieldModel<uint32_t, address, 31, 1>;\n    /**\n   \
    \  * @brief EPDIS field\n     *\n     * EPDIS\n     */\n    using epdis = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    /**\n     * @brief SODDFRM_SD1PID field\n     *\n    \
    \ * SODDFRM\n     */\n    using soddfrm_sd1pid = FieldModel<uint32_t, address,\
    \ 29, 1>;\n    /**\n     * @brief SEVNFRM_SD0PID field\n     *\n     * SD0PID/SEVNFRM\n\
    \     */\n    using sevnfrm_sd0pid = FieldModel<uint32_t, address, 28, 1>;\n \
    \   /**\n     * @brief SNAK field\n     *\n     * SNAK\n     */\n    using snak\
    \ = FieldModel<uint32_t, address, 27, 1>;\n    /**\n     * @brief CNAK field\n\
    \     *\n     * CNAK\n     */\n    using cnak = FieldModel<uint32_t, address,\
    \ 26, 1>;\n    /**\n     * @brief TXFNUM field\n     *\n     * TXFNUM\n     */\n\
    \    using txfnum = FieldModel<uint32_t, address, 22, 4>;\n    /**\n     * @brief\
    \ STALL field\n     *\n     * Stall\n     */\n    using stall = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    /**\n     * @brief EPTYP field\n     *\n     * EPTYP\n\
    \     */\n    using eptyp = FieldModel<uint32_t, address, 18, 2>;\n    /**\n \
    \    * @brief NAKSTS field\n     *\n     * NAKSTS\n     */\n    using naksts =\
    \ FieldModel<uint32_t, address, 17, 1>;\n    /**\n     * @brief EONUM_DPID field\n\
    \     *\n     * EONUM/DPID\n     */\n    using eonum_dpid = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    /**\n     * @brief USBAEP field\n     *\n     * USBAEP\n\
    \     */\n    using usbaep = FieldModel<uint32_t, address, 15, 1>;\n    /**\n\
    \     * @brief MPSIZ field\n     *\n     * MPSIZ\n     */\n    using mpsiz = FieldModel<uint32_t,\
    \ address, 0, 11>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief EPENA field\n       *\n\
    \       * EPENA\n       */\n      BitFieldModel<uint32_t, 31, 1> epena;\n    \
    \  /**\n       * @brief EPDIS field\n       *\n       * EPDIS\n       */\n   \
    \   BitFieldModel<uint32_t, 30, 1> epdis;\n      /**\n       * @brief SODDFRM_SD1PID\
    \ field\n       *\n       * SODDFRM\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 1> soddfrm_sd1pid;\n      /**\n       * @brief SEVNFRM_SD0PID field\n  \
    \     *\n       * SD0PID/SEVNFRM\n       */\n      BitFieldModel<uint32_t, 28,\
    \ 1> sevnfrm_sd0pid;\n      /**\n       * @brief SNAK field\n       *\n      \
    \ * SNAK\n       */\n      BitFieldModel<uint32_t, 27, 1> snak;\n      /**\n \
    \      * @brief CNAK field\n       *\n       * CNAK\n       */\n      BitFieldModel<uint32_t,\
    \ 26, 1> cnak;\n      /**\n       * @brief TXFNUM field\n       *\n       * TXFNUM\n\
    \       */\n      BitFieldModel<uint32_t, 22, 4> txfnum;\n      /**\n       *\
    \ @brief STALL field\n       *\n       * Stall\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 1> stall;\n      /**\n       * @brief EPTYP field\n       *\n       * EPTYP\n\
    \       */\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      /**\n       * @brief\
    \ NAKSTS field\n       *\n       * NAKSTS\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> naksts;\n      /**\n       * @brief EONUM_DPID field\n       *\n    \
    \   * EONUM/DPID\n       */\n      BitFieldModel<uint32_t, 16, 1> eonum_dpid;\n\
    \      /**\n       * @brief USBAEP field\n       *\n       * USBAEP\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> usbaep;\n      /**\n       * @brief MPSIZ\
    \ field\n       *\n       * MPSIZ\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 11> mpsiz;\n    };\n  };\n\npublic:\n  /**\n   * @brief DIEPCTL2 register\n\
    \   *\n   * OTG device endpoint-2 control\n   *           register\n   */\n  using\
    \ diepctl2 = Diepctl2Reg<BaseAddress + 0x0140>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Diepctl3Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief EPENA field\n     *\n     * EPENA\n  \
    \   */\n    using epena = FieldModel<uint32_t, address, 31, 1>;\n    /**\n   \
    \  * @brief EPDIS field\n     *\n     * EPDIS\n     */\n    using epdis = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    /**\n     * @brief SODDFRM_SD1PID field\n     *\n    \
    \ * SODDFRM\n     */\n    using soddfrm_sd1pid = FieldModel<uint32_t, address,\
    \ 29, 1>;\n    /**\n     * @brief SEVNFRM_SD0PID field\n     *\n     * SD0PID/SEVNFRM\n\
    \     */\n    using sevnfrm_sd0pid = FieldModel<uint32_t, address, 28, 1>;\n \
    \   /**\n     * @brief SNAK field\n     *\n     * SNAK\n     */\n    using snak\
    \ = FieldModel<uint32_t, address, 27, 1>;\n    /**\n     * @brief CNAK field\n\
    \     *\n     * CNAK\n     */\n    using cnak = FieldModel<uint32_t, address,\
    \ 26, 1>;\n    /**\n     * @brief TXFNUM field\n     *\n     * TXFNUM\n     */\n\
    \    using txfnum = FieldModel<uint32_t, address, 22, 4>;\n    /**\n     * @brief\
    \ STALL field\n     *\n     * Stall\n     */\n    using stall = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    /**\n     * @brief EPTYP field\n     *\n     * EPTYP\n\
    \     */\n    using eptyp = FieldModel<uint32_t, address, 18, 2>;\n    /**\n \
    \    * @brief NAKSTS field\n     *\n     * NAKSTS\n     */\n    using naksts =\
    \ FieldModel<uint32_t, address, 17, 1>;\n    /**\n     * @brief EONUM_DPID field\n\
    \     *\n     * EONUM/DPID\n     */\n    using eonum_dpid = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    /**\n     * @brief USBAEP field\n     *\n     * USBAEP\n\
    \     */\n    using usbaep = FieldModel<uint32_t, address, 15, 1>;\n    /**\n\
    \     * @brief MPSIZ field\n     *\n     * MPSIZ\n     */\n    using mpsiz = FieldModel<uint32_t,\
    \ address, 0, 11>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief EPENA field\n       *\n\
    \       * EPENA\n       */\n      BitFieldModel<uint32_t, 31, 1> epena;\n    \
    \  /**\n       * @brief EPDIS field\n       *\n       * EPDIS\n       */\n   \
    \   BitFieldModel<uint32_t, 30, 1> epdis;\n      /**\n       * @brief SODDFRM_SD1PID\
    \ field\n       *\n       * SODDFRM\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 1> soddfrm_sd1pid;\n      /**\n       * @brief SEVNFRM_SD0PID field\n  \
    \     *\n       * SD0PID/SEVNFRM\n       */\n      BitFieldModel<uint32_t, 28,\
    \ 1> sevnfrm_sd0pid;\n      /**\n       * @brief SNAK field\n       *\n      \
    \ * SNAK\n       */\n      BitFieldModel<uint32_t, 27, 1> snak;\n      /**\n \
    \      * @brief CNAK field\n       *\n       * CNAK\n       */\n      BitFieldModel<uint32_t,\
    \ 26, 1> cnak;\n      /**\n       * @brief TXFNUM field\n       *\n       * TXFNUM\n\
    \       */\n      BitFieldModel<uint32_t, 22, 4> txfnum;\n      /**\n       *\
    \ @brief STALL field\n       *\n       * Stall\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 1> stall;\n      /**\n       * @brief EPTYP field\n       *\n       * EPTYP\n\
    \       */\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      /**\n       * @brief\
    \ NAKSTS field\n       *\n       * NAKSTS\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> naksts;\n      /**\n       * @brief EONUM_DPID field\n       *\n    \
    \   * EONUM/DPID\n       */\n      BitFieldModel<uint32_t, 16, 1> eonum_dpid;\n\
    \      /**\n       * @brief USBAEP field\n       *\n       * USBAEP\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> usbaep;\n      /**\n       * @brief MPSIZ\
    \ field\n       *\n       * MPSIZ\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 11> mpsiz;\n    };\n  };\n\npublic:\n  /**\n   * @brief DIEPCTL3 register\n\
    \   *\n   * OTG device endpoint-3 control\n   *           register\n   */\n  using\
    \ diepctl3 = Diepctl3Reg<BaseAddress + 0x0160>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Doepctl0Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief EPENA field\n     *\n     * EPENA\n  \
    \   */\n    using epena = FieldModel<uint32_t, address, 31, 1>;\n    /**\n   \
    \  * @brief EPDIS field\n     *\n     * EPDIS\n     */\n    using epdis = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    /**\n     * @brief SNAK field\n     *\n     * SNAK\n \
    \    */\n    using snak = FieldModel<uint32_t, address, 27, 1>;\n    /**\n   \
    \  * @brief CNAK field\n     *\n     * CNAK\n     */\n    using cnak = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    /**\n     * @brief STALL field\n     *\n     * Stall\n\
    \     */\n    using stall = FieldModel<uint32_t, address, 21, 1>;\n    /**\n \
    \    * @brief SNPM field\n     *\n     * SNPM\n     */\n    using snpm = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief EPTYP field\n     *\n     * EPTYP\n\
    \     */\n    using eptyp = FieldModel<uint32_t, address, 18, 2>;\n    /**\n \
    \    * @brief NAKSTS field\n     *\n     * NAKSTS\n     */\n    using naksts =\
    \ FieldModel<uint32_t, address, 17, 1>;\n    /**\n     * @brief USBAEP field\n\
    \     *\n     * USBAEP\n     */\n    using usbaep = FieldModel<uint32_t, address,\
    \ 15, 1>;\n    /**\n     * @brief MPSIZ field\n     *\n     * MPSIZ\n     */\n\
    \    using mpsiz = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ EPENA field\n       *\n       * EPENA\n       */\n      BitFieldModel<uint32_t,\
    \ 31, 1> epena;\n      /**\n       * @brief EPDIS field\n       *\n       * EPDIS\n\
    \       */\n      BitFieldModel<uint32_t, 30, 1> epdis;\n      /**\n       * @brief\
    \ SNAK field\n       *\n       * SNAK\n       */\n      BitFieldModel<uint32_t,\
    \ 27, 1> snak;\n      /**\n       * @brief CNAK field\n       *\n       * CNAK\n\
    \       */\n      BitFieldModel<uint32_t, 26, 1> cnak;\n      /**\n       * @brief\
    \ STALL field\n       *\n       * Stall\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 1> stall;\n      /**\n       * @brief SNPM field\n       *\n       * SNPM\n\
    \       */\n      BitFieldModel<uint32_t, 20, 1> snpm;\n      /**\n       * @brief\
    \ EPTYP field\n       *\n       * EPTYP\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      /**\n       * @brief NAKSTS field\n       *\n       * NAKSTS\n\
    \       */\n      BitFieldModel<uint32_t, 17, 1> naksts;\n      /**\n       *\
    \ @brief USBAEP field\n       *\n       * USBAEP\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> usbaep;\n      /**\n       * @brief MPSIZ field\n       *\n       * MPSIZ\n\
    \       */\n      BitFieldModel<uint32_t, 0, 2> mpsiz;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief DOEPCTL0 register\n   *\n   * device endpoint-0 control\n\
    \   *           register\n   */\n  using doepctl0 = Doepctl0Reg<BaseAddress +\
    \ 0x0300>;\n\nprivate:\n  template<unsigned int address>\n  class Doepctl1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ EPENA field\n     *\n     * EPENA\n     */\n    using epena = FieldModel<uint32_t,\
    \ address, 31, 1>;\n    /**\n     * @brief EPDIS field\n     *\n     * EPDIS\n\
    \     */\n    using epdis = FieldModel<uint32_t, address, 30, 1>;\n    /**\n \
    \    * @brief SODDFRM_SD1PID field\n     *\n     * SODDFRM\n     */\n    using\
    \ soddfrm_sd1pid = FieldModel<uint32_t, address, 29, 1>;\n    /**\n     * @brief\
    \ SEVNFRM_SD0PID field\n     *\n     * SD0PID/SEVNFRM\n     */\n    using sevnfrm_sd0pid\
    \ = FieldModel<uint32_t, address, 28, 1>;\n    /**\n     * @brief SNAK field\n\
    \     *\n     * SNAK\n     */\n    using snak = FieldModel<uint32_t, address,\
    \ 27, 1>;\n    /**\n     * @brief CNAK field\n     *\n     * CNAK\n     */\n \
    \   using cnak = FieldModel<uint32_t, address, 26, 1>;\n    /**\n     * @brief\
    \ STALL field\n     *\n     * Stall\n     */\n    using stall = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    /**\n     * @brief SNPM field\n     *\n     * SNPM\n \
    \    */\n    using snpm = FieldModel<uint32_t, address, 20, 1>;\n    /**\n   \
    \  * @brief EPTYP field\n     *\n     * EPTYP\n     */\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    /**\n     * @brief NAKSTS field\n     *\n     * NAKSTS\n\
    \     */\n    using naksts = FieldModel<uint32_t, address, 17, 1>;\n    /**\n\
    \     * @brief EONUM_DPID field\n     *\n     * EONUM/DPID\n     */\n    using\
    \ eonum_dpid = FieldModel<uint32_t, address, 16, 1>;\n    /**\n     * @brief USBAEP\
    \ field\n     *\n     * USBAEP\n     */\n    using usbaep = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief MPSIZ field\n     *\n     * MPSIZ\n\
    \     */\n    using mpsiz = FieldModel<uint32_t, address, 0, 11>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief EPENA field\n       *\n       * EPENA\n       */\n      BitFieldModel<uint32_t,\
    \ 31, 1> epena;\n      /**\n       * @brief EPDIS field\n       *\n       * EPDIS\n\
    \       */\n      BitFieldModel<uint32_t, 30, 1> epdis;\n      /**\n       * @brief\
    \ SODDFRM_SD1PID field\n       *\n       * SODDFRM\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 1> soddfrm_sd1pid;\n      /**\n       * @brief SEVNFRM_SD0PID field\n  \
    \     *\n       * SD0PID/SEVNFRM\n       */\n      BitFieldModel<uint32_t, 28,\
    \ 1> sevnfrm_sd0pid;\n      /**\n       * @brief SNAK field\n       *\n      \
    \ * SNAK\n       */\n      BitFieldModel<uint32_t, 27, 1> snak;\n      /**\n \
    \      * @brief CNAK field\n       *\n       * CNAK\n       */\n      BitFieldModel<uint32_t,\
    \ 26, 1> cnak;\n      /**\n       * @brief STALL field\n       *\n       * Stall\n\
    \       */\n      BitFieldModel<uint32_t, 21, 1> stall;\n      /**\n       * @brief\
    \ SNPM field\n       *\n       * SNPM\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 1> snpm;\n      /**\n       * @brief EPTYP field\n       *\n       * EPTYP\n\
    \       */\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      /**\n       * @brief\
    \ NAKSTS field\n       *\n       * NAKSTS\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> naksts;\n      /**\n       * @brief EONUM_DPID field\n       *\n    \
    \   * EONUM/DPID\n       */\n      BitFieldModel<uint32_t, 16, 1> eonum_dpid;\n\
    \      /**\n       * @brief USBAEP field\n       *\n       * USBAEP\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> usbaep;\n      /**\n       * @brief MPSIZ\
    \ field\n       *\n       * MPSIZ\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 11> mpsiz;\n    };\n  };\n\npublic:\n  /**\n   * @brief DOEPCTL1 register\n\
    \   *\n   * device endpoint-1 control\n   *           register\n   */\n  using\
    \ doepctl1 = Doepctl1Reg<BaseAddress + 0x0320>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Doepctl2Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief EPENA field\n     *\n     * EPENA\n  \
    \   */\n    using epena = FieldModel<uint32_t, address, 31, 1>;\n    /**\n   \
    \  * @brief EPDIS field\n     *\n     * EPDIS\n     */\n    using epdis = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    /**\n     * @brief SODDFRM_SD1PID field\n     *\n    \
    \ * SODDFRM\n     */\n    using soddfrm_sd1pid = FieldModel<uint32_t, address,\
    \ 29, 1>;\n    /**\n     * @brief SEVNFRM_SD0PID field\n     *\n     * SD0PID/SEVNFRM\n\
    \     */\n    using sevnfrm_sd0pid = FieldModel<uint32_t, address, 28, 1>;\n \
    \   /**\n     * @brief SNAK field\n     *\n     * SNAK\n     */\n    using snak\
    \ = FieldModel<uint32_t, address, 27, 1>;\n    /**\n     * @brief CNAK field\n\
    \     *\n     * CNAK\n     */\n    using cnak = FieldModel<uint32_t, address,\
    \ 26, 1>;\n    /**\n     * @brief STALL field\n     *\n     * Stall\n     */\n\
    \    using stall = FieldModel<uint32_t, address, 21, 1>;\n    /**\n     * @brief\
    \ SNPM field\n     *\n     * SNPM\n     */\n    using snpm = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief EPTYP field\n     *\n     * EPTYP\n\
    \     */\n    using eptyp = FieldModel<uint32_t, address, 18, 2>;\n    /**\n \
    \    * @brief NAKSTS field\n     *\n     * NAKSTS\n     */\n    using naksts =\
    \ FieldModel<uint32_t, address, 17, 1>;\n    /**\n     * @brief EONUM_DPID field\n\
    \     *\n     * EONUM/DPID\n     */\n    using eonum_dpid = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    /**\n     * @brief USBAEP field\n     *\n     * USBAEP\n\
    \     */\n    using usbaep = FieldModel<uint32_t, address, 15, 1>;\n    /**\n\
    \     * @brief MPSIZ field\n     *\n     * MPSIZ\n     */\n    using mpsiz = FieldModel<uint32_t,\
    \ address, 0, 11>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief EPENA field\n       *\n\
    \       * EPENA\n       */\n      BitFieldModel<uint32_t, 31, 1> epena;\n    \
    \  /**\n       * @brief EPDIS field\n       *\n       * EPDIS\n       */\n   \
    \   BitFieldModel<uint32_t, 30, 1> epdis;\n      /**\n       * @brief SODDFRM_SD1PID\
    \ field\n       *\n       * SODDFRM\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 1> soddfrm_sd1pid;\n      /**\n       * @brief SEVNFRM_SD0PID field\n  \
    \     *\n       * SD0PID/SEVNFRM\n       */\n      BitFieldModel<uint32_t, 28,\
    \ 1> sevnfrm_sd0pid;\n      /**\n       * @brief SNAK field\n       *\n      \
    \ * SNAK\n       */\n      BitFieldModel<uint32_t, 27, 1> snak;\n      /**\n \
    \      * @brief CNAK field\n       *\n       * CNAK\n       */\n      BitFieldModel<uint32_t,\
    \ 26, 1> cnak;\n      /**\n       * @brief STALL field\n       *\n       * Stall\n\
    \       */\n      BitFieldModel<uint32_t, 21, 1> stall;\n      /**\n       * @brief\
    \ SNPM field\n       *\n       * SNPM\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 1> snpm;\n      /**\n       * @brief EPTYP field\n       *\n       * EPTYP\n\
    \       */\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      /**\n       * @brief\
    \ NAKSTS field\n       *\n       * NAKSTS\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> naksts;\n      /**\n       * @brief EONUM_DPID field\n       *\n    \
    \   * EONUM/DPID\n       */\n      BitFieldModel<uint32_t, 16, 1> eonum_dpid;\n\
    \      /**\n       * @brief USBAEP field\n       *\n       * USBAEP\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> usbaep;\n      /**\n       * @brief MPSIZ\
    \ field\n       *\n       * MPSIZ\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 11> mpsiz;\n    };\n  };\n\npublic:\n  /**\n   * @brief DOEPCTL2 register\n\
    \   *\n   * device endpoint-2 control\n   *           register\n   */\n  using\
    \ doepctl2 = Doepctl2Reg<BaseAddress + 0x0340>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Doepctl3Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief EPENA field\n     *\n     * EPENA\n  \
    \   */\n    using epena = FieldModel<uint32_t, address, 31, 1>;\n    /**\n   \
    \  * @brief EPDIS field\n     *\n     * EPDIS\n     */\n    using epdis = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    /**\n     * @brief SODDFRM_SD1PID field\n     *\n    \
    \ * SODDFRM\n     */\n    using soddfrm_sd1pid = FieldModel<uint32_t, address,\
    \ 29, 1>;\n    /**\n     * @brief SEVNFRM_SD0PID field\n     *\n     * SD0PID/SEVNFRM\n\
    \     */\n    using sevnfrm_sd0pid = FieldModel<uint32_t, address, 28, 1>;\n \
    \   /**\n     * @brief SNAK field\n     *\n     * SNAK\n     */\n    using snak\
    \ = FieldModel<uint32_t, address, 27, 1>;\n    /**\n     * @brief CNAK field\n\
    \     *\n     * CNAK\n     */\n    using cnak = FieldModel<uint32_t, address,\
    \ 26, 1>;\n    /**\n     * @brief STALL field\n     *\n     * Stall\n     */\n\
    \    using stall = FieldModel<uint32_t, address, 21, 1>;\n    /**\n     * @brief\
    \ SNPM field\n     *\n     * SNPM\n     */\n    using snpm = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief EPTYP field\n     *\n     * EPTYP\n\
    \     */\n    using eptyp = FieldModel<uint32_t, address, 18, 2>;\n    /**\n \
    \    * @brief NAKSTS field\n     *\n     * NAKSTS\n     */\n    using naksts =\
    \ FieldModel<uint32_t, address, 17, 1>;\n    /**\n     * @brief EONUM_DPID field\n\
    \     *\n     * EONUM/DPID\n     */\n    using eonum_dpid = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    /**\n     * @brief USBAEP field\n     *\n     * USBAEP\n\
    \     */\n    using usbaep = FieldModel<uint32_t, address, 15, 1>;\n    /**\n\
    \     * @brief MPSIZ field\n     *\n     * MPSIZ\n     */\n    using mpsiz = FieldModel<uint32_t,\
    \ address, 0, 11>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief EPENA field\n       *\n\
    \       * EPENA\n       */\n      BitFieldModel<uint32_t, 31, 1> epena;\n    \
    \  /**\n       * @brief EPDIS field\n       *\n       * EPDIS\n       */\n   \
    \   BitFieldModel<uint32_t, 30, 1> epdis;\n      /**\n       * @brief SODDFRM_SD1PID\
    \ field\n       *\n       * SODDFRM\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 1> soddfrm_sd1pid;\n      /**\n       * @brief SEVNFRM_SD0PID field\n  \
    \     *\n       * SD0PID/SEVNFRM\n       */\n      BitFieldModel<uint32_t, 28,\
    \ 1> sevnfrm_sd0pid;\n      /**\n       * @brief SNAK field\n       *\n      \
    \ * SNAK\n       */\n      BitFieldModel<uint32_t, 27, 1> snak;\n      /**\n \
    \      * @brief CNAK field\n       *\n       * CNAK\n       */\n      BitFieldModel<uint32_t,\
    \ 26, 1> cnak;\n      /**\n       * @brief STALL field\n       *\n       * Stall\n\
    \       */\n      BitFieldModel<uint32_t, 21, 1> stall;\n      /**\n       * @brief\
    \ SNPM field\n       *\n       * SNPM\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 1> snpm;\n      /**\n       * @brief EPTYP field\n       *\n       * EPTYP\n\
    \       */\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      /**\n       * @brief\
    \ NAKSTS field\n       *\n       * NAKSTS\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> naksts;\n      /**\n       * @brief EONUM_DPID field\n       *\n    \
    \   * EONUM/DPID\n       */\n      BitFieldModel<uint32_t, 16, 1> eonum_dpid;\n\
    \      /**\n       * @brief USBAEP field\n       *\n       * USBAEP\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> usbaep;\n      /**\n       * @brief MPSIZ\
    \ field\n       *\n       * MPSIZ\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 11> mpsiz;\n    };\n  };\n\npublic:\n  /**\n   * @brief DOEPCTL3 register\n\
    \   *\n   * device endpoint-3 control\n   *           register\n   */\n  using\
    \ doepctl3 = Doepctl3Reg<BaseAddress + 0x0360>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Diepint0Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief TXFE field\n     *\n     * TXFE\n    \
    \ */\n    using txfe = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief\
    \ INEPNE field\n     *\n     * INEPNE\n     */\n    using inepne = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief ITTXFE field\n     *\n     * ITTXFE\n\
    \     */\n    using ittxfe = FieldModel<uint32_t, address, 4, 1>;\n    /**\n \
    \    * @brief TOC field\n     *\n     * TOC\n     */\n    using toc = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief EPDISD field\n     *\n     * EPDISD\n\
    \     */\n    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n    /**\n \
    \    * @brief XFRC field\n     *\n     * XFRC\n     */\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief TXFE field\n       *\n\
    \       * TXFE\n       */\n      BitFieldModel<uint32_t, 7, 1> txfe;\n      /**\n\
    \       * @brief INEPNE field\n       *\n       * INEPNE\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> inepne;\n      /**\n       * @brief ITTXFE field\n       *\n       * ITTXFE\n\
    \       */\n      BitFieldModel<uint32_t, 4, 1> ittxfe;\n      /**\n       * @brief\
    \ TOC field\n       *\n       * TOC\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> toc;\n      /**\n       * @brief EPDISD field\n       *\n       * EPDISD\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> epdisd;\n      /**\n       * @brief\
    \ XFRC field\n       *\n       * XFRC\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n    };\n  };\n\npublic:\n  /**\n   * @brief DIEPINT0 register\n\
    \   *\n   * device endpoint-x interrupt\n   *           register\n   */\n  using\
    \ diepint0 = Diepint0Reg<BaseAddress + 0x0108>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Diepint1Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief TXFE field\n     *\n     * TXFE\n    \
    \ */\n    using txfe = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief\
    \ INEPNE field\n     *\n     * INEPNE\n     */\n    using inepne = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief ITTXFE field\n     *\n     * ITTXFE\n\
    \     */\n    using ittxfe = FieldModel<uint32_t, address, 4, 1>;\n    /**\n \
    \    * @brief TOC field\n     *\n     * TOC\n     */\n    using toc = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief EPDISD field\n     *\n     * EPDISD\n\
    \     */\n    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n    /**\n \
    \    * @brief XFRC field\n     *\n     * XFRC\n     */\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief TXFE field\n       *\n\
    \       * TXFE\n       */\n      BitFieldModel<uint32_t, 7, 1> txfe;\n      /**\n\
    \       * @brief INEPNE field\n       *\n       * INEPNE\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> inepne;\n      /**\n       * @brief ITTXFE field\n       *\n       * ITTXFE\n\
    \       */\n      BitFieldModel<uint32_t, 4, 1> ittxfe;\n      /**\n       * @brief\
    \ TOC field\n       *\n       * TOC\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> toc;\n      /**\n       * @brief EPDISD field\n       *\n       * EPDISD\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> epdisd;\n      /**\n       * @brief\
    \ XFRC field\n       *\n       * XFRC\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n    };\n  };\n\npublic:\n  /**\n   * @brief DIEPINT1 register\n\
    \   *\n   * device endpoint-1 interrupt\n   *           register\n   */\n  using\
    \ diepint1 = Diepint1Reg<BaseAddress + 0x0128>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Diepint2Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief TXFE field\n     *\n     * TXFE\n    \
    \ */\n    using txfe = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief\
    \ INEPNE field\n     *\n     * INEPNE\n     */\n    using inepne = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief ITTXFE field\n     *\n     * ITTXFE\n\
    \     */\n    using ittxfe = FieldModel<uint32_t, address, 4, 1>;\n    /**\n \
    \    * @brief TOC field\n     *\n     * TOC\n     */\n    using toc = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief EPDISD field\n     *\n     * EPDISD\n\
    \     */\n    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n    /**\n \
    \    * @brief XFRC field\n     *\n     * XFRC\n     */\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief TXFE field\n       *\n\
    \       * TXFE\n       */\n      BitFieldModel<uint32_t, 7, 1> txfe;\n      /**\n\
    \       * @brief INEPNE field\n       *\n       * INEPNE\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> inepne;\n      /**\n       * @brief ITTXFE field\n       *\n       * ITTXFE\n\
    \       */\n      BitFieldModel<uint32_t, 4, 1> ittxfe;\n      /**\n       * @brief\
    \ TOC field\n       *\n       * TOC\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> toc;\n      /**\n       * @brief EPDISD field\n       *\n       * EPDISD\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> epdisd;\n      /**\n       * @brief\
    \ XFRC field\n       *\n       * XFRC\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n    };\n  };\n\npublic:\n  /**\n   * @brief DIEPINT2 register\n\
    \   *\n   * device endpoint-2 interrupt\n   *           register\n   */\n  using\
    \ diepint2 = Diepint2Reg<BaseAddress + 0x0148>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Diepint3Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief TXFE field\n     *\n     * TXFE\n    \
    \ */\n    using txfe = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief\
    \ INEPNE field\n     *\n     * INEPNE\n     */\n    using inepne = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief ITTXFE field\n     *\n     * ITTXFE\n\
    \     */\n    using ittxfe = FieldModel<uint32_t, address, 4, 1>;\n    /**\n \
    \    * @brief TOC field\n     *\n     * TOC\n     */\n    using toc = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief EPDISD field\n     *\n     * EPDISD\n\
    \     */\n    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n    /**\n \
    \    * @brief XFRC field\n     *\n     * XFRC\n     */\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief TXFE field\n       *\n\
    \       * TXFE\n       */\n      BitFieldModel<uint32_t, 7, 1> txfe;\n      /**\n\
    \       * @brief INEPNE field\n       *\n       * INEPNE\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> inepne;\n      /**\n       * @brief ITTXFE field\n       *\n       * ITTXFE\n\
    \       */\n      BitFieldModel<uint32_t, 4, 1> ittxfe;\n      /**\n       * @brief\
    \ TOC field\n       *\n       * TOC\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> toc;\n      /**\n       * @brief EPDISD field\n       *\n       * EPDISD\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> epdisd;\n      /**\n       * @brief\
    \ XFRC field\n       *\n       * XFRC\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n    };\n  };\n\npublic:\n  /**\n   * @brief DIEPINT3 register\n\
    \   *\n   * device endpoint-3 interrupt\n   *           register\n   */\n  using\
    \ diepint3 = Diepint3Reg<BaseAddress + 0x0168>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Doepint0Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief B2BSTUP field\n     *\n     * B2BSTUP\n\
    \     */\n    using b2bstup = FieldModel<uint32_t, address, 6, 1>;\n    /**\n\
    \     * @brief OTEPDIS field\n     *\n     * OTEPDIS\n     */\n    using otepdis\
    \ = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief STUP field\n\
    \     *\n     * STUP\n     */\n    using stup = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief EPDISD field\n     *\n     * EPDISD\n     */\n\
    \    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief\
    \ XFRC field\n     *\n     * XFRC\n     */\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief B2BSTUP field\n       *\n\
    \       * B2BSTUP\n       */\n      BitFieldModel<uint32_t, 6, 1> b2bstup;\n \
    \     /**\n       * @brief OTEPDIS field\n       *\n       * OTEPDIS\n       */\n\
    \      BitFieldModel<uint32_t, 4, 1> otepdis;\n      /**\n       * @brief STUP\
    \ field\n       *\n       * STUP\n       */\n      BitFieldModel<uint32_t, 3,\
    \ 1> stup;\n      /**\n       * @brief EPDISD field\n       *\n       * EPDISD\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> epdisd;\n      /**\n       * @brief\
    \ XFRC field\n       *\n       * XFRC\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n    };\n  };\n\npublic:\n  /**\n   * @brief DOEPINT0 register\n\
    \   *\n   * device endpoint-0 interrupt\n   *           register\n   */\n  using\
    \ doepint0 = Doepint0Reg<BaseAddress + 0x0308>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Doepint1Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief B2BSTUP field\n     *\n     * B2BSTUP\n\
    \     */\n    using b2bstup = FieldModel<uint32_t, address, 6, 1>;\n    /**\n\
    \     * @brief OTEPDIS field\n     *\n     * OTEPDIS\n     */\n    using otepdis\
    \ = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief STUP field\n\
    \     *\n     * STUP\n     */\n    using stup = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief EPDISD field\n     *\n     * EPDISD\n     */\n\
    \    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief\
    \ XFRC field\n     *\n     * XFRC\n     */\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief B2BSTUP field\n       *\n\
    \       * B2BSTUP\n       */\n      BitFieldModel<uint32_t, 6, 1> b2bstup;\n \
    \     /**\n       * @brief OTEPDIS field\n       *\n       * OTEPDIS\n       */\n\
    \      BitFieldModel<uint32_t, 4, 1> otepdis;\n      /**\n       * @brief STUP\
    \ field\n       *\n       * STUP\n       */\n      BitFieldModel<uint32_t, 3,\
    \ 1> stup;\n      /**\n       * @brief EPDISD field\n       *\n       * EPDISD\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> epdisd;\n      /**\n       * @brief\
    \ XFRC field\n       *\n       * XFRC\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n    };\n  };\n\npublic:\n  /**\n   * @brief DOEPINT1 register\n\
    \   *\n   * device endpoint-1 interrupt\n   *           register\n   */\n  using\
    \ doepint1 = Doepint1Reg<BaseAddress + 0x0328>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Doepint2Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief B2BSTUP field\n     *\n     * B2BSTUP\n\
    \     */\n    using b2bstup = FieldModel<uint32_t, address, 6, 1>;\n    /**\n\
    \     * @brief OTEPDIS field\n     *\n     * OTEPDIS\n     */\n    using otepdis\
    \ = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief STUP field\n\
    \     *\n     * STUP\n     */\n    using stup = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief EPDISD field\n     *\n     * EPDISD\n     */\n\
    \    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief\
    \ XFRC field\n     *\n     * XFRC\n     */\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief B2BSTUP field\n       *\n\
    \       * B2BSTUP\n       */\n      BitFieldModel<uint32_t, 6, 1> b2bstup;\n \
    \     /**\n       * @brief OTEPDIS field\n       *\n       * OTEPDIS\n       */\n\
    \      BitFieldModel<uint32_t, 4, 1> otepdis;\n      /**\n       * @brief STUP\
    \ field\n       *\n       * STUP\n       */\n      BitFieldModel<uint32_t, 3,\
    \ 1> stup;\n      /**\n       * @brief EPDISD field\n       *\n       * EPDISD\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> epdisd;\n      /**\n       * @brief\
    \ XFRC field\n       *\n       * XFRC\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n    };\n  };\n\npublic:\n  /**\n   * @brief DOEPINT2 register\n\
    \   *\n   * device endpoint-2 interrupt\n   *           register\n   */\n  using\
    \ doepint2 = Doepint2Reg<BaseAddress + 0x0348>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Doepint3Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief B2BSTUP field\n     *\n     * B2BSTUP\n\
    \     */\n    using b2bstup = FieldModel<uint32_t, address, 6, 1>;\n    /**\n\
    \     * @brief OTEPDIS field\n     *\n     * OTEPDIS\n     */\n    using otepdis\
    \ = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief STUP field\n\
    \     *\n     * STUP\n     */\n    using stup = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief EPDISD field\n     *\n     * EPDISD\n     */\n\
    \    using epdisd = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief\
    \ XFRC field\n     *\n     * XFRC\n     */\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief B2BSTUP field\n       *\n\
    \       * B2BSTUP\n       */\n      BitFieldModel<uint32_t, 6, 1> b2bstup;\n \
    \     /**\n       * @brief OTEPDIS field\n       *\n       * OTEPDIS\n       */\n\
    \      BitFieldModel<uint32_t, 4, 1> otepdis;\n      /**\n       * @brief STUP\
    \ field\n       *\n       * STUP\n       */\n      BitFieldModel<uint32_t, 3,\
    \ 1> stup;\n      /**\n       * @brief EPDISD field\n       *\n       * EPDISD\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> epdisd;\n      /**\n       * @brief\
    \ XFRC field\n       *\n       * XFRC\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n    };\n  };\n\npublic:\n  /**\n   * @brief DOEPINT3 register\n\
    \   *\n   * device endpoint-3 interrupt\n   *           register\n   */\n  using\
    \ doepint3 = Doepint3Reg<BaseAddress + 0x0368>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Dieptsiz0Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief PKTCNT field\n     *\n     * Packet count\n\
    \     */\n    using pktcnt = FieldModel<uint32_t, address, 19, 2>;\n    /**\n\
    \     * @brief XFRSIZ field\n     *\n     * Transfer size\n     */\n    using\
    \ xfrsiz = FieldModel<uint32_t, address, 0, 7>;\n\n  public:\n    /**\n     *\
    \ @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ PKTCNT field\n       *\n       * Packet count\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 2> pktcnt;\n      /**\n       * @brief XFRSIZ field\n       *\n       *\
    \ Transfer size\n       */\n      BitFieldModel<uint32_t, 0, 7> xfrsiz;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief DIEPTSIZ0 register\n   *\n   * device endpoint-0\
    \ transfer size\n   *           register\n   */\n  using dieptsiz0 = Dieptsiz0Reg<BaseAddress\
    \ + 0x0110>;\n\nprivate:\n  template<unsigned int address>\n  class Doeptsiz0Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ STUPCNT field\n     *\n     * SETUP packet count\n     */\n    using stupcnt\
    \ = FieldModel<uint32_t, address, 29, 2>;\n    /**\n     * @brief PKTCNT field\n\
    \     *\n     * Packet count\n     */\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief XFRSIZ field\n     *\n     * Transfer\
    \ size\n     */\n    using xfrsiz = FieldModel<uint32_t, address, 0, 7>;\n\n \
    \ public:\n    /**\n     * @brief Register union\n     *\n     * Can be used to\
    \ create a local register variable for easy bit manipulation.\n     * Useful for\
    \ read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief STUPCNT field\n       *\n       * SETUP packet\
    \ count\n       */\n      BitFieldModel<uint32_t, 29, 2> stupcnt;\n      /**\n\
    \       * @brief PKTCNT field\n       *\n       * Packet count\n       */\n  \
    \    BitFieldModel<uint32_t, 19, 1> pktcnt;\n      /**\n       * @brief XFRSIZ\
    \ field\n       *\n       * Transfer size\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 7> xfrsiz;\n    };\n  };\n\npublic:\n  /**\n   * @brief DOEPTSIZ0 register\n\
    \   *\n   * device OUT endpoint-0 transfer size\n   *           register\n   */\n\
    \  using doeptsiz0 = Doeptsiz0Reg<BaseAddress + 0x0310>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Dieptsiz1Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief MCNT field\n     *\n     * Multi count\n\
    \     */\n    using mcnt = FieldModel<uint32_t, address, 29, 2>;\n    /**\n  \
    \   * @brief PKTCNT field\n     *\n     * Packet count\n     */\n    using pktcnt\
    \ = FieldModel<uint32_t, address, 19, 10>;\n    /**\n     * @brief XFRSIZ field\n\
    \     *\n     * Transfer size\n     */\n    using xfrsiz = FieldModel<uint32_t,\
    \ address, 0, 19>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief MCNT field\n       *\n\
    \       * Multi count\n       */\n      BitFieldModel<uint32_t, 29, 2> mcnt;\n\
    \      /**\n       * @brief PKTCNT field\n       *\n       * Packet count\n  \
    \     */\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      /**\n       * @brief\
    \ XFRSIZ field\n       *\n       * Transfer size\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n    };\n  };\n\npublic:\n  /**\n   * @brief DIEPTSIZ1 register\n\
    \   *\n   * device endpoint-1 transfer size\n   *           register\n   */\n\
    \  using dieptsiz1 = Dieptsiz1Reg<BaseAddress + 0x0130>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Dieptsiz2Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief MCNT field\n     *\n     * Multi count\n\
    \     */\n    using mcnt = FieldModel<uint32_t, address, 29, 2>;\n    /**\n  \
    \   * @brief PKTCNT field\n     *\n     * Packet count\n     */\n    using pktcnt\
    \ = FieldModel<uint32_t, address, 19, 10>;\n    /**\n     * @brief XFRSIZ field\n\
    \     *\n     * Transfer size\n     */\n    using xfrsiz = FieldModel<uint32_t,\
    \ address, 0, 19>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief MCNT field\n       *\n\
    \       * Multi count\n       */\n      BitFieldModel<uint32_t, 29, 2> mcnt;\n\
    \      /**\n       * @brief PKTCNT field\n       *\n       * Packet count\n  \
    \     */\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      /**\n       * @brief\
    \ XFRSIZ field\n       *\n       * Transfer size\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n    };\n  };\n\npublic:\n  /**\n   * @brief DIEPTSIZ2 register\n\
    \   *\n   * device endpoint-2 transfer size\n   *           register\n   */\n\
    \  using dieptsiz2 = Dieptsiz2Reg<BaseAddress + 0x0150>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Dieptsiz3Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief MCNT field\n     *\n     * Multi count\n\
    \     */\n    using mcnt = FieldModel<uint32_t, address, 29, 2>;\n    /**\n  \
    \   * @brief PKTCNT field\n     *\n     * Packet count\n     */\n    using pktcnt\
    \ = FieldModel<uint32_t, address, 19, 10>;\n    /**\n     * @brief XFRSIZ field\n\
    \     *\n     * Transfer size\n     */\n    using xfrsiz = FieldModel<uint32_t,\
    \ address, 0, 19>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief MCNT field\n       *\n\
    \       * Multi count\n       */\n      BitFieldModel<uint32_t, 29, 2> mcnt;\n\
    \      /**\n       * @brief PKTCNT field\n       *\n       * Packet count\n  \
    \     */\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      /**\n       * @brief\
    \ XFRSIZ field\n       *\n       * Transfer size\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n    };\n  };\n\npublic:\n  /**\n   * @brief DIEPTSIZ3 register\n\
    \   *\n   * device endpoint-3 transfer size\n   *           register\n   */\n\
    \  using dieptsiz3 = Dieptsiz3Reg<BaseAddress + 0x0170>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Dtxfsts0Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief INEPTFSAV field\n     *\n     * IN endpoint\
    \ TxFIFO space\n     *               available\n     */\n    using ineptfsav =\
    \ FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register\
    \ union\n     *\n     * Can be used to create a local register variable for easy\
    \ bit manipulation.\n     * Useful for read-modify-write operations.\n     */\n\
    \    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief INEPTFSAV\
    \ field\n       *\n       * IN endpoint TxFIFO space\n       *               available\n\
    \       */\n      BitFieldModel<uint32_t, 0, 16> ineptfsav;\n    };\n  };\n\n\
    public:\n  /**\n   * @brief DTXFSTS0 register\n   *\n   * OTG_FS device IN endpoint\
    \ transmit FIFO\n   *           status register\n   */\n  using dtxfsts0 = Dtxfsts0Reg<BaseAddress\
    \ + 0x0118>;\n\nprivate:\n  template<unsigned int address>\n  class Dtxfsts1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ INEPTFSAV field\n     *\n     * IN endpoint TxFIFO space\n     *           \
    \    available\n     */\n    using ineptfsav = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief INEPTFSAV field\n       *\n\
    \       * IN endpoint TxFIFO space\n       *               available\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ineptfsav;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief DTXFSTS1 register\n   *\n   * OTG_FS device IN endpoint transmit\
    \ FIFO\n   *           status register\n   */\n  using dtxfsts1 = Dtxfsts1Reg<BaseAddress\
    \ + 0x0138>;\n\nprivate:\n  template<unsigned int address>\n  class Dtxfsts2Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ INEPTFSAV field\n     *\n     * IN endpoint TxFIFO space\n     *           \
    \    available\n     */\n    using ineptfsav = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief INEPTFSAV field\n       *\n\
    \       * IN endpoint TxFIFO space\n       *               available\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ineptfsav;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief DTXFSTS2 register\n   *\n   * OTG_FS device IN endpoint transmit\
    \ FIFO\n   *           status register\n   */\n  using dtxfsts2 = Dtxfsts2Reg<BaseAddress\
    \ + 0x0158>;\n\nprivate:\n  template<unsigned int address>\n  class Dtxfsts3Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ INEPTFSAV field\n     *\n     * IN endpoint TxFIFO space\n     *           \
    \    available\n     */\n    using ineptfsav = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief INEPTFSAV field\n       *\n\
    \       * IN endpoint TxFIFO space\n       *               available\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ineptfsav;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief DTXFSTS3 register\n   *\n   * OTG_FS device IN endpoint transmit\
    \ FIFO\n   *           status register\n   */\n  using dtxfsts3 = Dtxfsts3Reg<BaseAddress\
    \ + 0x0178>;\n\nprivate:\n  template<unsigned int address>\n  class Doeptsiz1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ RXDPID_STUPCNT field\n     *\n     * Received data PID/SETUP packet\n     *\
    \               count\n     */\n    using rxdpid_stupcnt = FieldModel<uint32_t,\
    \ address, 29, 2>;\n    /**\n     * @brief PKTCNT field\n     *\n     * Packet\
    \ count\n     */\n    using pktcnt = FieldModel<uint32_t, address, 19, 10>;\n\
    \    /**\n     * @brief XFRSIZ field\n     *\n     * Transfer size\n     */\n\
    \    using xfrsiz = FieldModel<uint32_t, address, 0, 19>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ RXDPID_STUPCNT field\n       *\n       * Received data PID/SETUP packet\n  \
    \     *               count\n       */\n      BitFieldModel<uint32_t, 29, 2> rxdpid_stupcnt;\n\
    \      /**\n       * @brief PKTCNT field\n       *\n       * Packet count\n  \
    \     */\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      /**\n       * @brief\
    \ XFRSIZ field\n       *\n       * Transfer size\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n    };\n  };\n\npublic:\n  /**\n   * @brief DOEPTSIZ1 register\n\
    \   *\n   * device OUT endpoint-1 transfer size\n   *           register\n   */\n\
    \  using doeptsiz1 = Doeptsiz1Reg<BaseAddress + 0x0330>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Doeptsiz2Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief RXDPID_STUPCNT field\n     *\n     * Received\
    \ data PID/SETUP packet\n     *               count\n     */\n    using rxdpid_stupcnt\
    \ = FieldModel<uint32_t, address, 29, 2>;\n    /**\n     * @brief PKTCNT field\n\
    \     *\n     * Packet count\n     */\n    using pktcnt = FieldModel<uint32_t,\
    \ address, 19, 10>;\n    /**\n     * @brief XFRSIZ field\n     *\n     * Transfer\
    \ size\n     */\n    using xfrsiz = FieldModel<uint32_t, address, 0, 19>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief RXDPID_STUPCNT field\n       *\n       *\
    \ Received data PID/SETUP packet\n       *               count\n       */\n  \
    \    BitFieldModel<uint32_t, 29, 2> rxdpid_stupcnt;\n      /**\n       * @brief\
    \ PKTCNT field\n       *\n       * Packet count\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 10> pktcnt;\n      /**\n       * @brief XFRSIZ field\n       *\n       *\
    \ Transfer size\n       */\n      BitFieldModel<uint32_t, 0, 19> xfrsiz;\n   \
    \ };\n  };\n\npublic:\n  /**\n   * @brief DOEPTSIZ2 register\n   *\n   * device\
    \ OUT endpoint-2 transfer size\n   *           register\n   */\n  using doeptsiz2\
    \ = Doeptsiz2Reg<BaseAddress + 0x0350>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Doeptsiz3Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief RXDPID_STUPCNT field\n     *\n     * Received data PID/SETUP\
    \ packet\n     *               count\n     */\n    using rxdpid_stupcnt = FieldModel<uint32_t,\
    \ address, 29, 2>;\n    /**\n     * @brief PKTCNT field\n     *\n     * Packet\
    \ count\n     */\n    using pktcnt = FieldModel<uint32_t, address, 19, 10>;\n\
    \    /**\n     * @brief XFRSIZ field\n     *\n     * Transfer size\n     */\n\
    \    using xfrsiz = FieldModel<uint32_t, address, 0, 19>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ RXDPID_STUPCNT field\n       *\n       * Received data PID/SETUP packet\n  \
    \     *               count\n       */\n      BitFieldModel<uint32_t, 29, 2> rxdpid_stupcnt;\n\
    \      /**\n       * @brief PKTCNT field\n       *\n       * Packet count\n  \
    \     */\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      /**\n       * @brief\
    \ XFRSIZ field\n       *\n       * Transfer size\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n    };\n  };\n\npublic:\n  /**\n   * @brief DOEPTSIZ3 register\n\
    \   *\n   * device OUT endpoint-3 transfer size\n   *           register\n   */\n\
    \  using doeptsiz3 = Doeptsiz3Reg<BaseAddress + 0x0370>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class DiepctlxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    /**\n     * @brief EPENA field\n \
    \    *\n     * EPENA\n     */\n    using epena = FieldModel<uint32_t, address,\
    \ 31, 1, bankOffset>;\n    /**\n     * @brief EPDIS field\n     *\n     * EPDIS\n\
    \     */\n    using epdis = FieldModel<uint32_t, address, 30, 1, bankOffset>;\n\
    \    /**\n     * @brief SODDFRM_SD1PID field\n     *\n     * SODDFRM/SD1PID\n\
    \     */\n    using soddfrm_sd1pid = FieldModel<uint32_t, address, 29, 1, bankOffset>;\n\
    \    /**\n     * @brief SEVNFRM_SD0PID field\n     *\n     * SD0PID/SEVNFRM\n\
    \     */\n    using sevnfrm_sd0pid = FieldModel<uint32_t, address, 28, 1, bankOffset>;\n\
    \    /**\n     * @brief SNAK field\n     *\n     * SNAK\n     */\n    using snak\
    \ = FieldModel<uint32_t, address, 27, 1, bankOffset>;\n    /**\n     * @brief\
    \ CNAK field\n     *\n     * CNAK\n     */\n    using cnak = FieldModel<uint32_t,\
    \ address, 26, 1, bankOffset>;\n    /**\n     * @brief TXFNUM field\n     *\n\
    \     * TXFNUM\n     */\n    using txfnum = FieldModel<uint32_t, address, 22,\
    \ 4, bankOffset>;\n    /**\n     * @brief STALL field\n     *\n     * Stall\n\
    \     */\n    using stall = FieldModel<uint32_t, address, 21, 1, bankOffset>;\n\
    \    /**\n     * @brief EPTYP field\n     *\n     * EPTYP\n     */\n    using\
    \ eptyp = FieldModel<uint32_t, address, 18, 2, bankOffset>;\n    /**\n     * @brief\
    \ NAKSTS field\n     *\n     * NAKSTS\n     */\n    using naksts = FieldModel<uint32_t,\
    \ address, 17, 1, bankOffset>;\n    /**\n     * @brief EONUM_DPID field\n    \
    \ *\n     * EONUM/DPID\n     */\n    using eonum_dpid = FieldModel<uint32_t, address,\
    \ 16, 1, bankOffset>;\n    /**\n     * @brief USBAEP field\n     *\n     * USBAEP\n\
    \     */\n    using usbaep = FieldModel<uint32_t, address, 15, 1, bankOffset>;\n\
    \    /**\n     * @brief MPSIZ field\n     *\n     * MPSIZ\n     */\n    using\
    \ mpsiz = FieldModel<uint32_t, address, 0, 11, bankOffset>;\n\n  public:\n   \
    \ union reg\n    {\n      uint32_t value;\n      /**\n       * @brief EPENA field\n\
    \       *\n       * EPENA\n       */\n      BitFieldModel<uint32_t, 31, 1> epena;\n\
    \      /**\n       * @brief EPDIS field\n       *\n       * EPDIS\n       */\n\
    \      BitFieldModel<uint32_t, 30, 1> epdis;\n      /**\n       * @brief SODDFRM_SD1PID\
    \ field\n       *\n       * SODDFRM/SD1PID\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 1> soddfrm_sd1pid;\n      /**\n       * @brief SEVNFRM_SD0PID field\n  \
    \     *\n       * SD0PID/SEVNFRM\n       */\n      BitFieldModel<uint32_t, 28,\
    \ 1> sevnfrm_sd0pid;\n      /**\n       * @brief SNAK field\n       *\n      \
    \ * SNAK\n       */\n      BitFieldModel<uint32_t, 27, 1> snak;\n      /**\n \
    \      * @brief CNAK field\n       *\n       * CNAK\n       */\n      BitFieldModel<uint32_t,\
    \ 26, 1> cnak;\n      /**\n       * @brief TXFNUM field\n       *\n       * TXFNUM\n\
    \       */\n      BitFieldModel<uint32_t, 22, 4> txfnum;\n      /**\n       *\
    \ @brief STALL field\n       *\n       * Stall\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 1> stall;\n      /**\n       * @brief EPTYP field\n       *\n       * EPTYP\n\
    \       */\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      /**\n       * @brief\
    \ NAKSTS field\n       *\n       * NAKSTS\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> naksts;\n      /**\n       * @brief EONUM_DPID field\n       *\n    \
    \   * EONUM/DPID\n       */\n      BitFieldModel<uint32_t, 16, 1> eonum_dpid;\n\
    \      /**\n       * @brief USBAEP field\n       *\n       * USBAEP\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> usbaep;\n      /**\n       * @brief MPSIZ\
    \ field\n       *\n       * MPSIZ\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 11> mpsiz;\n    };\n  };\n\npublic:\n  /**\n   * @brief DIEPCTLX register bank\n\
    \   *\n   * OTG device endpoint-1 control\n   *           register\n   */\n  using\
    \ diepctlx = DiepctlxBankReg<BaseAddress + 0x0120, 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class DoepctlxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    /**\n     * @brief EPENA field\n \
    \    *\n     * EPENA\n     */\n    using epena = FieldModel<uint32_t, address,\
    \ 31, 1, bankOffset>;\n    /**\n     * @brief EPDIS field\n     *\n     * EPDIS\n\
    \     */\n    using epdis = FieldModel<uint32_t, address, 30, 1, bankOffset>;\n\
    \    /**\n     * @brief SODDFRM_SD1PID field\n     *\n     * SODDFRM\n     */\n\
    \    using soddfrm_sd1pid = FieldModel<uint32_t, address, 29, 1, bankOffset>;\n\
    \    /**\n     * @brief SEVNFRM_SD0PID field\n     *\n     * SD0PID/SEVNFRM\n\
    \     */\n    using sevnfrm_sd0pid = FieldModel<uint32_t, address, 28, 1, bankOffset>;\n\
    \    /**\n     * @brief SNAK field\n     *\n     * SNAK\n     */\n    using snak\
    \ = FieldModel<uint32_t, address, 27, 1, bankOffset>;\n    /**\n     * @brief\
    \ CNAK field\n     *\n     * CNAK\n     */\n    using cnak = FieldModel<uint32_t,\
    \ address, 26, 1, bankOffset>;\n    /**\n     * @brief STALL field\n     *\n \
    \    * Stall\n     */\n    using stall = FieldModel<uint32_t, address, 21, 1,\
    \ bankOffset>;\n    /**\n     * @brief SNPM field\n     *\n     * SNPM\n     */\n\
    \    using snpm = FieldModel<uint32_t, address, 20, 1, bankOffset>;\n    /**\n\
    \     * @brief EPTYP field\n     *\n     * EPTYP\n     */\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2, bankOffset>;\n    /**\n     * @brief NAKSTS field\n     *\n\
    \     * NAKSTS\n     */\n    using naksts = FieldModel<uint32_t, address, 17,\
    \ 1, bankOffset>;\n    /**\n     * @brief EONUM_DPID field\n     *\n     * EONUM/DPID\n\
    \     */\n    using eonum_dpid = FieldModel<uint32_t, address, 16, 1, bankOffset>;\n\
    \    /**\n     * @brief USBAEP field\n     *\n     * USBAEP\n     */\n    using\
    \ usbaep = FieldModel<uint32_t, address, 15, 1, bankOffset>;\n    /**\n     *\
    \ @brief MPSIZ field\n     *\n     * MPSIZ\n     */\n    using mpsiz = FieldModel<uint32_t,\
    \ address, 0, 11, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief EPENA field\n       *\n       * EPENA\n \
    \      */\n      BitFieldModel<uint32_t, 31, 1> epena;\n      /**\n       * @brief\
    \ EPDIS field\n       *\n       * EPDIS\n       */\n      BitFieldModel<uint32_t,\
    \ 30, 1> epdis;\n      /**\n       * @brief SODDFRM_SD1PID field\n       *\n \
    \      * SODDFRM\n       */\n      BitFieldModel<uint32_t, 29, 1> soddfrm_sd1pid;\n\
    \      /**\n       * @brief SEVNFRM_SD0PID field\n       *\n       * SD0PID/SEVNFRM\n\
    \       */\n      BitFieldModel<uint32_t, 28, 1> sevnfrm_sd0pid;\n      /**\n\
    \       * @brief SNAK field\n       *\n       * SNAK\n       */\n      BitFieldModel<uint32_t,\
    \ 27, 1> snak;\n      /**\n       * @brief CNAK field\n       *\n       * CNAK\n\
    \       */\n      BitFieldModel<uint32_t, 26, 1> cnak;\n      /**\n       * @brief\
    \ STALL field\n       *\n       * Stall\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 1> stall;\n      /**\n       * @brief SNPM field\n       *\n       * SNPM\n\
    \       */\n      BitFieldModel<uint32_t, 20, 1> snpm;\n      /**\n       * @brief\
    \ EPTYP field\n       *\n       * EPTYP\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 2> eptyp;\n      /**\n       * @brief NAKSTS field\n       *\n       * NAKSTS\n\
    \       */\n      BitFieldModel<uint32_t, 17, 1> naksts;\n      /**\n       *\
    \ @brief EONUM_DPID field\n       *\n       * EONUM/DPID\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> eonum_dpid;\n      /**\n       * @brief USBAEP field\n       *\n    \
    \   * USBAEP\n       */\n      BitFieldModel<uint32_t, 15, 1> usbaep;\n      /**\n\
    \       * @brief MPSIZ field\n       *\n       * MPSIZ\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 11> mpsiz;\n    };\n  };\n\npublic:\n  /**\n   * @brief DOEPCTLX register\
    \ bank\n   *\n   * device endpoint-1 control\n   *           register\n   */\n\
    \  using doepctlx = DoepctlxBankReg<BaseAddress + 0x0320, 0x0020>;\n\nprivate:\n\
    \  template<unsigned int address, unsigned int bankOffset>\n  class DiepintxBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    /**\n     * @brief TXFE field\n     *\n     * TXFE\n     */\n    using txfe\
    \ = FieldModel<uint32_t, address, 7, 1, bankOffset>;\n    /**\n     * @brief INEPNE\
    \ field\n     *\n     * INEPNE\n     */\n    using inepne = FieldModel<uint32_t,\
    \ address, 6, 1, bankOffset>;\n    /**\n     * @brief ITTXFE field\n     *\n \
    \    * ITTXFE\n     */\n    using ittxfe = FieldModel<uint32_t, address, 4, 1,\
    \ bankOffset>;\n    /**\n     * @brief TOC field\n     *\n     * TOC\n     */\n\
    \    using toc = FieldModel<uint32_t, address, 3, 1, bankOffset>;\n    /**\n \
    \    * @brief EPDISD field\n     *\n     * EPDISD\n     */\n    using epdisd =\
    \ FieldModel<uint32_t, address, 1, 1, bankOffset>;\n    /**\n     * @brief XFRC\
    \ field\n     *\n     * XFRC\n     */\n    using xfrc = FieldModel<uint32_t, address,\
    \ 0, 1, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      /**\n       * @brief TXFE field\n       *\n       * TXFE\n       */\n \
    \     BitFieldModel<uint32_t, 7, 1> txfe;\n      /**\n       * @brief INEPNE field\n\
    \       *\n       * INEPNE\n       */\n      BitFieldModel<uint32_t, 6, 1> inepne;\n\
    \      /**\n       * @brief ITTXFE field\n       *\n       * ITTXFE\n       */\n\
    \      BitFieldModel<uint32_t, 4, 1> ittxfe;\n      /**\n       * @brief TOC field\n\
    \       *\n       * TOC\n       */\n      BitFieldModel<uint32_t, 3, 1> toc;\n\
    \      /**\n       * @brief EPDISD field\n       *\n       * EPDISD\n       */\n\
    \      BitFieldModel<uint32_t, 1, 1> epdisd;\n      /**\n       * @brief XFRC\
    \ field\n       *\n       * XFRC\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 1> xfrc;\n    };\n  };\n\npublic:\n  /**\n   * @brief DIEPINTX register bank\n\
    \   *\n   * device endpoint-x interrupt\n   *           register\n   */\n  using\
    \ diepintx = DiepintxBankReg<BaseAddress + 0x0108, 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class DoepintxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    /**\n     * @brief B2BSTUP field\n\
    \     *\n     * B2BSTUP\n     */\n    using b2bstup = FieldModel<uint32_t, address,\
    \ 6, 1, bankOffset>;\n    /**\n     * @brief OTEPDIS field\n     *\n     * OTEPDIS\n\
    \     */\n    using otepdis = FieldModel<uint32_t, address, 4, 1, bankOffset>;\n\
    \    /**\n     * @brief STUP field\n     *\n     * STUP\n     */\n    using stup\
    \ = FieldModel<uint32_t, address, 3, 1, bankOffset>;\n    /**\n     * @brief EPDISD\
    \ field\n     *\n     * EPDISD\n     */\n    using epdisd = FieldModel<uint32_t,\
    \ address, 1, 1, bankOffset>;\n    /**\n     * @brief XFRC field\n     *\n   \
    \  * XFRC\n     */\n    using xfrc = FieldModel<uint32_t, address, 0, 1, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      /**\n       *\
    \ @brief B2BSTUP field\n       *\n       * B2BSTUP\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> b2bstup;\n      /**\n       * @brief OTEPDIS field\n       *\n       *\
    \ OTEPDIS\n       */\n      BitFieldModel<uint32_t, 4, 1> otepdis;\n      /**\n\
    \       * @brief STUP field\n       *\n       * STUP\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> stup;\n      /**\n       * @brief EPDISD field\n       *\n       * EPDISD\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> epdisd;\n      /**\n       * @brief\
    \ XFRC field\n       *\n       * XFRC\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> xfrc;\n    };\n  };\n\npublic:\n  /**\n   * @brief DOEPINTX register bank\n\
    \   *\n   * device endpoint-0 interrupt\n   *           register\n   */\n  using\
    \ doepintx = DoepintxBankReg<BaseAddress + 0x0308, 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class DieptsizxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    /**\n     * @brief MCNT field\n  \
    \   *\n     * Multi count\n     */\n    using mcnt = FieldModel<uint32_t, address,\
    \ 29, 2, bankOffset>;\n    /**\n     * @brief PKTCNT field\n     *\n     * Packet\
    \ count\n     */\n    using pktcnt = FieldModel<uint32_t, address, 19, 10, bankOffset>;\n\
    \    /**\n     * @brief XFRSIZ field\n     *\n     * Transfer size\n     */\n\
    \    using xfrsiz = FieldModel<uint32_t, address, 0, 19, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief MCNT\
    \ field\n       *\n       * Multi count\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 2> mcnt;\n      /**\n       * @brief PKTCNT field\n       *\n       * Packet\
    \ count\n       */\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      /**\n\
    \       * @brief XFRSIZ field\n       *\n       * Transfer size\n       */\n \
    \     BitFieldModel<uint32_t, 0, 19> xfrsiz;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief DIEPTSIZX register bank\n   *\n   * device endpoint-1 transfer size\n\
    \   *           register\n   */\n  using dieptsizx = DieptsizxBankReg<BaseAddress\
    \ + 0x0130, 0x0020>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class DtxfstsxBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    /**\n     * @brief INEPTFSAV field\n     *\n\
    \     * IN endpoint TxFIFO space\n     *               available\n     */\n  \
    \  using ineptfsav = FieldModel<uint32_t, address, 0, 16, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief INEPTFSAV\
    \ field\n       *\n       * IN endpoint TxFIFO space\n       *               available\n\
    \       */\n      BitFieldModel<uint32_t, 0, 16> ineptfsav;\n    };\n  };\n\n\
    public:\n  /**\n   * @brief DTXFSTSX register bank\n   *\n   * OTG_FS device IN\
    \ endpoint transmit FIFO\n   *           status register\n   */\n  using dtxfstsx\
    \ = DtxfstsxBankReg<BaseAddress + 0x0118, 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class DoeptsizxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    /**\n     * @brief RXDPID_STUPCNT\
    \ field\n     *\n     * Received data PID/SETUP packet\n     *               count\n\
    \     */\n    using rxdpid_stupcnt = FieldModel<uint32_t, address, 29, 2, bankOffset>;\n\
    \    /**\n     * @brief PKTCNT field\n     *\n     * Packet count\n     */\n \
    \   using pktcnt = FieldModel<uint32_t, address, 19, 10, bankOffset>;\n    /**\n\
    \     * @brief XFRSIZ field\n     *\n     * Transfer size\n     */\n    using\
    \ xfrsiz = FieldModel<uint32_t, address, 0, 19, bankOffset>;\n\n  public:\n  \
    \  union reg\n    {\n      uint32_t value;\n      /**\n       * @brief RXDPID_STUPCNT\
    \ field\n       *\n       * Received data PID/SETUP packet\n       *         \
    \      count\n       */\n      BitFieldModel<uint32_t, 29, 2> rxdpid_stupcnt;\n\
    \      /**\n       * @brief PKTCNT field\n       *\n       * Packet count\n  \
    \     */\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      /**\n       * @brief\
    \ XFRSIZ field\n       *\n       * Transfer size\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 19> xfrsiz;\n    };\n  };\n\npublic:\n  /**\n   * @brief DOEPTSIZX register\
    \ bank\n   *\n   * device OUT endpoint-1 transfer size\n   *           register\n\
    \   */\n  using doeptsizx = DoeptsizxBankReg<BaseAddress + 0x0330, 0x0020>;\n\n\
    };\n\n}\n\n#endif /* DRAL_STM32F411_OTG_FS_DEVICE_H */"
  name: OTG_FS_DEVICE
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_OTG_FS_GLOBAL_H\n#define DRAL_STM32F411_OTG_FS_GLOBAL_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ OTG_FS_GLOBAL peripheral\n *\n * USB on the go full speed\n */\nclass otg_fs_global\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x50000000; /**< Peripheral\
    \ base address */\n\nprivate:\n  template<unsigned int address>\n  class Fs_gotgctlReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ SRQSCS field\n     *\n     * Session request success\n     */\n    using srqscs\
    \ = FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief SRQ field\n \
    \    *\n     * Session request\n     */\n    using srq = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief AVALOEN field\n     *\n     * AVALOEN\n\
    \     */\n    using avaloen = FieldModel<uint32_t, address, 4, 1>;\n    /**\n\
    \     * @brief BVALOEN field\n     *\n     * BVALOEN\n     */\n    using bvaloen\
    \ = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief BVALOVAL field\n\
    \     *\n     * BVALOVAL\n     */\n    using bvaloval = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    /**\n     * @brief HNGSCS field\n     *\n     * Host negotiation\
    \ success\n     */\n    using hngscs = FieldModel<uint32_t, address, 8, 1>;\n\
    \    /**\n     * @brief HNPRQ field\n     *\n     * HNP request\n     */\n   \
    \ using hnprq = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief HSHNPEN\
    \ field\n     *\n     * Host set HNP enable\n     */\n    using hshnpen = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief DHNPEN field\n     *\n     * Device\
    \ HNP enabled\n     */\n    using dhnpen = FieldModel<uint32_t, address, 11, 1>;\n\
    \    /**\n     * @brief CIDSTS field\n     *\n     * Connector ID status\n   \
    \  */\n    using cidsts = FieldModel<uint32_t, address, 16, 1>;\n    /**\n   \
    \  * @brief DBCT field\n     *\n     * Long/short debounce time\n     */\n   \
    \ using dbct = FieldModel<uint32_t, address, 17, 1>;\n    /**\n     * @brief ASVLD\
    \ field\n     *\n     * A-session valid\n     */\n    using asvld = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    /**\n     * @brief BSVLD field\n     *\n     * B-session\
    \ valid\n     */\n    using bsvld = FieldModel<uint32_t, address, 19, 1>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief SRQSCS field\n       *\n       * Session\
    \ request success\n       */\n      BitFieldModel<uint32_t, 0, 1> srqscs;\n  \
    \    /**\n       * @brief SRQ field\n       *\n       * Session request\n    \
    \   */\n      BitFieldModel<uint32_t, 1, 1> srq;\n      /**\n       * @brief AVALOEN\
    \ field\n       *\n       * AVALOEN\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> avaloen;\n      /**\n       * @brief BVALOEN field\n       *\n       *\
    \ BVALOEN\n       */\n      BitFieldModel<uint32_t, 6, 1> bvaloen;\n      /**\n\
    \       * @brief BVALOVAL field\n       *\n       * BVALOVAL\n       */\n    \
    \  BitFieldModel<uint32_t, 7, 1> bvaloval;\n      /**\n       * @brief HNGSCS\
    \ field\n       *\n       * Host negotiation success\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> hngscs;\n      /**\n       * @brief HNPRQ field\n       *\n       * HNP\
    \ request\n       */\n      BitFieldModel<uint32_t, 9, 1> hnprq;\n      /**\n\
    \       * @brief HSHNPEN field\n       *\n       * Host set HNP enable\n     \
    \  */\n      BitFieldModel<uint32_t, 10, 1> hshnpen;\n      /**\n       * @brief\
    \ DHNPEN field\n       *\n       * Device HNP enabled\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> dhnpen;\n      /**\n       * @brief CIDSTS field\n       *\n       *\
    \ Connector ID status\n       */\n      BitFieldModel<uint32_t, 16, 1> cidsts;\n\
    \      /**\n       * @brief DBCT field\n       *\n       * Long/short debounce\
    \ time\n       */\n      BitFieldModel<uint32_t, 17, 1> dbct;\n      /**\n   \
    \    * @brief ASVLD field\n       *\n       * A-session valid\n       */\n   \
    \   BitFieldModel<uint32_t, 18, 1> asvld;\n      /**\n       * @brief BSVLD field\n\
    \       *\n       * B-session valid\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> bsvld;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_GOTGCTL register\n\
    \   *\n   * OTG_FS control and status register\n   *           (OTG_FS_GOTGCTL)\n\
    \   */\n  using fs_gotgctl = Fs_gotgctlReg<BaseAddress + 0x0000>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_gotgintReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief SEDET field\n     *\n     *\
    \ Session end detected\n     */\n    using sedet = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief SRSSCHG field\n     *\n     * Session request\
    \ success status\n     *               change\n     */\n    using srsschg = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief HNSSCHG field\n     *\n     * Host negotiation\
    \ success status\n     *               change\n     */\n    using hnsschg = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief HNGDET field\n     *\n     * Host negotiation\
    \ detected\n     */\n    using hngdet = FieldModel<uint32_t, address, 17, 1>;\n\
    \    /**\n     * @brief ADTOCHG field\n     *\n     * A-device timeout change\n\
    \     */\n    using adtochg = FieldModel<uint32_t, address, 18, 1>;\n    /**\n\
    \     * @brief DBCDNE field\n     *\n     * Debounce done\n     */\n    using\
    \ dbcdne = FieldModel<uint32_t, address, 19, 1>;\n\n  public:\n    /**\n     *\
    \ @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ SEDET field\n       *\n       * Session end detected\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> sedet;\n      /**\n       * @brief SRSSCHG field\n       *\n       * Session\
    \ request success status\n       *               change\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> srsschg;\n      /**\n       * @brief HNSSCHG field\n       *\n       *\
    \ Host negotiation success status\n       *               change\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> hnsschg;\n      /**\n       * @brief HNGDET\
    \ field\n       *\n       * Host negotiation detected\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> hngdet;\n      /**\n       * @brief ADTOCHG field\n       *\n       *\
    \ A-device timeout change\n       */\n      BitFieldModel<uint32_t, 18, 1> adtochg;\n\
    \      /**\n       * @brief DBCDNE field\n       *\n       * Debounce done\n \
    \      */\n      BitFieldModel<uint32_t, 19, 1> dbcdne;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief FS_GOTGINT register\n   *\n   * OTG_FS interrupt register\n\
    \   *           (OTG_FS_GOTGINT)\n   */\n  using fs_gotgint = Fs_gotgintReg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_gahbcfgReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ GINT field\n     *\n     * Global interrupt mask\n     */\n    using gint =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief TXFELVL field\n\
    \     *\n     * TxFIFO empty level\n     */\n    using txfelvl = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief PTXFELVL field\n     *\n     * Periodic\
    \ TxFIFO empty\n     *               level\n     */\n    using ptxfelvl = FieldModel<uint32_t,\
    \ address, 8, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief GINT field\n       *\n\
    \       * Global interrupt mask\n       */\n      BitFieldModel<uint32_t, 0, 1>\
    \ gint;\n      /**\n       * @brief TXFELVL field\n       *\n       * TxFIFO empty\
    \ level\n       */\n      BitFieldModel<uint32_t, 7, 1> txfelvl;\n      /**\n\
    \       * @brief PTXFELVL field\n       *\n       * Periodic TxFIFO empty\n  \
    \     *               level\n       */\n      BitFieldModel<uint32_t, 8, 1> ptxfelvl;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief FS_GAHBCFG register\n   *\n   * OTG_FS\
    \ AHB configuration register\n   *           (OTG_FS_GAHBCFG)\n   */\n  using\
    \ fs_gahbcfg = Fs_gahbcfgReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Fs_gusbcfgReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief TOCAL field\n     *\n     * FS timeout\
    \ calibration\n     */\n    using tocal = FieldModel<uint32_t, address, 0, 3>;\n\
    \    /**\n     * @brief PHYSEL field\n     *\n     * Full Speed serial transceiver\n\
    \     *               select\n     */\n    using physel = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief SRPCAP field\n     *\n     * SRP-capable\n\
    \     */\n    using srpcap = FieldModel<uint32_t, address, 8, 1>;\n    /**\n \
    \    * @brief HNPCAP field\n     *\n     * HNP-capable\n     */\n    using hnpcap\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief TRDT field\n\
    \     *\n     * USB turnaround time\n     */\n    using trdt = FieldModel<uint32_t,\
    \ address, 10, 4>;\n    /**\n     * @brief FHMOD field\n     *\n     * Force host\
    \ mode\n     */\n    using fhmod = FieldModel<uint32_t, address, 29, 1>;\n   \
    \ /**\n     * @brief FDMOD field\n     *\n     * Force device mode\n     */\n\
    \    using fdmod = FieldModel<uint32_t, address, 30, 1>;\n    /**\n     * @brief\
    \ CTXPKT field\n     *\n     * Corrupt Tx packet\n     */\n    using ctxpkt =\
    \ FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    /**\n     * @brief Register\
    \ union\n     *\n     * Can be used to create a local register variable for easy\
    \ bit manipulation.\n     * Useful for read-modify-write operations.\n     */\n\
    \    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief TOCAL\
    \ field\n       *\n       * FS timeout calibration\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 3> tocal;\n      /**\n       * @brief PHYSEL field\n       *\n       * Full\
    \ Speed serial transceiver\n       *               select\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> physel;\n      /**\n       * @brief SRPCAP field\n       *\n       * SRP-capable\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> srpcap;\n      /**\n       * @brief\
    \ HNPCAP field\n       *\n       * HNP-capable\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> hnpcap;\n      /**\n       * @brief TRDT field\n       *\n       * USB\
    \ turnaround time\n       */\n      BitFieldModel<uint32_t, 10, 4> trdt;\n   \
    \   /**\n       * @brief FHMOD field\n       *\n       * Force host mode\n   \
    \    */\n      BitFieldModel<uint32_t, 29, 1> fhmod;\n      /**\n       * @brief\
    \ FDMOD field\n       *\n       * Force device mode\n       */\n      BitFieldModel<uint32_t,\
    \ 30, 1> fdmod;\n      /**\n       * @brief CTXPKT field\n       *\n       * Corrupt\
    \ Tx packet\n       */\n      BitFieldModel<uint32_t, 31, 1> ctxpkt;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief FS_GUSBCFG register\n   *\n   * OTG_FS USB\
    \ configuration register\n   *           (OTG_FS_GUSBCFG)\n   */\n  using fs_gusbcfg\
    \ = Fs_gusbcfgReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class Fs_grstctlReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief CSRST field\n     *\n     * Core soft\
    \ reset\n     */\n    using csrst = FieldModel<uint32_t, address, 0, 1>;\n   \
    \ /**\n     * @brief HSRST field\n     *\n     * HCLK soft reset\n     */\n  \
    \  using hsrst = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief\
    \ FCRST field\n     *\n     * Host frame counter reset\n     */\n    using fcrst\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief RXFFLSH field\n\
    \     *\n     * RxFIFO flush\n     */\n    using rxfflsh = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief TXFFLSH field\n     *\n     * TxFIFO\
    \ flush\n     */\n    using txfflsh = FieldModel<uint32_t, address, 5, 1>;\n \
    \   /**\n     * @brief TXFNUM field\n     *\n     * TxFIFO number\n     */\n \
    \   using txfnum = FieldModel<uint32_t, address, 6, 5>;\n    /**\n     * @brief\
    \ AHBIDL field\n     *\n     * AHB master idle\n     */\n    using ahbidl = FieldModel<uint32_t,\
    \ address, 31, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CSRST field\n       *\n\
    \       * Core soft reset\n       */\n      BitFieldModel<uint32_t, 0, 1> csrst;\n\
    \      /**\n       * @brief HSRST field\n       *\n       * HCLK soft reset\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> hsrst;\n      /**\n       * @brief\
    \ FCRST field\n       *\n       * Host frame counter reset\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> fcrst;\n      /**\n       * @brief RXFFLSH field\n       *\n       * RxFIFO\
    \ flush\n       */\n      BitFieldModel<uint32_t, 4, 1> rxfflsh;\n      /**\n\
    \       * @brief TXFFLSH field\n       *\n       * TxFIFO flush\n       */\n \
    \     BitFieldModel<uint32_t, 5, 1> txfflsh;\n      /**\n       * @brief TXFNUM\
    \ field\n       *\n       * TxFIFO number\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 5> txfnum;\n      /**\n       * @brief AHBIDL field\n       *\n       * AHB\
    \ master idle\n       */\n      BitFieldModel<uint32_t, 31, 1> ahbidl;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief FS_GRSTCTL register\n   *\n   * OTG_FS reset\
    \ register\n   *           (OTG_FS_GRSTCTL)\n   */\n  using fs_grstctl = Fs_grstctlReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_gintstsReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ CMOD field\n     *\n     * Current mode of operation\n     */\n    using cmod\
    \ = FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief MMIS field\n\
    \     *\n     * Mode mismatch interrupt\n     */\n    using mmis = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief OTGINT field\n     *\n     * OTG interrupt\n\
    \     */\n    using otgint = FieldModel<uint32_t, address, 2, 1>;\n    /**\n \
    \    * @brief SOF field\n     *\n     * Start of frame\n     */\n    using sof\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief RXFLVL field\n\
    \     *\n     * RxFIFO non-empty\n     */\n    using rxflvl = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief NPTXFE field\n     *\n     * Non-periodic\
    \ TxFIFO empty\n     */\n    using nptxfe = FieldModel<uint32_t, address, 5, 1>;\n\
    \    /**\n     * @brief GINAKEFF field\n     *\n     * Global IN non-periodic\
    \ NAK\n     *               effective\n     */\n    using ginakeff = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief GOUTNAKEFF field\n     *\n     * Global\
    \ OUT NAK effective\n     */\n    using goutnakeff = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    /**\n     * @brief ESUSP field\n     *\n     * Early suspend\n \
    \    */\n    using esusp = FieldModel<uint32_t, address, 10, 1>;\n    /**\n  \
    \   * @brief USBSUSP field\n     *\n     * USB suspend\n     */\n    using usbsusp\
    \ = FieldModel<uint32_t, address, 11, 1>;\n    /**\n     * @brief USBRST field\n\
    \     *\n     * USB reset\n     */\n    using usbrst = FieldModel<uint32_t, address,\
    \ 12, 1>;\n    /**\n     * @brief ENUMDNE field\n     *\n     * Enumeration done\n\
    \     */\n    using enumdne = FieldModel<uint32_t, address, 13, 1>;\n    /**\n\
    \     * @brief ISOODRP field\n     *\n     * Isochronous OUT packet dropped\n\
    \     *               interrupt\n     */\n    using isoodrp = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief EOPF field\n     *\n     * End of periodic\
    \ frame\n     *               interrupt\n     */\n    using eopf = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief IEPINT field\n     *\n     * IN endpoint\
    \ interrupt\n     */\n    using iepint = FieldModel<uint32_t, address, 18, 1>;\n\
    \    /**\n     * @brief OEPINT field\n     *\n     * OUT endpoint interrupt\n\
    \     */\n    using oepint = FieldModel<uint32_t, address, 19, 1>;\n    /**\n\
    \     * @brief IISOIXFR field\n     *\n     * Incomplete isochronous IN\n    \
    \ *               transfer\n     */\n    using iisoixfr = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief IPXFR_INCOMPISOOUT field\n     *\n\
    \     * Incomplete periodic transfer(Host\n     *               mode)/Incomplete\
    \ isochronous OUT transfer(Device\n     *               mode)\n     */\n    using\
    \ ipxfr_incompisoout = FieldModel<uint32_t, address, 21, 1>;\n    /**\n     *\
    \ @brief HPRTINT field\n     *\n     * Host port interrupt\n     */\n    using\
    \ hprtint = FieldModel<uint32_t, address, 24, 1>;\n    /**\n     * @brief HCINT\
    \ field\n     *\n     * Host channels interrupt\n     */\n    using hcint = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    /**\n     * @brief PTXFE field\n     *\n     * Periodic\
    \ TxFIFO empty\n     */\n    using ptxfe = FieldModel<uint32_t, address, 26, 1>;\n\
    \    /**\n     * @brief CIDSCHG field\n     *\n     * Connector ID status change\n\
    \     */\n    using cidschg = FieldModel<uint32_t, address, 28, 1>;\n    /**\n\
    \     * @brief DISCINT field\n     *\n     * Disconnect detected\n     *     \
    \          interrupt\n     */\n    using discint = FieldModel<uint32_t, address,\
    \ 29, 1>;\n    /**\n     * @brief SRQINT field\n     *\n     * Session request/new\
    \ session detected\n     *               interrupt\n     */\n    using srqint\
    \ = FieldModel<uint32_t, address, 30, 1>;\n    /**\n     * @brief WKUPINT field\n\
    \     *\n     * Resume/remote wakeup detected\n     *               interrupt\n\
    \     */\n    using wkupint = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CMOD field\n       *\n       * Current mode of operation\n  \
    \     */\n      BitFieldModel<uint32_t, 0, 1> cmod;\n      /**\n       * @brief\
    \ MMIS field\n       *\n       * Mode mismatch interrupt\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> mmis;\n      /**\n       * @brief OTGINT field\n       *\n       * OTG\
    \ interrupt\n       */\n      BitFieldModel<uint32_t, 2, 1> otgint;\n      /**\n\
    \       * @brief SOF field\n       *\n       * Start of frame\n       */\n   \
    \   BitFieldModel<uint32_t, 3, 1> sof;\n      /**\n       * @brief RXFLVL field\n\
    \       *\n       * RxFIFO non-empty\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> rxflvl;\n      /**\n       * @brief NPTXFE field\n       *\n       * Non-periodic\
    \ TxFIFO empty\n       */\n      BitFieldModel<uint32_t, 5, 1> nptxfe;\n     \
    \ /**\n       * @brief GINAKEFF field\n       *\n       * Global IN non-periodic\
    \ NAK\n       *               effective\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> ginakeff;\n      /**\n       * @brief GOUTNAKEFF field\n       *\n   \
    \    * Global OUT NAK effective\n       */\n      BitFieldModel<uint32_t, 7, 1>\
    \ goutnakeff;\n      /**\n       * @brief ESUSP field\n       *\n       * Early\
    \ suspend\n       */\n      BitFieldModel<uint32_t, 10, 1> esusp;\n      /**\n\
    \       * @brief USBSUSP field\n       *\n       * USB suspend\n       */\n  \
    \    BitFieldModel<uint32_t, 11, 1> usbsusp;\n      /**\n       * @brief USBRST\
    \ field\n       *\n       * USB reset\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> usbrst;\n      /**\n       * @brief ENUMDNE field\n       *\n       *\
    \ Enumeration done\n       */\n      BitFieldModel<uint32_t, 13, 1> enumdne;\n\
    \      /**\n       * @brief ISOODRP field\n       *\n       * Isochronous OUT\
    \ packet dropped\n       *               interrupt\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> isoodrp;\n      /**\n       * @brief EOPF field\n       *\n       * End\
    \ of periodic frame\n       *               interrupt\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> eopf;\n      /**\n       * @brief IEPINT field\n       *\n       * IN\
    \ endpoint interrupt\n       */\n      BitFieldModel<uint32_t, 18, 1> iepint;\n\
    \      /**\n       * @brief OEPINT field\n       *\n       * OUT endpoint interrupt\n\
    \       */\n      BitFieldModel<uint32_t, 19, 1> oepint;\n      /**\n       *\
    \ @brief IISOIXFR field\n       *\n       * Incomplete isochronous IN\n      \
    \ *               transfer\n       */\n      BitFieldModel<uint32_t, 20, 1> iisoixfr;\n\
    \      /**\n       * @brief IPXFR_INCOMPISOOUT field\n       *\n       * Incomplete\
    \ periodic transfer(Host\n       *               mode)/Incomplete isochronous\
    \ OUT transfer(Device\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 1> ipxfr_incompisoout;\n      /**\n       * @brief HPRTINT field\n     \
    \  *\n       * Host port interrupt\n       */\n      BitFieldModel<uint32_t, 24,\
    \ 1> hprtint;\n      /**\n       * @brief HCINT field\n       *\n       * Host\
    \ channels interrupt\n       */\n      BitFieldModel<uint32_t, 25, 1> hcint;\n\
    \      /**\n       * @brief PTXFE field\n       *\n       * Periodic TxFIFO empty\n\
    \       */\n      BitFieldModel<uint32_t, 26, 1> ptxfe;\n      /**\n       * @brief\
    \ CIDSCHG field\n       *\n       * Connector ID status change\n       */\n  \
    \    BitFieldModel<uint32_t, 28, 1> cidschg;\n      /**\n       * @brief DISCINT\
    \ field\n       *\n       * Disconnect detected\n       *               interrupt\n\
    \       */\n      BitFieldModel<uint32_t, 29, 1> discint;\n      /**\n       *\
    \ @brief SRQINT field\n       *\n       * Session request/new session detected\n\
    \       *               interrupt\n       */\n      BitFieldModel<uint32_t, 30,\
    \ 1> srqint;\n      /**\n       * @brief WKUPINT field\n       *\n       * Resume/remote\
    \ wakeup detected\n       *               interrupt\n       */\n      BitFieldModel<uint32_t,\
    \ 31, 1> wkupint;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_GINTSTS register\n\
    \   *\n   * OTG_FS core interrupt register\n   *           (OTG_FS_GINTSTS)\n\
    \   */\n  using fs_gintsts = Fs_gintstsReg<BaseAddress + 0x0014>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_gintmskReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief MMISM field\n     *\n     *\
    \ Mode mismatch interrupt\n     *               mask\n     */\n    using mmism\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief OTGINT field\n\
    \     *\n     * OTG interrupt mask\n     */\n    using otgint = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief SOFM field\n     *\n     * Start of\
    \ frame mask\n     */\n    using sofm = FieldModel<uint32_t, address, 3, 1>;\n\
    \    /**\n     * @brief RXFLVLM field\n     *\n     * Receive FIFO non-empty\n\
    \     *               mask\n     */\n    using rxflvlm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief NPTXFEM field\n     *\n     * Non-periodic\
    \ TxFIFO empty\n     *               mask\n     */\n    using nptxfem = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief GINAKEFFM field\n     *\n     * Global\
    \ non-periodic IN NAK effective\n     *               mask\n     */\n    using\
    \ ginakeffm = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief GONAKEFFM\
    \ field\n     *\n     * Global OUT NAK effective\n     *               mask\n\
    \     */\n    using gonakeffm = FieldModel<uint32_t, address, 7, 1>;\n    /**\n\
    \     * @brief ESUSPM field\n     *\n     * Early suspend mask\n     */\n    using\
    \ esuspm = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief USBSUSPM\
    \ field\n     *\n     * USB suspend mask\n     */\n    using usbsuspm = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief USBRST field\n     *\n     * USB reset\
    \ mask\n     */\n    using usbrst = FieldModel<uint32_t, address, 12, 1>;\n  \
    \  /**\n     * @brief ENUMDNEM field\n     *\n     * Enumeration done mask\n \
    \    */\n    using enumdnem = FieldModel<uint32_t, address, 13, 1>;\n    /**\n\
    \     * @brief ISOODRPM field\n     *\n     * Isochronous OUT packet dropped interrupt\n\
    \     *               mask\n     */\n    using isoodrpm = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief EOPFM field\n     *\n     * End of\
    \ periodic frame interrupt\n     *               mask\n     */\n    using eopfm\
    \ = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief EPMISM field\n\
    \     *\n     * Endpoint mismatch interrupt\n     *               mask\n     */\n\
    \    using epmism = FieldModel<uint32_t, address, 17, 1>;\n    /**\n     * @brief\
    \ IEPINT field\n     *\n     * IN endpoints interrupt\n     *               mask\n\
    \     */\n    using iepint = FieldModel<uint32_t, address, 18, 1>;\n    /**\n\
    \     * @brief OEPINT field\n     *\n     * OUT endpoints interrupt\n     *  \
    \             mask\n     */\n    using oepint = FieldModel<uint32_t, address,\
    \ 19, 1>;\n    /**\n     * @brief IISOIXFRM field\n     *\n     * Incomplete isochronous\
    \ IN transfer\n     *               mask\n     */\n    using iisoixfrm = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief IPXFRM_IISOOXFRM field\n     *\n  \
    \   * Incomplete periodic transfer mask(Host\n     *               mode)/Incomplete\
    \ isochronous OUT transfer mask(Device\n     *               mode)\n     */\n\
    \    using ipxfrm_iisooxfrm = FieldModel<uint32_t, address, 21, 1>;\n    /**\n\
    \     * @brief PRTIM field\n     *\n     * Host port interrupt mask\n     */\n\
    \    using prtim = FieldModel<uint32_t, address, 24, 1>;\n    /**\n     * @brief\
    \ HCIM field\n     *\n     * Host channels interrupt\n     *               mask\n\
    \     */\n    using hcim = FieldModel<uint32_t, address, 25, 1>;\n    /**\n  \
    \   * @brief PTXFEM field\n     *\n     * Periodic TxFIFO empty mask\n     */\n\
    \    using ptxfem = FieldModel<uint32_t, address, 26, 1>;\n    /**\n     * @brief\
    \ CIDSCHGM field\n     *\n     * Connector ID status change\n     *          \
    \     mask\n     */\n    using cidschgm = FieldModel<uint32_t, address, 28, 1>;\n\
    \    /**\n     * @brief DISCINT field\n     *\n     * Disconnect detected interrupt\n\
    \     *               mask\n     */\n    using discint = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    /**\n     * @brief SRQIM field\n     *\n     * Session\
    \ request/new session detected\n     *               interrupt mask\n     */\n\
    \    using srqim = FieldModel<uint32_t, address, 30, 1>;\n    /**\n     * @brief\
    \ WUIM field\n     *\n     * Resume/remote wakeup detected interrupt\n     * \
    \              mask\n     */\n    using wuim = FieldModel<uint32_t, address, 31,\
    \ 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief MMISM field\n       *\n   \
    \    * Mode mismatch interrupt\n       *               mask\n       */\n     \
    \ BitFieldModel<uint32_t, 1, 1> mmism;\n      /**\n       * @brief OTGINT field\n\
    \       *\n       * OTG interrupt mask\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> otgint;\n      /**\n       * @brief SOFM field\n       *\n       * Start\
    \ of frame mask\n       */\n      BitFieldModel<uint32_t, 3, 1> sofm;\n      /**\n\
    \       * @brief RXFLVLM field\n       *\n       * Receive FIFO non-empty\n  \
    \     *               mask\n       */\n      BitFieldModel<uint32_t, 4, 1> rxflvlm;\n\
    \      /**\n       * @brief NPTXFEM field\n       *\n       * Non-periodic TxFIFO\
    \ empty\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> nptxfem;\n      /**\n       * @brief GINAKEFFM field\n       *\n     \
    \  * Global non-periodic IN NAK effective\n       *               mask\n     \
    \  */\n      BitFieldModel<uint32_t, 6, 1> ginakeffm;\n      /**\n       * @brief\
    \ GONAKEFFM field\n       *\n       * Global OUT NAK effective\n       *     \
    \          mask\n       */\n      BitFieldModel<uint32_t, 7, 1> gonakeffm;\n \
    \     /**\n       * @brief ESUSPM field\n       *\n       * Early suspend mask\n\
    \       */\n      BitFieldModel<uint32_t, 10, 1> esuspm;\n      /**\n       *\
    \ @brief USBSUSPM field\n       *\n       * USB suspend mask\n       */\n    \
    \  BitFieldModel<uint32_t, 11, 1> usbsuspm;\n      /**\n       * @brief USBRST\
    \ field\n       *\n       * USB reset mask\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> usbrst;\n      /**\n       * @brief ENUMDNEM field\n       *\n      \
    \ * Enumeration done mask\n       */\n      BitFieldModel<uint32_t, 13, 1> enumdnem;\n\
    \      /**\n       * @brief ISOODRPM field\n       *\n       * Isochronous OUT\
    \ packet dropped interrupt\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> isoodrpm;\n      /**\n       * @brief EOPFM field\n       *\n       *\
    \ End of periodic frame interrupt\n       *               mask\n       */\n  \
    \    BitFieldModel<uint32_t, 15, 1> eopfm;\n      /**\n       * @brief EPMISM\
    \ field\n       *\n       * Endpoint mismatch interrupt\n       *            \
    \   mask\n       */\n      BitFieldModel<uint32_t, 17, 1> epmism;\n      /**\n\
    \       * @brief IEPINT field\n       *\n       * IN endpoints interrupt\n   \
    \    *               mask\n       */\n      BitFieldModel<uint32_t, 18, 1> iepint;\n\
    \      /**\n       * @brief OEPINT field\n       *\n       * OUT endpoints interrupt\n\
    \       *               mask\n       */\n      BitFieldModel<uint32_t, 19, 1>\
    \ oepint;\n      /**\n       * @brief IISOIXFRM field\n       *\n       * Incomplete\
    \ isochronous IN transfer\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 1> iisoixfrm;\n      /**\n       * @brief IPXFRM_IISOOXFRM field\n     \
    \  *\n       * Incomplete periodic transfer mask(Host\n       *              \
    \ mode)/Incomplete isochronous OUT transfer mask(Device\n       *            \
    \   mode)\n       */\n      BitFieldModel<uint32_t, 21, 1> ipxfrm_iisooxfrm;\n\
    \      /**\n       * @brief PRTIM field\n       *\n       * Host port interrupt\
    \ mask\n       */\n      BitFieldModel<uint32_t, 24, 1> prtim;\n      /**\n  \
    \     * @brief HCIM field\n       *\n       * Host channels interrupt\n      \
    \ *               mask\n       */\n      BitFieldModel<uint32_t, 25, 1> hcim;\n\
    \      /**\n       * @brief PTXFEM field\n       *\n       * Periodic TxFIFO empty\
    \ mask\n       */\n      BitFieldModel<uint32_t, 26, 1> ptxfem;\n      /**\n \
    \      * @brief CIDSCHGM field\n       *\n       * Connector ID status change\n\
    \       *               mask\n       */\n      BitFieldModel<uint32_t, 28, 1>\
    \ cidschgm;\n      /**\n       * @brief DISCINT field\n       *\n       * Disconnect\
    \ detected interrupt\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 1> discint;\n      /**\n       * @brief SRQIM field\n       *\n       *\
    \ Session request/new session detected\n       *               interrupt mask\n\
    \       */\n      BitFieldModel<uint32_t, 30, 1> srqim;\n      /**\n       * @brief\
    \ WUIM field\n       *\n       * Resume/remote wakeup detected interrupt\n   \
    \    *               mask\n       */\n      BitFieldModel<uint32_t, 31, 1> wuim;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief FS_GINTMSK register\n   *\n   * OTG_FS\
    \ interrupt mask register\n   *           (OTG_FS_GINTMSK)\n   */\n  using fs_gintmsk\
    \ = Fs_gintmskReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class Fs_grxstsr_deviceReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief EPNUM field\n     *\n     * Endpoint number\n\
    \     */\n    using epnum = FieldModel<uint32_t, address, 0, 4>;\n    /**\n  \
    \   * @brief BCNT field\n     *\n     * Byte count\n     */\n    using bcnt =\
    \ FieldModel<uint32_t, address, 4, 11>;\n    /**\n     * @brief DPID field\n \
    \    *\n     * Data PID\n     */\n    using dpid = FieldModel<uint32_t, address,\
    \ 15, 2>;\n    /**\n     * @brief PKTSTS field\n     *\n     * Packet status\n\
    \     */\n    using pktsts = FieldModel<uint32_t, address, 17, 4>;\n    /**\n\
    \     * @brief FRMNUM field\n     *\n     * Frame number\n     */\n    using frmnum\
    \ = FieldModel<uint32_t, address, 21, 4>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ EPNUM field\n       *\n       * Endpoint number\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> epnum;\n      /**\n       * @brief BCNT field\n       *\n       * Byte\
    \ count\n       */\n      BitFieldModel<uint32_t, 4, 11> bcnt;\n      /**\n  \
    \     * @brief DPID field\n       *\n       * Data PID\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 2> dpid;\n      /**\n       * @brief PKTSTS field\n       *\n       * Packet\
    \ status\n       */\n      BitFieldModel<uint32_t, 17, 4> pktsts;\n      /**\n\
    \       * @brief FRMNUM field\n       *\n       * Frame number\n       */\n  \
    \    BitFieldModel<uint32_t, 21, 4> frmnum;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief FS_GRXSTSR_DEVICE register\n   *\n   * OTG_FS Receive status debug\
    \ read(Device\n   *           mode)\n   */\n  using fs_grxstsr_device = Fs_grxstsr_deviceReg<BaseAddress\
    \ + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_grxstsp_deviceReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ EPNUM field\n     *\n     * Endpoint number\n     */\n    using epnum = FieldModel<uint32_t,\
    \ address, 0, 4>;\n    /**\n     * @brief BCNT field\n     *\n     * Byte count\n\
    \     */\n    using bcnt = FieldModel<uint32_t, address, 4, 11>;\n    /**\n  \
    \   * @brief DPID field\n     *\n     * Data PID\n     */\n    using dpid = FieldModel<uint32_t,\
    \ address, 15, 2>;\n    /**\n     * @brief PKTSTS field\n     *\n     * Packet\
    \ status\n     */\n    using pktsts = FieldModel<uint32_t, address, 17, 4>;\n\
    \    /**\n     * @brief FRMNUM field\n     *\n     * Frame number\n     */\n \
    \   using frmnum = FieldModel<uint32_t, address, 21, 4>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ EPNUM field\n       *\n       * Endpoint number\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> epnum;\n      /**\n       * @brief BCNT field\n       *\n       * Byte\
    \ count\n       */\n      BitFieldModel<uint32_t, 4, 11> bcnt;\n      /**\n  \
    \     * @brief DPID field\n       *\n       * Data PID\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 2> dpid;\n      /**\n       * @brief PKTSTS field\n       *\n       * Packet\
    \ status\n       */\n      BitFieldModel<uint32_t, 17, 4> pktsts;\n      /**\n\
    \       * @brief FRMNUM field\n       *\n       * Frame number\n       */\n  \
    \    BitFieldModel<uint32_t, 21, 4> frmnum;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief FS_GRXSTSP_DEVICE register\n   *\n   * OTG_FS Receive status debug\
    \ read(Device\n   *           mode)\n   */\n  using fs_grxstsp_device = Fs_grxstsp_deviceReg<BaseAddress\
    \ + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_grxstsr_hostReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ EPNUM field\n     *\n     * Endpoint number\n     */\n    using epnum = FieldModel<uint32_t,\
    \ address, 0, 4>;\n    /**\n     * @brief BCNT field\n     *\n     * Byte count\n\
    \     */\n    using bcnt = FieldModel<uint32_t, address, 4, 11>;\n    /**\n  \
    \   * @brief DPID field\n     *\n     * Data PID\n     */\n    using dpid = FieldModel<uint32_t,\
    \ address, 15, 2>;\n    /**\n     * @brief PKTSTS field\n     *\n     * Packet\
    \ status\n     */\n    using pktsts = FieldModel<uint32_t, address, 17, 4>;\n\
    \    /**\n     * @brief FRMNUM field\n     *\n     * Frame number\n     */\n \
    \   using frmnum = FieldModel<uint32_t, address, 21, 4>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ EPNUM field\n       *\n       * Endpoint number\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> epnum;\n      /**\n       * @brief BCNT field\n       *\n       * Byte\
    \ count\n       */\n      BitFieldModel<uint32_t, 4, 11> bcnt;\n      /**\n  \
    \     * @brief DPID field\n       *\n       * Data PID\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 2> dpid;\n      /**\n       * @brief PKTSTS field\n       *\n       * Packet\
    \ status\n       */\n      BitFieldModel<uint32_t, 17, 4> pktsts;\n      /**\n\
    \       * @brief FRMNUM field\n       *\n       * Frame number\n       */\n  \
    \    BitFieldModel<uint32_t, 21, 4> frmnum;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief FS_GRXSTSR_HOST register\n   *\n   * OTG_FS Receive status debug\
    \ read(Host\n   *           mode)\n   */\n  using fs_grxstsr_host = Fs_grxstsr_hostReg<BaseAddress\
    \ + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_grxstsp_hostReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ EPNUM field\n     *\n     * Endpoint number\n     */\n    using epnum = FieldModel<uint32_t,\
    \ address, 0, 4>;\n    /**\n     * @brief BCNT field\n     *\n     * Byte count\n\
    \     */\n    using bcnt = FieldModel<uint32_t, address, 4, 11>;\n    /**\n  \
    \   * @brief DPID field\n     *\n     * Data PID\n     */\n    using dpid = FieldModel<uint32_t,\
    \ address, 15, 2>;\n    /**\n     * @brief PKTSTS field\n     *\n     * Packet\
    \ status\n     */\n    using pktsts = FieldModel<uint32_t, address, 17, 4>;\n\
    \    /**\n     * @brief FRMNUM field\n     *\n     * Frame number\n     */\n \
    \   using frmnum = FieldModel<uint32_t, address, 21, 4>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ EPNUM field\n       *\n       * Endpoint number\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> epnum;\n      /**\n       * @brief BCNT field\n       *\n       * Byte\
    \ count\n       */\n      BitFieldModel<uint32_t, 4, 11> bcnt;\n      /**\n  \
    \     * @brief DPID field\n       *\n       * Data PID\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 2> dpid;\n      /**\n       * @brief PKTSTS field\n       *\n       * Packet\
    \ status\n       */\n      BitFieldModel<uint32_t, 17, 4> pktsts;\n      /**\n\
    \       * @brief FRMNUM field\n       *\n       * Frame number\n       */\n  \
    \    BitFieldModel<uint32_t, 21, 4> frmnum;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief FS_GRXSTSP_HOST register\n   *\n   * OTG_FS Receive status debug\
    \ read(Host\n   *           mode)\n   */\n  using fs_grxstsp_host = Fs_grxstsp_hostReg<BaseAddress\
    \ + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_grxfsizReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ RXFD field\n     *\n     * RxFIFO depth\n     */\n    using rxfd = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief RXFD field\n       *\n\
    \       * RxFIFO depth\n       */\n      BitFieldModel<uint32_t, 0, 16> rxfd;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief FS_GRXFSIZ register\n   *\n   * OTG_FS\
    \ Receive FIFO size register\n   *           (OTG_FS_GRXFSIZ)\n   */\n  using\
    \ fs_grxfsiz = Fs_grxfsizReg<BaseAddress + 0x0024>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Fs_gnptxfsiz_deviceReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief TX0FSA field\n     *\n    \
    \ * Endpoint 0 transmit RAM start\n     *               address\n     */\n   \
    \ using tx0fsa = FieldModel<uint32_t, address, 0, 16>;\n    /**\n     * @brief\
    \ TX0FD field\n     *\n     * Endpoint 0 TxFIFO depth\n     */\n    using tx0fd\
    \ = FieldModel<uint32_t, address, 16, 16>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ TX0FSA field\n       *\n       * Endpoint 0 transmit RAM start\n       *   \
    \            address\n       */\n      BitFieldModel<uint32_t, 0, 16> tx0fsa;\n\
    \      /**\n       * @brief TX0FD field\n       *\n       * Endpoint 0 TxFIFO\
    \ depth\n       */\n      BitFieldModel<uint32_t, 16, 16> tx0fd;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief FS_GNPTXFSIZ_DEVICE register\n   *\n   * OTG_FS\
    \ non-periodic transmit FIFO size\n   *           register (Device mode)\n   */\n\
    \  using fs_gnptxfsiz_device = Fs_gnptxfsiz_deviceReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Fs_gnptxfsiz_hostReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief NPTXFSA\
    \ field\n     *\n     * Non-periodic transmit RAM start\n     *              \
    \ address\n     */\n    using nptxfsa = FieldModel<uint32_t, address, 0, 16>;\n\
    \    /**\n     * @brief NPTXFD field\n     *\n     * Non-periodic TxFIFO depth\n\
    \     */\n    using nptxfd = FieldModel<uint32_t, address, 16, 16>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief NPTXFSA field\n       *\n       * Non-periodic transmit RAM start\n\
    \       *               address\n       */\n      BitFieldModel<uint32_t, 0, 16>\
    \ nptxfsa;\n      /**\n       * @brief NPTXFD field\n       *\n       * Non-periodic\
    \ TxFIFO depth\n       */\n      BitFieldModel<uint32_t, 16, 16> nptxfd;\n   \
    \ };\n  };\n\npublic:\n  /**\n   * @brief FS_GNPTXFSIZ_HOST register\n   *\n \
    \  * OTG_FS non-periodic transmit FIFO size\n   *           register (Host mode)\n\
    \   */\n  using fs_gnptxfsiz_host = Fs_gnptxfsiz_hostReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Fs_gnptxstsReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief NPTXFSAV\
    \ field\n     *\n     * Non-periodic TxFIFO space\n     *               available\n\
    \     */\n    using nptxfsav = FieldModel<uint32_t, address, 0, 16>;\n    /**\n\
    \     * @brief NPTQXSAV field\n     *\n     * Non-periodic transmit request queue\n\
    \     *               space available\n     */\n    using nptqxsav = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    /**\n     * @brief NPTXQTOP field\n     *\n     * Top\
    \ of the non-periodic transmit request\n     *               queue\n     */\n\
    \    using nptxqtop = FieldModel<uint32_t, address, 24, 7>;\n\n  public:\n   \
    \ /**\n     * @brief Register union\n     *\n     * Can be used to create a local\
    \ register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief NPTXFSAV field\n       *\n       * Non-periodic TxFIFO space\n\
    \       *               available\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 16> nptxfsav;\n      /**\n       * @brief NPTQXSAV field\n       *\n       *\
    \ Non-periodic transmit request queue\n       *               space available\n\
    \       */\n      BitFieldModel<uint32_t, 16, 8> nptqxsav;\n      /**\n      \
    \ * @brief NPTXQTOP field\n       *\n       * Top of the non-periodic transmit\
    \ request\n       *               queue\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 7> nptxqtop;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_GNPTXSTS register\n\
    \   *\n   * OTG_FS non-periodic transmit FIFO/queue\n   *           status register\
    \ (OTG_FS_GNPTXSTS)\n   */\n  using fs_gnptxsts = Fs_gnptxstsReg<BaseAddress +\
    \ 0x002C>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_gccfgReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ PWRDWN field\n     *\n     * Power down\n     */\n    using pwrdwn = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    /**\n     * @brief VBUSASEN field\n     *\n     * Enable\
    \ the VBUS sensing\n     *               device\n     */\n    using vbusasen =\
    \ FieldModel<uint32_t, address, 18, 1>;\n    /**\n     * @brief VBUSBSEN field\n\
    \     *\n     * Enable the VBUS sensing\n     *               device\n     */\n\
    \    using vbusbsen = FieldModel<uint32_t, address, 19, 1>;\n    /**\n     * @brief\
    \ SOFOUTEN field\n     *\n     * SOF output enable\n     */\n    using sofouten\
    \ = FieldModel<uint32_t, address, 20, 1>;\n    /**\n     * @brief NOVBUSSENS field\n\
    \     *\n     * No VBUS sensing\n     */\n    using novbussens = FieldModel<uint32_t,\
    \ address, 21, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief PWRDWN field\n       *\n\
    \       * Power down\n       */\n      BitFieldModel<uint32_t, 16, 1> pwrdwn;\n\
    \      /**\n       * @brief VBUSASEN field\n       *\n       * Enable the VBUS\
    \ sensing\n       *               device\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 1> vbusasen;\n      /**\n       * @brief VBUSBSEN field\n       *\n    \
    \   * Enable the VBUS sensing\n       *               device\n       */\n    \
    \  BitFieldModel<uint32_t, 19, 1> vbusbsen;\n      /**\n       * @brief SOFOUTEN\
    \ field\n       *\n       * SOF output enable\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 1> sofouten;\n      /**\n       * @brief NOVBUSSENS field\n       *\n  \
    \     * No VBUS sensing\n       */\n      BitFieldModel<uint32_t, 21, 1> novbussens;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief FS_GCCFG register\n   *\n   * OTG_FS\
    \ general core configuration register\n   *           (OTG_FS_GCCFG)\n   */\n\
    \  using fs_gccfg = Fs_gccfgReg<BaseAddress + 0x0038>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Fs_cidReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief PRODUCT_ID field\n     *\n     * Product\
    \ ID field\n     */\n    using product_id = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief PRODUCT_ID field\n       *\n       * Product\
    \ ID field\n       */\n      BitFieldModel<uint32_t, 0, 32> product_id;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief FS_CID register\n   *\n   * core ID register\n\
    \   */\n  using fs_cid = Fs_cidReg<BaseAddress + 0x003C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Fs_hptxfsizReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief PTXSA field\n     *\n     * Host periodic\
    \ TxFIFO start\n     *               address\n     */\n    using ptxsa = FieldModel<uint32_t,\
    \ address, 0, 16>;\n    /**\n     * @brief PTXFSIZ field\n     *\n     * Host\
    \ periodic TxFIFO depth\n     */\n    using ptxfsiz = FieldModel<uint32_t, address,\
    \ 16, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief PTXSA field\n       *\n\
    \       * Host periodic TxFIFO start\n       *               address\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ptxsa;\n      /**\n       * @brief PTXFSIZ\
    \ field\n       *\n       * Host periodic TxFIFO depth\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 16> ptxfsiz;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_HPTXFSIZ register\n\
    \   *\n   * OTG_FS Host periodic transmit FIFO size\n   *           register (OTG_FS_HPTXFSIZ)\n\
    \   */\n  using fs_hptxfsiz = Fs_hptxfsizReg<BaseAddress + 0x0100>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_dieptxf1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief INEPTXSA field\n     *\n  \
    \   * IN endpoint FIFO2 transmit RAM start\n     *               address\n   \
    \  */\n    using ineptxsa = FieldModel<uint32_t, address, 0, 16>;\n    /**\n \
    \    * @brief INEPTXFD field\n     *\n     * IN endpoint TxFIFO depth\n     */\n\
    \    using ineptxfd = FieldModel<uint32_t, address, 16, 16>;\n\n  public:\n  \
    \  /**\n     * @brief Register union\n     *\n     * Can be used to create a local\
    \ register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief INEPTXSA field\n       *\n       * IN endpoint FIFO2 transmit\
    \ RAM start\n       *               address\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> ineptxsa;\n      /**\n       * @brief INEPTXFD field\n       *\n    \
    \   * IN endpoint TxFIFO depth\n       */\n      BitFieldModel<uint32_t, 16, 16>\
    \ ineptxfd;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_DIEPTXF1 register\n\
    \   *\n   * OTG_FS device IN endpoint transmit FIFO size\n   *           register\
    \ (OTG_FS_DIEPTXF2)\n   */\n  using fs_dieptxf1 = Fs_dieptxf1Reg<BaseAddress +\
    \ 0x0104>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_dieptxf2Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ INEPTXSA field\n     *\n     * IN endpoint FIFO3 transmit RAM start\n     *\
    \               address\n     */\n    using ineptxsa = FieldModel<uint32_t, address,\
    \ 0, 16>;\n    /**\n     * @brief INEPTXFD field\n     *\n     * IN endpoint TxFIFO\
    \ depth\n     */\n    using ineptxfd = FieldModel<uint32_t, address, 16, 16>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief INEPTXSA field\n       *\n       * IN endpoint\
    \ FIFO3 transmit RAM start\n       *               address\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> ineptxsa;\n      /**\n       * @brief INEPTXFD field\n       *\n    \
    \   * IN endpoint TxFIFO depth\n       */\n      BitFieldModel<uint32_t, 16, 16>\
    \ ineptxfd;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_DIEPTXF2 register\n\
    \   *\n   * OTG_FS device IN endpoint transmit FIFO size\n   *           register\
    \ (OTG_FS_DIEPTXF3)\n   */\n  using fs_dieptxf2 = Fs_dieptxf2Reg<BaseAddress +\
    \ 0x0108>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_dieptxf3Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ INEPTXSA field\n     *\n     * IN endpoint FIFO4 transmit RAM start\n     *\
    \               address\n     */\n    using ineptxsa = FieldModel<uint32_t, address,\
    \ 0, 16>;\n    /**\n     * @brief INEPTXFD field\n     *\n     * IN endpoint TxFIFO\
    \ depth\n     */\n    using ineptxfd = FieldModel<uint32_t, address, 16, 16>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief INEPTXSA field\n       *\n       * IN endpoint\
    \ FIFO4 transmit RAM start\n       *               address\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> ineptxsa;\n      /**\n       * @brief INEPTXFD field\n       *\n    \
    \   * IN endpoint TxFIFO depth\n       */\n      BitFieldModel<uint32_t, 16, 16>\
    \ ineptxfd;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_DIEPTXF3 register\n\
    \   *\n   * OTG_FS device IN endpoint transmit FIFO size\n   *           register\
    \ (OTG_FS_DIEPTXF4)\n   */\n  using fs_dieptxf3 = Fs_dieptxf3Reg<BaseAddress +\
    \ 0x010C>;\n\nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n\
    \  class Fs_grxstsx_deviceBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    /**\n     * @brief EPNUM field\n     *\n  \
    \   * Endpoint number\n     */\n    using epnum = FieldModel<uint32_t, address,\
    \ 0, 4, bankOffset>;\n    /**\n     * @brief BCNT field\n     *\n     * Byte count\n\
    \     */\n    using bcnt = FieldModel<uint32_t, address, 4, 11, bankOffset>;\n\
    \    /**\n     * @brief DPID field\n     *\n     * Data PID\n     */\n    using\
    \ dpid = FieldModel<uint32_t, address, 15, 2, bankOffset>;\n    /**\n     * @brief\
    \ PKTSTS field\n     *\n     * Packet status\n     */\n    using pktsts = FieldModel<uint32_t,\
    \ address, 17, 4, bankOffset>;\n    /**\n     * @brief FRMNUM field\n     *\n\
    \     * Frame number\n     */\n    using frmnum = FieldModel<uint32_t, address,\
    \ 21, 4, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      /**\n       * @brief EPNUM field\n       *\n       * Endpoint number\n\
    \       */\n      BitFieldModel<uint32_t, 0, 4> epnum;\n      /**\n       * @brief\
    \ BCNT field\n       *\n       * Byte count\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 11> bcnt;\n      /**\n       * @brief DPID field\n       *\n       * Data\
    \ PID\n       */\n      BitFieldModel<uint32_t, 15, 2> dpid;\n      /**\n    \
    \   * @brief PKTSTS field\n       *\n       * Packet status\n       */\n     \
    \ BitFieldModel<uint32_t, 17, 4> pktsts;\n      /**\n       * @brief FRMNUM field\n\
    \       *\n       * Frame number\n       */\n      BitFieldModel<uint32_t, 21,\
    \ 4> frmnum;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_GRXSTSX_DEVICE register\
    \ bank\n   *\n   * OTG_FS Receive status debug read(Device\n   *           mode)\n\
    \   */\n  using fs_grxstsx_device = Fs_grxstsx_deviceBankReg<BaseAddress + 0x001C,\
    \ 0x0004>;\n\nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n\
    \  class Fs_grxstsx_hostBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    /**\n     * @brief EPNUM field\n     *\n  \
    \   * Endpoint number\n     */\n    using epnum = FieldModel<uint32_t, address,\
    \ 0, 4, bankOffset>;\n    /**\n     * @brief BCNT field\n     *\n     * Byte count\n\
    \     */\n    using bcnt = FieldModel<uint32_t, address, 4, 11, bankOffset>;\n\
    \    /**\n     * @brief DPID field\n     *\n     * Data PID\n     */\n    using\
    \ dpid = FieldModel<uint32_t, address, 15, 2, bankOffset>;\n    /**\n     * @brief\
    \ PKTSTS field\n     *\n     * Packet status\n     */\n    using pktsts = FieldModel<uint32_t,\
    \ address, 17, 4, bankOffset>;\n    /**\n     * @brief FRMNUM field\n     *\n\
    \     * Frame number\n     */\n    using frmnum = FieldModel<uint32_t, address,\
    \ 21, 4, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      /**\n       * @brief EPNUM field\n       *\n       * Endpoint number\n\
    \       */\n      BitFieldModel<uint32_t, 0, 4> epnum;\n      /**\n       * @brief\
    \ BCNT field\n       *\n       * Byte count\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 11> bcnt;\n      /**\n       * @brief DPID field\n       *\n       * Data\
    \ PID\n       */\n      BitFieldModel<uint32_t, 15, 2> dpid;\n      /**\n    \
    \   * @brief PKTSTS field\n       *\n       * Packet status\n       */\n     \
    \ BitFieldModel<uint32_t, 17, 4> pktsts;\n      /**\n       * @brief FRMNUM field\n\
    \       *\n       * Frame number\n       */\n      BitFieldModel<uint32_t, 21,\
    \ 4> frmnum;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_GRXSTSX_HOST register\
    \ bank\n   *\n   * OTG_FS Receive status debug read(Host\n   *           mode)\n\
    \   */\n  using fs_grxstsx_host = Fs_grxstsx_hostBankReg<BaseAddress + 0x001C,\
    \ 0x0004>;\n\nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n\
    \  class Fs_dieptxfxBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n\
    \  {\n  public:\n    /**\n     * @brief INEPTXSA field\n     *\n     * IN endpoint\
    \ FIFO2 transmit RAM start\n     *               address\n     */\n    using ineptxsa\
    \ = FieldModel<uint32_t, address, 0, 16, bankOffset>;\n    /**\n     * @brief\
    \ INEPTXFD field\n     *\n     * IN endpoint TxFIFO depth\n     */\n    using\
    \ ineptxfd = FieldModel<uint32_t, address, 16, 16, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief INEPTXSA\
    \ field\n       *\n       * IN endpoint FIFO2 transmit RAM start\n       *   \
    \            address\n       */\n      BitFieldModel<uint32_t, 0, 16> ineptxsa;\n\
    \      /**\n       * @brief INEPTXFD field\n       *\n       * IN endpoint TxFIFO\
    \ depth\n       */\n      BitFieldModel<uint32_t, 16, 16> ineptxfd;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief FS_DIEPTXFX register bank\n   *\n   * OTG_FS\
    \ device IN endpoint transmit FIFO size\n   *           register (OTG_FS_DIEPTXF2)\n\
    \   */\n  using fs_dieptxfx = Fs_dieptxfxBankReg<BaseAddress + 0x0104, 0x0004>;\n\
    \n};\n\n}\n\n#endif /* DRAL_STM32F411_OTG_FS_GLOBAL_H */"
  name: OTG_FS_GLOBAL
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_OTG_FS_HOST_H\n#define DRAL_STM32F411_OTG_FS_HOST_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ OTG_FS_HOST peripheral\n *\n * USB on the go full speed\n */\nclass otg_fs_host\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x50000400; /**< Peripheral\
    \ base address */\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcfgReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ FSLSPCS field\n     *\n     * FS/LS PHY clock select\n     */\n    using fslspcs\
    \ = FieldModel<uint32_t, address, 0, 2>;\n    /**\n     * @brief FSLSS field\n\
    \     *\n     * FS- and LS-only support\n     */\n    using fslss = FieldModel<uint32_t,\
    \ address, 2, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief FSLSPCS field\n       *\n\
    \       * FS/LS PHY clock select\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 2> fslspcs;\n      /**\n       * @brief FSLSS field\n       *\n       * FS-\
    \ and LS-only support\n       */\n      BitFieldModel<uint32_t, 2, 1> fslss;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief FS_HCFG register\n   *\n   * OTG_FS\
    \ host configuration register\n   *           (OTG_FS_HCFG)\n   */\n  using fs_hcfg\
    \ = Fs_hcfgReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class HfirReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief FRIVL field\n     *\n     * Frame interval\n     */\n \
    \   using frivl = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ FRIVL field\n       *\n       * Frame interval\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> frivl;\n    };\n  };\n\npublic:\n  /**\n   * @brief HFIR register\n \
    \  *\n   * OTG_FS Host frame interval\n   *           register\n   */\n  using\
    \ hfir = HfirReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Fs_hfnumReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief FRNUM field\n     *\n     * Frame number\n     */\n  \
    \  using frnum = FieldModel<uint32_t, address, 0, 16>;\n    /**\n     * @brief\
    \ FTREM field\n     *\n     * Frame time remaining\n     */\n    using ftrem =\
    \ FieldModel<uint32_t, address, 16, 16>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ FRNUM field\n       *\n       * Frame number\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> frnum;\n      /**\n       * @brief FTREM field\n       *\n       * Frame\
    \ time remaining\n       */\n      BitFieldModel<uint32_t, 16, 16> ftrem;\n  \
    \  };\n  };\n\npublic:\n  /**\n   * @brief FS_HFNUM register\n   *\n   * OTG_FS\
    \ host frame number/frame time\n   *           remaining register (OTG_FS_HFNUM)\n\
    \   */\n  using fs_hfnum = Fs_hfnumReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Fs_hptxstsReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief PTXFSAVL field\n     *\n     * Periodic\
    \ transmit data FIFO space\n     *               available\n     */\n    using\
    \ ptxfsavl = FieldModel<uint32_t, address, 0, 16>;\n    /**\n     * @brief PTXQSAV\
    \ field\n     *\n     * Periodic transmit request queue space\n     *        \
    \       available\n     */\n    using ptxqsav = FieldModel<uint32_t, address,\
    \ 16, 8>;\n    /**\n     * @brief PTXQTOP field\n     *\n     * Top of the periodic\
    \ transmit request\n     *               queue\n     */\n    using ptxqtop = FieldModel<uint32_t,\
    \ address, 24, 8>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief PTXFSAVL field\n      \
    \ *\n       * Periodic transmit data FIFO space\n       *               available\n\
    \       */\n      BitFieldModel<uint32_t, 0, 16> ptxfsavl;\n      /**\n      \
    \ * @brief PTXQSAV field\n       *\n       * Periodic transmit request queue space\n\
    \       *               available\n       */\n      BitFieldModel<uint32_t, 16,\
    \ 8> ptxqsav;\n      /**\n       * @brief PTXQTOP field\n       *\n       * Top\
    \ of the periodic transmit request\n       *               queue\n       */\n\
    \      BitFieldModel<uint32_t, 24, 8> ptxqtop;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief FS_HPTXSTS register\n   *\n   * OTG_FS_Host periodic transmit FIFO/queue\n\
    \   *           status register (OTG_FS_HPTXSTS)\n   */\n  using fs_hptxsts =\
    \ Fs_hptxstsReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class HaintReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief HAINT field\n     *\n     * Channel interrupts\n     */\n\
    \    using haint = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ HAINT field\n       *\n       * Channel interrupts\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> haint;\n    };\n  };\n\npublic:\n  /**\n   * @brief HAINT register\n\
    \   *\n   * OTG_FS Host all channels interrupt\n   *           register\n   */\n\
    \  using haint = HaintReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class HaintmskReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief HAINTM field\n     *\n     * Channel interrupt\
    \ mask\n     */\n    using haintm = FieldModel<uint32_t, address, 0, 16>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief HAINTM field\n       *\n       * Channel\
    \ interrupt mask\n       */\n      BitFieldModel<uint32_t, 0, 16> haintm;\n  \
    \  };\n  };\n\npublic:\n  /**\n   * @brief HAINTMSK register\n   *\n   * OTG_FS\
    \ host all channels interrupt mask\n   *           register\n   */\n  using haintmsk\
    \ = HaintmskReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Fs_hprtReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief PCSTS field\n     *\n     * Port connect status\n    \
    \ */\n    using pcsts = FieldModel<uint32_t, address, 0, 1>;\n    /**\n     *\
    \ @brief PCDET field\n     *\n     * Port connect detected\n     */\n    using\
    \ pcdet = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief PENA field\n\
    \     *\n     * Port enable\n     */\n    using pena = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief PENCHNG field\n     *\n     * Port enable/disable\
    \ change\n     */\n    using penchng = FieldModel<uint32_t, address, 3, 1>;\n\
    \    /**\n     * @brief POCA field\n     *\n     * Port overcurrent active\n \
    \    */\n    using poca = FieldModel<uint32_t, address, 4, 1>;\n    /**\n    \
    \ * @brief POCCHNG field\n     *\n     * Port overcurrent change\n     */\n  \
    \  using pocchng = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief\
    \ PRES field\n     *\n     * Port resume\n     */\n    using pres = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief PSUSP field\n     *\n     * Port suspend\n\
    \     */\n    using psusp = FieldModel<uint32_t, address, 7, 1>;\n    /**\n  \
    \   * @brief PRST field\n     *\n     * Port reset\n     */\n    using prst =\
    \ FieldModel<uint32_t, address, 8, 1>;\n    /**\n     * @brief PLSTS field\n \
    \    *\n     * Port line status\n     */\n    using plsts = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    /**\n     * @brief PPWR field\n     *\n     * Port power\n\
    \     */\n    using ppwr = FieldModel<uint32_t, address, 12, 1>;\n    /**\n  \
    \   * @brief PTCTL field\n     *\n     * Port test control\n     */\n    using\
    \ ptctl = FieldModel<uint32_t, address, 13, 4>;\n    /**\n     * @brief PSPD field\n\
    \     *\n     * Port speed\n     */\n    using pspd = FieldModel<uint32_t, address,\
    \ 17, 2>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief PCSTS field\n       *\n\
    \       * Port connect status\n       */\n      BitFieldModel<uint32_t, 0, 1>\
    \ pcsts;\n      /**\n       * @brief PCDET field\n       *\n       * Port connect\
    \ detected\n       */\n      BitFieldModel<uint32_t, 1, 1> pcdet;\n      /**\n\
    \       * @brief PENA field\n       *\n       * Port enable\n       */\n     \
    \ BitFieldModel<uint32_t, 2, 1> pena;\n      /**\n       * @brief PENCHNG field\n\
    \       *\n       * Port enable/disable change\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> penchng;\n      /**\n       * @brief POCA field\n       *\n       * Port\
    \ overcurrent active\n       */\n      BitFieldModel<uint32_t, 4, 1> poca;\n \
    \     /**\n       * @brief POCCHNG field\n       *\n       * Port overcurrent\
    \ change\n       */\n      BitFieldModel<uint32_t, 5, 1> pocchng;\n      /**\n\
    \       * @brief PRES field\n       *\n       * Port resume\n       */\n     \
    \ BitFieldModel<uint32_t, 6, 1> pres;\n      /**\n       * @brief PSUSP field\n\
    \       *\n       * Port suspend\n       */\n      BitFieldModel<uint32_t, 7,\
    \ 1> psusp;\n      /**\n       * @brief PRST field\n       *\n       * Port reset\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> prst;\n      /**\n       * @brief\
    \ PLSTS field\n       *\n       * Port line status\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 2> plsts;\n      /**\n       * @brief PPWR field\n       *\n       * Port\
    \ power\n       */\n      BitFieldModel<uint32_t, 12, 1> ppwr;\n      /**\n  \
    \     * @brief PTCTL field\n       *\n       * Port test control\n       */\n\
    \      BitFieldModel<uint32_t, 13, 4> ptctl;\n      /**\n       * @brief PSPD\
    \ field\n       *\n       * Port speed\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 2> pspd;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_HPRT register\n\
    \   *\n   * OTG_FS host port control and status register\n   *           (OTG_FS_HPRT)\n\
    \   */\n  using fs_hprt = Fs_hprtReg<BaseAddress + 0x0040>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Fs_hcchar0Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief MPSIZ field\n     *\n     * Maximum packet\
    \ size\n     */\n    using mpsiz = FieldModel<uint32_t, address, 0, 11>;\n   \
    \ /**\n     * @brief EPNUM field\n     *\n     * Endpoint number\n     */\n  \
    \  using epnum = FieldModel<uint32_t, address, 11, 4>;\n    /**\n     * @brief\
    \ EPDIR field\n     *\n     * Endpoint direction\n     */\n    using epdir = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief LSDEV field\n     *\n     * Low-speed\
    \ device\n     */\n    using lsdev = FieldModel<uint32_t, address, 17, 1>;\n \
    \   /**\n     * @brief EPTYP field\n     *\n     * Endpoint type\n     */\n  \
    \  using eptyp = FieldModel<uint32_t, address, 18, 2>;\n    /**\n     * @brief\
    \ MCNT field\n     *\n     * Multicount\n     */\n    using mcnt = FieldModel<uint32_t,\
    \ address, 20, 2>;\n    /**\n     * @brief DAD field\n     *\n     * Device address\n\
    \     */\n    using dad = FieldModel<uint32_t, address, 22, 7>;\n    /**\n   \
    \  * @brief ODDFRM field\n     *\n     * Odd frame\n     */\n    using oddfrm\
    \ = FieldModel<uint32_t, address, 29, 1>;\n    /**\n     * @brief CHDIS field\n\
    \     *\n     * Channel disable\n     */\n    using chdis = FieldModel<uint32_t,\
    \ address, 30, 1>;\n    /**\n     * @brief CHENA field\n     *\n     * Channel\
    \ enable\n     */\n    using chena = FieldModel<uint32_t, address, 31, 1>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief MPSIZ field\n       *\n       * Maximum packet\
    \ size\n       */\n      BitFieldModel<uint32_t, 0, 11> mpsiz;\n      /**\n  \
    \     * @brief EPNUM field\n       *\n       * Endpoint number\n       */\n  \
    \    BitFieldModel<uint32_t, 11, 4> epnum;\n      /**\n       * @brief EPDIR field\n\
    \       *\n       * Endpoint direction\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> epdir;\n      /**\n       * @brief LSDEV field\n       *\n       * Low-speed\
    \ device\n       */\n      BitFieldModel<uint32_t, 17, 1> lsdev;\n      /**\n\
    \       * @brief EPTYP field\n       *\n       * Endpoint type\n       */\n  \
    \    BitFieldModel<uint32_t, 18, 2> eptyp;\n      /**\n       * @brief MCNT field\n\
    \       *\n       * Multicount\n       */\n      BitFieldModel<uint32_t, 20, 2>\
    \ mcnt;\n      /**\n       * @brief DAD field\n       *\n       * Device address\n\
    \       */\n      BitFieldModel<uint32_t, 22, 7> dad;\n      /**\n       * @brief\
    \ ODDFRM field\n       *\n       * Odd frame\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 1> oddfrm;\n      /**\n       * @brief CHDIS field\n       *\n       * Channel\
    \ disable\n       */\n      BitFieldModel<uint32_t, 30, 1> chdis;\n      /**\n\
    \       * @brief CHENA field\n       *\n       * Channel enable\n       */\n \
    \     BitFieldModel<uint32_t, 31, 1> chena;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief FS_HCCHAR0 register\n   *\n   * OTG_FS host channel-0 characteristics\n\
    \   *           register (OTG_FS_HCCHAR0)\n   */\n  using fs_hcchar0 = Fs_hcchar0Reg<BaseAddress\
    \ + 0x0100>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcchar1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ MPSIZ field\n     *\n     * Maximum packet size\n     */\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    /**\n     * @brief EPNUM field\n\
    \     *\n     * Endpoint number\n     */\n    using epnum = FieldModel<uint32_t,\
    \ address, 11, 4>;\n    /**\n     * @brief EPDIR field\n     *\n     * Endpoint\
    \ direction\n     */\n    using epdir = FieldModel<uint32_t, address, 15, 1>;\n\
    \    /**\n     * @brief LSDEV field\n     *\n     * Low-speed device\n     */\n\
    \    using lsdev = FieldModel<uint32_t, address, 17, 1>;\n    /**\n     * @brief\
    \ EPTYP field\n     *\n     * Endpoint type\n     */\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    /**\n     * @brief MCNT field\n     *\n     * Multicount\n\
    \     */\n    using mcnt = FieldModel<uint32_t, address, 20, 2>;\n    /**\n  \
    \   * @brief DAD field\n     *\n     * Device address\n     */\n    using dad\
    \ = FieldModel<uint32_t, address, 22, 7>;\n    /**\n     * @brief ODDFRM field\n\
    \     *\n     * Odd frame\n     */\n    using oddfrm = FieldModel<uint32_t, address,\
    \ 29, 1>;\n    /**\n     * @brief CHDIS field\n     *\n     * Channel disable\n\
    \     */\n    using chdis = FieldModel<uint32_t, address, 30, 1>;\n    /**\n \
    \    * @brief CHENA field\n     *\n     * Channel enable\n     */\n    using chena\
    \ = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ MPSIZ field\n       *\n       * Maximum packet size\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 11> mpsiz;\n      /**\n       * @brief EPNUM field\n       *\n       * Endpoint\
    \ number\n       */\n      BitFieldModel<uint32_t, 11, 4> epnum;\n      /**\n\
    \       * @brief EPDIR field\n       *\n       * Endpoint direction\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> epdir;\n      /**\n       * @brief LSDEV\
    \ field\n       *\n       * Low-speed device\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> lsdev;\n      /**\n       * @brief EPTYP field\n       *\n       * Endpoint\
    \ type\n       */\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      /**\n  \
    \     * @brief MCNT field\n       *\n       * Multicount\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 2> mcnt;\n      /**\n       * @brief DAD field\n       *\n       * Device\
    \ address\n       */\n      BitFieldModel<uint32_t, 22, 7> dad;\n      /**\n \
    \      * @brief ODDFRM field\n       *\n       * Odd frame\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 1> oddfrm;\n      /**\n       * @brief CHDIS field\n       *\n       * Channel\
    \ disable\n       */\n      BitFieldModel<uint32_t, 30, 1> chdis;\n      /**\n\
    \       * @brief CHENA field\n       *\n       * Channel enable\n       */\n \
    \     BitFieldModel<uint32_t, 31, 1> chena;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief FS_HCCHAR1 register\n   *\n   * OTG_FS host channel-1 characteristics\n\
    \   *           register (OTG_FS_HCCHAR1)\n   */\n  using fs_hcchar1 = Fs_hcchar1Reg<BaseAddress\
    \ + 0x0120>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcchar2Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ MPSIZ field\n     *\n     * Maximum packet size\n     */\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    /**\n     * @brief EPNUM field\n\
    \     *\n     * Endpoint number\n     */\n    using epnum = FieldModel<uint32_t,\
    \ address, 11, 4>;\n    /**\n     * @brief EPDIR field\n     *\n     * Endpoint\
    \ direction\n     */\n    using epdir = FieldModel<uint32_t, address, 15, 1>;\n\
    \    /**\n     * @brief LSDEV field\n     *\n     * Low-speed device\n     */\n\
    \    using lsdev = FieldModel<uint32_t, address, 17, 1>;\n    /**\n     * @brief\
    \ EPTYP field\n     *\n     * Endpoint type\n     */\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    /**\n     * @brief MCNT field\n     *\n     * Multicount\n\
    \     */\n    using mcnt = FieldModel<uint32_t, address, 20, 2>;\n    /**\n  \
    \   * @brief DAD field\n     *\n     * Device address\n     */\n    using dad\
    \ = FieldModel<uint32_t, address, 22, 7>;\n    /**\n     * @brief ODDFRM field\n\
    \     *\n     * Odd frame\n     */\n    using oddfrm = FieldModel<uint32_t, address,\
    \ 29, 1>;\n    /**\n     * @brief CHDIS field\n     *\n     * Channel disable\n\
    \     */\n    using chdis = FieldModel<uint32_t, address, 30, 1>;\n    /**\n \
    \    * @brief CHENA field\n     *\n     * Channel enable\n     */\n    using chena\
    \ = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ MPSIZ field\n       *\n       * Maximum packet size\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 11> mpsiz;\n      /**\n       * @brief EPNUM field\n       *\n       * Endpoint\
    \ number\n       */\n      BitFieldModel<uint32_t, 11, 4> epnum;\n      /**\n\
    \       * @brief EPDIR field\n       *\n       * Endpoint direction\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> epdir;\n      /**\n       * @brief LSDEV\
    \ field\n       *\n       * Low-speed device\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> lsdev;\n      /**\n       * @brief EPTYP field\n       *\n       * Endpoint\
    \ type\n       */\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      /**\n  \
    \     * @brief MCNT field\n       *\n       * Multicount\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 2> mcnt;\n      /**\n       * @brief DAD field\n       *\n       * Device\
    \ address\n       */\n      BitFieldModel<uint32_t, 22, 7> dad;\n      /**\n \
    \      * @brief ODDFRM field\n       *\n       * Odd frame\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 1> oddfrm;\n      /**\n       * @brief CHDIS field\n       *\n       * Channel\
    \ disable\n       */\n      BitFieldModel<uint32_t, 30, 1> chdis;\n      /**\n\
    \       * @brief CHENA field\n       *\n       * Channel enable\n       */\n \
    \     BitFieldModel<uint32_t, 31, 1> chena;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief FS_HCCHAR2 register\n   *\n   * OTG_FS host channel-2 characteristics\n\
    \   *           register (OTG_FS_HCCHAR2)\n   */\n  using fs_hcchar2 = Fs_hcchar2Reg<BaseAddress\
    \ + 0x0140>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcchar3Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ MPSIZ field\n     *\n     * Maximum packet size\n     */\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    /**\n     * @brief EPNUM field\n\
    \     *\n     * Endpoint number\n     */\n    using epnum = FieldModel<uint32_t,\
    \ address, 11, 4>;\n    /**\n     * @brief EPDIR field\n     *\n     * Endpoint\
    \ direction\n     */\n    using epdir = FieldModel<uint32_t, address, 15, 1>;\n\
    \    /**\n     * @brief LSDEV field\n     *\n     * Low-speed device\n     */\n\
    \    using lsdev = FieldModel<uint32_t, address, 17, 1>;\n    /**\n     * @brief\
    \ EPTYP field\n     *\n     * Endpoint type\n     */\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    /**\n     * @brief MCNT field\n     *\n     * Multicount\n\
    \     */\n    using mcnt = FieldModel<uint32_t, address, 20, 2>;\n    /**\n  \
    \   * @brief DAD field\n     *\n     * Device address\n     */\n    using dad\
    \ = FieldModel<uint32_t, address, 22, 7>;\n    /**\n     * @brief ODDFRM field\n\
    \     *\n     * Odd frame\n     */\n    using oddfrm = FieldModel<uint32_t, address,\
    \ 29, 1>;\n    /**\n     * @brief CHDIS field\n     *\n     * Channel disable\n\
    \     */\n    using chdis = FieldModel<uint32_t, address, 30, 1>;\n    /**\n \
    \    * @brief CHENA field\n     *\n     * Channel enable\n     */\n    using chena\
    \ = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ MPSIZ field\n       *\n       * Maximum packet size\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 11> mpsiz;\n      /**\n       * @brief EPNUM field\n       *\n       * Endpoint\
    \ number\n       */\n      BitFieldModel<uint32_t, 11, 4> epnum;\n      /**\n\
    \       * @brief EPDIR field\n       *\n       * Endpoint direction\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> epdir;\n      /**\n       * @brief LSDEV\
    \ field\n       *\n       * Low-speed device\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> lsdev;\n      /**\n       * @brief EPTYP field\n       *\n       * Endpoint\
    \ type\n       */\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      /**\n  \
    \     * @brief MCNT field\n       *\n       * Multicount\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 2> mcnt;\n      /**\n       * @brief DAD field\n       *\n       * Device\
    \ address\n       */\n      BitFieldModel<uint32_t, 22, 7> dad;\n      /**\n \
    \      * @brief ODDFRM field\n       *\n       * Odd frame\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 1> oddfrm;\n      /**\n       * @brief CHDIS field\n       *\n       * Channel\
    \ disable\n       */\n      BitFieldModel<uint32_t, 30, 1> chdis;\n      /**\n\
    \       * @brief CHENA field\n       *\n       * Channel enable\n       */\n \
    \     BitFieldModel<uint32_t, 31, 1> chena;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief FS_HCCHAR3 register\n   *\n   * OTG_FS host channel-3 characteristics\n\
    \   *           register (OTG_FS_HCCHAR3)\n   */\n  using fs_hcchar3 = Fs_hcchar3Reg<BaseAddress\
    \ + 0x0160>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcchar4Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ MPSIZ field\n     *\n     * Maximum packet size\n     */\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    /**\n     * @brief EPNUM field\n\
    \     *\n     * Endpoint number\n     */\n    using epnum = FieldModel<uint32_t,\
    \ address, 11, 4>;\n    /**\n     * @brief EPDIR field\n     *\n     * Endpoint\
    \ direction\n     */\n    using epdir = FieldModel<uint32_t, address, 15, 1>;\n\
    \    /**\n     * @brief LSDEV field\n     *\n     * Low-speed device\n     */\n\
    \    using lsdev = FieldModel<uint32_t, address, 17, 1>;\n    /**\n     * @brief\
    \ EPTYP field\n     *\n     * Endpoint type\n     */\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    /**\n     * @brief MCNT field\n     *\n     * Multicount\n\
    \     */\n    using mcnt = FieldModel<uint32_t, address, 20, 2>;\n    /**\n  \
    \   * @brief DAD field\n     *\n     * Device address\n     */\n    using dad\
    \ = FieldModel<uint32_t, address, 22, 7>;\n    /**\n     * @brief ODDFRM field\n\
    \     *\n     * Odd frame\n     */\n    using oddfrm = FieldModel<uint32_t, address,\
    \ 29, 1>;\n    /**\n     * @brief CHDIS field\n     *\n     * Channel disable\n\
    \     */\n    using chdis = FieldModel<uint32_t, address, 30, 1>;\n    /**\n \
    \    * @brief CHENA field\n     *\n     * Channel enable\n     */\n    using chena\
    \ = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ MPSIZ field\n       *\n       * Maximum packet size\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 11> mpsiz;\n      /**\n       * @brief EPNUM field\n       *\n       * Endpoint\
    \ number\n       */\n      BitFieldModel<uint32_t, 11, 4> epnum;\n      /**\n\
    \       * @brief EPDIR field\n       *\n       * Endpoint direction\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> epdir;\n      /**\n       * @brief LSDEV\
    \ field\n       *\n       * Low-speed device\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> lsdev;\n      /**\n       * @brief EPTYP field\n       *\n       * Endpoint\
    \ type\n       */\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      /**\n  \
    \     * @brief MCNT field\n       *\n       * Multicount\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 2> mcnt;\n      /**\n       * @brief DAD field\n       *\n       * Device\
    \ address\n       */\n      BitFieldModel<uint32_t, 22, 7> dad;\n      /**\n \
    \      * @brief ODDFRM field\n       *\n       * Odd frame\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 1> oddfrm;\n      /**\n       * @brief CHDIS field\n       *\n       * Channel\
    \ disable\n       */\n      BitFieldModel<uint32_t, 30, 1> chdis;\n      /**\n\
    \       * @brief CHENA field\n       *\n       * Channel enable\n       */\n \
    \     BitFieldModel<uint32_t, 31, 1> chena;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief FS_HCCHAR4 register\n   *\n   * OTG_FS host channel-4 characteristics\n\
    \   *           register (OTG_FS_HCCHAR4)\n   */\n  using fs_hcchar4 = Fs_hcchar4Reg<BaseAddress\
    \ + 0x0180>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcchar5Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ MPSIZ field\n     *\n     * Maximum packet size\n     */\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    /**\n     * @brief EPNUM field\n\
    \     *\n     * Endpoint number\n     */\n    using epnum = FieldModel<uint32_t,\
    \ address, 11, 4>;\n    /**\n     * @brief EPDIR field\n     *\n     * Endpoint\
    \ direction\n     */\n    using epdir = FieldModel<uint32_t, address, 15, 1>;\n\
    \    /**\n     * @brief LSDEV field\n     *\n     * Low-speed device\n     */\n\
    \    using lsdev = FieldModel<uint32_t, address, 17, 1>;\n    /**\n     * @brief\
    \ EPTYP field\n     *\n     * Endpoint type\n     */\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    /**\n     * @brief MCNT field\n     *\n     * Multicount\n\
    \     */\n    using mcnt = FieldModel<uint32_t, address, 20, 2>;\n    /**\n  \
    \   * @brief DAD field\n     *\n     * Device address\n     */\n    using dad\
    \ = FieldModel<uint32_t, address, 22, 7>;\n    /**\n     * @brief ODDFRM field\n\
    \     *\n     * Odd frame\n     */\n    using oddfrm = FieldModel<uint32_t, address,\
    \ 29, 1>;\n    /**\n     * @brief CHDIS field\n     *\n     * Channel disable\n\
    \     */\n    using chdis = FieldModel<uint32_t, address, 30, 1>;\n    /**\n \
    \    * @brief CHENA field\n     *\n     * Channel enable\n     */\n    using chena\
    \ = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ MPSIZ field\n       *\n       * Maximum packet size\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 11> mpsiz;\n      /**\n       * @brief EPNUM field\n       *\n       * Endpoint\
    \ number\n       */\n      BitFieldModel<uint32_t, 11, 4> epnum;\n      /**\n\
    \       * @brief EPDIR field\n       *\n       * Endpoint direction\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> epdir;\n      /**\n       * @brief LSDEV\
    \ field\n       *\n       * Low-speed device\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> lsdev;\n      /**\n       * @brief EPTYP field\n       *\n       * Endpoint\
    \ type\n       */\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      /**\n  \
    \     * @brief MCNT field\n       *\n       * Multicount\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 2> mcnt;\n      /**\n       * @brief DAD field\n       *\n       * Device\
    \ address\n       */\n      BitFieldModel<uint32_t, 22, 7> dad;\n      /**\n \
    \      * @brief ODDFRM field\n       *\n       * Odd frame\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 1> oddfrm;\n      /**\n       * @brief CHDIS field\n       *\n       * Channel\
    \ disable\n       */\n      BitFieldModel<uint32_t, 30, 1> chdis;\n      /**\n\
    \       * @brief CHENA field\n       *\n       * Channel enable\n       */\n \
    \     BitFieldModel<uint32_t, 31, 1> chena;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief FS_HCCHAR5 register\n   *\n   * OTG_FS host channel-5 characteristics\n\
    \   *           register (OTG_FS_HCCHAR5)\n   */\n  using fs_hcchar5 = Fs_hcchar5Reg<BaseAddress\
    \ + 0x01A0>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcchar6Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ MPSIZ field\n     *\n     * Maximum packet size\n     */\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    /**\n     * @brief EPNUM field\n\
    \     *\n     * Endpoint number\n     */\n    using epnum = FieldModel<uint32_t,\
    \ address, 11, 4>;\n    /**\n     * @brief EPDIR field\n     *\n     * Endpoint\
    \ direction\n     */\n    using epdir = FieldModel<uint32_t, address, 15, 1>;\n\
    \    /**\n     * @brief LSDEV field\n     *\n     * Low-speed device\n     */\n\
    \    using lsdev = FieldModel<uint32_t, address, 17, 1>;\n    /**\n     * @brief\
    \ EPTYP field\n     *\n     * Endpoint type\n     */\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    /**\n     * @brief MCNT field\n     *\n     * Multicount\n\
    \     */\n    using mcnt = FieldModel<uint32_t, address, 20, 2>;\n    /**\n  \
    \   * @brief DAD field\n     *\n     * Device address\n     */\n    using dad\
    \ = FieldModel<uint32_t, address, 22, 7>;\n    /**\n     * @brief ODDFRM field\n\
    \     *\n     * Odd frame\n     */\n    using oddfrm = FieldModel<uint32_t, address,\
    \ 29, 1>;\n    /**\n     * @brief CHDIS field\n     *\n     * Channel disable\n\
    \     */\n    using chdis = FieldModel<uint32_t, address, 30, 1>;\n    /**\n \
    \    * @brief CHENA field\n     *\n     * Channel enable\n     */\n    using chena\
    \ = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ MPSIZ field\n       *\n       * Maximum packet size\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 11> mpsiz;\n      /**\n       * @brief EPNUM field\n       *\n       * Endpoint\
    \ number\n       */\n      BitFieldModel<uint32_t, 11, 4> epnum;\n      /**\n\
    \       * @brief EPDIR field\n       *\n       * Endpoint direction\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> epdir;\n      /**\n       * @brief LSDEV\
    \ field\n       *\n       * Low-speed device\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> lsdev;\n      /**\n       * @brief EPTYP field\n       *\n       * Endpoint\
    \ type\n       */\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      /**\n  \
    \     * @brief MCNT field\n       *\n       * Multicount\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 2> mcnt;\n      /**\n       * @brief DAD field\n       *\n       * Device\
    \ address\n       */\n      BitFieldModel<uint32_t, 22, 7> dad;\n      /**\n \
    \      * @brief ODDFRM field\n       *\n       * Odd frame\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 1> oddfrm;\n      /**\n       * @brief CHDIS field\n       *\n       * Channel\
    \ disable\n       */\n      BitFieldModel<uint32_t, 30, 1> chdis;\n      /**\n\
    \       * @brief CHENA field\n       *\n       * Channel enable\n       */\n \
    \     BitFieldModel<uint32_t, 31, 1> chena;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief FS_HCCHAR6 register\n   *\n   * OTG_FS host channel-6 characteristics\n\
    \   *           register (OTG_FS_HCCHAR6)\n   */\n  using fs_hcchar6 = Fs_hcchar6Reg<BaseAddress\
    \ + 0x01C0>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcchar7Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ MPSIZ field\n     *\n     * Maximum packet size\n     */\n    using mpsiz =\
    \ FieldModel<uint32_t, address, 0, 11>;\n    /**\n     * @brief EPNUM field\n\
    \     *\n     * Endpoint number\n     */\n    using epnum = FieldModel<uint32_t,\
    \ address, 11, 4>;\n    /**\n     * @brief EPDIR field\n     *\n     * Endpoint\
    \ direction\n     */\n    using epdir = FieldModel<uint32_t, address, 15, 1>;\n\
    \    /**\n     * @brief LSDEV field\n     *\n     * Low-speed device\n     */\n\
    \    using lsdev = FieldModel<uint32_t, address, 17, 1>;\n    /**\n     * @brief\
    \ EPTYP field\n     *\n     * Endpoint type\n     */\n    using eptyp = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    /**\n     * @brief MCNT field\n     *\n     * Multicount\n\
    \     */\n    using mcnt = FieldModel<uint32_t, address, 20, 2>;\n    /**\n  \
    \   * @brief DAD field\n     *\n     * Device address\n     */\n    using dad\
    \ = FieldModel<uint32_t, address, 22, 7>;\n    /**\n     * @brief ODDFRM field\n\
    \     *\n     * Odd frame\n     */\n    using oddfrm = FieldModel<uint32_t, address,\
    \ 29, 1>;\n    /**\n     * @brief CHDIS field\n     *\n     * Channel disable\n\
    \     */\n    using chdis = FieldModel<uint32_t, address, 30, 1>;\n    /**\n \
    \    * @brief CHENA field\n     *\n     * Channel enable\n     */\n    using chena\
    \ = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ MPSIZ field\n       *\n       * Maximum packet size\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 11> mpsiz;\n      /**\n       * @brief EPNUM field\n       *\n       * Endpoint\
    \ number\n       */\n      BitFieldModel<uint32_t, 11, 4> epnum;\n      /**\n\
    \       * @brief EPDIR field\n       *\n       * Endpoint direction\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> epdir;\n      /**\n       * @brief LSDEV\
    \ field\n       *\n       * Low-speed device\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> lsdev;\n      /**\n       * @brief EPTYP field\n       *\n       * Endpoint\
    \ type\n       */\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      /**\n  \
    \     * @brief MCNT field\n       *\n       * Multicount\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 2> mcnt;\n      /**\n       * @brief DAD field\n       *\n       * Device\
    \ address\n       */\n      BitFieldModel<uint32_t, 22, 7> dad;\n      /**\n \
    \      * @brief ODDFRM field\n       *\n       * Odd frame\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 1> oddfrm;\n      /**\n       * @brief CHDIS field\n       *\n       * Channel\
    \ disable\n       */\n      BitFieldModel<uint32_t, 30, 1> chdis;\n      /**\n\
    \       * @brief CHENA field\n       *\n       * Channel enable\n       */\n \
    \     BitFieldModel<uint32_t, 31, 1> chena;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief FS_HCCHAR7 register\n   *\n   * OTG_FS host channel-7 characteristics\n\
    \   *           register (OTG_FS_HCCHAR7)\n   */\n  using fs_hcchar7 = Fs_hcchar7Reg<BaseAddress\
    \ + 0x01E0>;\n\nprivate:\n  template<unsigned int address>\n  class Fs_hcint0Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ XFRC field\n     *\n     * Transfer completed\n     */\n    using xfrc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    /**\n     * @brief CHH field\n     *\n     * Channel halted\n\
    \     */\n    using chh = FieldModel<uint32_t, address, 1, 1>;\n    /**\n    \
    \ * @brief STALL field\n     *\n     * STALL response received\n     *       \
    \        interrupt\n     */\n    using stall = FieldModel<uint32_t, address, 3,\
    \ 1>;\n    /**\n     * @brief NAK field\n     *\n     * NAK response received\n\
    \     *               interrupt\n     */\n    using nak = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ACK field\n     *\n     * ACK response\
    \ received/transmitted\n     *               interrupt\n     */\n    using ack\
    \ = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief TXERR field\n\
    \     *\n     * Transaction error\n     */\n    using txerr = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief BBERR field\n     *\n     * Babble error\n\
    \     */\n    using bberr = FieldModel<uint32_t, address, 8, 1>;\n    /**\n  \
    \   * @brief FRMOR field\n     *\n     * Frame overrun\n     */\n    using frmor\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief DTERR field\n\
    \     *\n     * Data toggle error\n     */\n    using dterr = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief XFRC field\n       *\n\
    \       * Transfer completed\n       */\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n\
    \      /**\n       * @brief CHH field\n       *\n       * Channel halted\n   \
    \    */\n      BitFieldModel<uint32_t, 1, 1> chh;\n      /**\n       * @brief\
    \ STALL field\n       *\n       * STALL response received\n       *          \
    \     interrupt\n       */\n      BitFieldModel<uint32_t, 3, 1> stall;\n     \
    \ /**\n       * @brief NAK field\n       *\n       * NAK response received\n \
    \      *               interrupt\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 1> nak;\n      /**\n       * @brief ACK field\n       *\n       * ACK response\
    \ received/transmitted\n       *               interrupt\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      /**\n       * @brief TXERR field\n       *\n       * Transaction\
    \ error\n       */\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      /**\n  \
    \     * @brief BBERR field\n       *\n       * Babble error\n       */\n     \
    \ BitFieldModel<uint32_t, 8, 1> bberr;\n      /**\n       * @brief FRMOR field\n\
    \       *\n       * Frame overrun\n       */\n      BitFieldModel<uint32_t, 9,\
    \ 1> frmor;\n      /**\n       * @brief DTERR field\n       *\n       * Data toggle\
    \ error\n       */\n      BitFieldModel<uint32_t, 10, 1> dterr;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief FS_HCINT0 register\n   *\n   * OTG_FS host channel-0\
    \ interrupt register\n   *           (OTG_FS_HCINT0)\n   */\n  using fs_hcint0\
    \ = Fs_hcint0Reg<BaseAddress + 0x0108>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Fs_hcint1Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief XFRC field\n     *\n     * Transfer completed\n     */\n\
    \    using xfrc = FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief\
    \ CHH field\n     *\n     * Channel halted\n     */\n    using chh = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief STALL field\n     *\n     * STALL response\
    \ received\n     *               interrupt\n     */\n    using stall = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief NAK field\n     *\n     * NAK response\
    \ received\n     *               interrupt\n     */\n    using nak = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ACK field\n     *\n     * ACK response\
    \ received/transmitted\n     *               interrupt\n     */\n    using ack\
    \ = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief TXERR field\n\
    \     *\n     * Transaction error\n     */\n    using txerr = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief BBERR field\n     *\n     * Babble error\n\
    \     */\n    using bberr = FieldModel<uint32_t, address, 8, 1>;\n    /**\n  \
    \   * @brief FRMOR field\n     *\n     * Frame overrun\n     */\n    using frmor\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief DTERR field\n\
    \     *\n     * Data toggle error\n     */\n    using dterr = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief XFRC field\n       *\n\
    \       * Transfer completed\n       */\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n\
    \      /**\n       * @brief CHH field\n       *\n       * Channel halted\n   \
    \    */\n      BitFieldModel<uint32_t, 1, 1> chh;\n      /**\n       * @brief\
    \ STALL field\n       *\n       * STALL response received\n       *          \
    \     interrupt\n       */\n      BitFieldModel<uint32_t, 3, 1> stall;\n     \
    \ /**\n       * @brief NAK field\n       *\n       * NAK response received\n \
    \      *               interrupt\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 1> nak;\n      /**\n       * @brief ACK field\n       *\n       * ACK response\
    \ received/transmitted\n       *               interrupt\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      /**\n       * @brief TXERR field\n       *\n       * Transaction\
    \ error\n       */\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      /**\n  \
    \     * @brief BBERR field\n       *\n       * Babble error\n       */\n     \
    \ BitFieldModel<uint32_t, 8, 1> bberr;\n      /**\n       * @brief FRMOR field\n\
    \       *\n       * Frame overrun\n       */\n      BitFieldModel<uint32_t, 9,\
    \ 1> frmor;\n      /**\n       * @brief DTERR field\n       *\n       * Data toggle\
    \ error\n       */\n      BitFieldModel<uint32_t, 10, 1> dterr;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief FS_HCINT1 register\n   *\n   * OTG_FS host channel-1\
    \ interrupt register\n   *           (OTG_FS_HCINT1)\n   */\n  using fs_hcint1\
    \ = Fs_hcint1Reg<BaseAddress + 0x0128>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Fs_hcint2Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief XFRC field\n     *\n     * Transfer completed\n     */\n\
    \    using xfrc = FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief\
    \ CHH field\n     *\n     * Channel halted\n     */\n    using chh = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief STALL field\n     *\n     * STALL response\
    \ received\n     *               interrupt\n     */\n    using stall = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief NAK field\n     *\n     * NAK response\
    \ received\n     *               interrupt\n     */\n    using nak = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ACK field\n     *\n     * ACK response\
    \ received/transmitted\n     *               interrupt\n     */\n    using ack\
    \ = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief TXERR field\n\
    \     *\n     * Transaction error\n     */\n    using txerr = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief BBERR field\n     *\n     * Babble error\n\
    \     */\n    using bberr = FieldModel<uint32_t, address, 8, 1>;\n    /**\n  \
    \   * @brief FRMOR field\n     *\n     * Frame overrun\n     */\n    using frmor\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief DTERR field\n\
    \     *\n     * Data toggle error\n     */\n    using dterr = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief XFRC field\n       *\n\
    \       * Transfer completed\n       */\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n\
    \      /**\n       * @brief CHH field\n       *\n       * Channel halted\n   \
    \    */\n      BitFieldModel<uint32_t, 1, 1> chh;\n      /**\n       * @brief\
    \ STALL field\n       *\n       * STALL response received\n       *          \
    \     interrupt\n       */\n      BitFieldModel<uint32_t, 3, 1> stall;\n     \
    \ /**\n       * @brief NAK field\n       *\n       * NAK response received\n \
    \      *               interrupt\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 1> nak;\n      /**\n       * @brief ACK field\n       *\n       * ACK response\
    \ received/transmitted\n       *               interrupt\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      /**\n       * @brief TXERR field\n       *\n       * Transaction\
    \ error\n       */\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      /**\n  \
    \     * @brief BBERR field\n       *\n       * Babble error\n       */\n     \
    \ BitFieldModel<uint32_t, 8, 1> bberr;\n      /**\n       * @brief FRMOR field\n\
    \       *\n       * Frame overrun\n       */\n      BitFieldModel<uint32_t, 9,\
    \ 1> frmor;\n      /**\n       * @brief DTERR field\n       *\n       * Data toggle\
    \ error\n       */\n      BitFieldModel<uint32_t, 10, 1> dterr;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief FS_HCINT2 register\n   *\n   * OTG_FS host channel-2\
    \ interrupt register\n   *           (OTG_FS_HCINT2)\n   */\n  using fs_hcint2\
    \ = Fs_hcint2Reg<BaseAddress + 0x0148>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Fs_hcint3Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief XFRC field\n     *\n     * Transfer completed\n     */\n\
    \    using xfrc = FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief\
    \ CHH field\n     *\n     * Channel halted\n     */\n    using chh = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief STALL field\n     *\n     * STALL response\
    \ received\n     *               interrupt\n     */\n    using stall = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief NAK field\n     *\n     * NAK response\
    \ received\n     *               interrupt\n     */\n    using nak = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ACK field\n     *\n     * ACK response\
    \ received/transmitted\n     *               interrupt\n     */\n    using ack\
    \ = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief TXERR field\n\
    \     *\n     * Transaction error\n     */\n    using txerr = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief BBERR field\n     *\n     * Babble error\n\
    \     */\n    using bberr = FieldModel<uint32_t, address, 8, 1>;\n    /**\n  \
    \   * @brief FRMOR field\n     *\n     * Frame overrun\n     */\n    using frmor\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief DTERR field\n\
    \     *\n     * Data toggle error\n     */\n    using dterr = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief XFRC field\n       *\n\
    \       * Transfer completed\n       */\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n\
    \      /**\n       * @brief CHH field\n       *\n       * Channel halted\n   \
    \    */\n      BitFieldModel<uint32_t, 1, 1> chh;\n      /**\n       * @brief\
    \ STALL field\n       *\n       * STALL response received\n       *          \
    \     interrupt\n       */\n      BitFieldModel<uint32_t, 3, 1> stall;\n     \
    \ /**\n       * @brief NAK field\n       *\n       * NAK response received\n \
    \      *               interrupt\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 1> nak;\n      /**\n       * @brief ACK field\n       *\n       * ACK response\
    \ received/transmitted\n       *               interrupt\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      /**\n       * @brief TXERR field\n       *\n       * Transaction\
    \ error\n       */\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      /**\n  \
    \     * @brief BBERR field\n       *\n       * Babble error\n       */\n     \
    \ BitFieldModel<uint32_t, 8, 1> bberr;\n      /**\n       * @brief FRMOR field\n\
    \       *\n       * Frame overrun\n       */\n      BitFieldModel<uint32_t, 9,\
    \ 1> frmor;\n      /**\n       * @brief DTERR field\n       *\n       * Data toggle\
    \ error\n       */\n      BitFieldModel<uint32_t, 10, 1> dterr;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief FS_HCINT3 register\n   *\n   * OTG_FS host channel-3\
    \ interrupt register\n   *           (OTG_FS_HCINT3)\n   */\n  using fs_hcint3\
    \ = Fs_hcint3Reg<BaseAddress + 0x0168>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Fs_hcint4Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief XFRC field\n     *\n     * Transfer completed\n     */\n\
    \    using xfrc = FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief\
    \ CHH field\n     *\n     * Channel halted\n     */\n    using chh = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief STALL field\n     *\n     * STALL response\
    \ received\n     *               interrupt\n     */\n    using stall = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief NAK field\n     *\n     * NAK response\
    \ received\n     *               interrupt\n     */\n    using nak = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ACK field\n     *\n     * ACK response\
    \ received/transmitted\n     *               interrupt\n     */\n    using ack\
    \ = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief TXERR field\n\
    \     *\n     * Transaction error\n     */\n    using txerr = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief BBERR field\n     *\n     * Babble error\n\
    \     */\n    using bberr = FieldModel<uint32_t, address, 8, 1>;\n    /**\n  \
    \   * @brief FRMOR field\n     *\n     * Frame overrun\n     */\n    using frmor\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief DTERR field\n\
    \     *\n     * Data toggle error\n     */\n    using dterr = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief XFRC field\n       *\n\
    \       * Transfer completed\n       */\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n\
    \      /**\n       * @brief CHH field\n       *\n       * Channel halted\n   \
    \    */\n      BitFieldModel<uint32_t, 1, 1> chh;\n      /**\n       * @brief\
    \ STALL field\n       *\n       * STALL response received\n       *          \
    \     interrupt\n       */\n      BitFieldModel<uint32_t, 3, 1> stall;\n     \
    \ /**\n       * @brief NAK field\n       *\n       * NAK response received\n \
    \      *               interrupt\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 1> nak;\n      /**\n       * @brief ACK field\n       *\n       * ACK response\
    \ received/transmitted\n       *               interrupt\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      /**\n       * @brief TXERR field\n       *\n       * Transaction\
    \ error\n       */\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      /**\n  \
    \     * @brief BBERR field\n       *\n       * Babble error\n       */\n     \
    \ BitFieldModel<uint32_t, 8, 1> bberr;\n      /**\n       * @brief FRMOR field\n\
    \       *\n       * Frame overrun\n       */\n      BitFieldModel<uint32_t, 9,\
    \ 1> frmor;\n      /**\n       * @brief DTERR field\n       *\n       * Data toggle\
    \ error\n       */\n      BitFieldModel<uint32_t, 10, 1> dterr;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief FS_HCINT4 register\n   *\n   * OTG_FS host channel-4\
    \ interrupt register\n   *           (OTG_FS_HCINT4)\n   */\n  using fs_hcint4\
    \ = Fs_hcint4Reg<BaseAddress + 0x0188>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Fs_hcint5Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief XFRC field\n     *\n     * Transfer completed\n     */\n\
    \    using xfrc = FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief\
    \ CHH field\n     *\n     * Channel halted\n     */\n    using chh = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief STALL field\n     *\n     * STALL response\
    \ received\n     *               interrupt\n     */\n    using stall = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief NAK field\n     *\n     * NAK response\
    \ received\n     *               interrupt\n     */\n    using nak = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ACK field\n     *\n     * ACK response\
    \ received/transmitted\n     *               interrupt\n     */\n    using ack\
    \ = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief TXERR field\n\
    \     *\n     * Transaction error\n     */\n    using txerr = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief BBERR field\n     *\n     * Babble error\n\
    \     */\n    using bberr = FieldModel<uint32_t, address, 8, 1>;\n    /**\n  \
    \   * @brief FRMOR field\n     *\n     * Frame overrun\n     */\n    using frmor\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief DTERR field\n\
    \     *\n     * Data toggle error\n     */\n    using dterr = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief XFRC field\n       *\n\
    \       * Transfer completed\n       */\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n\
    \      /**\n       * @brief CHH field\n       *\n       * Channel halted\n   \
    \    */\n      BitFieldModel<uint32_t, 1, 1> chh;\n      /**\n       * @brief\
    \ STALL field\n       *\n       * STALL response received\n       *          \
    \     interrupt\n       */\n      BitFieldModel<uint32_t, 3, 1> stall;\n     \
    \ /**\n       * @brief NAK field\n       *\n       * NAK response received\n \
    \      *               interrupt\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 1> nak;\n      /**\n       * @brief ACK field\n       *\n       * ACK response\
    \ received/transmitted\n       *               interrupt\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      /**\n       * @brief TXERR field\n       *\n       * Transaction\
    \ error\n       */\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      /**\n  \
    \     * @brief BBERR field\n       *\n       * Babble error\n       */\n     \
    \ BitFieldModel<uint32_t, 8, 1> bberr;\n      /**\n       * @brief FRMOR field\n\
    \       *\n       * Frame overrun\n       */\n      BitFieldModel<uint32_t, 9,\
    \ 1> frmor;\n      /**\n       * @brief DTERR field\n       *\n       * Data toggle\
    \ error\n       */\n      BitFieldModel<uint32_t, 10, 1> dterr;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief FS_HCINT5 register\n   *\n   * OTG_FS host channel-5\
    \ interrupt register\n   *           (OTG_FS_HCINT5)\n   */\n  using fs_hcint5\
    \ = Fs_hcint5Reg<BaseAddress + 0x01A8>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Fs_hcint6Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief XFRC field\n     *\n     * Transfer completed\n     */\n\
    \    using xfrc = FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief\
    \ CHH field\n     *\n     * Channel halted\n     */\n    using chh = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief STALL field\n     *\n     * STALL response\
    \ received\n     *               interrupt\n     */\n    using stall = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief NAK field\n     *\n     * NAK response\
    \ received\n     *               interrupt\n     */\n    using nak = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ACK field\n     *\n     * ACK response\
    \ received/transmitted\n     *               interrupt\n     */\n    using ack\
    \ = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief TXERR field\n\
    \     *\n     * Transaction error\n     */\n    using txerr = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief BBERR field\n     *\n     * Babble error\n\
    \     */\n    using bberr = FieldModel<uint32_t, address, 8, 1>;\n    /**\n  \
    \   * @brief FRMOR field\n     *\n     * Frame overrun\n     */\n    using frmor\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief DTERR field\n\
    \     *\n     * Data toggle error\n     */\n    using dterr = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief XFRC field\n       *\n\
    \       * Transfer completed\n       */\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n\
    \      /**\n       * @brief CHH field\n       *\n       * Channel halted\n   \
    \    */\n      BitFieldModel<uint32_t, 1, 1> chh;\n      /**\n       * @brief\
    \ STALL field\n       *\n       * STALL response received\n       *          \
    \     interrupt\n       */\n      BitFieldModel<uint32_t, 3, 1> stall;\n     \
    \ /**\n       * @brief NAK field\n       *\n       * NAK response received\n \
    \      *               interrupt\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 1> nak;\n      /**\n       * @brief ACK field\n       *\n       * ACK response\
    \ received/transmitted\n       *               interrupt\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      /**\n       * @brief TXERR field\n       *\n       * Transaction\
    \ error\n       */\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      /**\n  \
    \     * @brief BBERR field\n       *\n       * Babble error\n       */\n     \
    \ BitFieldModel<uint32_t, 8, 1> bberr;\n      /**\n       * @brief FRMOR field\n\
    \       *\n       * Frame overrun\n       */\n      BitFieldModel<uint32_t, 9,\
    \ 1> frmor;\n      /**\n       * @brief DTERR field\n       *\n       * Data toggle\
    \ error\n       */\n      BitFieldModel<uint32_t, 10, 1> dterr;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief FS_HCINT6 register\n   *\n   * OTG_FS host channel-6\
    \ interrupt register\n   *           (OTG_FS_HCINT6)\n   */\n  using fs_hcint6\
    \ = Fs_hcint6Reg<BaseAddress + 0x01C8>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Fs_hcint7Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief XFRC field\n     *\n     * Transfer completed\n     */\n\
    \    using xfrc = FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief\
    \ CHH field\n     *\n     * Channel halted\n     */\n    using chh = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief STALL field\n     *\n     * STALL response\
    \ received\n     *               interrupt\n     */\n    using stall = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief NAK field\n     *\n     * NAK response\
    \ received\n     *               interrupt\n     */\n    using nak = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ACK field\n     *\n     * ACK response\
    \ received/transmitted\n     *               interrupt\n     */\n    using ack\
    \ = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief TXERR field\n\
    \     *\n     * Transaction error\n     */\n    using txerr = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief BBERR field\n     *\n     * Babble error\n\
    \     */\n    using bberr = FieldModel<uint32_t, address, 8, 1>;\n    /**\n  \
    \   * @brief FRMOR field\n     *\n     * Frame overrun\n     */\n    using frmor\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief DTERR field\n\
    \     *\n     * Data toggle error\n     */\n    using dterr = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief XFRC field\n       *\n\
    \       * Transfer completed\n       */\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n\
    \      /**\n       * @brief CHH field\n       *\n       * Channel halted\n   \
    \    */\n      BitFieldModel<uint32_t, 1, 1> chh;\n      /**\n       * @brief\
    \ STALL field\n       *\n       * STALL response received\n       *          \
    \     interrupt\n       */\n      BitFieldModel<uint32_t, 3, 1> stall;\n     \
    \ /**\n       * @brief NAK field\n       *\n       * NAK response received\n \
    \      *               interrupt\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 1> nak;\n      /**\n       * @brief ACK field\n       *\n       * ACK response\
    \ received/transmitted\n       *               interrupt\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      /**\n       * @brief TXERR field\n       *\n       * Transaction\
    \ error\n       */\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      /**\n  \
    \     * @brief BBERR field\n       *\n       * Babble error\n       */\n     \
    \ BitFieldModel<uint32_t, 8, 1> bberr;\n      /**\n       * @brief FRMOR field\n\
    \       *\n       * Frame overrun\n       */\n      BitFieldModel<uint32_t, 9,\
    \ 1> frmor;\n      /**\n       * @brief DTERR field\n       *\n       * Data toggle\
    \ error\n       */\n      BitFieldModel<uint32_t, 10, 1> dterr;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief FS_HCINT7 register\n   *\n   * OTG_FS host channel-7\
    \ interrupt register\n   *           (OTG_FS_HCINT7)\n   */\n  using fs_hcint7\
    \ = Fs_hcint7Reg<BaseAddress + 0x01E8>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Fs_hcintmsk0Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief XFRCM field\n     *\n     * Transfer completed mask\n\
    \     */\n    using xfrcm = FieldModel<uint32_t, address, 0, 1>;\n    /**\n  \
    \   * @brief CHHM field\n     *\n     * Channel halted mask\n     */\n    using\
    \ chhm = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief STALLM field\n\
    \     *\n     * STALL response received interrupt\n     *               mask\n\
    \     */\n    using stallm = FieldModel<uint32_t, address, 3, 1>;\n    /**\n \
    \    * @brief NAKM field\n     *\n     * NAK response received interrupt\n   \
    \  *               mask\n     */\n    using nakm = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief ACKM field\n     *\n     * ACK response received/transmitted\n\
    \     *               interrupt mask\n     */\n    using ackm = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief NYET field\n     *\n     * response\
    \ received interrupt\n     *               mask\n     */\n    using nyet = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief TXERRM field\n     *\n     * Transaction\
    \ error mask\n     */\n    using txerrm = FieldModel<uint32_t, address, 7, 1>;\n\
    \    /**\n     * @brief BBERRM field\n     *\n     * Babble error mask\n     */\n\
    \    using bberrm = FieldModel<uint32_t, address, 8, 1>;\n    /**\n     * @brief\
    \ FRMORM field\n     *\n     * Frame overrun mask\n     */\n    using frmorm =\
    \ FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief DTERRM field\n\
    \     *\n     * Data toggle error mask\n     */\n    using dterrm = FieldModel<uint32_t,\
    \ address, 10, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief XFRCM field\n       *\n\
    \       * Transfer completed mask\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 1> xfrcm;\n      /**\n       * @brief CHHM field\n       *\n       * Channel\
    \ halted mask\n       */\n      BitFieldModel<uint32_t, 1, 1> chhm;\n      /**\n\
    \       * @brief STALLM field\n       *\n       * STALL response received interrupt\n\
    \       *               mask\n       */\n      BitFieldModel<uint32_t, 3, 1> stallm;\n\
    \      /**\n       * @brief NAKM field\n       *\n       * NAK response received\
    \ interrupt\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> nakm;\n      /**\n       * @brief ACKM field\n       *\n       * ACK response\
    \ received/transmitted\n       *               interrupt mask\n       */\n   \
    \   BitFieldModel<uint32_t, 5, 1> ackm;\n      /**\n       * @brief NYET field\n\
    \       *\n       * response received interrupt\n       *               mask\n\
    \       */\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      /**\n       * @brief\
    \ TXERRM field\n       *\n       * Transaction error mask\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerrm;\n      /**\n       * @brief BBERRM field\n       *\n       * Babble\
    \ error mask\n       */\n      BitFieldModel<uint32_t, 8, 1> bberrm;\n      /**\n\
    \       * @brief FRMORM field\n       *\n       * Frame overrun mask\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> frmorm;\n      /**\n       * @brief DTERRM\
    \ field\n       *\n       * Data toggle error mask\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterrm;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_HCINTMSK0 register\n\
    \   *\n   * OTG_FS host channel-0 mask register\n   *           (OTG_FS_HCINTMSK0)\n\
    \   */\n  using fs_hcintmsk0 = Fs_hcintmsk0Reg<BaseAddress + 0x010C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_hcintmsk1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief XFRCM field\n     *\n     *\
    \ Transfer completed mask\n     */\n    using xfrcm = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    /**\n     * @brief CHHM field\n     *\n     * Channel halted mask\n\
    \     */\n    using chhm = FieldModel<uint32_t, address, 1, 1>;\n    /**\n   \
    \  * @brief STALLM field\n     *\n     * STALL response received interrupt\n \
    \    *               mask\n     */\n    using stallm = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief NAKM field\n     *\n     * NAK response received\
    \ interrupt\n     *               mask\n     */\n    using nakm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ACKM field\n     *\n     * ACK response\
    \ received/transmitted\n     *               interrupt mask\n     */\n    using\
    \ ackm = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief NYET field\n\
    \     *\n     * response received interrupt\n     *               mask\n     */\n\
    \    using nyet = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief\
    \ TXERRM field\n     *\n     * Transaction error mask\n     */\n    using txerrm\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief BBERRM field\n\
    \     *\n     * Babble error mask\n     */\n    using bberrm = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief FRMORM field\n     *\n     * Frame overrun\
    \ mask\n     */\n    using frmorm = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ /**\n     * @brief DTERRM field\n     *\n     * Data toggle error mask\n   \
    \  */\n    using dterrm = FieldModel<uint32_t, address, 10, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief XFRCM field\n       *\n       * Transfer completed mask\n   \
    \    */\n      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      /**\n       * @brief\
    \ CHHM field\n       *\n       * Channel halted mask\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> chhm;\n      /**\n       * @brief STALLM field\n       *\n       * STALL\
    \ response received interrupt\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> stallm;\n      /**\n       * @brief NAKM field\n       *\n       * NAK\
    \ response received interrupt\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> nakm;\n      /**\n       * @brief ACKM field\n       *\n       * ACK response\
    \ received/transmitted\n       *               interrupt mask\n       */\n   \
    \   BitFieldModel<uint32_t, 5, 1> ackm;\n      /**\n       * @brief NYET field\n\
    \       *\n       * response received interrupt\n       *               mask\n\
    \       */\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      /**\n       * @brief\
    \ TXERRM field\n       *\n       * Transaction error mask\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerrm;\n      /**\n       * @brief BBERRM field\n       *\n       * Babble\
    \ error mask\n       */\n      BitFieldModel<uint32_t, 8, 1> bberrm;\n      /**\n\
    \       * @brief FRMORM field\n       *\n       * Frame overrun mask\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> frmorm;\n      /**\n       * @brief DTERRM\
    \ field\n       *\n       * Data toggle error mask\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterrm;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_HCINTMSK1 register\n\
    \   *\n   * OTG_FS host channel-1 mask register\n   *           (OTG_FS_HCINTMSK1)\n\
    \   */\n  using fs_hcintmsk1 = Fs_hcintmsk1Reg<BaseAddress + 0x012C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_hcintmsk2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief XFRCM field\n     *\n     *\
    \ Transfer completed mask\n     */\n    using xfrcm = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    /**\n     * @brief CHHM field\n     *\n     * Channel halted mask\n\
    \     */\n    using chhm = FieldModel<uint32_t, address, 1, 1>;\n    /**\n   \
    \  * @brief STALLM field\n     *\n     * STALL response received interrupt\n \
    \    *               mask\n     */\n    using stallm = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief NAKM field\n     *\n     * NAK response received\
    \ interrupt\n     *               mask\n     */\n    using nakm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ACKM field\n     *\n     * ACK response\
    \ received/transmitted\n     *               interrupt mask\n     */\n    using\
    \ ackm = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief NYET field\n\
    \     *\n     * response received interrupt\n     *               mask\n     */\n\
    \    using nyet = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief\
    \ TXERRM field\n     *\n     * Transaction error mask\n     */\n    using txerrm\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief BBERRM field\n\
    \     *\n     * Babble error mask\n     */\n    using bberrm = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief FRMORM field\n     *\n     * Frame overrun\
    \ mask\n     */\n    using frmorm = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ /**\n     * @brief DTERRM field\n     *\n     * Data toggle error mask\n   \
    \  */\n    using dterrm = FieldModel<uint32_t, address, 10, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief XFRCM field\n       *\n       * Transfer completed mask\n   \
    \    */\n      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      /**\n       * @brief\
    \ CHHM field\n       *\n       * Channel halted mask\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> chhm;\n      /**\n       * @brief STALLM field\n       *\n       * STALL\
    \ response received interrupt\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> stallm;\n      /**\n       * @brief NAKM field\n       *\n       * NAK\
    \ response received interrupt\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> nakm;\n      /**\n       * @brief ACKM field\n       *\n       * ACK response\
    \ received/transmitted\n       *               interrupt mask\n       */\n   \
    \   BitFieldModel<uint32_t, 5, 1> ackm;\n      /**\n       * @brief NYET field\n\
    \       *\n       * response received interrupt\n       *               mask\n\
    \       */\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      /**\n       * @brief\
    \ TXERRM field\n       *\n       * Transaction error mask\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerrm;\n      /**\n       * @brief BBERRM field\n       *\n       * Babble\
    \ error mask\n       */\n      BitFieldModel<uint32_t, 8, 1> bberrm;\n      /**\n\
    \       * @brief FRMORM field\n       *\n       * Frame overrun mask\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> frmorm;\n      /**\n       * @brief DTERRM\
    \ field\n       *\n       * Data toggle error mask\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterrm;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_HCINTMSK2 register\n\
    \   *\n   * OTG_FS host channel-2 mask register\n   *           (OTG_FS_HCINTMSK2)\n\
    \   */\n  using fs_hcintmsk2 = Fs_hcintmsk2Reg<BaseAddress + 0x014C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_hcintmsk3Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief XFRCM field\n     *\n     *\
    \ Transfer completed mask\n     */\n    using xfrcm = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    /**\n     * @brief CHHM field\n     *\n     * Channel halted mask\n\
    \     */\n    using chhm = FieldModel<uint32_t, address, 1, 1>;\n    /**\n   \
    \  * @brief STALLM field\n     *\n     * STALL response received interrupt\n \
    \    *               mask\n     */\n    using stallm = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief NAKM field\n     *\n     * NAK response received\
    \ interrupt\n     *               mask\n     */\n    using nakm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ACKM field\n     *\n     * ACK response\
    \ received/transmitted\n     *               interrupt mask\n     */\n    using\
    \ ackm = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief NYET field\n\
    \     *\n     * response received interrupt\n     *               mask\n     */\n\
    \    using nyet = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief\
    \ TXERRM field\n     *\n     * Transaction error mask\n     */\n    using txerrm\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief BBERRM field\n\
    \     *\n     * Babble error mask\n     */\n    using bberrm = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief FRMORM field\n     *\n     * Frame overrun\
    \ mask\n     */\n    using frmorm = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ /**\n     * @brief DTERRM field\n     *\n     * Data toggle error mask\n   \
    \  */\n    using dterrm = FieldModel<uint32_t, address, 10, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief XFRCM field\n       *\n       * Transfer completed mask\n   \
    \    */\n      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      /**\n       * @brief\
    \ CHHM field\n       *\n       * Channel halted mask\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> chhm;\n      /**\n       * @brief STALLM field\n       *\n       * STALL\
    \ response received interrupt\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> stallm;\n      /**\n       * @brief NAKM field\n       *\n       * NAK\
    \ response received interrupt\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> nakm;\n      /**\n       * @brief ACKM field\n       *\n       * ACK response\
    \ received/transmitted\n       *               interrupt mask\n       */\n   \
    \   BitFieldModel<uint32_t, 5, 1> ackm;\n      /**\n       * @brief NYET field\n\
    \       *\n       * response received interrupt\n       *               mask\n\
    \       */\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      /**\n       * @brief\
    \ TXERRM field\n       *\n       * Transaction error mask\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerrm;\n      /**\n       * @brief BBERRM field\n       *\n       * Babble\
    \ error mask\n       */\n      BitFieldModel<uint32_t, 8, 1> bberrm;\n      /**\n\
    \       * @brief FRMORM field\n       *\n       * Frame overrun mask\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> frmorm;\n      /**\n       * @brief DTERRM\
    \ field\n       *\n       * Data toggle error mask\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterrm;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_HCINTMSK3 register\n\
    \   *\n   * OTG_FS host channel-3 mask register\n   *           (OTG_FS_HCINTMSK3)\n\
    \   */\n  using fs_hcintmsk3 = Fs_hcintmsk3Reg<BaseAddress + 0x016C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_hcintmsk4Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief XFRCM field\n     *\n     *\
    \ Transfer completed mask\n     */\n    using xfrcm = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    /**\n     * @brief CHHM field\n     *\n     * Channel halted mask\n\
    \     */\n    using chhm = FieldModel<uint32_t, address, 1, 1>;\n    /**\n   \
    \  * @brief STALLM field\n     *\n     * STALL response received interrupt\n \
    \    *               mask\n     */\n    using stallm = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief NAKM field\n     *\n     * NAK response received\
    \ interrupt\n     *               mask\n     */\n    using nakm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ACKM field\n     *\n     * ACK response\
    \ received/transmitted\n     *               interrupt mask\n     */\n    using\
    \ ackm = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief NYET field\n\
    \     *\n     * response received interrupt\n     *               mask\n     */\n\
    \    using nyet = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief\
    \ TXERRM field\n     *\n     * Transaction error mask\n     */\n    using txerrm\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief BBERRM field\n\
    \     *\n     * Babble error mask\n     */\n    using bberrm = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief FRMORM field\n     *\n     * Frame overrun\
    \ mask\n     */\n    using frmorm = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ /**\n     * @brief DTERRM field\n     *\n     * Data toggle error mask\n   \
    \  */\n    using dterrm = FieldModel<uint32_t, address, 10, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief XFRCM field\n       *\n       * Transfer completed mask\n   \
    \    */\n      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      /**\n       * @brief\
    \ CHHM field\n       *\n       * Channel halted mask\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> chhm;\n      /**\n       * @brief STALLM field\n       *\n       * STALL\
    \ response received interrupt\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> stallm;\n      /**\n       * @brief NAKM field\n       *\n       * NAK\
    \ response received interrupt\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> nakm;\n      /**\n       * @brief ACKM field\n       *\n       * ACK response\
    \ received/transmitted\n       *               interrupt mask\n       */\n   \
    \   BitFieldModel<uint32_t, 5, 1> ackm;\n      /**\n       * @brief NYET field\n\
    \       *\n       * response received interrupt\n       *               mask\n\
    \       */\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      /**\n       * @brief\
    \ TXERRM field\n       *\n       * Transaction error mask\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerrm;\n      /**\n       * @brief BBERRM field\n       *\n       * Babble\
    \ error mask\n       */\n      BitFieldModel<uint32_t, 8, 1> bberrm;\n      /**\n\
    \       * @brief FRMORM field\n       *\n       * Frame overrun mask\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> frmorm;\n      /**\n       * @brief DTERRM\
    \ field\n       *\n       * Data toggle error mask\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterrm;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_HCINTMSK4 register\n\
    \   *\n   * OTG_FS host channel-4 mask register\n   *           (OTG_FS_HCINTMSK4)\n\
    \   */\n  using fs_hcintmsk4 = Fs_hcintmsk4Reg<BaseAddress + 0x018C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_hcintmsk5Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief XFRCM field\n     *\n     *\
    \ Transfer completed mask\n     */\n    using xfrcm = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    /**\n     * @brief CHHM field\n     *\n     * Channel halted mask\n\
    \     */\n    using chhm = FieldModel<uint32_t, address, 1, 1>;\n    /**\n   \
    \  * @brief STALLM field\n     *\n     * STALL response received interrupt\n \
    \    *               mask\n     */\n    using stallm = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief NAKM field\n     *\n     * NAK response received\
    \ interrupt\n     *               mask\n     */\n    using nakm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ACKM field\n     *\n     * ACK response\
    \ received/transmitted\n     *               interrupt mask\n     */\n    using\
    \ ackm = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief NYET field\n\
    \     *\n     * response received interrupt\n     *               mask\n     */\n\
    \    using nyet = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief\
    \ TXERRM field\n     *\n     * Transaction error mask\n     */\n    using txerrm\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief BBERRM field\n\
    \     *\n     * Babble error mask\n     */\n    using bberrm = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief FRMORM field\n     *\n     * Frame overrun\
    \ mask\n     */\n    using frmorm = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ /**\n     * @brief DTERRM field\n     *\n     * Data toggle error mask\n   \
    \  */\n    using dterrm = FieldModel<uint32_t, address, 10, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief XFRCM field\n       *\n       * Transfer completed mask\n   \
    \    */\n      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      /**\n       * @brief\
    \ CHHM field\n       *\n       * Channel halted mask\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> chhm;\n      /**\n       * @brief STALLM field\n       *\n       * STALL\
    \ response received interrupt\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> stallm;\n      /**\n       * @brief NAKM field\n       *\n       * NAK\
    \ response received interrupt\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> nakm;\n      /**\n       * @brief ACKM field\n       *\n       * ACK response\
    \ received/transmitted\n       *               interrupt mask\n       */\n   \
    \   BitFieldModel<uint32_t, 5, 1> ackm;\n      /**\n       * @brief NYET field\n\
    \       *\n       * response received interrupt\n       *               mask\n\
    \       */\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      /**\n       * @brief\
    \ TXERRM field\n       *\n       * Transaction error mask\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerrm;\n      /**\n       * @brief BBERRM field\n       *\n       * Babble\
    \ error mask\n       */\n      BitFieldModel<uint32_t, 8, 1> bberrm;\n      /**\n\
    \       * @brief FRMORM field\n       *\n       * Frame overrun mask\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> frmorm;\n      /**\n       * @brief DTERRM\
    \ field\n       *\n       * Data toggle error mask\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterrm;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_HCINTMSK5 register\n\
    \   *\n   * OTG_FS host channel-5 mask register\n   *           (OTG_FS_HCINTMSK5)\n\
    \   */\n  using fs_hcintmsk5 = Fs_hcintmsk5Reg<BaseAddress + 0x01AC>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_hcintmsk6Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief XFRCM field\n     *\n     *\
    \ Transfer completed mask\n     */\n    using xfrcm = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    /**\n     * @brief CHHM field\n     *\n     * Channel halted mask\n\
    \     */\n    using chhm = FieldModel<uint32_t, address, 1, 1>;\n    /**\n   \
    \  * @brief STALLM field\n     *\n     * STALL response received interrupt\n \
    \    *               mask\n     */\n    using stallm = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief NAKM field\n     *\n     * NAK response received\
    \ interrupt\n     *               mask\n     */\n    using nakm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ACKM field\n     *\n     * ACK response\
    \ received/transmitted\n     *               interrupt mask\n     */\n    using\
    \ ackm = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief NYET field\n\
    \     *\n     * response received interrupt\n     *               mask\n     */\n\
    \    using nyet = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief\
    \ TXERRM field\n     *\n     * Transaction error mask\n     */\n    using txerrm\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief BBERRM field\n\
    \     *\n     * Babble error mask\n     */\n    using bberrm = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief FRMORM field\n     *\n     * Frame overrun\
    \ mask\n     */\n    using frmorm = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ /**\n     * @brief DTERRM field\n     *\n     * Data toggle error mask\n   \
    \  */\n    using dterrm = FieldModel<uint32_t, address, 10, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief XFRCM field\n       *\n       * Transfer completed mask\n   \
    \    */\n      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      /**\n       * @brief\
    \ CHHM field\n       *\n       * Channel halted mask\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> chhm;\n      /**\n       * @brief STALLM field\n       *\n       * STALL\
    \ response received interrupt\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> stallm;\n      /**\n       * @brief NAKM field\n       *\n       * NAK\
    \ response received interrupt\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> nakm;\n      /**\n       * @brief ACKM field\n       *\n       * ACK response\
    \ received/transmitted\n       *               interrupt mask\n       */\n   \
    \   BitFieldModel<uint32_t, 5, 1> ackm;\n      /**\n       * @brief NYET field\n\
    \       *\n       * response received interrupt\n       *               mask\n\
    \       */\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      /**\n       * @brief\
    \ TXERRM field\n       *\n       * Transaction error mask\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerrm;\n      /**\n       * @brief BBERRM field\n       *\n       * Babble\
    \ error mask\n       */\n      BitFieldModel<uint32_t, 8, 1> bberrm;\n      /**\n\
    \       * @brief FRMORM field\n       *\n       * Frame overrun mask\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> frmorm;\n      /**\n       * @brief DTERRM\
    \ field\n       *\n       * Data toggle error mask\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterrm;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_HCINTMSK6 register\n\
    \   *\n   * OTG_FS host channel-6 mask register\n   *           (OTG_FS_HCINTMSK6)\n\
    \   */\n  using fs_hcintmsk6 = Fs_hcintmsk6Reg<BaseAddress + 0x01CC>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_hcintmsk7Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief XFRCM field\n     *\n     *\
    \ Transfer completed mask\n     */\n    using xfrcm = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    /**\n     * @brief CHHM field\n     *\n     * Channel halted mask\n\
    \     */\n    using chhm = FieldModel<uint32_t, address, 1, 1>;\n    /**\n   \
    \  * @brief STALLM field\n     *\n     * STALL response received interrupt\n \
    \    *               mask\n     */\n    using stallm = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief NAKM field\n     *\n     * NAK response received\
    \ interrupt\n     *               mask\n     */\n    using nakm = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ACKM field\n     *\n     * ACK response\
    \ received/transmitted\n     *               interrupt mask\n     */\n    using\
    \ ackm = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief NYET field\n\
    \     *\n     * response received interrupt\n     *               mask\n     */\n\
    \    using nyet = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief\
    \ TXERRM field\n     *\n     * Transaction error mask\n     */\n    using txerrm\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief BBERRM field\n\
    \     *\n     * Babble error mask\n     */\n    using bberrm = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief FRMORM field\n     *\n     * Frame overrun\
    \ mask\n     */\n    using frmorm = FieldModel<uint32_t, address, 9, 1>;\n   \
    \ /**\n     * @brief DTERRM field\n     *\n     * Data toggle error mask\n   \
    \  */\n    using dterrm = FieldModel<uint32_t, address, 10, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief XFRCM field\n       *\n       * Transfer completed mask\n   \
    \    */\n      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      /**\n       * @brief\
    \ CHHM field\n       *\n       * Channel halted mask\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> chhm;\n      /**\n       * @brief STALLM field\n       *\n       * STALL\
    \ response received interrupt\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> stallm;\n      /**\n       * @brief NAKM field\n       *\n       * NAK\
    \ response received interrupt\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> nakm;\n      /**\n       * @brief ACKM field\n       *\n       * ACK response\
    \ received/transmitted\n       *               interrupt mask\n       */\n   \
    \   BitFieldModel<uint32_t, 5, 1> ackm;\n      /**\n       * @brief NYET field\n\
    \       *\n       * response received interrupt\n       *               mask\n\
    \       */\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      /**\n       * @brief\
    \ TXERRM field\n       *\n       * Transaction error mask\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerrm;\n      /**\n       * @brief BBERRM field\n       *\n       * Babble\
    \ error mask\n       */\n      BitFieldModel<uint32_t, 8, 1> bberrm;\n      /**\n\
    \       * @brief FRMORM field\n       *\n       * Frame overrun mask\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> frmorm;\n      /**\n       * @brief DTERRM\
    \ field\n       *\n       * Data toggle error mask\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterrm;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_HCINTMSK7 register\n\
    \   *\n   * OTG_FS host channel-7 mask register\n   *           (OTG_FS_HCINTMSK7)\n\
    \   */\n  using fs_hcintmsk7 = Fs_hcintmsk7Reg<BaseAddress + 0x01EC>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Fs_hctsiz0Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief XFRSIZ field\n     *\n    \
    \ * Transfer size\n     */\n    using xfrsiz = FieldModel<uint32_t, address, 0,\
    \ 19>;\n    /**\n     * @brief PKTCNT field\n     *\n     * Packet count\n   \
    \  */\n    using pktcnt = FieldModel<uint32_t, address, 19, 10>;\n    /**\n  \
    \   * @brief DPID field\n     *\n     * Data PID\n     */\n    using dpid = FieldModel<uint32_t,\
    \ address, 29, 2>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief XFRSIZ field\n       *\n\
    \       * Transfer size\n       */\n      BitFieldModel<uint32_t, 0, 19> xfrsiz;\n\
    \      /**\n       * @brief PKTCNT field\n       *\n       * Packet count\n  \
    \     */\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      /**\n       * @brief\
    \ DPID field\n       *\n       * Data PID\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_HCTSIZ0 register\n\
    \   *\n   * OTG_FS host channel-0 transfer size\n   *           register\n   */\n\
    \  using fs_hctsiz0 = Fs_hctsiz0Reg<BaseAddress + 0x0110>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Fs_hctsiz1Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief XFRSIZ field\n     *\n     * Transfer\
    \ size\n     */\n    using xfrsiz = FieldModel<uint32_t, address, 0, 19>;\n  \
    \  /**\n     * @brief PKTCNT field\n     *\n     * Packet count\n     */\n   \
    \ using pktcnt = FieldModel<uint32_t, address, 19, 10>;\n    /**\n     * @brief\
    \ DPID field\n     *\n     * Data PID\n     */\n    using dpid = FieldModel<uint32_t,\
    \ address, 29, 2>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief XFRSIZ field\n       *\n\
    \       * Transfer size\n       */\n      BitFieldModel<uint32_t, 0, 19> xfrsiz;\n\
    \      /**\n       * @brief PKTCNT field\n       *\n       * Packet count\n  \
    \     */\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      /**\n       * @brief\
    \ DPID field\n       *\n       * Data PID\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_HCTSIZ1 register\n\
    \   *\n   * OTG_FS host channel-1 transfer size\n   *           register\n   */\n\
    \  using fs_hctsiz1 = Fs_hctsiz1Reg<BaseAddress + 0x0130>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Fs_hctsiz2Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief XFRSIZ field\n     *\n     * Transfer\
    \ size\n     */\n    using xfrsiz = FieldModel<uint32_t, address, 0, 19>;\n  \
    \  /**\n     * @brief PKTCNT field\n     *\n     * Packet count\n     */\n   \
    \ using pktcnt = FieldModel<uint32_t, address, 19, 10>;\n    /**\n     * @brief\
    \ DPID field\n     *\n     * Data PID\n     */\n    using dpid = FieldModel<uint32_t,\
    \ address, 29, 2>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief XFRSIZ field\n       *\n\
    \       * Transfer size\n       */\n      BitFieldModel<uint32_t, 0, 19> xfrsiz;\n\
    \      /**\n       * @brief PKTCNT field\n       *\n       * Packet count\n  \
    \     */\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      /**\n       * @brief\
    \ DPID field\n       *\n       * Data PID\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_HCTSIZ2 register\n\
    \   *\n   * OTG_FS host channel-2 transfer size\n   *           register\n   */\n\
    \  using fs_hctsiz2 = Fs_hctsiz2Reg<BaseAddress + 0x0150>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Fs_hctsiz3Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief XFRSIZ field\n     *\n     * Transfer\
    \ size\n     */\n    using xfrsiz = FieldModel<uint32_t, address, 0, 19>;\n  \
    \  /**\n     * @brief PKTCNT field\n     *\n     * Packet count\n     */\n   \
    \ using pktcnt = FieldModel<uint32_t, address, 19, 10>;\n    /**\n     * @brief\
    \ DPID field\n     *\n     * Data PID\n     */\n    using dpid = FieldModel<uint32_t,\
    \ address, 29, 2>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief XFRSIZ field\n       *\n\
    \       * Transfer size\n       */\n      BitFieldModel<uint32_t, 0, 19> xfrsiz;\n\
    \      /**\n       * @brief PKTCNT field\n       *\n       * Packet count\n  \
    \     */\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      /**\n       * @brief\
    \ DPID field\n       *\n       * Data PID\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_HCTSIZ3 register\n\
    \   *\n   * OTG_FS host channel-3 transfer size\n   *           register\n   */\n\
    \  using fs_hctsiz3 = Fs_hctsiz3Reg<BaseAddress + 0x0170>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Fs_hctsiz4Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief XFRSIZ field\n     *\n     * Transfer\
    \ size\n     */\n    using xfrsiz = FieldModel<uint32_t, address, 0, 19>;\n  \
    \  /**\n     * @brief PKTCNT field\n     *\n     * Packet count\n     */\n   \
    \ using pktcnt = FieldModel<uint32_t, address, 19, 10>;\n    /**\n     * @brief\
    \ DPID field\n     *\n     * Data PID\n     */\n    using dpid = FieldModel<uint32_t,\
    \ address, 29, 2>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief XFRSIZ field\n       *\n\
    \       * Transfer size\n       */\n      BitFieldModel<uint32_t, 0, 19> xfrsiz;\n\
    \      /**\n       * @brief PKTCNT field\n       *\n       * Packet count\n  \
    \     */\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      /**\n       * @brief\
    \ DPID field\n       *\n       * Data PID\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_HCTSIZ4 register\n\
    \   *\n   * OTG_FS host channel-x transfer size\n   *           register\n   */\n\
    \  using fs_hctsiz4 = Fs_hctsiz4Reg<BaseAddress + 0x0190>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Fs_hctsiz5Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief XFRSIZ field\n     *\n     * Transfer\
    \ size\n     */\n    using xfrsiz = FieldModel<uint32_t, address, 0, 19>;\n  \
    \  /**\n     * @brief PKTCNT field\n     *\n     * Packet count\n     */\n   \
    \ using pktcnt = FieldModel<uint32_t, address, 19, 10>;\n    /**\n     * @brief\
    \ DPID field\n     *\n     * Data PID\n     */\n    using dpid = FieldModel<uint32_t,\
    \ address, 29, 2>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief XFRSIZ field\n       *\n\
    \       * Transfer size\n       */\n      BitFieldModel<uint32_t, 0, 19> xfrsiz;\n\
    \      /**\n       * @brief PKTCNT field\n       *\n       * Packet count\n  \
    \     */\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      /**\n       * @brief\
    \ DPID field\n       *\n       * Data PID\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_HCTSIZ5 register\n\
    \   *\n   * OTG_FS host channel-5 transfer size\n   *           register\n   */\n\
    \  using fs_hctsiz5 = Fs_hctsiz5Reg<BaseAddress + 0x01B0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Fs_hctsiz6Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief XFRSIZ field\n     *\n     * Transfer\
    \ size\n     */\n    using xfrsiz = FieldModel<uint32_t, address, 0, 19>;\n  \
    \  /**\n     * @brief PKTCNT field\n     *\n     * Packet count\n     */\n   \
    \ using pktcnt = FieldModel<uint32_t, address, 19, 10>;\n    /**\n     * @brief\
    \ DPID field\n     *\n     * Data PID\n     */\n    using dpid = FieldModel<uint32_t,\
    \ address, 29, 2>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief XFRSIZ field\n       *\n\
    \       * Transfer size\n       */\n      BitFieldModel<uint32_t, 0, 19> xfrsiz;\n\
    \      /**\n       * @brief PKTCNT field\n       *\n       * Packet count\n  \
    \     */\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      /**\n       * @brief\
    \ DPID field\n       *\n       * Data PID\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_HCTSIZ6 register\n\
    \   *\n   * OTG_FS host channel-6 transfer size\n   *           register\n   */\n\
    \  using fs_hctsiz6 = Fs_hctsiz6Reg<BaseAddress + 0x01D0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Fs_hctsiz7Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief XFRSIZ field\n     *\n     * Transfer\
    \ size\n     */\n    using xfrsiz = FieldModel<uint32_t, address, 0, 19>;\n  \
    \  /**\n     * @brief PKTCNT field\n     *\n     * Packet count\n     */\n   \
    \ using pktcnt = FieldModel<uint32_t, address, 19, 10>;\n    /**\n     * @brief\
    \ DPID field\n     *\n     * Data PID\n     */\n    using dpid = FieldModel<uint32_t,\
    \ address, 29, 2>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief XFRSIZ field\n       *\n\
    \       * Transfer size\n       */\n      BitFieldModel<uint32_t, 0, 19> xfrsiz;\n\
    \      /**\n       * @brief PKTCNT field\n       *\n       * Packet count\n  \
    \     */\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      /**\n       * @brief\
    \ DPID field\n       *\n       * Data PID\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_HCTSIZ7 register\n\
    \   *\n   * OTG_FS host channel-7 transfer size\n   *           register\n   */\n\
    \  using fs_hctsiz7 = Fs_hctsiz7Reg<BaseAddress + 0x01F0>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class Fs_hccharxBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    /**\n     * @brief MPSIZ field\n \
    \    *\n     * Maximum packet size\n     */\n    using mpsiz = FieldModel<uint32_t,\
    \ address, 0, 11, bankOffset>;\n    /**\n     * @brief EPNUM field\n     *\n \
    \    * Endpoint number\n     */\n    using epnum = FieldModel<uint32_t, address,\
    \ 11, 4, bankOffset>;\n    /**\n     * @brief EPDIR field\n     *\n     * Endpoint\
    \ direction\n     */\n    using epdir = FieldModel<uint32_t, address, 15, 1, bankOffset>;\n\
    \    /**\n     * @brief LSDEV field\n     *\n     * Low-speed device\n     */\n\
    \    using lsdev = FieldModel<uint32_t, address, 17, 1, bankOffset>;\n    /**\n\
    \     * @brief EPTYP field\n     *\n     * Endpoint type\n     */\n    using eptyp\
    \ = FieldModel<uint32_t, address, 18, 2, bankOffset>;\n    /**\n     * @brief\
    \ MCNT field\n     *\n     * Multicount\n     */\n    using mcnt = FieldModel<uint32_t,\
    \ address, 20, 2, bankOffset>;\n    /**\n     * @brief DAD field\n     *\n   \
    \  * Device address\n     */\n    using dad = FieldModel<uint32_t, address, 22,\
    \ 7, bankOffset>;\n    /**\n     * @brief ODDFRM field\n     *\n     * Odd frame\n\
    \     */\n    using oddfrm = FieldModel<uint32_t, address, 29, 1, bankOffset>;\n\
    \    /**\n     * @brief CHDIS field\n     *\n     * Channel disable\n     */\n\
    \    using chdis = FieldModel<uint32_t, address, 30, 1, bankOffset>;\n    /**\n\
    \     * @brief CHENA field\n     *\n     * Channel enable\n     */\n    using\
    \ chena = FieldModel<uint32_t, address, 31, 1, bankOffset>;\n\n  public:\n   \
    \ union reg\n    {\n      uint32_t value;\n      /**\n       * @brief MPSIZ field\n\
    \       *\n       * Maximum packet size\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 11> mpsiz;\n      /**\n       * @brief EPNUM field\n       *\n       * Endpoint\
    \ number\n       */\n      BitFieldModel<uint32_t, 11, 4> epnum;\n      /**\n\
    \       * @brief EPDIR field\n       *\n       * Endpoint direction\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> epdir;\n      /**\n       * @brief LSDEV\
    \ field\n       *\n       * Low-speed device\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> lsdev;\n      /**\n       * @brief EPTYP field\n       *\n       * Endpoint\
    \ type\n       */\n      BitFieldModel<uint32_t, 18, 2> eptyp;\n      /**\n  \
    \     * @brief MCNT field\n       *\n       * Multicount\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 2> mcnt;\n      /**\n       * @brief DAD field\n       *\n       * Device\
    \ address\n       */\n      BitFieldModel<uint32_t, 22, 7> dad;\n      /**\n \
    \      * @brief ODDFRM field\n       *\n       * Odd frame\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 1> oddfrm;\n      /**\n       * @brief CHDIS field\n       *\n       * Channel\
    \ disable\n       */\n      BitFieldModel<uint32_t, 30, 1> chdis;\n      /**\n\
    \       * @brief CHENA field\n       *\n       * Channel enable\n       */\n \
    \     BitFieldModel<uint32_t, 31, 1> chena;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief FS_HCCHARX register bank\n   *\n   * OTG_FS host channel-0 characteristics\n\
    \   *           register (OTG_FS_HCCHAR0)\n   */\n  using fs_hccharx = Fs_hccharxBankReg<BaseAddress\
    \ + 0x0100, 0x0020>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class Fs_hcintxBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    /**\n     * @brief XFRC field\n     *\n   \
    \  * Transfer completed\n     */\n    using xfrc = FieldModel<uint32_t, address,\
    \ 0, 1, bankOffset>;\n    /**\n     * @brief CHH field\n     *\n     * Channel\
    \ halted\n     */\n    using chh = FieldModel<uint32_t, address, 1, 1, bankOffset>;\n\
    \    /**\n     * @brief STALL field\n     *\n     * STALL response received\n\
    \     *               interrupt\n     */\n    using stall = FieldModel<uint32_t,\
    \ address, 3, 1, bankOffset>;\n    /**\n     * @brief NAK field\n     *\n    \
    \ * NAK response received\n     *               interrupt\n     */\n    using\
    \ nak = FieldModel<uint32_t, address, 4, 1, bankOffset>;\n    /**\n     * @brief\
    \ ACK field\n     *\n     * ACK response received/transmitted\n     *        \
    \       interrupt\n     */\n    using ack = FieldModel<uint32_t, address, 5, 1,\
    \ bankOffset>;\n    /**\n     * @brief TXERR field\n     *\n     * Transaction\
    \ error\n     */\n    using txerr = FieldModel<uint32_t, address, 7, 1, bankOffset>;\n\
    \    /**\n     * @brief BBERR field\n     *\n     * Babble error\n     */\n  \
    \  using bberr = FieldModel<uint32_t, address, 8, 1, bankOffset>;\n    /**\n \
    \    * @brief FRMOR field\n     *\n     * Frame overrun\n     */\n    using frmor\
    \ = FieldModel<uint32_t, address, 9, 1, bankOffset>;\n    /**\n     * @brief DTERR\
    \ field\n     *\n     * Data toggle error\n     */\n    using dterr = FieldModel<uint32_t,\
    \ address, 10, 1, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief XFRC field\n       *\n       * Transfer completed\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> xfrc;\n      /**\n       * @brief\
    \ CHH field\n       *\n       * Channel halted\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> chh;\n      /**\n       * @brief STALL field\n       *\n       * STALL\
    \ response received\n       *               interrupt\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> stall;\n      /**\n       * @brief NAK field\n       *\n       * NAK response\
    \ received\n       *               interrupt\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> nak;\n      /**\n       * @brief ACK field\n       *\n       * ACK response\
    \ received/transmitted\n       *               interrupt\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> ack;\n      /**\n       * @brief TXERR field\n       *\n       * Transaction\
    \ error\n       */\n      BitFieldModel<uint32_t, 7, 1> txerr;\n      /**\n  \
    \     * @brief BBERR field\n       *\n       * Babble error\n       */\n     \
    \ BitFieldModel<uint32_t, 8, 1> bberr;\n      /**\n       * @brief FRMOR field\n\
    \       *\n       * Frame overrun\n       */\n      BitFieldModel<uint32_t, 9,\
    \ 1> frmor;\n      /**\n       * @brief DTERR field\n       *\n       * Data toggle\
    \ error\n       */\n      BitFieldModel<uint32_t, 10, 1> dterr;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief FS_HCINTX register bank\n   *\n   * OTG_FS host\
    \ channel-0 interrupt register\n   *           (OTG_FS_HCINT0)\n   */\n  using\
    \ fs_hcintx = Fs_hcintxBankReg<BaseAddress + 0x0108, 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class Fs_hcintmskxBankReg : public\
    \ RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n    /**\n\
    \     * @brief XFRCM field\n     *\n     * Transfer completed mask\n     */\n\
    \    using xfrcm = FieldModel<uint32_t, address, 0, 1, bankOffset>;\n    /**\n\
    \     * @brief CHHM field\n     *\n     * Channel halted mask\n     */\n    using\
    \ chhm = FieldModel<uint32_t, address, 1, 1, bankOffset>;\n    /**\n     * @brief\
    \ STALLM field\n     *\n     * STALL response received interrupt\n     *     \
    \          mask\n     */\n    using stallm = FieldModel<uint32_t, address, 3,\
    \ 1, bankOffset>;\n    /**\n     * @brief NAKM field\n     *\n     * NAK response\
    \ received interrupt\n     *               mask\n     */\n    using nakm = FieldModel<uint32_t,\
    \ address, 4, 1, bankOffset>;\n    /**\n     * @brief ACKM field\n     *\n   \
    \  * ACK response received/transmitted\n     *               interrupt mask\n\
    \     */\n    using ackm = FieldModel<uint32_t, address, 5, 1, bankOffset>;\n\
    \    /**\n     * @brief NYET field\n     *\n     * response received interrupt\n\
    \     *               mask\n     */\n    using nyet = FieldModel<uint32_t, address,\
    \ 6, 1, bankOffset>;\n    /**\n     * @brief TXERRM field\n     *\n     * Transaction\
    \ error mask\n     */\n    using txerrm = FieldModel<uint32_t, address, 7, 1,\
    \ bankOffset>;\n    /**\n     * @brief BBERRM field\n     *\n     * Babble error\
    \ mask\n     */\n    using bberrm = FieldModel<uint32_t, address, 8, 1, bankOffset>;\n\
    \    /**\n     * @brief FRMORM field\n     *\n     * Frame overrun mask\n    \
    \ */\n    using frmorm = FieldModel<uint32_t, address, 9, 1, bankOffset>;\n  \
    \  /**\n     * @brief DTERRM field\n     *\n     * Data toggle error mask\n  \
    \   */\n    using dterrm = FieldModel<uint32_t, address, 10, 1, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      /**\n       *\
    \ @brief XFRCM field\n       *\n       * Transfer completed mask\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> xfrcm;\n      /**\n       * @brief CHHM field\n\
    \       *\n       * Channel halted mask\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> chhm;\n      /**\n       * @brief STALLM field\n       *\n       * STALL\
    \ response received interrupt\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> stallm;\n      /**\n       * @brief NAKM field\n       *\n       * NAK\
    \ response received interrupt\n       *               mask\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> nakm;\n      /**\n       * @brief ACKM field\n       *\n       * ACK response\
    \ received/transmitted\n       *               interrupt mask\n       */\n   \
    \   BitFieldModel<uint32_t, 5, 1> ackm;\n      /**\n       * @brief NYET field\n\
    \       *\n       * response received interrupt\n       *               mask\n\
    \       */\n      BitFieldModel<uint32_t, 6, 1> nyet;\n      /**\n       * @brief\
    \ TXERRM field\n       *\n       * Transaction error mask\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> txerrm;\n      /**\n       * @brief BBERRM field\n       *\n       * Babble\
    \ error mask\n       */\n      BitFieldModel<uint32_t, 8, 1> bberrm;\n      /**\n\
    \       * @brief FRMORM field\n       *\n       * Frame overrun mask\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> frmorm;\n      /**\n       * @brief DTERRM\
    \ field\n       *\n       * Data toggle error mask\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> dterrm;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_HCINTMSKX register\
    \ bank\n   *\n   * OTG_FS host channel-0 mask register\n   *           (OTG_FS_HCINTMSK0)\n\
    \   */\n  using fs_hcintmskx = Fs_hcintmskxBankReg<BaseAddress + 0x010C, 0x0020>;\n\
    \nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n  class\
    \ Fs_hctsizxBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n\
    \  {\n  public:\n    /**\n     * @brief XFRSIZ field\n     *\n     * Transfer\
    \ size\n     */\n    using xfrsiz = FieldModel<uint32_t, address, 0, 19, bankOffset>;\n\
    \    /**\n     * @brief PKTCNT field\n     *\n     * Packet count\n     */\n \
    \   using pktcnt = FieldModel<uint32_t, address, 19, 10, bankOffset>;\n    /**\n\
    \     * @brief DPID field\n     *\n     * Data PID\n     */\n    using dpid =\
    \ FieldModel<uint32_t, address, 29, 2, bankOffset>;\n\n  public:\n    union reg\n\
    \    {\n      uint32_t value;\n      /**\n       * @brief XFRSIZ field\n     \
    \  *\n       * Transfer size\n       */\n      BitFieldModel<uint32_t, 0, 19>\
    \ xfrsiz;\n      /**\n       * @brief PKTCNT field\n       *\n       * Packet\
    \ count\n       */\n      BitFieldModel<uint32_t, 19, 10> pktcnt;\n      /**\n\
    \       * @brief DPID field\n       *\n       * Data PID\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 2> dpid;\n    };\n  };\n\npublic:\n  /**\n   * @brief FS_HCTSIZX register\
    \ bank\n   *\n   * OTG_FS host channel-0 transfer size\n   *           register\n\
    \   */\n  using fs_hctsizx = Fs_hctsizxBankReg<BaseAddress + 0x0110, 0x0020>;\n\
    \n};\n\n}\n\n#endif /* DRAL_STM32F411_OTG_FS_HOST_H */"
  name: OTG_FS_HOST
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_OTG_FS_PWRCLK_H\n#define DRAL_STM32F411_OTG_FS_PWRCLK_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ OTG_FS_PWRCLK peripheral\n *\n * USB on the go full speed\n */\nclass otg_fs_pwrclk\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x50000E00; /**< Peripheral\
    \ base address */\n\nprivate:\n  template<unsigned int address>\n  class Fs_pcgcctlReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ STPPCLK field\n     *\n     * Stop PHY clock\n     */\n    using stppclk = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    /**\n     * @brief GATEHCLK field\n     *\n     * Gate\
    \ HCLK\n     */\n    using gatehclk = FieldModel<uint32_t, address, 1, 1>;\n \
    \   /**\n     * @brief PHYSUSP field\n     *\n     * PHY Suspended\n     */\n\
    \    using physusp = FieldModel<uint32_t, address, 4, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ STPPCLK field\n       *\n       * Stop PHY clock\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> stppclk;\n      /**\n       * @brief GATEHCLK field\n       *\n      \
    \ * Gate HCLK\n       */\n      BitFieldModel<uint32_t, 1, 1> gatehclk;\n    \
    \  /**\n       * @brief PHYSUSP field\n       *\n       * PHY Suspended\n    \
    \   */\n      BitFieldModel<uint32_t, 4, 1> physusp;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief FS_PCGCCTL register\n   *\n   * OTG_FS power and clock gating\
    \ control\n   *           register\n   */\n  using fs_pcgcctl = Fs_pcgcctlReg<BaseAddress\
    \ + 0x0000>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_OTG_FS_PWRCLK_H */"
  name: OTG_FS_PWRCLK
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_PWR_H\n#define DRAL_STM32F411_PWR_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ PWR peripheral\n *\n * Power control\n */\nclass pwr\n{\npublic:\n  static constexpr\
    \ unsigned int BaseAddress = 0x40007000; /**< Peripheral base address */\n\nprivate:\n\
    \  template<unsigned int address>\n  class CrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief VOS field\n     *\n     * Regulator\
    \ voltage scaling output\n     *               selection\n     */\n    using vos\
    \ = FieldModel<uint32_t, address, 14, 2>;\n    /**\n     * @brief ADCDC1 field\n\
    \     *\n     * ADCDC1\n     */\n    using adcdc1 = FieldModel<uint32_t, address,\
    \ 13, 1>;\n    /**\n     * @brief FPDS field\n     *\n     * Flash power down\
    \ in Stop\n     *               mode\n     */\n    using fpds = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief DBP field\n     *\n     * Disable backup\
    \ domain write\n     *               protection\n     */\n    using dbp = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief PLS field\n     *\n     * PVD level\
    \ selection\n     */\n    using pls = FieldModel<uint32_t, address, 5, 3>;\n \
    \   /**\n     * @brief PVDE field\n     *\n     * Power voltage detector\n   \
    \  *               enable\n     */\n    using pvde = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief CSBF field\n     *\n     * Clear standby flag\n\
    \     */\n    using csbf = FieldModel<uint32_t, address, 3, 1>;\n    /**\n   \
    \  * @brief CWUF field\n     *\n     * Clear wakeup flag\n     */\n    using cwuf\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief PDDS field\n\
    \     *\n     * Power down deepsleep\n     */\n    using pdds = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief LPDS field\n     *\n     * Low-power\
    \ deep sleep\n     */\n    using lpds = FieldModel<uint32_t, address, 0, 1>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief VOS field\n       *\n       * Regulator voltage\
    \ scaling output\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 2> vos;\n      /**\n       * @brief ADCDC1 field\n       *\n       * ADCDC1\n\
    \       */\n      BitFieldModel<uint32_t, 13, 1> adcdc1;\n      /**\n       *\
    \ @brief FPDS field\n       *\n       * Flash power down in Stop\n       *   \
    \            mode\n       */\n      BitFieldModel<uint32_t, 9, 1> fpds;\n    \
    \  /**\n       * @brief DBP field\n       *\n       * Disable backup domain write\n\
    \       *               protection\n       */\n      BitFieldModel<uint32_t, 8,\
    \ 1> dbp;\n      /**\n       * @brief PLS field\n       *\n       * PVD level\
    \ selection\n       */\n      BitFieldModel<uint32_t, 5, 3> pls;\n      /**\n\
    \       * @brief PVDE field\n       *\n       * Power voltage detector\n     \
    \  *               enable\n       */\n      BitFieldModel<uint32_t, 4, 1> pvde;\n\
    \      /**\n       * @brief CSBF field\n       *\n       * Clear standby flag\n\
    \       */\n      BitFieldModel<uint32_t, 3, 1> csbf;\n      /**\n       * @brief\
    \ CWUF field\n       *\n       * Clear wakeup flag\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cwuf;\n      /**\n       * @brief PDDS field\n       *\n       * Power\
    \ down deepsleep\n       */\n      BitFieldModel<uint32_t, 1, 1> pdds;\n     \
    \ /**\n       * @brief LPDS field\n       *\n       * Low-power deep sleep\n \
    \      */\n      BitFieldModel<uint32_t, 0, 1> lpds;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR register\n   *\n   * power control register\n   */\n  using\
    \ cr = CrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class CsrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief WUF field\n     *\n     * Wakeup flag\n     */\n    using\
    \ wuf = FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief SBF field\n\
    \     *\n     * Standby flag\n     */\n    using sbf = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    /**\n     * @brief PVDO field\n     *\n     * PVD output\n     */\n\
    \    using pvdo = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief\
    \ BRR field\n     *\n     * Backup regulator ready\n     */\n    using brr = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief EWUP field\n     *\n     * Enable WKUP\
    \ pin\n     */\n    using ewup = FieldModel<uint32_t, address, 8, 1>;\n    /**\n\
    \     * @brief BRE field\n     *\n     * Backup regulator enable\n     */\n  \
    \  using bre = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief VOSRDY\
    \ field\n     *\n     * Regulator voltage scaling output\n     *             \
    \  selection ready bit\n     */\n    using vosrdy = FieldModel<uint32_t, address,\
    \ 14, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief WUF field\n       *\n \
    \      * Wakeup flag\n       */\n      BitFieldModel<uint32_t, 0, 1> wuf;\n  \
    \    /**\n       * @brief SBF field\n       *\n       * Standby flag\n       */\n\
    \      BitFieldModel<uint32_t, 1, 1> sbf;\n      /**\n       * @brief PVDO field\n\
    \       *\n       * PVD output\n       */\n      BitFieldModel<uint32_t, 2, 1>\
    \ pvdo;\n      /**\n       * @brief BRR field\n       *\n       * Backup regulator\
    \ ready\n       */\n      BitFieldModel<uint32_t, 3, 1> brr;\n      /**\n    \
    \   * @brief EWUP field\n       *\n       * Enable WKUP pin\n       */\n     \
    \ BitFieldModel<uint32_t, 8, 1> ewup;\n      /**\n       * @brief BRE field\n\
    \       *\n       * Backup regulator enable\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> bre;\n      /**\n       * @brief VOSRDY field\n       *\n       * Regulator\
    \ voltage scaling output\n       *               selection ready bit\n       */\n\
    \      BitFieldModel<uint32_t, 14, 1> vosrdy;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief CSR register\n   *\n   * power control/status register\n   */\n \
    \ using csr = CsrReg<BaseAddress + 0x0004>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_PWR_H\
    \ */"
  name: PWR
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_RCC_H\n#define DRAL_STM32F411_RCC_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ RCC peripheral\n *\n * Reset and clock control\n */\nclass rcc\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40023800; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class CrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief PLLI2SRDY\
    \ field\n     *\n     * PLLI2S clock ready flag\n     */\n    using plli2srdy\
    \ = FieldModel<uint32_t, address, 27, 1>;\n    /**\n     * @brief PLLI2SON field\n\
    \     *\n     * PLLI2S enable\n     */\n    using plli2son = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    /**\n     * @brief PLLRDY field\n     *\n     * Main PLL\
    \ (PLL) clock ready\n     *               flag\n     */\n    using pllrdy = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    /**\n     * @brief PLLON field\n     *\n     * Main PLL\
    \ (PLL) enable\n     */\n    using pllon = FieldModel<uint32_t, address, 24, 1>;\n\
    \    /**\n     * @brief CSSON field\n     *\n     * Clock security system\n  \
    \   *               enable\n     */\n    using csson = FieldModel<uint32_t, address,\
    \ 19, 1>;\n    /**\n     * @brief HSEBYP field\n     *\n     * HSE clock bypass\n\
    \     */\n    using hsebyp = FieldModel<uint32_t, address, 18, 1>;\n    /**\n\
    \     * @brief HSERDY field\n     *\n     * HSE clock ready flag\n     */\n  \
    \  using hserdy = FieldModel<uint32_t, address, 17, 1>;\n    /**\n     * @brief\
    \ HSEON field\n     *\n     * HSE clock enable\n     */\n    using hseon = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    /**\n     * @brief HSICAL field\n     *\n     * Internal\
    \ high-speed clock\n     *               calibration\n     */\n    using hsical\
    \ = FieldModel<uint32_t, address, 8, 8>;\n    /**\n     * @brief HSITRIM field\n\
    \     *\n     * Internal high-speed clock\n     *               trimming\n   \
    \  */\n    using hsitrim = FieldModel<uint32_t, address, 3, 5>;\n    /**\n   \
    \  * @brief HSIRDY field\n     *\n     * Internal high-speed clock ready\n   \
    \  *               flag\n     */\n    using hsirdy = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    /**\n     * @brief HSION field\n     *\n     * Internal high-speed\
    \ clock\n     *               enable\n     */\n    using hsion = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief PLLI2SRDY field\n     \
    \  *\n       * PLLI2S clock ready flag\n       */\n      BitFieldModel<uint32_t,\
    \ 27, 1> plli2srdy;\n      /**\n       * @brief PLLI2SON field\n       *\n   \
    \    * PLLI2S enable\n       */\n      BitFieldModel<uint32_t, 26, 1> plli2son;\n\
    \      /**\n       * @brief PLLRDY field\n       *\n       * Main PLL (PLL) clock\
    \ ready\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 1> pllrdy;\n      /**\n       * @brief PLLON field\n       *\n       * Main\
    \ PLL (PLL) enable\n       */\n      BitFieldModel<uint32_t, 24, 1> pllon;\n \
    \     /**\n       * @brief CSSON field\n       *\n       * Clock security system\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 19, 1>\
    \ csson;\n      /**\n       * @brief HSEBYP field\n       *\n       * HSE clock\
    \ bypass\n       */\n      BitFieldModel<uint32_t, 18, 1> hsebyp;\n      /**\n\
    \       * @brief HSERDY field\n       *\n       * HSE clock ready flag\n     \
    \  */\n      BitFieldModel<uint32_t, 17, 1> hserdy;\n      /**\n       * @brief\
    \ HSEON field\n       *\n       * HSE clock enable\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> hseon;\n      /**\n       * @brief HSICAL field\n       *\n       * Internal\
    \ high-speed clock\n       *               calibration\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 8> hsical;\n      /**\n       * @brief HSITRIM field\n       *\n       *\
    \ Internal high-speed clock\n       *               trimming\n       */\n    \
    \  BitFieldModel<uint32_t, 3, 5> hsitrim;\n      /**\n       * @brief HSIRDY field\n\
    \       *\n       * Internal high-speed clock ready\n       *               flag\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> hsirdy;\n      /**\n       * @brief\
    \ HSION field\n       *\n       * Internal high-speed clock\n       *        \
    \       enable\n       */\n      BitFieldModel<uint32_t, 0, 1> hsion;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief CR register\n   *\n   * clock control register\n\
    \   */\n  using cr = CrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class PllcfgrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief PLLQ3 field\n     *\n     * Main PLL (PLL)\
    \ division factor for USB\n     *               OTG FS, SDIO and random number\
    \ generator\n     *               clocks\n     */\n    using pllq3 = FieldModel<uint32_t,\
    \ address, 27, 1>;\n    /**\n     * @brief PLLQ2 field\n     *\n     * Main PLL\
    \ (PLL) division factor for USB\n     *               OTG FS, SDIO and random\
    \ number generator\n     *               clocks\n     */\n    using pllq2 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    /**\n     * @brief PLLQ1 field\n     *\n     * Main PLL\
    \ (PLL) division factor for USB\n     *               OTG FS, SDIO and random\
    \ number generator\n     *               clocks\n     */\n    using pllq1 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    /**\n     * @brief PLLQ0 field\n     *\n     * Main PLL\
    \ (PLL) division factor for USB\n     *               OTG FS, SDIO and random\
    \ number generator\n     *               clocks\n     */\n    using pllq0 = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    /**\n     * @brief PLLSRC field\n     *\n     * Main PLL(PLL)\
    \ and audio PLL (PLLI2S)\n     *               entry clock source\n     */\n \
    \   using pllsrc = FieldModel<uint32_t, address, 22, 1>;\n    /**\n     * @brief\
    \ PLLP1 field\n     *\n     * Main PLL (PLL) division factor for main\n     *\
    \               system clock\n     */\n    using pllp1 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    /**\n     * @brief PLLP0 field\n     *\n     * Main PLL\
    \ (PLL) division factor for main\n     *               system clock\n     */\n\
    \    using pllp0 = FieldModel<uint32_t, address, 16, 1>;\n    /**\n     * @brief\
    \ PLLN8 field\n     *\n     * Main PLL (PLL) multiplication factor for\n     *\
    \               VCO\n     */\n    using plln8 = FieldModel<uint32_t, address,\
    \ 14, 1>;\n    /**\n     * @brief PLLN7 field\n     *\n     * Main PLL (PLL) multiplication\
    \ factor for\n     *               VCO\n     */\n    using plln7 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief PLLN6 field\n     *\n     * Main PLL\
    \ (PLL) multiplication factor for\n     *               VCO\n     */\n    using\
    \ plln6 = FieldModel<uint32_t, address, 12, 1>;\n    /**\n     * @brief PLLN5\
    \ field\n     *\n     * Main PLL (PLL) multiplication factor for\n     *     \
    \          VCO\n     */\n    using plln5 = FieldModel<uint32_t, address, 11, 1>;\n\
    \    /**\n     * @brief PLLN4 field\n     *\n     * Main PLL (PLL) multiplication\
    \ factor for\n     *               VCO\n     */\n    using plln4 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief PLLN3 field\n     *\n     * Main PLL\
    \ (PLL) multiplication factor for\n     *               VCO\n     */\n    using\
    \ plln3 = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief PLLN2 field\n\
    \     *\n     * Main PLL (PLL) multiplication factor for\n     *             \
    \  VCO\n     */\n    using plln2 = FieldModel<uint32_t, address, 8, 1>;\n    /**\n\
    \     * @brief PLLN1 field\n     *\n     * Main PLL (PLL) multiplication factor\
    \ for\n     *               VCO\n     */\n    using plln1 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief PLLN0 field\n     *\n     * Main PLL\
    \ (PLL) multiplication factor for\n     *               VCO\n     */\n    using\
    \ plln0 = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief PLLM5 field\n\
    \     *\n     * Division factor for the main PLL (PLL)\n     *               and\
    \ audio PLL (PLLI2S) input clock\n     */\n    using pllm5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief PLLM4 field\n     *\n     * Division\
    \ factor for the main PLL (PLL)\n     *               and audio PLL (PLLI2S) input\
    \ clock\n     */\n    using pllm4 = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ /**\n     * @brief PLLM3 field\n     *\n     * Division factor for the main\
    \ PLL (PLL)\n     *               and audio PLL (PLLI2S) input clock\n     */\n\
    \    using pllm3 = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief\
    \ PLLM2 field\n     *\n     * Division factor for the main PLL (PLL)\n     * \
    \              and audio PLL (PLLI2S) input clock\n     */\n    using pllm2 =\
    \ FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief PLLM1 field\n \
    \    *\n     * Division factor for the main PLL (PLL)\n     *               and\
    \ audio PLL (PLLI2S) input clock\n     */\n    using pllm1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief PLLM0 field\n     *\n     * Division\
    \ factor for the main PLL (PLL)\n     *               and audio PLL (PLLI2S) input\
    \ clock\n     */\n    using pllm0 = FieldModel<uint32_t, address, 0, 1>;\n\n \
    \ public:\n    /**\n     * @brief Register union\n     *\n     * Can be used to\
    \ create a local register variable for easy bit manipulation.\n     * Useful for\
    \ read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief PLLQ3 field\n       *\n       * Main PLL\
    \ (PLL) division factor for USB\n       *               OTG FS, SDIO and random\
    \ number generator\n       *               clocks\n       */\n      BitFieldModel<uint32_t,\
    \ 27, 1> pllq3;\n      /**\n       * @brief PLLQ2 field\n       *\n       * Main\
    \ PLL (PLL) division factor for USB\n       *               OTG FS, SDIO and random\
    \ number generator\n       *               clocks\n       */\n      BitFieldModel<uint32_t,\
    \ 26, 1> pllq2;\n      /**\n       * @brief PLLQ1 field\n       *\n       * Main\
    \ PLL (PLL) division factor for USB\n       *               OTG FS, SDIO and random\
    \ number generator\n       *               clocks\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 1> pllq1;\n      /**\n       * @brief PLLQ0 field\n       *\n       * Main\
    \ PLL (PLL) division factor for USB\n       *               OTG FS, SDIO and random\
    \ number generator\n       *               clocks\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 1> pllq0;\n      /**\n       * @brief PLLSRC field\n       *\n       * Main\
    \ PLL(PLL) and audio PLL (PLLI2S)\n       *               entry clock source\n\
    \       */\n      BitFieldModel<uint32_t, 22, 1> pllsrc;\n      /**\n       *\
    \ @brief PLLP1 field\n       *\n       * Main PLL (PLL) division factor for main\n\
    \       *               system clock\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> pllp1;\n      /**\n       * @brief PLLP0 field\n       *\n       * Main\
    \ PLL (PLL) division factor for main\n       *               system clock\n  \
    \     */\n      BitFieldModel<uint32_t, 16, 1> pllp0;\n      /**\n       * @brief\
    \ PLLN8 field\n       *\n       * Main PLL (PLL) multiplication factor for\n \
    \      *               VCO\n       */\n      BitFieldModel<uint32_t, 14, 1> plln8;\n\
    \      /**\n       * @brief PLLN7 field\n       *\n       * Main PLL (PLL) multiplication\
    \ factor for\n       *               VCO\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> plln7;\n      /**\n       * @brief PLLN6 field\n       *\n       * Main\
    \ PLL (PLL) multiplication factor for\n       *               VCO\n       */\n\
    \      BitFieldModel<uint32_t, 12, 1> plln6;\n      /**\n       * @brief PLLN5\
    \ field\n       *\n       * Main PLL (PLL) multiplication factor for\n       *\
    \               VCO\n       */\n      BitFieldModel<uint32_t, 11, 1> plln5;\n\
    \      /**\n       * @brief PLLN4 field\n       *\n       * Main PLL (PLL) multiplication\
    \ factor for\n       *               VCO\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> plln4;\n      /**\n       * @brief PLLN3 field\n       *\n       * Main\
    \ PLL (PLL) multiplication factor for\n       *               VCO\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> plln3;\n      /**\n       * @brief PLLN2\
    \ field\n       *\n       * Main PLL (PLL) multiplication factor for\n       *\
    \               VCO\n       */\n      BitFieldModel<uint32_t, 8, 1> plln2;\n \
    \     /**\n       * @brief PLLN1 field\n       *\n       * Main PLL (PLL) multiplication\
    \ factor for\n       *               VCO\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> plln1;\n      /**\n       * @brief PLLN0 field\n       *\n       * Main\
    \ PLL (PLL) multiplication factor for\n       *               VCO\n       */\n\
    \      BitFieldModel<uint32_t, 6, 1> plln0;\n      /**\n       * @brief PLLM5\
    \ field\n       *\n       * Division factor for the main PLL (PLL)\n       * \
    \              and audio PLL (PLLI2S) input clock\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> pllm5;\n      /**\n       * @brief PLLM4 field\n       *\n       * Division\
    \ factor for the main PLL (PLL)\n       *               and audio PLL (PLLI2S)\
    \ input clock\n       */\n      BitFieldModel<uint32_t, 4, 1> pllm4;\n      /**\n\
    \       * @brief PLLM3 field\n       *\n       * Division factor for the main\
    \ PLL (PLL)\n       *               and audio PLL (PLLI2S) input clock\n     \
    \  */\n      BitFieldModel<uint32_t, 3, 1> pllm3;\n      /**\n       * @brief\
    \ PLLM2 field\n       *\n       * Division factor for the main PLL (PLL)\n   \
    \    *               and audio PLL (PLLI2S) input clock\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> pllm2;\n      /**\n       * @brief PLLM1 field\n       *\n       * Division\
    \ factor for the main PLL (PLL)\n       *               and audio PLL (PLLI2S)\
    \ input clock\n       */\n      BitFieldModel<uint32_t, 1, 1> pllm1;\n      /**\n\
    \       * @brief PLLM0 field\n       *\n       * Division factor for the main\
    \ PLL (PLL)\n       *               and audio PLL (PLLI2S) input clock\n     \
    \  */\n      BitFieldModel<uint32_t, 0, 1> pllm0;\n    };\n  };\n\npublic:\n \
    \ /**\n   * @brief PLLCFGR register\n   *\n   * PLL configuration register\n \
    \  */\n  using pllcfgr = PllcfgrReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CfgrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief MCO2 field\n     *\n     * Microcontroller\
    \ clock output\n     *               2\n     */\n    using mco2 = FieldModel<uint32_t,\
    \ address, 30, 2>;\n    /**\n     * @brief MCO2PRE field\n     *\n     * MCO2\
    \ prescaler\n     */\n    using mco2pre = FieldModel<uint32_t, address, 27, 3>;\n\
    \    /**\n     * @brief MCO1PRE field\n     *\n     * MCO1 prescaler\n     */\n\
    \    using mco1pre = FieldModel<uint32_t, address, 24, 3>;\n    /**\n     * @brief\
    \ I2SSRC field\n     *\n     * I2S clock selection\n     */\n    using i2ssrc\
    \ = FieldModel<uint32_t, address, 23, 1>;\n    /**\n     * @brief MCO1 field\n\
    \     *\n     * Microcontroller clock output\n     *               1\n     */\n\
    \    using mco1 = FieldModel<uint32_t, address, 21, 2>;\n    /**\n     * @brief\
    \ RTCPRE field\n     *\n     * HSE division factor for RTC\n     *           \
    \    clock\n     */\n    using rtcpre = FieldModel<uint32_t, address, 16, 5>;\n\
    \    /**\n     * @brief PPRE2 field\n     *\n     * APB high-speed prescaler\n\
    \     *               (APB2)\n     */\n    using ppre2 = FieldModel<uint32_t,\
    \ address, 13, 3>;\n    /**\n     * @brief PPRE1 field\n     *\n     * APB Low\
    \ speed prescaler\n     *               (APB1)\n     */\n    using ppre1 = FieldModel<uint32_t,\
    \ address, 10, 3>;\n    /**\n     * @brief HPRE field\n     *\n     * AHB prescaler\n\
    \     */\n    using hpre = FieldModel<uint32_t, address, 4, 4>;\n    /**\n   \
    \  * @brief SWS1 field\n     *\n     * System clock switch status\n     */\n \
    \   using sws1 = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief\
    \ SWS0 field\n     *\n     * System clock switch status\n     */\n    using sws0\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief SW1 field\n \
    \    *\n     * System clock switch\n     */\n    using sw1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief SW0 field\n     *\n     * System clock\
    \ switch\n     */\n    using sw0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief MCO2 field\n       *\n       * Microcontroller clock output\n\
    \       *               2\n       */\n      BitFieldModel<uint32_t, 30, 2> mco2;\n\
    \      /**\n       * @brief MCO2PRE field\n       *\n       * MCO2 prescaler\n\
    \       */\n      BitFieldModel<uint32_t, 27, 3> mco2pre;\n      /**\n       *\
    \ @brief MCO1PRE field\n       *\n       * MCO1 prescaler\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 3> mco1pre;\n      /**\n       * @brief I2SSRC field\n       *\n       *\
    \ I2S clock selection\n       */\n      BitFieldModel<uint32_t, 23, 1> i2ssrc;\n\
    \      /**\n       * @brief MCO1 field\n       *\n       * Microcontroller clock\
    \ output\n       *               1\n       */\n      BitFieldModel<uint32_t, 21,\
    \ 2> mco1;\n      /**\n       * @brief RTCPRE field\n       *\n       * HSE division\
    \ factor for RTC\n       *               clock\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 5> rtcpre;\n      /**\n       * @brief PPRE2 field\n       *\n       * APB\
    \ high-speed prescaler\n       *               (APB2)\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 3> ppre2;\n      /**\n       * @brief PPRE1 field\n       *\n       * APB\
    \ Low speed prescaler\n       *               (APB1)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 3> ppre1;\n      /**\n       * @brief HPRE field\n       *\n       * AHB\
    \ prescaler\n       */\n      BitFieldModel<uint32_t, 4, 4> hpre;\n      /**\n\
    \       * @brief SWS1 field\n       *\n       * System clock switch status\n \
    \      */\n      BitFieldModel<uint32_t, 3, 1> sws1;\n      /**\n       * @brief\
    \ SWS0 field\n       *\n       * System clock switch status\n       */\n     \
    \ BitFieldModel<uint32_t, 2, 1> sws0;\n      /**\n       * @brief SW1 field\n\
    \       *\n       * System clock switch\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> sw1;\n      /**\n       * @brief SW0 field\n       *\n       * System\
    \ clock switch\n       */\n      BitFieldModel<uint32_t, 0, 1> sw0;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief CFGR register\n   *\n   * clock configuration\
    \ register\n   */\n  using cfgr = CfgrReg<BaseAddress + 0x0008>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class CirReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CSSC field\n     *\n     *\
    \ Clock security system interrupt\n     *               clear\n     */\n    using\
    \ cssc = FieldModel<uint32_t, address, 23, 1>;\n    /**\n     * @brief PLLI2SRDYC\
    \ field\n     *\n     * PLLI2S ready interrupt\n     *               clear\n \
    \    */\n    using plli2srdyc = FieldModel<uint32_t, address, 21, 1>;\n    /**\n\
    \     * @brief PLLRDYC field\n     *\n     * Main PLL(PLL) ready interrupt\n \
    \    *               clear\n     */\n    using pllrdyc = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief HSERDYC field\n     *\n     * HSE ready\
    \ interrupt clear\n     */\n    using hserdyc = FieldModel<uint32_t, address,\
    \ 19, 1>;\n    /**\n     * @brief HSIRDYC field\n     *\n     * HSI ready interrupt\
    \ clear\n     */\n    using hsirdyc = FieldModel<uint32_t, address, 18, 1>;\n\
    \    /**\n     * @brief LSERDYC field\n     *\n     * LSE ready interrupt clear\n\
    \     */\n    using lserdyc = FieldModel<uint32_t, address, 17, 1>;\n    /**\n\
    \     * @brief LSIRDYC field\n     *\n     * LSI ready interrupt clear\n     */\n\
    \    using lsirdyc = FieldModel<uint32_t, address, 16, 1>;\n    /**\n     * @brief\
    \ PLLI2SRDYIE field\n     *\n     * PLLI2S ready interrupt\n     *           \
    \    enable\n     */\n    using plli2srdyie = FieldModel<uint32_t, address, 13,\
    \ 1>;\n    /**\n     * @brief PLLRDYIE field\n     *\n     * Main PLL (PLL) ready\
    \ interrupt\n     *               enable\n     */\n    using pllrdyie = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief HSERDYIE field\n     *\n     * HSE\
    \ ready interrupt enable\n     */\n    using hserdyie = FieldModel<uint32_t, address,\
    \ 11, 1>;\n    /**\n     * @brief HSIRDYIE field\n     *\n     * HSI ready interrupt\
    \ enable\n     */\n    using hsirdyie = FieldModel<uint32_t, address, 10, 1>;\n\
    \    /**\n     * @brief LSERDYIE field\n     *\n     * LSE ready interrupt enable\n\
    \     */\n    using lserdyie = FieldModel<uint32_t, address, 9, 1>;\n    /**\n\
    \     * @brief LSIRDYIE field\n     *\n     * LSI ready interrupt enable\n   \
    \  */\n    using lsirdyie = FieldModel<uint32_t, address, 8, 1>;\n    /**\n  \
    \   * @brief CSSF field\n     *\n     * Clock security system interrupt\n    \
    \ *               flag\n     */\n    using cssf = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    /**\n     * @brief PLLI2SRDYF field\n     *\n     * PLLI2S ready\
    \ interrupt\n     *               flag\n     */\n    using plli2srdyf = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief PLLRDYF field\n     *\n     * Main PLL\
    \ (PLL) ready interrupt\n     *               flag\n     */\n    using pllrdyf\
    \ = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief HSERDYF field\n\
    \     *\n     * HSE ready interrupt flag\n     */\n    using hserdyf = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief HSIRDYF field\n     *\n     * HSI ready\
    \ interrupt flag\n     */\n    using hsirdyf = FieldModel<uint32_t, address, 2,\
    \ 1>;\n    /**\n     * @brief LSERDYF field\n     *\n     * LSE ready interrupt\
    \ flag\n     */\n    using lserdyf = FieldModel<uint32_t, address, 1, 1>;\n  \
    \  /**\n     * @brief LSIRDYF field\n     *\n     * LSI ready interrupt flag\n\
    \     */\n    using lsirdyf = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CSSC field\n       *\n       * Clock security system interrupt\n\
    \       *               clear\n       */\n      BitFieldModel<uint32_t, 23, 1>\
    \ cssc;\n      /**\n       * @brief PLLI2SRDYC field\n       *\n       * PLLI2S\
    \ ready interrupt\n       *               clear\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 1> plli2srdyc;\n      /**\n       * @brief PLLRDYC field\n       *\n   \
    \    * Main PLL(PLL) ready interrupt\n       *               clear\n       */\n\
    \      BitFieldModel<uint32_t, 20, 1> pllrdyc;\n      /**\n       * @brief HSERDYC\
    \ field\n       *\n       * HSE ready interrupt clear\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> hserdyc;\n      /**\n       * @brief HSIRDYC field\n       *\n      \
    \ * HSI ready interrupt clear\n       */\n      BitFieldModel<uint32_t, 18, 1>\
    \ hsirdyc;\n      /**\n       * @brief LSERDYC field\n       *\n       * LSE ready\
    \ interrupt clear\n       */\n      BitFieldModel<uint32_t, 17, 1> lserdyc;\n\
    \      /**\n       * @brief LSIRDYC field\n       *\n       * LSI ready interrupt\
    \ clear\n       */\n      BitFieldModel<uint32_t, 16, 1> lsirdyc;\n      /**\n\
    \       * @brief PLLI2SRDYIE field\n       *\n       * PLLI2S ready interrupt\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 13, 1>\
    \ plli2srdyie;\n      /**\n       * @brief PLLRDYIE field\n       *\n       *\
    \ Main PLL (PLL) ready interrupt\n       *               enable\n       */\n \
    \     BitFieldModel<uint32_t, 12, 1> pllrdyie;\n      /**\n       * @brief HSERDYIE\
    \ field\n       *\n       * HSE ready interrupt enable\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> hserdyie;\n      /**\n       * @brief HSIRDYIE field\n       *\n    \
    \   * HSI ready interrupt enable\n       */\n      BitFieldModel<uint32_t, 10,\
    \ 1> hsirdyie;\n      /**\n       * @brief LSERDYIE field\n       *\n       *\
    \ LSE ready interrupt enable\n       */\n      BitFieldModel<uint32_t, 9, 1> lserdyie;\n\
    \      /**\n       * @brief LSIRDYIE field\n       *\n       * LSI ready interrupt\
    \ enable\n       */\n      BitFieldModel<uint32_t, 8, 1> lsirdyie;\n      /**\n\
    \       * @brief CSSF field\n       *\n       * Clock security system interrupt\n\
    \       *               flag\n       */\n      BitFieldModel<uint32_t, 7, 1> cssf;\n\
    \      /**\n       * @brief PLLI2SRDYF field\n       *\n       * PLLI2S ready\
    \ interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> plli2srdyf;\n      /**\n       * @brief PLLRDYF field\n       *\n    \
    \   * Main PLL (PLL) ready interrupt\n       *               flag\n       */\n\
    \      BitFieldModel<uint32_t, 4, 1> pllrdyf;\n      /**\n       * @brief HSERDYF\
    \ field\n       *\n       * HSE ready interrupt flag\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> hserdyf;\n      /**\n       * @brief HSIRDYF field\n       *\n       *\
    \ HSI ready interrupt flag\n       */\n      BitFieldModel<uint32_t, 2, 1> hsirdyf;\n\
    \      /**\n       * @brief LSERDYF field\n       *\n       * LSE ready interrupt\
    \ flag\n       */\n      BitFieldModel<uint32_t, 1, 1> lserdyf;\n      /**\n \
    \      * @brief LSIRDYF field\n       *\n       * LSI ready interrupt flag\n \
    \      */\n      BitFieldModel<uint32_t, 0, 1> lsirdyf;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CIR register\n   *\n   * clock interrupt register\n   */\n\
    \  using cir = CirReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ahb1rstrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief DMA2RST field\n     *\n     * DMA2 reset\n\
    \     */\n    using dma2rst = FieldModel<uint32_t, address, 22, 1>;\n    /**\n\
    \     * @brief DMA1RST field\n     *\n     * DMA2 reset\n     */\n    using dma1rst\
    \ = FieldModel<uint32_t, address, 21, 1>;\n    /**\n     * @brief CRCRST field\n\
    \     *\n     * CRC reset\n     */\n    using crcrst = FieldModel<uint32_t, address,\
    \ 12, 1>;\n    /**\n     * @brief GPIOHRST field\n     *\n     * IO port H reset\n\
    \     */\n    using gpiohrst = FieldModel<uint32_t, address, 7, 1>;\n    /**\n\
    \     * @brief GPIOERST field\n     *\n     * IO port E reset\n     */\n    using\
    \ gpioerst = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief GPIODRST\
    \ field\n     *\n     * IO port D reset\n     */\n    using gpiodrst = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief GPIOCRST field\n     *\n     * IO port\
    \ C reset\n     */\n    using gpiocrst = FieldModel<uint32_t, address, 2, 1>;\n\
    \    /**\n     * @brief GPIOBRST field\n     *\n     * IO port B reset\n     */\n\
    \    using gpiobrst = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief\
    \ GPIOARST field\n     *\n     * IO port A reset\n     */\n    using gpioarst\
    \ = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ DMA2RST field\n       *\n       * DMA2 reset\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> dma2rst;\n      /**\n       * @brief DMA1RST field\n       *\n      \
    \ * DMA2 reset\n       */\n      BitFieldModel<uint32_t, 21, 1> dma1rst;\n   \
    \   /**\n       * @brief CRCRST field\n       *\n       * CRC reset\n       */\n\
    \      BitFieldModel<uint32_t, 12, 1> crcrst;\n      /**\n       * @brief GPIOHRST\
    \ field\n       *\n       * IO port H reset\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> gpiohrst;\n      /**\n       * @brief GPIOERST field\n       *\n     \
    \  * IO port E reset\n       */\n      BitFieldModel<uint32_t, 4, 1> gpioerst;\n\
    \      /**\n       * @brief GPIODRST field\n       *\n       * IO port D reset\n\
    \       */\n      BitFieldModel<uint32_t, 3, 1> gpiodrst;\n      /**\n       *\
    \ @brief GPIOCRST field\n       *\n       * IO port C reset\n       */\n     \
    \ BitFieldModel<uint32_t, 2, 1> gpiocrst;\n      /**\n       * @brief GPIOBRST\
    \ field\n       *\n       * IO port B reset\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> gpiobrst;\n      /**\n       * @brief GPIOARST field\n       *\n     \
    \  * IO port A reset\n       */\n      BitFieldModel<uint32_t, 0, 1> gpioarst;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief AHB1RSTR register\n   *\n   * AHB1\
    \ peripheral reset register\n   */\n  using ahb1rstr = Ahb1rstrReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class Ahb2rstrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ OTGFSRST field\n     *\n     * USB OTG FS module reset\n     */\n    using otgfsrst\
    \ = FieldModel<uint32_t, address, 7, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ OTGFSRST field\n       *\n       * USB OTG FS module reset\n       */\n    \
    \  BitFieldModel<uint32_t, 7, 1> otgfsrst;\n    };\n  };\n\npublic:\n  /**\n \
    \  * @brief AHB2RSTR register\n   *\n   * AHB2 peripheral reset register\n   */\n\
    \  using ahb2rstr = Ahb2rstrReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Apb1rstrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief PWRRST field\n     *\n     * Power interface\
    \ reset\n     */\n    using pwrrst = FieldModel<uint32_t, address, 28, 1>;\n \
    \   /**\n     * @brief I2C3RST field\n     *\n     * I2C3 reset\n     */\n   \
    \ using i2c3rst = FieldModel<uint32_t, address, 23, 1>;\n    /**\n     * @brief\
    \ I2C2RST field\n     *\n     * I2C 2 reset\n     */\n    using i2c2rst = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    /**\n     * @brief I2C1RST field\n     *\n     * I2C 1\
    \ reset\n     */\n    using i2c1rst = FieldModel<uint32_t, address, 21, 1>;\n\
    \    /**\n     * @brief UART2RST field\n     *\n     * USART 2 reset\n     */\n\
    \    using uart2rst = FieldModel<uint32_t, address, 17, 1>;\n    /**\n     * @brief\
    \ SPI3RST field\n     *\n     * SPI 3 reset\n     */\n    using spi3rst = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief SPI2RST field\n     *\n     * SPI 2\
    \ reset\n     */\n    using spi2rst = FieldModel<uint32_t, address, 14, 1>;\n\
    \    /**\n     * @brief WWDGRST field\n     *\n     * Window watchdog reset\n\
    \     */\n    using wwdgrst = FieldModel<uint32_t, address, 11, 1>;\n    /**\n\
    \     * @brief TIM5RST field\n     *\n     * TIM5 reset\n     */\n    using tim5rst\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief TIM4RST field\n\
    \     *\n     * TIM4 reset\n     */\n    using tim4rst = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief TIM3RST field\n     *\n     * TIM3 reset\n\
    \     */\n    using tim3rst = FieldModel<uint32_t, address, 1, 1>;\n    /**\n\
    \     * @brief TIM2RST field\n     *\n     * TIM2 reset\n     */\n    using tim2rst\
    \ = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ PWRRST field\n       *\n       * Power interface reset\n       */\n      BitFieldModel<uint32_t,\
    \ 28, 1> pwrrst;\n      /**\n       * @brief I2C3RST field\n       *\n       *\
    \ I2C3 reset\n       */\n      BitFieldModel<uint32_t, 23, 1> i2c3rst;\n     \
    \ /**\n       * @brief I2C2RST field\n       *\n       * I2C 2 reset\n       */\n\
    \      BitFieldModel<uint32_t, 22, 1> i2c2rst;\n      /**\n       * @brief I2C1RST\
    \ field\n       *\n       * I2C 1 reset\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 1> i2c1rst;\n      /**\n       * @brief UART2RST field\n       *\n     \
    \  * USART 2 reset\n       */\n      BitFieldModel<uint32_t, 17, 1> uart2rst;\n\
    \      /**\n       * @brief SPI3RST field\n       *\n       * SPI 3 reset\n  \
    \     */\n      BitFieldModel<uint32_t, 15, 1> spi3rst;\n      /**\n       * @brief\
    \ SPI2RST field\n       *\n       * SPI 2 reset\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> spi2rst;\n      /**\n       * @brief WWDGRST field\n       *\n      \
    \ * Window watchdog reset\n       */\n      BitFieldModel<uint32_t, 11, 1> wwdgrst;\n\
    \      /**\n       * @brief TIM5RST field\n       *\n       * TIM5 reset\n   \
    \    */\n      BitFieldModel<uint32_t, 3, 1> tim5rst;\n      /**\n       * @brief\
    \ TIM4RST field\n       *\n       * TIM4 reset\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> tim4rst;\n      /**\n       * @brief TIM3RST field\n       *\n       *\
    \ TIM3 reset\n       */\n      BitFieldModel<uint32_t, 1, 1> tim3rst;\n      /**\n\
    \       * @brief TIM2RST field\n       *\n       * TIM2 reset\n       */\n   \
    \   BitFieldModel<uint32_t, 0, 1> tim2rst;\n    };\n  };\n\npublic:\n  /**\n \
    \  * @brief APB1RSTR register\n   *\n   * APB1 peripheral reset register\n   */\n\
    \  using apb1rstr = Apb1rstrReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Apb2rstrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief TIM11RST field\n     *\n     * TIM11 reset\n\
    \     */\n    using tim11rst = FieldModel<uint32_t, address, 18, 1>;\n    /**\n\
    \     * @brief TIM10RST field\n     *\n     * TIM10 reset\n     */\n    using\
    \ tim10rst = FieldModel<uint32_t, address, 17, 1>;\n    /**\n     * @brief TIM9RST\
    \ field\n     *\n     * TIM9 reset\n     */\n    using tim9rst = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    /**\n     * @brief SYSCFGRST field\n     *\n     * System\
    \ configuration controller\n     *               reset\n     */\n    using syscfgrst\
    \ = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief SPI1RST field\n\
    \     *\n     * SPI 1 reset\n     */\n    using spi1rst = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief SDIORST field\n     *\n     * SDIO\
    \ reset\n     */\n    using sdiorst = FieldModel<uint32_t, address, 11, 1>;\n\
    \    /**\n     * @brief ADCRST field\n     *\n     * ADC interface reset (common\
    \ to all\n     *               ADCs)\n     */\n    using adcrst = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief USART6RST field\n     *\n     * USART6\
    \ reset\n     */\n    using usart6rst = FieldModel<uint32_t, address, 5, 1>;\n\
    \    /**\n     * @brief USART1RST field\n     *\n     * USART1 reset\n     */\n\
    \    using usart1rst = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief\
    \ TIM1RST field\n     *\n     * TIM1 reset\n     */\n    using tim1rst = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief TIM11RST field\n      \
    \ *\n       * TIM11 reset\n       */\n      BitFieldModel<uint32_t, 18, 1> tim11rst;\n\
    \      /**\n       * @brief TIM10RST field\n       *\n       * TIM10 reset\n \
    \      */\n      BitFieldModel<uint32_t, 17, 1> tim10rst;\n      /**\n       *\
    \ @brief TIM9RST field\n       *\n       * TIM9 reset\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> tim9rst;\n      /**\n       * @brief SYSCFGRST field\n       *\n    \
    \   * System configuration controller\n       *               reset\n       */\n\
    \      BitFieldModel<uint32_t, 14, 1> syscfgrst;\n      /**\n       * @brief SPI1RST\
    \ field\n       *\n       * SPI 1 reset\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> spi1rst;\n      /**\n       * @brief SDIORST field\n       *\n      \
    \ * SDIO reset\n       */\n      BitFieldModel<uint32_t, 11, 1> sdiorst;\n   \
    \   /**\n       * @brief ADCRST field\n       *\n       * ADC interface reset\
    \ (common to all\n       *               ADCs)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> adcrst;\n      /**\n       * @brief USART6RST field\n       *\n      \
    \ * USART6 reset\n       */\n      BitFieldModel<uint32_t, 5, 1> usart6rst;\n\
    \      /**\n       * @brief USART1RST field\n       *\n       * USART1 reset\n\
    \       */\n      BitFieldModel<uint32_t, 4, 1> usart1rst;\n      /**\n      \
    \ * @brief TIM1RST field\n       *\n       * TIM1 reset\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> tim1rst;\n    };\n  };\n\npublic:\n  /**\n   * @brief APB2RSTR register\n\
    \   *\n   * APB2 peripheral reset register\n   */\n  using apb2rstr = Apb2rstrReg<BaseAddress\
    \ + 0x0024>;\n\nprivate:\n  template<unsigned int address>\n  class Ahb1enrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ DMA2EN field\n     *\n     * DMA2 clock enable\n     */\n    using dma2en =\
    \ FieldModel<uint32_t, address, 22, 1>;\n    /**\n     * @brief DMA1EN field\n\
    \     *\n     * DMA1 clock enable\n     */\n    using dma1en = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    /**\n     * @brief CRCEN field\n     *\n     * CRC clock\
    \ enable\n     */\n    using crcen = FieldModel<uint32_t, address, 12, 1>;\n \
    \   /**\n     * @brief GPIOHEN field\n     *\n     * IO port H clock enable\n\
    \     */\n    using gpiohen = FieldModel<uint32_t, address, 7, 1>;\n    /**\n\
    \     * @brief GPIOEEN field\n     *\n     * IO port E clock enable\n     */\n\
    \    using gpioeen = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief\
    \ GPIODEN field\n     *\n     * IO port D clock enable\n     */\n    using gpioden\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief GPIOCEN field\n\
    \     *\n     * IO port C clock enable\n     */\n    using gpiocen = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief GPIOBEN field\n     *\n     * IO port\
    \ B clock enable\n     */\n    using gpioben = FieldModel<uint32_t, address, 1,\
    \ 1>;\n    /**\n     * @brief GPIOAEN field\n     *\n     * IO port A clock enable\n\
    \     */\n    using gpioaen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief DMA2EN field\n       *\n       * DMA2 clock enable\n       */\n\
    \      BitFieldModel<uint32_t, 22, 1> dma2en;\n      /**\n       * @brief DMA1EN\
    \ field\n       *\n       * DMA1 clock enable\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 1> dma1en;\n      /**\n       * @brief CRCEN field\n       *\n       * CRC\
    \ clock enable\n       */\n      BitFieldModel<uint32_t, 12, 1> crcen;\n     \
    \ /**\n       * @brief GPIOHEN field\n       *\n       * IO port H clock enable\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> gpiohen;\n      /**\n       *\
    \ @brief GPIOEEN field\n       *\n       * IO port E clock enable\n       */\n\
    \      BitFieldModel<uint32_t, 4, 1> gpioeen;\n      /**\n       * @brief GPIODEN\
    \ field\n       *\n       * IO port D clock enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> gpioden;\n      /**\n       * @brief GPIOCEN field\n       *\n       *\
    \ IO port C clock enable\n       */\n      BitFieldModel<uint32_t, 2, 1> gpiocen;\n\
    \      /**\n       * @brief GPIOBEN field\n       *\n       * IO port B clock\
    \ enable\n       */\n      BitFieldModel<uint32_t, 1, 1> gpioben;\n      /**\n\
    \       * @brief GPIOAEN field\n       *\n       * IO port A clock enable\n  \
    \     */\n      BitFieldModel<uint32_t, 0, 1> gpioaen;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief AHB1ENR register\n   *\n   * AHB1 peripheral clock register\n\
    \   */\n  using ahb1enr = Ahb1enrReg<BaseAddress + 0x0030>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ahb2enrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief OTGFSEN field\n     *\n     * USB OTG\
    \ FS clock enable\n     */\n    using otgfsen = FieldModel<uint32_t, address,\
    \ 7, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief OTGFSEN field\n       *\n \
    \      * USB OTG FS clock enable\n       */\n      BitFieldModel<uint32_t, 7,\
    \ 1> otgfsen;\n    };\n  };\n\npublic:\n  /**\n   * @brief AHB2ENR register\n\
    \   *\n   * AHB2 peripheral clock enable\n   *           register\n   */\n  using\
    \ ahb2enr = Ahb2enrReg<BaseAddress + 0x0034>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Apb1enrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief PWREN field\n     *\n     * Power interface\
    \ clock\n     *               enable\n     */\n    using pwren = FieldModel<uint32_t,\
    \ address, 28, 1>;\n    /**\n     * @brief I2C3EN field\n     *\n     * I2C3 clock\
    \ enable\n     */\n    using i2c3en = FieldModel<uint32_t, address, 23, 1>;\n\
    \    /**\n     * @brief I2C2EN field\n     *\n     * I2C2 clock enable\n     */\n\
    \    using i2c2en = FieldModel<uint32_t, address, 22, 1>;\n    /**\n     * @brief\
    \ I2C1EN field\n     *\n     * I2C1 clock enable\n     */\n    using i2c1en =\
    \ FieldModel<uint32_t, address, 21, 1>;\n    /**\n     * @brief USART2EN field\n\
    \     *\n     * USART 2 clock enable\n     */\n    using usart2en = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    /**\n     * @brief SPI3EN field\n     *\n     * SPI3 clock\
    \ enable\n     */\n    using spi3en = FieldModel<uint32_t, address, 15, 1>;\n\
    \    /**\n     * @brief SPI2EN field\n     *\n     * SPI2 clock enable\n     */\n\
    \    using spi2en = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief\
    \ WWDGEN field\n     *\n     * Window watchdog clock\n     *               enable\n\
    \     */\n    using wwdgen = FieldModel<uint32_t, address, 11, 1>;\n    /**\n\
    \     * @brief TIM5EN field\n     *\n     * TIM5 clock enable\n     */\n    using\
    \ tim5en = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief TIM4EN\
    \ field\n     *\n     * TIM4 clock enable\n     */\n    using tim4en = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief TIM3EN field\n     *\n     * TIM3 clock\
    \ enable\n     */\n    using tim3en = FieldModel<uint32_t, address, 1, 1>;\n \
    \   /**\n     * @brief TIM2EN field\n     *\n     * TIM2 clock enable\n     */\n\
    \    using tim2en = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ PWREN field\n       *\n       * Power interface clock\n       *            \
    \   enable\n       */\n      BitFieldModel<uint32_t, 28, 1> pwren;\n      /**\n\
    \       * @brief I2C3EN field\n       *\n       * I2C3 clock enable\n       */\n\
    \      BitFieldModel<uint32_t, 23, 1> i2c3en;\n      /**\n       * @brief I2C2EN\
    \ field\n       *\n       * I2C2 clock enable\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> i2c2en;\n      /**\n       * @brief I2C1EN field\n       *\n       *\
    \ I2C1 clock enable\n       */\n      BitFieldModel<uint32_t, 21, 1> i2c1en;\n\
    \      /**\n       * @brief USART2EN field\n       *\n       * USART 2 clock enable\n\
    \       */\n      BitFieldModel<uint32_t, 17, 1> usart2en;\n      /**\n      \
    \ * @brief SPI3EN field\n       *\n       * SPI3 clock enable\n       */\n   \
    \   BitFieldModel<uint32_t, 15, 1> spi3en;\n      /**\n       * @brief SPI2EN\
    \ field\n       *\n       * SPI2 clock enable\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> spi2en;\n      /**\n       * @brief WWDGEN field\n       *\n       *\
    \ Window watchdog clock\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> wwdgen;\n      /**\n       * @brief TIM5EN field\n       *\n       *\
    \ TIM5 clock enable\n       */\n      BitFieldModel<uint32_t, 3, 1> tim5en;\n\
    \      /**\n       * @brief TIM4EN field\n       *\n       * TIM4 clock enable\n\
    \       */\n      BitFieldModel<uint32_t, 2, 1> tim4en;\n      /**\n       * @brief\
    \ TIM3EN field\n       *\n       * TIM3 clock enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> tim3en;\n      /**\n       * @brief TIM2EN field\n       *\n       * TIM2\
    \ clock enable\n       */\n      BitFieldModel<uint32_t, 0, 1> tim2en;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief APB1ENR register\n   *\n   * APB1 peripheral\
    \ clock enable\n   *           register\n   */\n  using apb1enr = Apb1enrReg<BaseAddress\
    \ + 0x0040>;\n\nprivate:\n  template<unsigned int address>\n  class Apb2enrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ TIM1EN field\n     *\n     * TIM1 clock enable\n     */\n    using tim1en =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief USART1EN field\n\
    \     *\n     * USART1 clock enable\n     */\n    using usart1en = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief USART6EN field\n     *\n     * USART6\
    \ clock enable\n     */\n    using usart6en = FieldModel<uint32_t, address, 5,\
    \ 1>;\n    /**\n     * @brief ADC1EN field\n     *\n     * ADC1 clock enable\n\
    \     */\n    using adc1en = FieldModel<uint32_t, address, 8, 1>;\n    /**\n \
    \    * @brief SDIOEN field\n     *\n     * SDIO clock enable\n     */\n    using\
    \ sdioen = FieldModel<uint32_t, address, 11, 1>;\n    /**\n     * @brief SPI1EN\
    \ field\n     *\n     * SPI1 clock enable\n     */\n    using spi1en = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief SPI4EN field\n     *\n     * SPI4 clock\
    \ enable\n     */\n    using spi4en = FieldModel<uint32_t, address, 13, 1>;\n\
    \    /**\n     * @brief SYSCFGEN field\n     *\n     * System configuration controller\
    \ clock\n     *               enable\n     */\n    using syscfgen = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief TIM9EN field\n     *\n     * TIM9 clock\
    \ enable\n     */\n    using tim9en = FieldModel<uint32_t, address, 16, 1>;\n\
    \    /**\n     * @brief TIM10EN field\n     *\n     * TIM10 clock enable\n   \
    \  */\n    using tim10en = FieldModel<uint32_t, address, 17, 1>;\n    /**\n  \
    \   * @brief TIM11EN field\n     *\n     * TIM11 clock enable\n     */\n    using\
    \ tim11en = FieldModel<uint32_t, address, 18, 1>;\n\n  public:\n    /**\n    \
    \ * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ TIM1EN field\n       *\n       * TIM1 clock enable\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> tim1en;\n      /**\n       * @brief USART1EN field\n       *\n       *\
    \ USART1 clock enable\n       */\n      BitFieldModel<uint32_t, 4, 1> usart1en;\n\
    \      /**\n       * @brief USART6EN field\n       *\n       * USART6 clock enable\n\
    \       */\n      BitFieldModel<uint32_t, 5, 1> usart6en;\n      /**\n       *\
    \ @brief ADC1EN field\n       *\n       * ADC1 clock enable\n       */\n     \
    \ BitFieldModel<uint32_t, 8, 1> adc1en;\n      /**\n       * @brief SDIOEN field\n\
    \       *\n       * SDIO clock enable\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> sdioen;\n      /**\n       * @brief SPI1EN field\n       *\n       *\
    \ SPI1 clock enable\n       */\n      BitFieldModel<uint32_t, 12, 1> spi1en;\n\
    \      /**\n       * @brief SPI4EN field\n       *\n       * SPI4 clock enable\n\
    \       */\n      BitFieldModel<uint32_t, 13, 1> spi4en;\n      /**\n       *\
    \ @brief SYSCFGEN field\n       *\n       * System configuration controller clock\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 14, 1>\
    \ syscfgen;\n      /**\n       * @brief TIM9EN field\n       *\n       * TIM9\
    \ clock enable\n       */\n      BitFieldModel<uint32_t, 16, 1> tim9en;\n    \
    \  /**\n       * @brief TIM10EN field\n       *\n       * TIM10 clock enable\n\
    \       */\n      BitFieldModel<uint32_t, 17, 1> tim10en;\n      /**\n       *\
    \ @brief TIM11EN field\n       *\n       * TIM11 clock enable\n       */\n   \
    \   BitFieldModel<uint32_t, 18, 1> tim11en;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief APB2ENR register\n   *\n   * APB2 peripheral clock enable\n   * \
    \          register\n   */\n  using apb2enr = Apb2enrReg<BaseAddress + 0x0044>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Ahb1lpenrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief DMA2LPEN field\n     *\n  \
    \   * DMA2 clock enable during Sleep\n     *               mode\n     */\n   \
    \ using dma2lpen = FieldModel<uint32_t, address, 22, 1>;\n    /**\n     * @brief\
    \ DMA1LPEN field\n     *\n     * DMA1 clock enable during Sleep\n     *      \
    \         mode\n     */\n    using dma1lpen = FieldModel<uint32_t, address, 21,\
    \ 1>;\n    /**\n     * @brief SRAM1LPEN field\n     *\n     * SRAM 1interface\
    \ clock enable during\n     *               Sleep mode\n     */\n    using sram1lpen\
    \ = FieldModel<uint32_t, address, 16, 1>;\n    /**\n     * @brief FLITFLPEN field\n\
    \     *\n     * Flash interface clock enable during\n     *               Sleep\
    \ mode\n     */\n    using flitflpen = FieldModel<uint32_t, address, 15, 1>;\n\
    \    /**\n     * @brief CRCLPEN field\n     *\n     * CRC clock enable during\
    \ Sleep\n     *               mode\n     */\n    using crclpen = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief GPIOHLPEN field\n     *\n     * IO\
    \ port H clock enable during Sleep\n     *               mode\n     */\n    using\
    \ gpiohlpen = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief GPIOELPEN\
    \ field\n     *\n     * IO port E clock enable during Sleep\n     *          \
    \     mode\n     */\n    using gpioelpen = FieldModel<uint32_t, address, 4, 1>;\n\
    \    /**\n     * @brief GPIODLPEN field\n     *\n     * IO port D clock enable\
    \ during Sleep\n     *               mode\n     */\n    using gpiodlpen = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief GPIOCLPEN field\n     *\n     * IO port\
    \ C clock enable during Sleep\n     *               mode\n     */\n    using gpioclpen\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief GPIOBLPEN field\n\
    \     *\n     * IO port B clock enable during Sleep\n     *               mode\n\
    \     */\n    using gpioblpen = FieldModel<uint32_t, address, 1, 1>;\n    /**\n\
    \     * @brief GPIOALPEN field\n     *\n     * IO port A clock enable during sleep\n\
    \     *               mode\n     */\n    using gpioalpen = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief DMA2LPEN field\n      \
    \ *\n       * DMA2 clock enable during Sleep\n       *               mode\n  \
    \     */\n      BitFieldModel<uint32_t, 22, 1> dma2lpen;\n      /**\n       *\
    \ @brief DMA1LPEN field\n       *\n       * DMA1 clock enable during Sleep\n \
    \      *               mode\n       */\n      BitFieldModel<uint32_t, 21, 1> dma1lpen;\n\
    \      /**\n       * @brief SRAM1LPEN field\n       *\n       * SRAM 1interface\
    \ clock enable during\n       *               Sleep mode\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> sram1lpen;\n      /**\n       * @brief FLITFLPEN field\n       *\n  \
    \     * Flash interface clock enable during\n       *               Sleep mode\n\
    \       */\n      BitFieldModel<uint32_t, 15, 1> flitflpen;\n      /**\n     \
    \  * @brief CRCLPEN field\n       *\n       * CRC clock enable during Sleep\n\
    \       *               mode\n       */\n      BitFieldModel<uint32_t, 12, 1>\
    \ crclpen;\n      /**\n       * @brief GPIOHLPEN field\n       *\n       * IO\
    \ port H clock enable during Sleep\n       *               mode\n       */\n \
    \     BitFieldModel<uint32_t, 7, 1> gpiohlpen;\n      /**\n       * @brief GPIOELPEN\
    \ field\n       *\n       * IO port E clock enable during Sleep\n       *    \
    \           mode\n       */\n      BitFieldModel<uint32_t, 4, 1> gpioelpen;\n\
    \      /**\n       * @brief GPIODLPEN field\n       *\n       * IO port D clock\
    \ enable during Sleep\n       *               mode\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> gpiodlpen;\n      /**\n       * @brief GPIOCLPEN field\n       *\n   \
    \    * IO port C clock enable during Sleep\n       *               mode\n    \
    \   */\n      BitFieldModel<uint32_t, 2, 1> gpioclpen;\n      /**\n       * @brief\
    \ GPIOBLPEN field\n       *\n       * IO port B clock enable during Sleep\n  \
    \     *               mode\n       */\n      BitFieldModel<uint32_t, 1, 1> gpioblpen;\n\
    \      /**\n       * @brief GPIOALPEN field\n       *\n       * IO port A clock\
    \ enable during sleep\n       *               mode\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> gpioalpen;\n    };\n  };\n\npublic:\n  /**\n   * @brief AHB1LPENR register\n\
    \   *\n   * AHB1 peripheral clock enable in low power\n   *           mode register\n\
    \   */\n  using ahb1lpenr = Ahb1lpenrReg<BaseAddress + 0x0050>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Ahb2lpenrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief OTGFSLPEN field\n     *\n \
    \    * USB OTG FS clock enable during Sleep\n     *               mode\n     */\n\
    \    using otgfslpen = FieldModel<uint32_t, address, 7, 1>;\n\n  public:\n   \
    \ /**\n     * @brief Register union\n     *\n     * Can be used to create a local\
    \ register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief OTGFSLPEN field\n       *\n       * USB OTG FS clock enable during\
    \ Sleep\n       *               mode\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> otgfslpen;\n    };\n  };\n\npublic:\n  /**\n   * @brief AHB2LPENR register\n\
    \   *\n   * AHB2 peripheral clock enable in low power\n   *           mode register\n\
    \   */\n  using ahb2lpenr = Ahb2lpenrReg<BaseAddress + 0x0054>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Apb1lpenrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief PWRLPEN field\n     *\n   \
    \  * Power interface clock enable during\n     *               Sleep mode\n  \
    \   */\n    using pwrlpen = FieldModel<uint32_t, address, 28, 1>;\n    /**\n \
    \    * @brief I2C3LPEN field\n     *\n     * I2C3 clock enable during Sleep\n\
    \     *               mode\n     */\n    using i2c3lpen = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    /**\n     * @brief I2C2LPEN field\n     *\n     * I2C2\
    \ clock enable during Sleep\n     *               mode\n     */\n    using i2c2lpen\
    \ = FieldModel<uint32_t, address, 22, 1>;\n    /**\n     * @brief I2C1LPEN field\n\
    \     *\n     * I2C1 clock enable during Sleep\n     *               mode\n  \
    \   */\n    using i2c1lpen = FieldModel<uint32_t, address, 21, 1>;\n    /**\n\
    \     * @brief USART2LPEN field\n     *\n     * USART2 clock enable during Sleep\n\
    \     *               mode\n     */\n    using usart2lpen = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    /**\n     * @brief SPI3LPEN field\n     *\n     * SPI3\
    \ clock enable during Sleep\n     *               mode\n     */\n    using spi3lpen\
    \ = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief SPI2LPEN field\n\
    \     *\n     * SPI2 clock enable during Sleep\n     *               mode\n  \
    \   */\n    using spi2lpen = FieldModel<uint32_t, address, 14, 1>;\n    /**\n\
    \     * @brief WWDGLPEN field\n     *\n     * Window watchdog clock enable during\n\
    \     *               Sleep mode\n     */\n    using wwdglpen = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief TIM5LPEN field\n     *\n     * TIM5\
    \ clock enable during Sleep\n     *               mode\n     */\n    using tim5lpen\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief TIM4LPEN field\n\
    \     *\n     * TIM4 clock enable during Sleep\n     *               mode\n  \
    \   */\n    using tim4lpen = FieldModel<uint32_t, address, 2, 1>;\n    /**\n \
    \    * @brief TIM3LPEN field\n     *\n     * TIM3 clock enable during Sleep\n\
    \     *               mode\n     */\n    using tim3lpen = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief TIM2LPEN field\n     *\n     * TIM2\
    \ clock enable during Sleep\n     *               mode\n     */\n    using tim2lpen\
    \ = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ PWRLPEN field\n       *\n       * Power interface clock enable during\n    \
    \   *               Sleep mode\n       */\n      BitFieldModel<uint32_t, 28, 1>\
    \ pwrlpen;\n      /**\n       * @brief I2C3LPEN field\n       *\n       * I2C3\
    \ clock enable during Sleep\n       *               mode\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 1> i2c3lpen;\n      /**\n       * @brief I2C2LPEN field\n       *\n    \
    \   * I2C2 clock enable during Sleep\n       *               mode\n       */\n\
    \      BitFieldModel<uint32_t, 22, 1> i2c2lpen;\n      /**\n       * @brief I2C1LPEN\
    \ field\n       *\n       * I2C1 clock enable during Sleep\n       *         \
    \      mode\n       */\n      BitFieldModel<uint32_t, 21, 1> i2c1lpen;\n     \
    \ /**\n       * @brief USART2LPEN field\n       *\n       * USART2 clock enable\
    \ during Sleep\n       *               mode\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> usart2lpen;\n      /**\n       * @brief SPI3LPEN field\n       *\n  \
    \     * SPI3 clock enable during Sleep\n       *               mode\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> spi3lpen;\n      /**\n       * @brief SPI2LPEN\
    \ field\n       *\n       * SPI2 clock enable during Sleep\n       *         \
    \      mode\n       */\n      BitFieldModel<uint32_t, 14, 1> spi2lpen;\n     \
    \ /**\n       * @brief WWDGLPEN field\n       *\n       * Window watchdog clock\
    \ enable during\n       *               Sleep mode\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> wwdglpen;\n      /**\n       * @brief TIM5LPEN field\n       *\n    \
    \   * TIM5 clock enable during Sleep\n       *               mode\n       */\n\
    \      BitFieldModel<uint32_t, 3, 1> tim5lpen;\n      /**\n       * @brief TIM4LPEN\
    \ field\n       *\n       * TIM4 clock enable during Sleep\n       *         \
    \      mode\n       */\n      BitFieldModel<uint32_t, 2, 1> tim4lpen;\n      /**\n\
    \       * @brief TIM3LPEN field\n       *\n       * TIM3 clock enable during Sleep\n\
    \       *               mode\n       */\n      BitFieldModel<uint32_t, 1, 1> tim3lpen;\n\
    \      /**\n       * @brief TIM2LPEN field\n       *\n       * TIM2 clock enable\
    \ during Sleep\n       *               mode\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> tim2lpen;\n    };\n  };\n\npublic:\n  /**\n   * @brief APB1LPENR register\n\
    \   *\n   * APB1 peripheral clock enable in low power\n   *           mode register\n\
    \   */\n  using apb1lpenr = Apb1lpenrReg<BaseAddress + 0x0060>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Apb2lpenrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief TIM1LPEN field\n     *\n  \
    \   * TIM1 clock enable during Sleep\n     *               mode\n     */\n   \
    \ using tim1lpen = FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief\
    \ USART1LPEN field\n     *\n     * USART1 clock enable during Sleep\n     *  \
    \             mode\n     */\n    using usart1lpen = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief USART6LPEN field\n     *\n     * USART6 clock\
    \ enable during Sleep\n     *               mode\n     */\n    using usart6lpen\
    \ = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief ADC1LPEN field\n\
    \     *\n     * ADC1 clock enable during Sleep\n     *               mode\n  \
    \   */\n    using adc1lpen = FieldModel<uint32_t, address, 8, 1>;\n    /**\n \
    \    * @brief SDIOLPEN field\n     *\n     * SDIO clock enable during Sleep\n\
    \     *               mode\n     */\n    using sdiolpen = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief SPI1LPEN field\n     *\n     * SPI\
    \ 1 clock enable during Sleep\n     *               mode\n     */\n    using spi1lpen\
    \ = FieldModel<uint32_t, address, 12, 1>;\n    /**\n     * @brief SPI4LPEN field\n\
    \     *\n     * SPI4 clock enable during Sleep\n     *               mode\n  \
    \   */\n    using spi4lpen = FieldModel<uint32_t, address, 13, 1>;\n    /**\n\
    \     * @brief SYSCFGLPEN field\n     *\n     * System configuration controller\
    \ clock\n     *               enable during Sleep mode\n     */\n    using syscfglpen\
    \ = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief TIM9LPEN field\n\
    \     *\n     * TIM9 clock enable during sleep\n     *               mode\n  \
    \   */\n    using tim9lpen = FieldModel<uint32_t, address, 16, 1>;\n    /**\n\
    \     * @brief TIM10LPEN field\n     *\n     * TIM10 clock enable during Sleep\n\
    \     *               mode\n     */\n    using tim10lpen = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    /**\n     * @brief TIM11LPEN field\n     *\n     * TIM11\
    \ clock enable during Sleep\n     *               mode\n     */\n    using tim11lpen\
    \ = FieldModel<uint32_t, address, 18, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ TIM1LPEN field\n       *\n       * TIM1 clock enable during Sleep\n       *\
    \               mode\n       */\n      BitFieldModel<uint32_t, 0, 1> tim1lpen;\n\
    \      /**\n       * @brief USART1LPEN field\n       *\n       * USART1 clock\
    \ enable during Sleep\n       *               mode\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> usart1lpen;\n      /**\n       * @brief USART6LPEN field\n       *\n \
    \      * USART6 clock enable during Sleep\n       *               mode\n     \
    \  */\n      BitFieldModel<uint32_t, 5, 1> usart6lpen;\n      /**\n       * @brief\
    \ ADC1LPEN field\n       *\n       * ADC1 clock enable during Sleep\n       *\
    \               mode\n       */\n      BitFieldModel<uint32_t, 8, 1> adc1lpen;\n\
    \      /**\n       * @brief SDIOLPEN field\n       *\n       * SDIO clock enable\
    \ during Sleep\n       *               mode\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> sdiolpen;\n      /**\n       * @brief SPI1LPEN field\n       *\n    \
    \   * SPI 1 clock enable during Sleep\n       *               mode\n       */\n\
    \      BitFieldModel<uint32_t, 12, 1> spi1lpen;\n      /**\n       * @brief SPI4LPEN\
    \ field\n       *\n       * SPI4 clock enable during Sleep\n       *         \
    \      mode\n       */\n      BitFieldModel<uint32_t, 13, 1> spi4lpen;\n     \
    \ /**\n       * @brief SYSCFGLPEN field\n       *\n       * System configuration\
    \ controller clock\n       *               enable during Sleep mode\n       */\n\
    \      BitFieldModel<uint32_t, 14, 1> syscfglpen;\n      /**\n       * @brief\
    \ TIM9LPEN field\n       *\n       * TIM9 clock enable during sleep\n       *\
    \               mode\n       */\n      BitFieldModel<uint32_t, 16, 1> tim9lpen;\n\
    \      /**\n       * @brief TIM10LPEN field\n       *\n       * TIM10 clock enable\
    \ during Sleep\n       *               mode\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> tim10lpen;\n      /**\n       * @brief TIM11LPEN field\n       *\n  \
    \     * TIM11 clock enable during Sleep\n       *               mode\n       */\n\
    \      BitFieldModel<uint32_t, 18, 1> tim11lpen;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief APB2LPENR register\n   *\n   * APB2 peripheral clock enabled in low\
    \ power\n   *           mode register\n   */\n  using apb2lpenr = Apb2lpenrReg<BaseAddress\
    \ + 0x0064>;\n\nprivate:\n  template<unsigned int address>\n  class BdcrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ BDRST field\n     *\n     * Backup domain software\n     *               reset\n\
    \     */\n    using bdrst = FieldModel<uint32_t, address, 16, 1>;\n    /**\n \
    \    * @brief RTCEN field\n     *\n     * RTC clock enable\n     */\n    using\
    \ rtcen = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief RTCSEL1\
    \ field\n     *\n     * RTC clock source selection\n     */\n    using rtcsel1\
    \ = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief RTCSEL0 field\n\
    \     *\n     * RTC clock source selection\n     */\n    using rtcsel0 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief LSEBYP field\n     *\n     * External\
    \ low-speed oscillator\n     *               bypass\n     */\n    using lsebyp\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief LSERDY field\n\
    \     *\n     * External low-speed oscillator\n     *               ready\n  \
    \   */\n    using lserdy = FieldModel<uint32_t, address, 1, 1>;\n    /**\n   \
    \  * @brief LSEON field\n     *\n     * External low-speed oscillator\n     *\
    \               enable\n     */\n    using lseon = FieldModel<uint32_t, address,\
    \ 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief BDRST field\n       *\n   \
    \    * Backup domain software\n       *               reset\n       */\n     \
    \ BitFieldModel<uint32_t, 16, 1> bdrst;\n      /**\n       * @brief RTCEN field\n\
    \       *\n       * RTC clock enable\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> rtcen;\n      /**\n       * @brief RTCSEL1 field\n       *\n       *\
    \ RTC clock source selection\n       */\n      BitFieldModel<uint32_t, 9, 1> rtcsel1;\n\
    \      /**\n       * @brief RTCSEL0 field\n       *\n       * RTC clock source\
    \ selection\n       */\n      BitFieldModel<uint32_t, 8, 1> rtcsel0;\n      /**\n\
    \       * @brief LSEBYP field\n       *\n       * External low-speed oscillator\n\
    \       *               bypass\n       */\n      BitFieldModel<uint32_t, 2, 1>\
    \ lsebyp;\n      /**\n       * @brief LSERDY field\n       *\n       * External\
    \ low-speed oscillator\n       *               ready\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> lserdy;\n      /**\n       * @brief LSEON field\n       *\n       * External\
    \ low-speed oscillator\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> lseon;\n    };\n  };\n\npublic:\n  /**\n   * @brief BDCR register\n  \
    \ *\n   * Backup domain control register\n   */\n  using bdcr = BdcrReg<BaseAddress\
    \ + 0x0070>;\n\nprivate:\n  template<unsigned int address>\n  class CsrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief LPWRRSTF\
    \ field\n     *\n     * Low-power reset flag\n     */\n    using lpwrrstf = FieldModel<uint32_t,\
    \ address, 31, 1>;\n    /**\n     * @brief WWDGRSTF field\n     *\n     * Window\
    \ watchdog reset flag\n     */\n    using wwdgrstf = FieldModel<uint32_t, address,\
    \ 30, 1>;\n    /**\n     * @brief WDGRSTF field\n     *\n     * Independent watchdog\
    \ reset\n     *               flag\n     */\n    using wdgrstf = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    /**\n     * @brief SFTRSTF field\n     *\n     * Software\
    \ reset flag\n     */\n    using sftrstf = FieldModel<uint32_t, address, 28, 1>;\n\
    \    /**\n     * @brief PORRSTF field\n     *\n     * POR/PDR reset flag\n   \
    \  */\n    using porrstf = FieldModel<uint32_t, address, 27, 1>;\n    /**\n  \
    \   * @brief PADRSTF field\n     *\n     * PIN reset flag\n     */\n    using\
    \ padrstf = FieldModel<uint32_t, address, 26, 1>;\n    /**\n     * @brief BORRSTF\
    \ field\n     *\n     * BOR reset flag\n     */\n    using borrstf = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    /**\n     * @brief RMVF field\n     *\n     * Remove reset\
    \ flag\n     */\n    using rmvf = FieldModel<uint32_t, address, 24, 1>;\n    /**\n\
    \     * @brief LSIRDY field\n     *\n     * Internal low-speed oscillator\n  \
    \   *               ready\n     */\n    using lsirdy = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    /**\n     * @brief LSION field\n     *\n     * Internal low-speed\
    \ oscillator\n     *               enable\n     */\n    using lsion = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief LPWRRSTF field\n      \
    \ *\n       * Low-power reset flag\n       */\n      BitFieldModel<uint32_t, 31,\
    \ 1> lpwrrstf;\n      /**\n       * @brief WWDGRSTF field\n       *\n       *\
    \ Window watchdog reset flag\n       */\n      BitFieldModel<uint32_t, 30, 1>\
    \ wwdgrstf;\n      /**\n       * @brief WDGRSTF field\n       *\n       * Independent\
    \ watchdog reset\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 29, 1> wdgrstf;\n      /**\n       * @brief SFTRSTF field\n       *\n      \
    \ * Software reset flag\n       */\n      BitFieldModel<uint32_t, 28, 1> sftrstf;\n\
    \      /**\n       * @brief PORRSTF field\n       *\n       * POR/PDR reset flag\n\
    \       */\n      BitFieldModel<uint32_t, 27, 1> porrstf;\n      /**\n       *\
    \ @brief PADRSTF field\n       *\n       * PIN reset flag\n       */\n      BitFieldModel<uint32_t,\
    \ 26, 1> padrstf;\n      /**\n       * @brief BORRSTF field\n       *\n      \
    \ * BOR reset flag\n       */\n      BitFieldModel<uint32_t, 25, 1> borrstf;\n\
    \      /**\n       * @brief RMVF field\n       *\n       * Remove reset flag\n\
    \       */\n      BitFieldModel<uint32_t, 24, 1> rmvf;\n      /**\n       * @brief\
    \ LSIRDY field\n       *\n       * Internal low-speed oscillator\n       *   \
    \            ready\n       */\n      BitFieldModel<uint32_t, 1, 1> lsirdy;\n \
    \     /**\n       * @brief LSION field\n       *\n       * Internal low-speed\
    \ oscillator\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> lsion;\n    };\n  };\n\npublic:\n  /**\n   * @brief CSR register\n   *\n\
    \   * clock control & status\n   *           register\n   */\n  using csr = CsrReg<BaseAddress\
    \ + 0x0074>;\n\nprivate:\n  template<unsigned int address>\n  class SscgrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ SSCGEN field\n     *\n     * Spread spectrum modulation\n     *            \
    \   enable\n     */\n    using sscgen = FieldModel<uint32_t, address, 31, 1>;\n\
    \    /**\n     * @brief SPREADSEL field\n     *\n     * Spread Select\n     */\n\
    \    using spreadsel = FieldModel<uint32_t, address, 30, 1>;\n    /**\n     *\
    \ @brief INCSTEP field\n     *\n     * Incrementation step\n     */\n    using\
    \ incstep = FieldModel<uint32_t, address, 13, 15>;\n    /**\n     * @brief MODPER\
    \ field\n     *\n     * Modulation period\n     */\n    using modper = FieldModel<uint32_t,\
    \ address, 0, 13>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief SSCGEN field\n       *\n\
    \       * Spread spectrum modulation\n       *               enable\n       */\n\
    \      BitFieldModel<uint32_t, 31, 1> sscgen;\n      /**\n       * @brief SPREADSEL\
    \ field\n       *\n       * Spread Select\n       */\n      BitFieldModel<uint32_t,\
    \ 30, 1> spreadsel;\n      /**\n       * @brief INCSTEP field\n       *\n    \
    \   * Incrementation step\n       */\n      BitFieldModel<uint32_t, 13, 15> incstep;\n\
    \      /**\n       * @brief MODPER field\n       *\n       * Modulation period\n\
    \       */\n      BitFieldModel<uint32_t, 0, 13> modper;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief SSCGR register\n   *\n   * spread spectrum clock generation\n\
    \   *           register\n   */\n  using sscgr = SscgrReg<BaseAddress + 0x0080>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Plli2scfgrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief PLLI2SRX field\n     *\n  \
    \   * PLLI2S division factor for I2S\n     *               clocks\n     */\n \
    \   using plli2srx = FieldModel<uint32_t, address, 28, 3>;\n    /**\n     * @brief\
    \ PLLI2SNX field\n     *\n     * PLLI2S multiplication factor for\n     *    \
    \           VCO\n     */\n    using plli2snx = FieldModel<uint32_t, address, 6,\
    \ 9>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief PLLI2SRX field\n       *\n\
    \       * PLLI2S division factor for I2S\n       *               clocks\n    \
    \   */\n      BitFieldModel<uint32_t, 28, 3> plli2srx;\n      /**\n       * @brief\
    \ PLLI2SNX field\n       *\n       * PLLI2S multiplication factor for\n      \
    \ *               VCO\n       */\n      BitFieldModel<uint32_t, 6, 9> plli2snx;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief PLLI2SCFGR register\n   *\n   * PLLI2S\
    \ configuration register\n   */\n  using plli2scfgr = Plli2scfgrReg<BaseAddress\
    \ + 0x0084>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_RCC_H */"
  name: RCC
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_RTC_H\n#define DRAL_STM32F411_RTC_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ RTC peripheral\n *\n * Real-time clock\n */\nclass rtc\n{\npublic:\n  static\
    \ constexpr unsigned int BaseAddress = 0x40002800; /**< Peripheral base address\
    \ */\n\nprivate:\n  template<unsigned int address>\n  class TrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief PM field\n     *\n     * AM/PM\
    \ notation\n     */\n    using pm = FieldModel<uint32_t, address, 22, 1>;\n  \
    \  /**\n     * @brief HT field\n     *\n     * Hour tens in BCD format\n     */\n\
    \    using ht = FieldModel<uint32_t, address, 20, 2>;\n    /**\n     * @brief\
    \ HU field\n     *\n     * Hour units in BCD format\n     */\n    using hu = FieldModel<uint32_t,\
    \ address, 16, 4>;\n    /**\n     * @brief MNT field\n     *\n     * Minute tens\
    \ in BCD format\n     */\n    using mnt = FieldModel<uint32_t, address, 12, 3>;\n\
    \    /**\n     * @brief MNU field\n     *\n     * Minute units in BCD format\n\
    \     */\n    using mnu = FieldModel<uint32_t, address, 8, 4>;\n    /**\n    \
    \ * @brief ST field\n     *\n     * Second tens in BCD format\n     */\n    using\
    \ st = FieldModel<uint32_t, address, 4, 3>;\n    /**\n     * @brief SU field\n\
    \     *\n     * Second units in BCD format\n     */\n    using su = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief PM field\n       *\n  \
    \     * AM/PM notation\n       */\n      BitFieldModel<uint32_t, 22, 1> pm;\n\
    \      /**\n       * @brief HT field\n       *\n       * Hour tens in BCD format\n\
    \       */\n      BitFieldModel<uint32_t, 20, 2> ht;\n      /**\n       * @brief\
    \ HU field\n       *\n       * Hour units in BCD format\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 4> hu;\n      /**\n       * @brief MNT field\n       *\n       * Minute\
    \ tens in BCD format\n       */\n      BitFieldModel<uint32_t, 12, 3> mnt;\n \
    \     /**\n       * @brief MNU field\n       *\n       * Minute units in BCD format\n\
    \       */\n      BitFieldModel<uint32_t, 8, 4> mnu;\n      /**\n       * @brief\
    \ ST field\n       *\n       * Second tens in BCD format\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 3> st;\n      /**\n       * @brief SU field\n       *\n       * Second units\
    \ in BCD format\n       */\n      BitFieldModel<uint32_t, 0, 4> su;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief TR register\n   *\n   * time register\n \
    \  */\n  using tr = TrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief YT field\n     *\n     * Year tens in BCD format\n\
    \     */\n    using yt = FieldModel<uint32_t, address, 20, 4>;\n    /**\n    \
    \ * @brief YU field\n     *\n     * Year units in BCD format\n     */\n    using\
    \ yu = FieldModel<uint32_t, address, 16, 4>;\n    /**\n     * @brief WDU field\n\
    \     *\n     * Week day units\n     */\n    using wdu = FieldModel<uint32_t,\
    \ address, 13, 3>;\n    /**\n     * @brief MT field\n     *\n     * Month tens\
    \ in BCD format\n     */\n    using mt = FieldModel<uint32_t, address, 12, 1>;\n\
    \    /**\n     * @brief MU field\n     *\n     * Month units in BCD format\n \
    \    */\n    using mu = FieldModel<uint32_t, address, 8, 4>;\n    /**\n     *\
    \ @brief DT field\n     *\n     * Date tens in BCD format\n     */\n    using\
    \ dt = FieldModel<uint32_t, address, 4, 2>;\n    /**\n     * @brief DU field\n\
    \     *\n     * Date units in BCD format\n     */\n    using du = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief YT field\n       *\n  \
    \     * Year tens in BCD format\n       */\n      BitFieldModel<uint32_t, 20,\
    \ 4> yt;\n      /**\n       * @brief YU field\n       *\n       * Year units in\
    \ BCD format\n       */\n      BitFieldModel<uint32_t, 16, 4> yu;\n      /**\n\
    \       * @brief WDU field\n       *\n       * Week day units\n       */\n   \
    \   BitFieldModel<uint32_t, 13, 3> wdu;\n      /**\n       * @brief MT field\n\
    \       *\n       * Month tens in BCD format\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> mt;\n      /**\n       * @brief MU field\n       *\n       * Month units\
    \ in BCD format\n       */\n      BitFieldModel<uint32_t, 8, 4> mu;\n      /**\n\
    \       * @brief DT field\n       *\n       * Date tens in BCD format\n      \
    \ */\n      BitFieldModel<uint32_t, 4, 2> dt;\n      /**\n       * @brief DU field\n\
    \       *\n       * Date units in BCD format\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> du;\n    };\n  };\n\npublic:\n  /**\n   * @brief DR register\n   *\n \
    \  * date register\n   */\n  using dr = DrReg<BaseAddress + 0x0004>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class CrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief COE field\n     *\n     * Calibration\
    \ output enable\n     */\n    using coe = FieldModel<uint32_t, address, 23, 1>;\n\
    \    /**\n     * @brief OSEL field\n     *\n     * Output selection\n     */\n\
    \    using osel = FieldModel<uint32_t, address, 21, 2>;\n    /**\n     * @brief\
    \ POL field\n     *\n     * Output polarity\n     */\n    using pol = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief COSEL field\n     *\n     * Calibration\
    \ Output\n     *               selection\n     */\n    using cosel = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief BKP field\n     *\n     * Backup\n\
    \     */\n    using bkp = FieldModel<uint32_t, address, 18, 1>;\n    /**\n   \
    \  * @brief SUB1H field\n     *\n     * Subtract 1 hour (winter time\n     * \
    \              change)\n     */\n    using sub1h = FieldModel<uint32_t, address,\
    \ 17, 1>;\n    /**\n     * @brief ADD1H field\n     *\n     * Add 1 hour (summer\
    \ time\n     *               change)\n     */\n    using add1h = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    /**\n     * @brief TSIE field\n     *\n     * Time-stamp\
    \ interrupt\n     *               enable\n     */\n    using tsie = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief WUTIE field\n     *\n     * Wakeup\
    \ timer interrupt\n     *               enable\n     */\n    using wutie = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief ALRBIE field\n     *\n     * Alarm\
    \ B interrupt enable\n     */\n    using alrbie = FieldModel<uint32_t, address,\
    \ 13, 1>;\n    /**\n     * @brief ALRAIE field\n     *\n     * Alarm A interrupt\
    \ enable\n     */\n    using alraie = FieldModel<uint32_t, address, 12, 1>;\n\
    \    /**\n     * @brief TSE field\n     *\n     * Time stamp enable\n     */\n\
    \    using tse = FieldModel<uint32_t, address, 11, 1>;\n    /**\n     * @brief\
    \ WUTE field\n     *\n     * Wakeup timer enable\n     */\n    using wute = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief ALRBE field\n     *\n     * Alarm B\
    \ enable\n     */\n    using alrbe = FieldModel<uint32_t, address, 9, 1>;\n  \
    \  /**\n     * @brief ALRAE field\n     *\n     * Alarm A enable\n     */\n  \
    \  using alrae = FieldModel<uint32_t, address, 8, 1>;\n    /**\n     * @brief\
    \ DCE field\n     *\n     * Coarse digital calibration\n     *               enable\n\
    \     */\n    using dce = FieldModel<uint32_t, address, 7, 1>;\n    /**\n    \
    \ * @brief FMT field\n     *\n     * Hour format\n     */\n    using fmt = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief BYPSHAD field\n     *\n     * Bypass\
    \ the shadow\n     *               registers\n     */\n    using bypshad = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief REFCKON field\n     *\n     * Reference\
    \ clock detection enable (50 or\n     *               60 Hz)\n     */\n    using\
    \ refckon = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief TSEDGE\
    \ field\n     *\n     * Time-stamp event active\n     *               edge\n \
    \    */\n    using tsedge = FieldModel<uint32_t, address, 3, 1>;\n    /**\n  \
    \   * @brief WCKSEL field\n     *\n     * Wakeup clock selection\n     */\n  \
    \  using wcksel = FieldModel<uint32_t, address, 0, 3>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ COE field\n       *\n       * Calibration output enable\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 1> coe;\n      /**\n       * @brief OSEL field\n       *\n       * Output\
    \ selection\n       */\n      BitFieldModel<uint32_t, 21, 2> osel;\n      /**\n\
    \       * @brief POL field\n       *\n       * Output polarity\n       */\n  \
    \    BitFieldModel<uint32_t, 20, 1> pol;\n      /**\n       * @brief COSEL field\n\
    \       *\n       * Calibration Output\n       *               selection\n   \
    \    */\n      BitFieldModel<uint32_t, 19, 1> cosel;\n      /**\n       * @brief\
    \ BKP field\n       *\n       * Backup\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 1> bkp;\n      /**\n       * @brief SUB1H field\n       *\n       * Subtract\
    \ 1 hour (winter time\n       *               change)\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> sub1h;\n      /**\n       * @brief ADD1H field\n       *\n       * Add\
    \ 1 hour (summer time\n       *               change)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> add1h;\n      /**\n       * @brief TSIE field\n       *\n       * Time-stamp\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> tsie;\n      /**\n       * @brief WUTIE field\n       *\n       * Wakeup\
    \ timer interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> wutie;\n      /**\n       * @brief ALRBIE field\n       *\n       * Alarm\
    \ B interrupt enable\n       */\n      BitFieldModel<uint32_t, 13, 1> alrbie;\n\
    \      /**\n       * @brief ALRAIE field\n       *\n       * Alarm A interrupt\
    \ enable\n       */\n      BitFieldModel<uint32_t, 12, 1> alraie;\n      /**\n\
    \       * @brief TSE field\n       *\n       * Time stamp enable\n       */\n\
    \      BitFieldModel<uint32_t, 11, 1> tse;\n      /**\n       * @brief WUTE field\n\
    \       *\n       * Wakeup timer enable\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> wute;\n      /**\n       * @brief ALRBE field\n       *\n       * Alarm\
    \ B enable\n       */\n      BitFieldModel<uint32_t, 9, 1> alrbe;\n      /**\n\
    \       * @brief ALRAE field\n       *\n       * Alarm A enable\n       */\n \
    \     BitFieldModel<uint32_t, 8, 1> alrae;\n      /**\n       * @brief DCE field\n\
    \       *\n       * Coarse digital calibration\n       *               enable\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> dce;\n      /**\n       * @brief\
    \ FMT field\n       *\n       * Hour format\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> fmt;\n      /**\n       * @brief BYPSHAD field\n       *\n       * Bypass\
    \ the shadow\n       *               registers\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> bypshad;\n      /**\n       * @brief REFCKON field\n       *\n       *\
    \ Reference clock detection enable (50 or\n       *               60 Hz)\n   \
    \    */\n      BitFieldModel<uint32_t, 4, 1> refckon;\n      /**\n       * @brief\
    \ TSEDGE field\n       *\n       * Time-stamp event active\n       *         \
    \      edge\n       */\n      BitFieldModel<uint32_t, 3, 1> tsedge;\n      /**\n\
    \       * @brief WCKSEL field\n       *\n       * Wakeup clock selection\n   \
    \    */\n      BitFieldModel<uint32_t, 0, 3> wcksel;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR register\n   *\n   * control register\n   */\n  using cr\
    \ = CrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class IsrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief ALRAWF field\n     *\n     * Alarm A write flag\n     */\n\
    \    using alrawf = FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief\
    \ ALRBWF field\n     *\n     * Alarm B write flag\n     */\n    using alrbwf =\
    \ FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief WUTWF field\n \
    \    *\n     * Wakeup timer write flag\n     */\n    using wutwf = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief SHPF field\n     *\n     * Shift operation\
    \ pending\n     */\n    using shpf = FieldModel<uint32_t, address, 3, 1>;\n  \
    \  /**\n     * @brief INITS field\n     *\n     * Initialization status flag\n\
    \     */\n    using inits = FieldModel<uint32_t, address, 4, 1>;\n    /**\n  \
    \   * @brief RSF field\n     *\n     * Registers synchronization\n     *     \
    \          flag\n     */\n    using rsf = FieldModel<uint32_t, address, 5, 1>;\n\
    \    /**\n     * @brief INITF field\n     *\n     * Initialization flag\n    \
    \ */\n    using initf = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     *\
    \ @brief INIT field\n     *\n     * Initialization mode\n     */\n    using init\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief ALRAF field\n\
    \     *\n     * Alarm A flag\n     */\n    using alraf = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief ALRBF field\n     *\n     * Alarm B\
    \ flag\n     */\n    using alrbf = FieldModel<uint32_t, address, 9, 1>;\n    /**\n\
    \     * @brief WUTF field\n     *\n     * Wakeup timer flag\n     */\n    using\
    \ wutf = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief TSF field\n\
    \     *\n     * Time-stamp flag\n     */\n    using tsf = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief TSOVF field\n     *\n     * Time-stamp\
    \ overflow flag\n     */\n    using tsovf = FieldModel<uint32_t, address, 12,\
    \ 1>;\n    /**\n     * @brief TAMP1F field\n     *\n     * Tamper detection flag\n\
    \     */\n    using tamp1f = FieldModel<uint32_t, address, 13, 1>;\n    /**\n\
    \     * @brief TAMP2F field\n     *\n     * TAMPER2 detection flag\n     */\n\
    \    using tamp2f = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief\
    \ RECALPF field\n     *\n     * Recalibration pending Flag\n     */\n    using\
    \ recalpf = FieldModel<uint32_t, address, 16, 1>;\n\n  public:\n    /**\n    \
    \ * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ ALRAWF field\n       *\n       * Alarm A write flag\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> alrawf;\n      /**\n       * @brief ALRBWF field\n       *\n       * Alarm\
    \ B write flag\n       */\n      BitFieldModel<uint32_t, 1, 1> alrbwf;\n     \
    \ /**\n       * @brief WUTWF field\n       *\n       * Wakeup timer write flag\n\
    \       */\n      BitFieldModel<uint32_t, 2, 1> wutwf;\n      /**\n       * @brief\
    \ SHPF field\n       *\n       * Shift operation pending\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> shpf;\n      /**\n       * @brief INITS field\n       *\n       * Initialization\
    \ status flag\n       */\n      BitFieldModel<uint32_t, 4, 1> inits;\n      /**\n\
    \       * @brief RSF field\n       *\n       * Registers synchronization\n   \
    \    *               flag\n       */\n      BitFieldModel<uint32_t, 5, 1> rsf;\n\
    \      /**\n       * @brief INITF field\n       *\n       * Initialization flag\n\
    \       */\n      BitFieldModel<uint32_t, 6, 1> initf;\n      /**\n       * @brief\
    \ INIT field\n       *\n       * Initialization mode\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> init;\n      /**\n       * @brief ALRAF field\n       *\n       * Alarm\
    \ A flag\n       */\n      BitFieldModel<uint32_t, 8, 1> alraf;\n      /**\n \
    \      * @brief ALRBF field\n       *\n       * Alarm B flag\n       */\n    \
    \  BitFieldModel<uint32_t, 9, 1> alrbf;\n      /**\n       * @brief WUTF field\n\
    \       *\n       * Wakeup timer flag\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> wutf;\n      /**\n       * @brief TSF field\n       *\n       * Time-stamp\
    \ flag\n       */\n      BitFieldModel<uint32_t, 11, 1> tsf;\n      /**\n    \
    \   * @brief TSOVF field\n       *\n       * Time-stamp overflow flag\n      \
    \ */\n      BitFieldModel<uint32_t, 12, 1> tsovf;\n      /**\n       * @brief\
    \ TAMP1F field\n       *\n       * Tamper detection flag\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> tamp1f;\n      /**\n       * @brief TAMP2F field\n       *\n       *\
    \ TAMPER2 detection flag\n       */\n      BitFieldModel<uint32_t, 14, 1> tamp2f;\n\
    \      /**\n       * @brief RECALPF field\n       *\n       * Recalibration pending\
    \ Flag\n       */\n      BitFieldModel<uint32_t, 16, 1> recalpf;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief ISR register\n   *\n   * initialization and status\n\
    \   *           register\n   */\n  using isr = IsrReg<BaseAddress + 0x000C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class PrerReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief PREDIV_A field\n     *\n  \
    \   * Asynchronous prescaler\n     *               factor\n     */\n    using\
    \ prediv_a = FieldModel<uint32_t, address, 16, 7>;\n    /**\n     * @brief PREDIV_S\
    \ field\n     *\n     * Synchronous prescaler\n     *               factor\n \
    \    */\n    using prediv_s = FieldModel<uint32_t, address, 0, 15>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief PREDIV_A field\n       *\n       * Asynchronous prescaler\n \
    \      *               factor\n       */\n      BitFieldModel<uint32_t, 16, 7>\
    \ prediv_a;\n      /**\n       * @brief PREDIV_S field\n       *\n       * Synchronous\
    \ prescaler\n       *               factor\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 15> prediv_s;\n    };\n  };\n\npublic:\n  /**\n   * @brief PRER register\n\
    \   *\n   * prescaler register\n   */\n  using prer = PrerReg<BaseAddress + 0x0010>;\n\
    \nprivate:\n  template<unsigned int address>\n  class WutrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief WUT field\n     *\n     * Wakeup\
    \ auto-reload value\n     *               bits\n     */\n    using wut = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief WUT field\n       *\n \
    \      * Wakeup auto-reload value\n       *               bits\n       */\n  \
    \    BitFieldModel<uint32_t, 0, 16> wut;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief WUTR register\n   *\n   * wakeup timer register\n   */\n  using wutr\
    \ = WutrReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class CalibrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief DCS field\n     *\n     * Digital calibration sign\n \
    \    */\n    using dcs = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     *\
    \ @brief DC field\n     *\n     * Digital calibration\n     */\n    using dc =\
    \ FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n    /**\n     * @brief Register\
    \ union\n     *\n     * Can be used to create a local register variable for easy\
    \ bit manipulation.\n     * Useful for read-modify-write operations.\n     */\n\
    \    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief DCS field\n\
    \       *\n       * Digital calibration sign\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> dcs;\n      /**\n       * @brief DC field\n       *\n       * Digital\
    \ calibration\n       */\n      BitFieldModel<uint32_t, 0, 5> dc;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief CALIBR register\n   *\n   * calibration register\n\
    \   */\n  using calibr = CalibrReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class AlrmarReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief MSK4 field\n     *\n     * Alarm A date\
    \ mask\n     */\n    using msk4 = FieldModel<uint32_t, address, 31, 1>;\n    /**\n\
    \     * @brief WDSEL field\n     *\n     * Week day selection\n     */\n    using\
    \ wdsel = FieldModel<uint32_t, address, 30, 1>;\n    /**\n     * @brief DT field\n\
    \     *\n     * Date tens in BCD format\n     */\n    using dt = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    /**\n     * @brief DU field\n     *\n     * Date units\
    \ or day in BCD\n     *               format\n     */\n    using du = FieldModel<uint32_t,\
    \ address, 24, 4>;\n    /**\n     * @brief MSK3 field\n     *\n     * Alarm A\
    \ hours mask\n     */\n    using msk3 = FieldModel<uint32_t, address, 23, 1>;\n\
    \    /**\n     * @brief PM field\n     *\n     * AM/PM notation\n     */\n   \
    \ using pm = FieldModel<uint32_t, address, 22, 1>;\n    /**\n     * @brief HT\
    \ field\n     *\n     * Hour tens in BCD format\n     */\n    using ht = FieldModel<uint32_t,\
    \ address, 20, 2>;\n    /**\n     * @brief HU field\n     *\n     * Hour units\
    \ in BCD format\n     */\n    using hu = FieldModel<uint32_t, address, 16, 4>;\n\
    \    /**\n     * @brief MSK2 field\n     *\n     * Alarm A minutes mask\n    \
    \ */\n    using msk2 = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     *\
    \ @brief MNT field\n     *\n     * Minute tens in BCD format\n     */\n    using\
    \ mnt = FieldModel<uint32_t, address, 12, 3>;\n    /**\n     * @brief MNU field\n\
    \     *\n     * Minute units in BCD format\n     */\n    using mnu = FieldModel<uint32_t,\
    \ address, 8, 4>;\n    /**\n     * @brief MSK1 field\n     *\n     * Alarm A seconds\
    \ mask\n     */\n    using msk1 = FieldModel<uint32_t, address, 7, 1>;\n    /**\n\
    \     * @brief ST field\n     *\n     * Second tens in BCD format\n     */\n \
    \   using st = FieldModel<uint32_t, address, 4, 3>;\n    /**\n     * @brief SU\
    \ field\n     *\n     * Second units in BCD format\n     */\n    using su = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief MSK4 field\n       *\n\
    \       * Alarm A date mask\n       */\n      BitFieldModel<uint32_t, 31, 1> msk4;\n\
    \      /**\n       * @brief WDSEL field\n       *\n       * Week day selection\n\
    \       */\n      BitFieldModel<uint32_t, 30, 1> wdsel;\n      /**\n       * @brief\
    \ DT field\n       *\n       * Date tens in BCD format\n       */\n      BitFieldModel<uint32_t,\
    \ 28, 2> dt;\n      /**\n       * @brief DU field\n       *\n       * Date units\
    \ or day in BCD\n       *               format\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 4> du;\n      /**\n       * @brief MSK3 field\n       *\n       * Alarm\
    \ A hours mask\n       */\n      BitFieldModel<uint32_t, 23, 1> msk3;\n      /**\n\
    \       * @brief PM field\n       *\n       * AM/PM notation\n       */\n    \
    \  BitFieldModel<uint32_t, 22, 1> pm;\n      /**\n       * @brief HT field\n \
    \      *\n       * Hour tens in BCD format\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 2> ht;\n      /**\n       * @brief HU field\n       *\n       * Hour units\
    \ in BCD format\n       */\n      BitFieldModel<uint32_t, 16, 4> hu;\n      /**\n\
    \       * @brief MSK2 field\n       *\n       * Alarm A minutes mask\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> msk2;\n      /**\n       * @brief MNT field\n\
    \       *\n       * Minute tens in BCD format\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 3> mnt;\n      /**\n       * @brief MNU field\n       *\n       * Minute\
    \ units in BCD format\n       */\n      BitFieldModel<uint32_t, 8, 4> mnu;\n \
    \     /**\n       * @brief MSK1 field\n       *\n       * Alarm A seconds mask\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> msk1;\n      /**\n       * @brief\
    \ ST field\n       *\n       * Second tens in BCD format\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 3> st;\n      /**\n       * @brief SU field\n       *\n       * Second units\
    \ in BCD format\n       */\n      BitFieldModel<uint32_t, 0, 4> su;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief ALRMAR register\n   *\n   * alarm A register\n\
    \   */\n  using alrmar = AlrmarReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class AlrmbrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief MSK4 field\n     *\n     * Alarm B date\
    \ mask\n     */\n    using msk4 = FieldModel<uint32_t, address, 31, 1>;\n    /**\n\
    \     * @brief WDSEL field\n     *\n     * Week day selection\n     */\n    using\
    \ wdsel = FieldModel<uint32_t, address, 30, 1>;\n    /**\n     * @brief DT field\n\
    \     *\n     * Date tens in BCD format\n     */\n    using dt = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    /**\n     * @brief DU field\n     *\n     * Date units\
    \ or day in BCD\n     *               format\n     */\n    using du = FieldModel<uint32_t,\
    \ address, 24, 4>;\n    /**\n     * @brief MSK3 field\n     *\n     * Alarm B\
    \ hours mask\n     */\n    using msk3 = FieldModel<uint32_t, address, 23, 1>;\n\
    \    /**\n     * @brief PM field\n     *\n     * AM/PM notation\n     */\n   \
    \ using pm = FieldModel<uint32_t, address, 22, 1>;\n    /**\n     * @brief HT\
    \ field\n     *\n     * Hour tens in BCD format\n     */\n    using ht = FieldModel<uint32_t,\
    \ address, 20, 2>;\n    /**\n     * @brief HU field\n     *\n     * Hour units\
    \ in BCD format\n     */\n    using hu = FieldModel<uint32_t, address, 16, 4>;\n\
    \    /**\n     * @brief MSK2 field\n     *\n     * Alarm B minutes mask\n    \
    \ */\n    using msk2 = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     *\
    \ @brief MNT field\n     *\n     * Minute tens in BCD format\n     */\n    using\
    \ mnt = FieldModel<uint32_t, address, 12, 3>;\n    /**\n     * @brief MNU field\n\
    \     *\n     * Minute units in BCD format\n     */\n    using mnu = FieldModel<uint32_t,\
    \ address, 8, 4>;\n    /**\n     * @brief MSK1 field\n     *\n     * Alarm B seconds\
    \ mask\n     */\n    using msk1 = FieldModel<uint32_t, address, 7, 1>;\n    /**\n\
    \     * @brief ST field\n     *\n     * Second tens in BCD format\n     */\n \
    \   using st = FieldModel<uint32_t, address, 4, 3>;\n    /**\n     * @brief SU\
    \ field\n     *\n     * Second units in BCD format\n     */\n    using su = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief MSK4 field\n       *\n\
    \       * Alarm B date mask\n       */\n      BitFieldModel<uint32_t, 31, 1> msk4;\n\
    \      /**\n       * @brief WDSEL field\n       *\n       * Week day selection\n\
    \       */\n      BitFieldModel<uint32_t, 30, 1> wdsel;\n      /**\n       * @brief\
    \ DT field\n       *\n       * Date tens in BCD format\n       */\n      BitFieldModel<uint32_t,\
    \ 28, 2> dt;\n      /**\n       * @brief DU field\n       *\n       * Date units\
    \ or day in BCD\n       *               format\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 4> du;\n      /**\n       * @brief MSK3 field\n       *\n       * Alarm\
    \ B hours mask\n       */\n      BitFieldModel<uint32_t, 23, 1> msk3;\n      /**\n\
    \       * @brief PM field\n       *\n       * AM/PM notation\n       */\n    \
    \  BitFieldModel<uint32_t, 22, 1> pm;\n      /**\n       * @brief HT field\n \
    \      *\n       * Hour tens in BCD format\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 2> ht;\n      /**\n       * @brief HU field\n       *\n       * Hour units\
    \ in BCD format\n       */\n      BitFieldModel<uint32_t, 16, 4> hu;\n      /**\n\
    \       * @brief MSK2 field\n       *\n       * Alarm B minutes mask\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> msk2;\n      /**\n       * @brief MNT field\n\
    \       *\n       * Minute tens in BCD format\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 3> mnt;\n      /**\n       * @brief MNU field\n       *\n       * Minute\
    \ units in BCD format\n       */\n      BitFieldModel<uint32_t, 8, 4> mnu;\n \
    \     /**\n       * @brief MSK1 field\n       *\n       * Alarm B seconds mask\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> msk1;\n      /**\n       * @brief\
    \ ST field\n       *\n       * Second tens in BCD format\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 3> st;\n      /**\n       * @brief SU field\n       *\n       * Second units\
    \ in BCD format\n       */\n      BitFieldModel<uint32_t, 0, 4> su;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief ALRMBR register\n   *\n   * alarm B register\n\
    \   */\n  using alrmbr = AlrmbrReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class WprReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief KEY field\n     *\n     * Write protection\
    \ key\n     */\n    using key = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief KEY field\n       *\n       * Write protection key\n       */\n\
    \      BitFieldModel<uint32_t, 0, 8> key;\n    };\n  };\n\npublic:\n  /**\n  \
    \ * @brief WPR register\n   *\n   * write protection register\n   */\n  using\
    \ wpr = WprReg<BaseAddress + 0x0024>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class SsrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief SS field\n     *\n     * Sub second value\n     */\n   \
    \ using ss = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    /**\n   \
    \  * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ SS field\n       *\n       * Sub second value\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> ss;\n    };\n  };\n\npublic:\n  /**\n   * @brief SSR register\n   *\n\
    \   * sub second register\n   */\n  using ssr = SsrReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class ShiftrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief ADD1S field\n     *\n     *\
    \ Add one second\n     */\n    using add1s = FieldModel<uint32_t, address, 31,\
    \ 1>;\n    /**\n     * @brief SUBFS field\n     *\n     * Subtract a fraction\
    \ of a\n     *               second\n     */\n    using subfs = FieldModel<uint32_t,\
    \ address, 0, 15>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief ADD1S field\n       *\n\
    \       * Add one second\n       */\n      BitFieldModel<uint32_t, 31, 1> add1s;\n\
    \      /**\n       * @brief SUBFS field\n       *\n       * Subtract a fraction\
    \ of a\n       *               second\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 15> subfs;\n    };\n  };\n\npublic:\n  /**\n   * @brief SHIFTR register\n\
    \   *\n   * shift control register\n   */\n  using shiftr = ShiftrReg<BaseAddress\
    \ + 0x002C>;\n\nprivate:\n  template<unsigned int address>\n  class TstrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ PM field\n     *\n     * AM/PM notation\n     */\n    using pm = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    /**\n     * @brief HT field\n     *\n     * Hour tens\
    \ in BCD format\n     */\n    using ht = FieldModel<uint32_t, address, 20, 2>;\n\
    \    /**\n     * @brief HU field\n     *\n     * Hour units in BCD format\n  \
    \   */\n    using hu = FieldModel<uint32_t, address, 16, 4>;\n    /**\n     *\
    \ @brief MNT field\n     *\n     * Minute tens in BCD format\n     */\n    using\
    \ mnt = FieldModel<uint32_t, address, 12, 3>;\n    /**\n     * @brief MNU field\n\
    \     *\n     * Minute units in BCD format\n     */\n    using mnu = FieldModel<uint32_t,\
    \ address, 8, 4>;\n    /**\n     * @brief ST field\n     *\n     * Second tens\
    \ in BCD format\n     */\n    using st = FieldModel<uint32_t, address, 4, 3>;\n\
    \    /**\n     * @brief SU field\n     *\n     * Second units in BCD format\n\
    \     */\n    using su = FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n \
    \   /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief PM field\n       *\n       * AM/PM notation\n       */\n    \
    \  BitFieldModel<uint32_t, 22, 1> pm;\n      /**\n       * @brief HT field\n \
    \      *\n       * Hour tens in BCD format\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 2> ht;\n      /**\n       * @brief HU field\n       *\n       * Hour units\
    \ in BCD format\n       */\n      BitFieldModel<uint32_t, 16, 4> hu;\n      /**\n\
    \       * @brief MNT field\n       *\n       * Minute tens in BCD format\n   \
    \    */\n      BitFieldModel<uint32_t, 12, 3> mnt;\n      /**\n       * @brief\
    \ MNU field\n       *\n       * Minute units in BCD format\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 4> mnu;\n      /**\n       * @brief ST field\n       *\n       * Second tens\
    \ in BCD format\n       */\n      BitFieldModel<uint32_t, 4, 3> st;\n      /**\n\
    \       * @brief SU field\n       *\n       * Second units in BCD format\n   \
    \    */\n      BitFieldModel<uint32_t, 0, 4> su;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief TSTR register\n   *\n   * time stamp time register\n   */\n  using\
    \ tstr = TstrReg<BaseAddress + 0x0030>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class TsdrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief WDU field\n     *\n     * Week day units\n     */\n   \
    \ using wdu = FieldModel<uint32_t, address, 13, 3>;\n    /**\n     * @brief MT\
    \ field\n     *\n     * Month tens in BCD format\n     */\n    using mt = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief MU field\n     *\n     * Month units\
    \ in BCD format\n     */\n    using mu = FieldModel<uint32_t, address, 8, 4>;\n\
    \    /**\n     * @brief DT field\n     *\n     * Date tens in BCD format\n   \
    \  */\n    using dt = FieldModel<uint32_t, address, 4, 2>;\n    /**\n     * @brief\
    \ DU field\n     *\n     * Date units in BCD format\n     */\n    using du = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief WDU field\n       *\n \
    \      * Week day units\n       */\n      BitFieldModel<uint32_t, 13, 3> wdu;\n\
    \      /**\n       * @brief MT field\n       *\n       * Month tens in BCD format\n\
    \       */\n      BitFieldModel<uint32_t, 12, 1> mt;\n      /**\n       * @brief\
    \ MU field\n       *\n       * Month units in BCD format\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 4> mu;\n      /**\n       * @brief DT field\n       *\n       * Date tens\
    \ in BCD format\n       */\n      BitFieldModel<uint32_t, 4, 2> dt;\n      /**\n\
    \       * @brief DU field\n       *\n       * Date units in BCD format\n     \
    \  */\n      BitFieldModel<uint32_t, 0, 4> du;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief TSDR register\n   *\n   * time stamp date register\n   */\n  using\
    \ tsdr = TsdrReg<BaseAddress + 0x0034>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class TsssrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief SS field\n     *\n     * Sub second value\n     */\n \
    \   using ss = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    /**\n \
    \    * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ SS field\n       *\n       * Sub second value\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> ss;\n    };\n  };\n\npublic:\n  /**\n   * @brief TSSSR register\n   *\n\
    \   * timestamp sub second register\n   */\n  using tsssr = TsssrReg<BaseAddress\
    \ + 0x0038>;\n\nprivate:\n  template<unsigned int address>\n  class CalrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ CALP field\n     *\n     * Increase frequency of RTC by 488.5\n     *      \
    \         ppm\n     */\n    using calp = FieldModel<uint32_t, address, 15, 1>;\n\
    \    /**\n     * @brief CALW8 field\n     *\n     * Use an 8-second calibration\
    \ cycle\n     *               period\n     */\n    using calw8 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief CALW16 field\n     *\n     * Use a\
    \ 16-second calibration cycle\n     *               period\n     */\n    using\
    \ calw16 = FieldModel<uint32_t, address, 13, 1>;\n    /**\n     * @brief CALM\
    \ field\n     *\n     * Calibration minus\n     */\n    using calm = FieldModel<uint32_t,\
    \ address, 0, 9>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CALP field\n       *\n\
    \       * Increase frequency of RTC by 488.5\n       *               ppm\n   \
    \    */\n      BitFieldModel<uint32_t, 15, 1> calp;\n      /**\n       * @brief\
    \ CALW8 field\n       *\n       * Use an 8-second calibration cycle\n       *\
    \               period\n       */\n      BitFieldModel<uint32_t, 14, 1> calw8;\n\
    \      /**\n       * @brief CALW16 field\n       *\n       * Use a 16-second calibration\
    \ cycle\n       *               period\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> calw16;\n      /**\n       * @brief CALM field\n       *\n       * Calibration\
    \ minus\n       */\n      BitFieldModel<uint32_t, 0, 9> calm;\n    };\n  };\n\n\
    public:\n  /**\n   * @brief CALR register\n   *\n   * calibration register\n \
    \  */\n  using calr = CalrReg<BaseAddress + 0x003C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class TafcrReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief ALARMOUTTYPE field\n     *\n     * AFO_ALARM\
    \ output type\n     */\n    using alarmouttype = FieldModel<uint32_t, address,\
    \ 18, 1>;\n    /**\n     * @brief TSINSEL field\n     *\n     * TIMESTAMP mapping\n\
    \     */\n    using tsinsel = FieldModel<uint32_t, address, 17, 1>;\n    /**\n\
    \     * @brief TAMP1INSEL field\n     *\n     * TAMPER1 mapping\n     */\n   \
    \ using tamp1insel = FieldModel<uint32_t, address, 16, 1>;\n    /**\n     * @brief\
    \ TAMPPUDIS field\n     *\n     * TAMPER pull-up disable\n     */\n    using tamppudis\
    \ = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief TAMPPRCH field\n\
    \     *\n     * Tamper precharge duration\n     */\n    using tampprch = FieldModel<uint32_t,\
    \ address, 13, 2>;\n    /**\n     * @brief TAMPFLT field\n     *\n     * Tamper\
    \ filter count\n     */\n    using tampflt = FieldModel<uint32_t, address, 11,\
    \ 2>;\n    /**\n     * @brief TAMPFREQ field\n     *\n     * Tamper sampling frequency\n\
    \     */\n    using tampfreq = FieldModel<uint32_t, address, 8, 3>;\n    /**\n\
    \     * @brief TAMPTS field\n     *\n     * Activate timestamp on tamper detection\n\
    \     *               event\n     */\n    using tampts = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief TAMP2TRG field\n     *\n     * Active\
    \ level for tamper 2\n     */\n    using tamp2trg = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief TAMP2E field\n     *\n     * Tamper 2 detection\
    \ enable\n     */\n    using tamp2e = FieldModel<uint32_t, address, 3, 1>;\n \
    \   /**\n     * @brief TAMPIE field\n     *\n     * Tamper interrupt enable\n\
    \     */\n    using tampie = FieldModel<uint32_t, address, 2, 1>;\n    /**\n \
    \    * @brief TAMP1TRG field\n     *\n     * Active level for tamper 1\n     */\n\
    \    using tamp1trg = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief\
    \ TAMP1E field\n     *\n     * Tamper 1 detection enable\n     */\n    using tamp1e\
    \ = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ ALARMOUTTYPE field\n       *\n       * AFO_ALARM output type\n       */\n  \
    \    BitFieldModel<uint32_t, 18, 1> alarmouttype;\n      /**\n       * @brief\
    \ TSINSEL field\n       *\n       * TIMESTAMP mapping\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> tsinsel;\n      /**\n       * @brief TAMP1INSEL field\n       *\n   \
    \    * TAMPER1 mapping\n       */\n      BitFieldModel<uint32_t, 16, 1> tamp1insel;\n\
    \      /**\n       * @brief TAMPPUDIS field\n       *\n       * TAMPER pull-up\
    \ disable\n       */\n      BitFieldModel<uint32_t, 15, 1> tamppudis;\n      /**\n\
    \       * @brief TAMPPRCH field\n       *\n       * Tamper precharge duration\n\
    \       */\n      BitFieldModel<uint32_t, 13, 2> tampprch;\n      /**\n      \
    \ * @brief TAMPFLT field\n       *\n       * Tamper filter count\n       */\n\
    \      BitFieldModel<uint32_t, 11, 2> tampflt;\n      /**\n       * @brief TAMPFREQ\
    \ field\n       *\n       * Tamper sampling frequency\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 3> tampfreq;\n      /**\n       * @brief TAMPTS field\n       *\n       *\
    \ Activate timestamp on tamper detection\n       *               event\n     \
    \  */\n      BitFieldModel<uint32_t, 7, 1> tampts;\n      /**\n       * @brief\
    \ TAMP2TRG field\n       *\n       * Active level for tamper 2\n       */\n  \
    \    BitFieldModel<uint32_t, 4, 1> tamp2trg;\n      /**\n       * @brief TAMP2E\
    \ field\n       *\n       * Tamper 2 detection enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> tamp2e;\n      /**\n       * @brief TAMPIE field\n       *\n       * Tamper\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 2, 1> tampie;\n \
    \     /**\n       * @brief TAMP1TRG field\n       *\n       * Active level for\
    \ tamper 1\n       */\n      BitFieldModel<uint32_t, 1, 1> tamp1trg;\n      /**\n\
    \       * @brief TAMP1E field\n       *\n       * Tamper 1 detection enable\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> tamp1e;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief TAFCR register\n   *\n   * tamper and alternate function configuration\n\
    \   *           register\n   */\n  using tafcr = TafcrReg<BaseAddress + 0x0040>;\n\
    \nprivate:\n  template<unsigned int address>\n  class AlrmassrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief MASKSS field\n     *\n    \
    \ * Mask the most-significant bits starting\n     *               at this bit\n\
    \     */\n    using maskss = FieldModel<uint32_t, address, 24, 4>;\n    /**\n\
    \     * @brief SS field\n     *\n     * Sub seconds value\n     */\n    using\
    \ ss = FieldModel<uint32_t, address, 0, 15>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ MASKSS field\n       *\n       * Mask the most-significant bits starting\n \
    \      *               at this bit\n       */\n      BitFieldModel<uint32_t, 24,\
    \ 4> maskss;\n      /**\n       * @brief SS field\n       *\n       * Sub seconds\
    \ value\n       */\n      BitFieldModel<uint32_t, 0, 15> ss;\n    };\n  };\n\n\
    public:\n  /**\n   * @brief ALRMASSR register\n   *\n   * alarm A sub second register\n\
    \   */\n  using alrmassr = AlrmassrReg<BaseAddress + 0x0044>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class AlrmbssrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief MASKSS field\n     *\n     * Mask the\
    \ most-significant bits starting\n     *               at this bit\n     */\n\
    \    using maskss = FieldModel<uint32_t, address, 24, 4>;\n    /**\n     * @brief\
    \ SS field\n     *\n     * Sub seconds value\n     */\n    using ss = FieldModel<uint32_t,\
    \ address, 0, 15>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief MASKSS field\n       *\n\
    \       * Mask the most-significant bits starting\n       *               at this\
    \ bit\n       */\n      BitFieldModel<uint32_t, 24, 4> maskss;\n      /**\n  \
    \     * @brief SS field\n       *\n       * Sub seconds value\n       */\n   \
    \   BitFieldModel<uint32_t, 0, 15> ss;\n    };\n  };\n\npublic:\n  /**\n   * @brief\
    \ ALRMBSSR register\n   *\n   * alarm B sub second register\n   */\n  using alrmbssr\
    \ = AlrmbssrReg<BaseAddress + 0x0048>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Bkp0rReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief BKP field\n     *\n     * BKP\n     */\n    using bkp\
    \ = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ BKP field\n       *\n       * BKP\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  /**\n   * @brief BKP0R register\n  \
    \ *\n   * backup register\n   */\n  using bkp0r = Bkp0rReg<BaseAddress + 0x0050>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Bkp1rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief BKP field\n     *\n     * BKP\n\
    \     */\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BKP field\n       *\n       * BKP\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  /**\n   * @brief BKP1R register\n  \
    \ *\n   * backup register\n   */\n  using bkp1r = Bkp1rReg<BaseAddress + 0x0054>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Bkp2rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief BKP field\n     *\n     * BKP\n\
    \     */\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BKP field\n       *\n       * BKP\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  /**\n   * @brief BKP2R register\n  \
    \ *\n   * backup register\n   */\n  using bkp2r = Bkp2rReg<BaseAddress + 0x0058>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Bkp3rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief BKP field\n     *\n     * BKP\n\
    \     */\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BKP field\n       *\n       * BKP\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  /**\n   * @brief BKP3R register\n  \
    \ *\n   * backup register\n   */\n  using bkp3r = Bkp3rReg<BaseAddress + 0x005C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Bkp4rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief BKP field\n     *\n     * BKP\n\
    \     */\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BKP field\n       *\n       * BKP\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  /**\n   * @brief BKP4R register\n  \
    \ *\n   * backup register\n   */\n  using bkp4r = Bkp4rReg<BaseAddress + 0x0060>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Bkp5rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief BKP field\n     *\n     * BKP\n\
    \     */\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BKP field\n       *\n       * BKP\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  /**\n   * @brief BKP5R register\n  \
    \ *\n   * backup register\n   */\n  using bkp5r = Bkp5rReg<BaseAddress + 0x0064>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Bkp6rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief BKP field\n     *\n     * BKP\n\
    \     */\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BKP field\n       *\n       * BKP\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  /**\n   * @brief BKP6R register\n  \
    \ *\n   * backup register\n   */\n  using bkp6r = Bkp6rReg<BaseAddress + 0x0068>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Bkp7rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief BKP field\n     *\n     * BKP\n\
    \     */\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BKP field\n       *\n       * BKP\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  /**\n   * @brief BKP7R register\n  \
    \ *\n   * backup register\n   */\n  using bkp7r = Bkp7rReg<BaseAddress + 0x006C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Bkp8rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief BKP field\n     *\n     * BKP\n\
    \     */\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BKP field\n       *\n       * BKP\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  /**\n   * @brief BKP8R register\n  \
    \ *\n   * backup register\n   */\n  using bkp8r = Bkp8rReg<BaseAddress + 0x0070>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Bkp9rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief BKP field\n     *\n     * BKP\n\
    \     */\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BKP field\n       *\n       * BKP\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  /**\n   * @brief BKP9R register\n  \
    \ *\n   * backup register\n   */\n  using bkp9r = Bkp9rReg<BaseAddress + 0x0074>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Bkp10rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief BKP field\n     *\n     * BKP\n\
    \     */\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BKP field\n       *\n       * BKP\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  /**\n   * @brief BKP10R register\n \
    \  *\n   * backup register\n   */\n  using bkp10r = Bkp10rReg<BaseAddress + 0x0078>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Bkp11rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief BKP field\n     *\n     * BKP\n\
    \     */\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BKP field\n       *\n       * BKP\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  /**\n   * @brief BKP11R register\n \
    \  *\n   * backup register\n   */\n  using bkp11r = Bkp11rReg<BaseAddress + 0x007C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Bkp12rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief BKP field\n     *\n     * BKP\n\
    \     */\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BKP field\n       *\n       * BKP\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  /**\n   * @brief BKP12R register\n \
    \  *\n   * backup register\n   */\n  using bkp12r = Bkp12rReg<BaseAddress + 0x0080>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Bkp13rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief BKP field\n     *\n     * BKP\n\
    \     */\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BKP field\n       *\n       * BKP\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  /**\n   * @brief BKP13R register\n \
    \  *\n   * backup register\n   */\n  using bkp13r = Bkp13rReg<BaseAddress + 0x0084>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Bkp14rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief BKP field\n     *\n     * BKP\n\
    \     */\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BKP field\n       *\n       * BKP\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  /**\n   * @brief BKP14R register\n \
    \  *\n   * backup register\n   */\n  using bkp14r = Bkp14rReg<BaseAddress + 0x0088>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Bkp15rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief BKP field\n     *\n     * BKP\n\
    \     */\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BKP field\n       *\n       * BKP\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  /**\n   * @brief BKP15R register\n \
    \  *\n   * backup register\n   */\n  using bkp15r = Bkp15rReg<BaseAddress + 0x008C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Bkp16rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief BKP field\n     *\n     * BKP\n\
    \     */\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BKP field\n       *\n       * BKP\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  /**\n   * @brief BKP16R register\n \
    \  *\n   * backup register\n   */\n  using bkp16r = Bkp16rReg<BaseAddress + 0x0090>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Bkp17rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief BKP field\n     *\n     * BKP\n\
    \     */\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BKP field\n       *\n       * BKP\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  /**\n   * @brief BKP17R register\n \
    \  *\n   * backup register\n   */\n  using bkp17r = Bkp17rReg<BaseAddress + 0x0094>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Bkp18rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief BKP field\n     *\n     * BKP\n\
    \     */\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BKP field\n       *\n       * BKP\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  /**\n   * @brief BKP18R register\n \
    \  *\n   * backup register\n   */\n  using bkp18r = Bkp18rReg<BaseAddress + 0x0098>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Bkp19rReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief BKP field\n     *\n     * BKP\n\
    \     */\n    using bkp = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BKP field\n       *\n       * BKP\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  /**\n   * @brief BKP19R register\n \
    \  *\n   * backup register\n   */\n  using bkp19r = Bkp19rReg<BaseAddress + 0x009C>;\n\
    \nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n  class\
    \ AlrmxrBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n\
    \  public:\n    /**\n     * @brief MSK4 field\n     *\n     * Alarm A date mask\n\
    \     */\n    using msk4 = FieldModel<uint32_t, address, 31, 1, bankOffset>;\n\
    \    /**\n     * @brief WDSEL field\n     *\n     * Week day selection\n     */\n\
    \    using wdsel = FieldModel<uint32_t, address, 30, 1, bankOffset>;\n    /**\n\
    \     * @brief DT field\n     *\n     * Date tens in BCD format\n     */\n   \
    \ using dt = FieldModel<uint32_t, address, 28, 2, bankOffset>;\n    /**\n    \
    \ * @brief DU field\n     *\n     * Date units or day in BCD\n     *         \
    \      format\n     */\n    using du = FieldModel<uint32_t, address, 24, 4, bankOffset>;\n\
    \    /**\n     * @brief MSK3 field\n     *\n     * Alarm A hours mask\n     */\n\
    \    using msk3 = FieldModel<uint32_t, address, 23, 1, bankOffset>;\n    /**\n\
    \     * @brief PM field\n     *\n     * AM/PM notation\n     */\n    using pm\
    \ = FieldModel<uint32_t, address, 22, 1, bankOffset>;\n    /**\n     * @brief\
    \ HT field\n     *\n     * Hour tens in BCD format\n     */\n    using ht = FieldModel<uint32_t,\
    \ address, 20, 2, bankOffset>;\n    /**\n     * @brief HU field\n     *\n    \
    \ * Hour units in BCD format\n     */\n    using hu = FieldModel<uint32_t, address,\
    \ 16, 4, bankOffset>;\n    /**\n     * @brief MSK2 field\n     *\n     * Alarm\
    \ A minutes mask\n     */\n    using msk2 = FieldModel<uint32_t, address, 15,\
    \ 1, bankOffset>;\n    /**\n     * @brief MNT field\n     *\n     * Minute tens\
    \ in BCD format\n     */\n    using mnt = FieldModel<uint32_t, address, 12, 3,\
    \ bankOffset>;\n    /**\n     * @brief MNU field\n     *\n     * Minute units\
    \ in BCD format\n     */\n    using mnu = FieldModel<uint32_t, address, 8, 4,\
    \ bankOffset>;\n    /**\n     * @brief MSK1 field\n     *\n     * Alarm A seconds\
    \ mask\n     */\n    using msk1 = FieldModel<uint32_t, address, 7, 1, bankOffset>;\n\
    \    /**\n     * @brief ST field\n     *\n     * Second tens in BCD format\n \
    \    */\n    using st = FieldModel<uint32_t, address, 4, 3, bankOffset>;\n   \
    \ /**\n     * @brief SU field\n     *\n     * Second units in BCD format\n   \
    \  */\n    using su = FieldModel<uint32_t, address, 0, 4, bankOffset>;\n\n  public:\n\
    \    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief MSK4\
    \ field\n       *\n       * Alarm A date mask\n       */\n      BitFieldModel<uint32_t,\
    \ 31, 1> msk4;\n      /**\n       * @brief WDSEL field\n       *\n       * Week\
    \ day selection\n       */\n      BitFieldModel<uint32_t, 30, 1> wdsel;\n    \
    \  /**\n       * @brief DT field\n       *\n       * Date tens in BCD format\n\
    \       */\n      BitFieldModel<uint32_t, 28, 2> dt;\n      /**\n       * @brief\
    \ DU field\n       *\n       * Date units or day in BCD\n       *            \
    \   format\n       */\n      BitFieldModel<uint32_t, 24, 4> du;\n      /**\n \
    \      * @brief MSK3 field\n       *\n       * Alarm A hours mask\n       */\n\
    \      BitFieldModel<uint32_t, 23, 1> msk3;\n      /**\n       * @brief PM field\n\
    \       *\n       * AM/PM notation\n       */\n      BitFieldModel<uint32_t, 22,\
    \ 1> pm;\n      /**\n       * @brief HT field\n       *\n       * Hour tens in\
    \ BCD format\n       */\n      BitFieldModel<uint32_t, 20, 2> ht;\n      /**\n\
    \       * @brief HU field\n       *\n       * Hour units in BCD format\n     \
    \  */\n      BitFieldModel<uint32_t, 16, 4> hu;\n      /**\n       * @brief MSK2\
    \ field\n       *\n       * Alarm A minutes mask\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> msk2;\n      /**\n       * @brief MNT field\n       *\n       * Minute\
    \ tens in BCD format\n       */\n      BitFieldModel<uint32_t, 12, 3> mnt;\n \
    \     /**\n       * @brief MNU field\n       *\n       * Minute units in BCD format\n\
    \       */\n      BitFieldModel<uint32_t, 8, 4> mnu;\n      /**\n       * @brief\
    \ MSK1 field\n       *\n       * Alarm A seconds mask\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> msk1;\n      /**\n       * @brief ST field\n       *\n       * Second\
    \ tens in BCD format\n       */\n      BitFieldModel<uint32_t, 4, 3> st;\n   \
    \   /**\n       * @brief SU field\n       *\n       * Second units in BCD format\n\
    \       */\n      BitFieldModel<uint32_t, 0, 4> su;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief ALRMXR register bank\n   *\n   * alarm A register\n   */\n\
    \  using alrmxr = AlrmxrBankReg<BaseAddress + 0x001C, 0x0004>;\n\nprivate:\n \
    \ template<unsigned int address, unsigned int bankOffset>\n  class AlrmxssrBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    /**\n     * @brief MASKSS field\n     *\n     * Mask the most-significant\
    \ bits starting\n     *               at this bit\n     */\n    using maskss =\
    \ FieldModel<uint32_t, address, 24, 4, bankOffset>;\n    /**\n     * @brief SS\
    \ field\n     *\n     * Sub seconds value\n     */\n    using ss = FieldModel<uint32_t,\
    \ address, 0, 15, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief MASKSS field\n       *\n       * Mask the\
    \ most-significant bits starting\n       *               at this bit\n       */\n\
    \      BitFieldModel<uint32_t, 24, 4> maskss;\n      /**\n       * @brief SS field\n\
    \       *\n       * Sub seconds value\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 15> ss;\n    };\n  };\n\npublic:\n  /**\n   * @brief ALRMXSSR register bank\n\
    \   *\n   * alarm A sub second register\n   */\n  using alrmxssr = AlrmxssrBankReg<BaseAddress\
    \ + 0x0044, 0x0004>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class BkpxrBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    /**\n     * @brief BKP field\n     *\n    \
    \ * BKP\n     */\n    using bkp = FieldModel<uint32_t, address, 0, 32, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      /**\n       *\
    \ @brief BKP field\n       *\n       * BKP\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> bkp;\n    };\n  };\n\npublic:\n  /**\n   * @brief BKPXR register bank\n\
    \   *\n   * backup register\n   */\n  using bkpxr = BkpxrBankReg<BaseAddress +\
    \ 0x0050, 0x0004>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_RTC_H */"
  name: RTC
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_SDIO_H\n#define DRAL_STM32F411_SDIO_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ SDIO peripheral\n *\n * Secure digital input/output\n *       interface\n */\n\
    class sdio\n{\npublic:\n  static constexpr unsigned int BaseAddress = 0x40012C00;\
    \ /**< Peripheral base address */\n\nprivate:\n  template<unsigned int address>\n\
    \  class PowerReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief PWRCTRL field\n     *\n     * PWRCTRL\n     */\n    using\
    \ pwrctrl = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    /**\n     *\
    \ @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ PWRCTRL field\n       *\n       * PWRCTRL\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> pwrctrl;\n    };\n  };\n\npublic:\n  /**\n   * @brief POWER register\n\
    \   *\n   * power control register\n   */\n  using power = PowerReg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class ClkcrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ HWFC_EN field\n     *\n     * HW Flow Control enable\n     */\n    using hwfc_en\
    \ = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief NEGEDGE field\n\
    \     *\n     * SDIO_CK dephasing selection\n     *               bit\n     */\n\
    \    using negedge = FieldModel<uint32_t, address, 13, 1>;\n    /**\n     * @brief\
    \ WIDBUS field\n     *\n     * Wide bus mode enable bit\n     */\n    using widbus\
    \ = FieldModel<uint32_t, address, 11, 2>;\n    /**\n     * @brief BYPASS field\n\
    \     *\n     * Clock divider bypass enable\n     *               bit\n     */\n\
    \    using bypass = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief\
    \ PWRSAV field\n     *\n     * Power saving configuration\n     *            \
    \   bit\n     */\n    using pwrsav = FieldModel<uint32_t, address, 9, 1>;\n  \
    \  /**\n     * @brief CLKEN field\n     *\n     * Clock enable bit\n     */\n\
    \    using clken = FieldModel<uint32_t, address, 8, 1>;\n    /**\n     * @brief\
    \ CLKDIV field\n     *\n     * Clock divide factor\n     */\n    using clkdiv\
    \ = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ HWFC_EN field\n       *\n       * HW Flow Control enable\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> hwfc_en;\n      /**\n       * @brief NEGEDGE field\n       *\n      \
    \ * SDIO_CK dephasing selection\n       *               bit\n       */\n     \
    \ BitFieldModel<uint32_t, 13, 1> negedge;\n      /**\n       * @brief WIDBUS field\n\
    \       *\n       * Wide bus mode enable bit\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 2> widbus;\n      /**\n       * @brief BYPASS field\n       *\n       *\
    \ Clock divider bypass enable\n       *               bit\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> bypass;\n      /**\n       * @brief PWRSAV field\n       *\n       *\
    \ Power saving configuration\n       *               bit\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> pwrsav;\n      /**\n       * @brief CLKEN field\n       *\n       * Clock\
    \ enable bit\n       */\n      BitFieldModel<uint32_t, 8, 1> clken;\n      /**\n\
    \       * @brief CLKDIV field\n       *\n       * Clock divide factor\n      \
    \ */\n      BitFieldModel<uint32_t, 0, 8> clkdiv;\n    };\n  };\n\npublic:\n \
    \ /**\n   * @brief CLKCR register\n   *\n   * SDI clock control register\n   */\n\
    \  using clkcr = ClkcrReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class ArgReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief CMDARG field\n     *\n     * Command argument\n\
    \     */\n    using cmdarg = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CMDARG field\n       *\n       * Command argument\n       */\n\
    \      BitFieldModel<uint32_t, 0, 32> cmdarg;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief ARG register\n   *\n   * argument register\n   */\n  using arg =\
    \ ArgReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class CmdReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief CE_ATACMD field\n     *\n     * CE-ATA command\n     */\n\
    \    using ce_atacmd = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     *\
    \ @brief NIEN field\n     *\n     * not Interrupt Enable\n     */\n    using nien\
    \ = FieldModel<uint32_t, address, 13, 1>;\n    /**\n     * @brief ENCMDCOMPL field\n\
    \     *\n     * Enable CMD completion\n     */\n    using encmdcompl = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief SDIOSUSPEND field\n     *\n     * SD\
    \ I/O suspend command\n     */\n    using sdiosuspend = FieldModel<uint32_t, address,\
    \ 11, 1>;\n    /**\n     * @brief CPSMEN field\n     *\n     * Command path state\
    \ machine (CPSM) Enable\n     *               bit\n     */\n    using cpsmen =\
    \ FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief WAITPEND field\n\
    \     *\n     * CPSM Waits for ends of data transfer\n     *               (CmdPend\
    \ internal signal).\n     */\n    using waitpend = FieldModel<uint32_t, address,\
    \ 9, 1>;\n    /**\n     * @brief WAITINT field\n     *\n     * CPSM waits for\
    \ interrupt\n     *               request\n     */\n    using waitint = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief WAITRESP field\n     *\n     * Wait\
    \ for response bits\n     */\n    using waitresp = FieldModel<uint32_t, address,\
    \ 6, 2>;\n    /**\n     * @brief CMDINDEX field\n     *\n     * Command index\n\
    \     */\n    using cmdindex = FieldModel<uint32_t, address, 0, 6>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CE_ATACMD field\n       *\n       * CE-ATA command\n       */\n\
    \      BitFieldModel<uint32_t, 14, 1> ce_atacmd;\n      /**\n       * @brief NIEN\
    \ field\n       *\n       * not Interrupt Enable\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> nien;\n      /**\n       * @brief ENCMDCOMPL field\n       *\n      \
    \ * Enable CMD completion\n       */\n      BitFieldModel<uint32_t, 12, 1> encmdcompl;\n\
    \      /**\n       * @brief SDIOSUSPEND field\n       *\n       * SD I/O suspend\
    \ command\n       */\n      BitFieldModel<uint32_t, 11, 1> sdiosuspend;\n    \
    \  /**\n       * @brief CPSMEN field\n       *\n       * Command path state machine\
    \ (CPSM) Enable\n       *               bit\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> cpsmen;\n      /**\n       * @brief WAITPEND field\n       *\n      \
    \ * CPSM Waits for ends of data transfer\n       *               (CmdPend internal\
    \ signal).\n       */\n      BitFieldModel<uint32_t, 9, 1> waitpend;\n      /**\n\
    \       * @brief WAITINT field\n       *\n       * CPSM waits for interrupt\n\
    \       *               request\n       */\n      BitFieldModel<uint32_t, 8, 1>\
    \ waitint;\n      /**\n       * @brief WAITRESP field\n       *\n       * Wait\
    \ for response bits\n       */\n      BitFieldModel<uint32_t, 6, 2> waitresp;\n\
    \      /**\n       * @brief CMDINDEX field\n       *\n       * Command index\n\
    \       */\n      BitFieldModel<uint32_t, 0, 6> cmdindex;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CMD register\n   *\n   * command register\n   */\n  using\
    \ cmd = CmdReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class RespcmdReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief RESPCMD field\n     *\n     * Response command index\n\
    \     */\n    using respcmd = FieldModel<uint32_t, address, 0, 6>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief RESPCMD field\n       *\n       * Response command index\n  \
    \     */\n      BitFieldModel<uint32_t, 0, 6> respcmd;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief RESPCMD register\n   *\n   * command response register\n \
    \  */\n  using respcmd = RespcmdReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Resp1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief CARDSTATUS1 field\n     *\n     * Card\
    \ Status\n     */\n    using cardstatus1 = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief CARDSTATUS1 field\n       *\n       * Card\
    \ Status\n       */\n      BitFieldModel<uint32_t, 0, 32> cardstatus1;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief RESP1 register\n   *\n   * response 1..4\
    \ register\n   */\n  using resp1 = Resp1Reg<BaseAddress + 0x0014>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Resp2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CARDSTATUS2 field\n     *\n\
    \     * Card Status\n     */\n    using cardstatus2 = FieldModel<uint32_t, address,\
    \ 0, 32>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CARDSTATUS2 field\n   \
    \    *\n       * Card Status\n       */\n      BitFieldModel<uint32_t, 0, 32>\
    \ cardstatus2;\n    };\n  };\n\npublic:\n  /**\n   * @brief RESP2 register\n \
    \  *\n   * response 1..4 register\n   */\n  using resp2 = Resp2Reg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class Resp3Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ CARDSTATUS3 field\n     *\n     * Card Status\n     */\n    using cardstatus3\
    \ = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CARDSTATUS3 field\n       *\n       * Card Status\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> cardstatus3;\n    };\n  };\n\npublic:\n  /**\n   * @brief RESP3 register\n\
    \   *\n   * response 1..4 register\n   */\n  using resp3 = Resp3Reg<BaseAddress\
    \ + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class Resp4Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ CARDSTATUS4 field\n     *\n     * Card Status\n     */\n    using cardstatus4\
    \ = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CARDSTATUS4 field\n       *\n       * Card Status\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> cardstatus4;\n    };\n  };\n\npublic:\n  /**\n   * @brief RESP4 register\n\
    \   *\n   * response 1..4 register\n   */\n  using resp4 = Resp4Reg<BaseAddress\
    \ + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n  class DtimerReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ DATATIME field\n     *\n     * Data timeout period\n     */\n    using datatime\
    \ = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ DATATIME field\n       *\n       * Data timeout period\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> datatime;\n    };\n  };\n\npublic:\n  /**\n   * @brief DTIMER register\n\
    \   *\n   * data timer register\n   */\n  using dtimer = DtimerReg<BaseAddress\
    \ + 0x0024>;\n\nprivate:\n  template<unsigned int address>\n  class DlenReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ DATALENGTH field\n     *\n     * Data length value\n     */\n    using datalength\
    \ = FieldModel<uint32_t, address, 0, 25>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ DATALENGTH field\n       *\n       * Data length value\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 25> datalength;\n    };\n  };\n\npublic:\n  /**\n   * @brief DLEN register\n\
    \   *\n   * data length register\n   */\n  using dlen = DlenReg<BaseAddress +\
    \ 0x0028>;\n\nprivate:\n  template<unsigned int address>\n  class DctrlReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief SDIOEN\
    \ field\n     *\n     * SD I/O enable functions\n     */\n    using sdioen = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief RWMOD field\n     *\n     * Read wait\
    \ mode\n     */\n    using rwmod = FieldModel<uint32_t, address, 10, 1>;\n   \
    \ /**\n     * @brief RWSTOP field\n     *\n     * Read wait stop\n     */\n  \
    \  using rwstop = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief\
    \ RWSTART field\n     *\n     * Read wait start\n     */\n    using rwstart =\
    \ FieldModel<uint32_t, address, 8, 1>;\n    /**\n     * @brief DBLOCKSIZE field\n\
    \     *\n     * Data block size\n     */\n    using dblocksize = FieldModel<uint32_t,\
    \ address, 4, 4>;\n    /**\n     * @brief DMAEN field\n     *\n     * DMA enable\
    \ bit\n     */\n    using dmaen = FieldModel<uint32_t, address, 3, 1>;\n    /**\n\
    \     * @brief DTMODE field\n     *\n     * Data transfer mode selection 1: Stream\n\
    \     *               or SDIO multibyte data transfer.\n     */\n    using dtmode\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief DTDIR field\n\
    \     *\n     * Data transfer direction\n     *               selection\n    \
    \ */\n    using dtdir = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     *\
    \ @brief DTEN field\n     *\n     * DTEN\n     */\n    using dten = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief SDIOEN field\n       *\n\
    \       * SD I/O enable functions\n       */\n      BitFieldModel<uint32_t, 11,\
    \ 1> sdioen;\n      /**\n       * @brief RWMOD field\n       *\n       * Read\
    \ wait mode\n       */\n      BitFieldModel<uint32_t, 10, 1> rwmod;\n      /**\n\
    \       * @brief RWSTOP field\n       *\n       * Read wait stop\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> rwstop;\n      /**\n       * @brief RWSTART\
    \ field\n       *\n       * Read wait start\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> rwstart;\n      /**\n       * @brief DBLOCKSIZE field\n       *\n    \
    \   * Data block size\n       */\n      BitFieldModel<uint32_t, 4, 4> dblocksize;\n\
    \      /**\n       * @brief DMAEN field\n       *\n       * DMA enable bit\n \
    \      */\n      BitFieldModel<uint32_t, 3, 1> dmaen;\n      /**\n       * @brief\
    \ DTMODE field\n       *\n       * Data transfer mode selection 1: Stream\n  \
    \     *               or SDIO multibyte data transfer.\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> dtmode;\n      /**\n       * @brief DTDIR field\n       *\n       * Data\
    \ transfer direction\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dtdir;\n      /**\n       * @brief DTEN field\n       *\n       * DTEN\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> dten;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief DCTRL register\n   *\n   * data control register\n   */\n\
    \  using dctrl = DctrlReg<BaseAddress + 0x002C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DcountReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief DATACOUNT field\n     *\n     * Data count\
    \ value\n     */\n    using datacount = FieldModel<uint32_t, address, 0, 25>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief DATACOUNT field\n       *\n       * Data\
    \ count value\n       */\n      BitFieldModel<uint32_t, 0, 25> datacount;\n  \
    \  };\n  };\n\npublic:\n  /**\n   * @brief DCOUNT register\n   *\n   * data counter\
    \ register\n   */\n  using dcount = DcountReg<BaseAddress + 0x0030>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class StaReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CEATAEND field\n     *\n  \
    \   * CE-ATA command completion signal\n     *               received for CMD61\n\
    \     */\n    using ceataend = FieldModel<uint32_t, address, 23, 1>;\n    /**\n\
    \     * @brief SDIOIT field\n     *\n     * SDIO interrupt received\n     */\n\
    \    using sdioit = FieldModel<uint32_t, address, 22, 1>;\n    /**\n     * @brief\
    \ RXDAVL field\n     *\n     * Data available in receive\n     *             \
    \  FIFO\n     */\n    using rxdavl = FieldModel<uint32_t, address, 21, 1>;\n \
    \   /**\n     * @brief TXDAVL field\n     *\n     * Data available in transmit\n\
    \     *               FIFO\n     */\n    using txdavl = FieldModel<uint32_t, address,\
    \ 20, 1>;\n    /**\n     * @brief RXFIFOE field\n     *\n     * Receive FIFO empty\n\
    \     */\n    using rxfifoe = FieldModel<uint32_t, address, 19, 1>;\n    /**\n\
    \     * @brief TXFIFOE field\n     *\n     * Transmit FIFO empty\n     */\n  \
    \  using txfifoe = FieldModel<uint32_t, address, 18, 1>;\n    /**\n     * @brief\
    \ RXFIFOF field\n     *\n     * Receive FIFO full\n     */\n    using rxfifof\
    \ = FieldModel<uint32_t, address, 17, 1>;\n    /**\n     * @brief TXFIFOF field\n\
    \     *\n     * Transmit FIFO full\n     */\n    using txfifof = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    /**\n     * @brief RXFIFOHF field\n     *\n     * Receive\
    \ FIFO half full: there are at\n     *               least 8 words in the FIFO\n\
    \     */\n    using rxfifohf = FieldModel<uint32_t, address, 15, 1>;\n    /**\n\
    \     * @brief TXFIFOHE field\n     *\n     * Transmit FIFO half empty: at least\
    \ 8\n     *               words can be written into the FIFO\n     */\n    using\
    \ txfifohe = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief RXACT\
    \ field\n     *\n     * Data receive in progress\n     */\n    using rxact = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief TXACT field\n     *\n     * Data transmit\
    \ in progress\n     */\n    using txact = FieldModel<uint32_t, address, 12, 1>;\n\
    \    /**\n     * @brief CMDACT field\n     *\n     * Command transfer in\n   \
    \  *               progress\n     */\n    using cmdact = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief DBCKEND field\n     *\n     * Data\
    \ block sent/received (CRC check\n     *               passed)\n     */\n    using\
    \ dbckend = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief STBITERR\
    \ field\n     *\n     * Start bit not detected on all data\n     *           \
    \    signals in wide bus mode\n     */\n    using stbiterr = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief DATAEND field\n     *\n     * Data end\
    \ (data counter, SDIDCOUNT, is\n     *               zero)\n     */\n    using\
    \ dataend = FieldModel<uint32_t, address, 8, 1>;\n    /**\n     * @brief CMDSENT\
    \ field\n     *\n     * Command sent (no response\n     *               required)\n\
    \     */\n    using cmdsent = FieldModel<uint32_t, address, 7, 1>;\n    /**\n\
    \     * @brief CMDREND field\n     *\n     * Command response received (CRC check\n\
    \     *               passed)\n     */\n    using cmdrend = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief RXOVERR field\n     *\n     * Received\
    \ FIFO overrun\n     *               error\n     */\n    using rxoverr = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief TXUNDERR field\n     *\n     * Transmit\
    \ FIFO underrun\n     *               error\n     */\n    using txunderr = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief DTIMEOUT field\n     *\n     * Data\
    \ timeout\n     */\n    using dtimeout = FieldModel<uint32_t, address, 3, 1>;\n\
    \    /**\n     * @brief CTIMEOUT field\n     *\n     * Command response timeout\n\
    \     */\n    using ctimeout = FieldModel<uint32_t, address, 2, 1>;\n    /**\n\
    \     * @brief DCRCFAIL field\n     *\n     * Data block sent/received (CRC check\n\
    \     *               failed)\n     */\n    using dcrcfail = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief CCRCFAIL field\n     *\n     * Command\
    \ response received (CRC check\n     *               failed)\n     */\n    using\
    \ ccrcfail = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n    \
    \ * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CEATAEND field\n       *\n       * CE-ATA command completion signal\n      \
    \ *               received for CMD61\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 1> ceataend;\n      /**\n       * @brief SDIOIT field\n       *\n      \
    \ * SDIO interrupt received\n       */\n      BitFieldModel<uint32_t, 22, 1> sdioit;\n\
    \      /**\n       * @brief RXDAVL field\n       *\n       * Data available in\
    \ receive\n       *               FIFO\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 1> rxdavl;\n      /**\n       * @brief TXDAVL field\n       *\n       *\
    \ Data available in transmit\n       *               FIFO\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 1> txdavl;\n      /**\n       * @brief RXFIFOE field\n       *\n       *\
    \ Receive FIFO empty\n       */\n      BitFieldModel<uint32_t, 19, 1> rxfifoe;\n\
    \      /**\n       * @brief TXFIFOE field\n       *\n       * Transmit FIFO empty\n\
    \       */\n      BitFieldModel<uint32_t, 18, 1> txfifoe;\n      /**\n       *\
    \ @brief RXFIFOF field\n       *\n       * Receive FIFO full\n       */\n    \
    \  BitFieldModel<uint32_t, 17, 1> rxfifof;\n      /**\n       * @brief TXFIFOF\
    \ field\n       *\n       * Transmit FIFO full\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> txfifof;\n      /**\n       * @brief RXFIFOHF field\n       *\n     \
    \  * Receive FIFO half full: there are at\n       *               least 8 words\
    \ in the FIFO\n       */\n      BitFieldModel<uint32_t, 15, 1> rxfifohf;\n   \
    \   /**\n       * @brief TXFIFOHE field\n       *\n       * Transmit FIFO half\
    \ empty: at least 8\n       *               words can be written into the FIFO\n\
    \       */\n      BitFieldModel<uint32_t, 14, 1> txfifohe;\n      /**\n      \
    \ * @brief RXACT field\n       *\n       * Data receive in progress\n       */\n\
    \      BitFieldModel<uint32_t, 13, 1> rxact;\n      /**\n       * @brief TXACT\
    \ field\n       *\n       * Data transmit in progress\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> txact;\n      /**\n       * @brief CMDACT field\n       *\n       * Command\
    \ transfer in\n       *               progress\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> cmdact;\n      /**\n       * @brief DBCKEND field\n       *\n       *\
    \ Data block sent/received (CRC check\n       *               passed)\n      \
    \ */\n      BitFieldModel<uint32_t, 10, 1> dbckend;\n      /**\n       * @brief\
    \ STBITERR field\n       *\n       * Start bit not detected on all data\n    \
    \   *               signals in wide bus mode\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> stbiterr;\n      /**\n       * @brief DATAEND field\n       *\n      \
    \ * Data end (data counter, SDIDCOUNT, is\n       *               zero)\n    \
    \   */\n      BitFieldModel<uint32_t, 8, 1> dataend;\n      /**\n       * @brief\
    \ CMDSENT field\n       *\n       * Command sent (no response\n       *      \
    \         required)\n       */\n      BitFieldModel<uint32_t, 7, 1> cmdsent;\n\
    \      /**\n       * @brief CMDREND field\n       *\n       * Command response\
    \ received (CRC check\n       *               passed)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> cmdrend;\n      /**\n       * @brief RXOVERR field\n       *\n       *\
    \ Received FIFO overrun\n       *               error\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> rxoverr;\n      /**\n       * @brief TXUNDERR field\n       *\n      \
    \ * Transmit FIFO underrun\n       *               error\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> txunderr;\n      /**\n       * @brief DTIMEOUT field\n       *\n     \
    \  * Data timeout\n       */\n      BitFieldModel<uint32_t, 3, 1> dtimeout;\n\
    \      /**\n       * @brief CTIMEOUT field\n       *\n       * Command response\
    \ timeout\n       */\n      BitFieldModel<uint32_t, 2, 1> ctimeout;\n      /**\n\
    \       * @brief DCRCFAIL field\n       *\n       * Data block sent/received (CRC\
    \ check\n       *               failed)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dcrcfail;\n      /**\n       * @brief CCRCFAIL field\n       *\n     \
    \  * Command response received (CRC check\n       *               failed)\n  \
    \     */\n      BitFieldModel<uint32_t, 0, 1> ccrcfail;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief STA register\n   *\n   * status register\n   */\n  using sta\
    \ = StaReg<BaseAddress + 0x0034>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class IcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief CEATAENDC field\n     *\n     * CEATAEND flag clear bit\n\
    \     */\n    using ceataendc = FieldModel<uint32_t, address, 23, 1>;\n    /**\n\
    \     * @brief SDIOITC field\n     *\n     * SDIOIT flag clear bit\n     */\n\
    \    using sdioitc = FieldModel<uint32_t, address, 22, 1>;\n    /**\n     * @brief\
    \ DBCKENDC field\n     *\n     * DBCKEND flag clear bit\n     */\n    using dbckendc\
    \ = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief STBITERRC field\n\
    \     *\n     * STBITERR flag clear bit\n     */\n    using stbiterrc = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief DATAENDC field\n     *\n     * DATAEND\
    \ flag clear bit\n     */\n    using dataendc = FieldModel<uint32_t, address,\
    \ 8, 1>;\n    /**\n     * @brief CMDSENTC field\n     *\n     * CMDSENT flag clear\
    \ bit\n     */\n    using cmdsentc = FieldModel<uint32_t, address, 7, 1>;\n  \
    \  /**\n     * @brief CMDRENDC field\n     *\n     * CMDREND flag clear bit\n\
    \     */\n    using cmdrendc = FieldModel<uint32_t, address, 6, 1>;\n    /**\n\
    \     * @brief RXOVERRC field\n     *\n     * RXOVERR flag clear bit\n     */\n\
    \    using rxoverrc = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief\
    \ TXUNDERRC field\n     *\n     * TXUNDERR flag clear bit\n     */\n    using\
    \ txunderrc = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief DTIMEOUTC\
    \ field\n     *\n     * DTIMEOUT flag clear bit\n     */\n    using dtimeoutc\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief CTIMEOUTC field\n\
    \     *\n     * CTIMEOUT flag clear bit\n     */\n    using ctimeoutc = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief DCRCFAILC field\n     *\n     * DCRCFAIL\
    \ flag clear bit\n     */\n    using dcrcfailc = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    /**\n     * @brief CCRCFAILC field\n     *\n     * CCRCFAIL flag\
    \ clear bit\n     */\n    using ccrcfailc = FieldModel<uint32_t, address, 0, 1>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief CEATAENDC field\n       *\n       * CEATAEND\
    \ flag clear bit\n       */\n      BitFieldModel<uint32_t, 23, 1> ceataendc;\n\
    \      /**\n       * @brief SDIOITC field\n       *\n       * SDIOIT flag clear\
    \ bit\n       */\n      BitFieldModel<uint32_t, 22, 1> sdioitc;\n      /**\n \
    \      * @brief DBCKENDC field\n       *\n       * DBCKEND flag clear bit\n  \
    \     */\n      BitFieldModel<uint32_t, 10, 1> dbckendc;\n      /**\n       *\
    \ @brief STBITERRC field\n       *\n       * STBITERR flag clear bit\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> stbiterrc;\n      /**\n       * @brief DATAENDC\
    \ field\n       *\n       * DATAEND flag clear bit\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> dataendc;\n      /**\n       * @brief CMDSENTC field\n       *\n     \
    \  * CMDSENT flag clear bit\n       */\n      BitFieldModel<uint32_t, 7, 1> cmdsentc;\n\
    \      /**\n       * @brief CMDRENDC field\n       *\n       * CMDREND flag clear\
    \ bit\n       */\n      BitFieldModel<uint32_t, 6, 1> cmdrendc;\n      /**\n \
    \      * @brief RXOVERRC field\n       *\n       * RXOVERR flag clear bit\n  \
    \     */\n      BitFieldModel<uint32_t, 5, 1> rxoverrc;\n      /**\n       * @brief\
    \ TXUNDERRC field\n       *\n       * TXUNDERR flag clear bit\n       */\n   \
    \   BitFieldModel<uint32_t, 4, 1> txunderrc;\n      /**\n       * @brief DTIMEOUTC\
    \ field\n       *\n       * DTIMEOUT flag clear bit\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> dtimeoutc;\n      /**\n       * @brief CTIMEOUTC field\n       *\n   \
    \    * CTIMEOUT flag clear bit\n       */\n      BitFieldModel<uint32_t, 2, 1>\
    \ ctimeoutc;\n      /**\n       * @brief DCRCFAILC field\n       *\n       * DCRCFAIL\
    \ flag clear bit\n       */\n      BitFieldModel<uint32_t, 1, 1> dcrcfailc;\n\
    \      /**\n       * @brief CCRCFAILC field\n       *\n       * CCRCFAIL flag\
    \ clear bit\n       */\n      BitFieldModel<uint32_t, 0, 1> ccrcfailc;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief ICR register\n   *\n   * interrupt clear\
    \ register\n   */\n  using icr = IcrReg<BaseAddress + 0x0038>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class MaskReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CEATAENDIE field\n     *\n\
    \     * CE-ATA command completion signal\n     *               received interrupt\
    \ enable\n     */\n    using ceataendie = FieldModel<uint32_t, address, 23, 1>;\n\
    \    /**\n     * @brief SDIOITIE field\n     *\n     * SDIO mode interrupt received\
    \ interrupt\n     *               enable\n     */\n    using sdioitie = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    /**\n     * @brief RXDAVLIE field\n     *\n     * Data\
    \ available in Rx FIFO interrupt\n     *               enable\n     */\n    using\
    \ rxdavlie = FieldModel<uint32_t, address, 21, 1>;\n    /**\n     * @brief TXDAVLIE\
    \ field\n     *\n     * Data available in Tx FIFO interrupt\n     *          \
    \     enable\n     */\n    using txdavlie = FieldModel<uint32_t, address, 20,\
    \ 1>;\n    /**\n     * @brief RXFIFOEIE field\n     *\n     * Rx FIFO empty interrupt\n\
    \     *               enable\n     */\n    using rxfifoeie = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief TXFIFOEIE field\n     *\n     * Tx\
    \ FIFO empty interrupt\n     *               enable\n     */\n    using txfifoeie\
    \ = FieldModel<uint32_t, address, 18, 1>;\n    /**\n     * @brief RXFIFOFIE field\n\
    \     *\n     * Rx FIFO full interrupt\n     *               enable\n     */\n\
    \    using rxfifofie = FieldModel<uint32_t, address, 17, 1>;\n    /**\n     *\
    \ @brief TXFIFOFIE field\n     *\n     * Tx FIFO full interrupt\n     *      \
    \         enable\n     */\n    using txfifofie = FieldModel<uint32_t, address,\
    \ 16, 1>;\n    /**\n     * @brief RXFIFOHFIE field\n     *\n     * Rx FIFO half\
    \ full interrupt\n     *               enable\n     */\n    using rxfifohfie =\
    \ FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief TXFIFOHEIE field\n\
    \     *\n     * Tx FIFO half empty interrupt\n     *               enable\n  \
    \   */\n    using txfifoheie = FieldModel<uint32_t, address, 14, 1>;\n    /**\n\
    \     * @brief RXACTIE field\n     *\n     * Data receive acting interrupt\n \
    \    *               enable\n     */\n    using rxactie = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief TXACTIE field\n     *\n     * Data\
    \ transmit acting interrupt\n     *               enable\n     */\n    using txactie\
    \ = FieldModel<uint32_t, address, 12, 1>;\n    /**\n     * @brief CMDACTIE field\n\
    \     *\n     * Command acting interrupt\n     *               enable\n     */\n\
    \    using cmdactie = FieldModel<uint32_t, address, 11, 1>;\n    /**\n     * @brief\
    \ DBCKENDIE field\n     *\n     * Data block end interrupt\n     *           \
    \    enable\n     */\n    using dbckendie = FieldModel<uint32_t, address, 10,\
    \ 1>;\n    /**\n     * @brief STBITERRIE field\n     *\n     * Start bit error\
    \ interrupt\n     *               enable\n     */\n    using stbiterrie = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief DATAENDIE field\n     *\n     * Data\
    \ end interrupt enable\n     */\n    using dataendie = FieldModel<uint32_t, address,\
    \ 8, 1>;\n    /**\n     * @brief CMDSENTIE field\n     *\n     * Command sent\
    \ interrupt\n     *               enable\n     */\n    using cmdsentie = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief CMDRENDIE field\n     *\n     * Command\
    \ response received interrupt\n     *               enable\n     */\n    using\
    \ cmdrendie = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief RXOVERRIE\
    \ field\n     *\n     * Rx FIFO overrun error interrupt\n     *              \
    \ enable\n     */\n    using rxoverrie = FieldModel<uint32_t, address, 5, 1>;\n\
    \    /**\n     * @brief TXUNDERRIE field\n     *\n     * Tx FIFO underrun error\
    \ interrupt\n     *               enable\n     */\n    using txunderrie = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief DTIMEOUTIE field\n     *\n     * Data\
    \ timeout interrupt\n     *               enable\n     */\n    using dtimeoutie\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief CTIMEOUTIE field\n\
    \     *\n     * Command timeout interrupt\n     *               enable\n     */\n\
    \    using ctimeoutie = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     *\
    \ @brief DCRCFAILIE field\n     *\n     * Data CRC fail interrupt\n     *    \
    \           enable\n     */\n    using dcrcfailie = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    /**\n     * @brief CCRCFAILIE field\n     *\n     * Command CRC\
    \ fail interrupt\n     *               enable\n     */\n    using ccrcfailie =\
    \ FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register\
    \ union\n     *\n     * Can be used to create a local register variable for easy\
    \ bit manipulation.\n     * Useful for read-modify-write operations.\n     */\n\
    \    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief CEATAENDIE\
    \ field\n       *\n       * CE-ATA command completion signal\n       *       \
    \        received interrupt enable\n       */\n      BitFieldModel<uint32_t, 23,\
    \ 1> ceataendie;\n      /**\n       * @brief SDIOITIE field\n       *\n      \
    \ * SDIO mode interrupt received interrupt\n       *               enable\n  \
    \     */\n      BitFieldModel<uint32_t, 22, 1> sdioitie;\n      /**\n       *\
    \ @brief RXDAVLIE field\n       *\n       * Data available in Rx FIFO interrupt\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 21, 1>\
    \ rxdavlie;\n      /**\n       * @brief TXDAVLIE field\n       *\n       * Data\
    \ available in Tx FIFO interrupt\n       *               enable\n       */\n \
    \     BitFieldModel<uint32_t, 20, 1> txdavlie;\n      /**\n       * @brief RXFIFOEIE\
    \ field\n       *\n       * Rx FIFO empty interrupt\n       *               enable\n\
    \       */\n      BitFieldModel<uint32_t, 19, 1> rxfifoeie;\n      /**\n     \
    \  * @brief TXFIFOEIE field\n       *\n       * Tx FIFO empty interrupt\n    \
    \   *               enable\n       */\n      BitFieldModel<uint32_t, 18, 1> txfifoeie;\n\
    \      /**\n       * @brief RXFIFOFIE field\n       *\n       * Rx FIFO full interrupt\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 17, 1>\
    \ rxfifofie;\n      /**\n       * @brief TXFIFOFIE field\n       *\n       * Tx\
    \ FIFO full interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> txfifofie;\n      /**\n       * @brief RXFIFOHFIE field\n       *\n \
    \      * Rx FIFO half full interrupt\n       *               enable\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> rxfifohfie;\n      /**\n       * @brief\
    \ TXFIFOHEIE field\n       *\n       * Tx FIFO half empty interrupt\n       *\
    \               enable\n       */\n      BitFieldModel<uint32_t, 14, 1> txfifoheie;\n\
    \      /**\n       * @brief RXACTIE field\n       *\n       * Data receive acting\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> rxactie;\n      /**\n       * @brief TXACTIE field\n       *\n      \
    \ * Data transmit acting interrupt\n       *               enable\n       */\n\
    \      BitFieldModel<uint32_t, 12, 1> txactie;\n      /**\n       * @brief CMDACTIE\
    \ field\n       *\n       * Command acting interrupt\n       *               enable\n\
    \       */\n      BitFieldModel<uint32_t, 11, 1> cmdactie;\n      /**\n      \
    \ * @brief DBCKENDIE field\n       *\n       * Data block end interrupt\n    \
    \   *               enable\n       */\n      BitFieldModel<uint32_t, 10, 1> dbckendie;\n\
    \      /**\n       * @brief STBITERRIE field\n       *\n       * Start bit error\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> stbiterrie;\n      /**\n       * @brief DATAENDIE field\n       *\n  \
    \     * Data end interrupt enable\n       */\n      BitFieldModel<uint32_t, 8,\
    \ 1> dataendie;\n      /**\n       * @brief CMDSENTIE field\n       *\n      \
    \ * Command sent interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> cmdsentie;\n      /**\n       * @brief CMDRENDIE field\n       *\n   \
    \    * Command response received interrupt\n       *               enable\n  \
    \     */\n      BitFieldModel<uint32_t, 6, 1> cmdrendie;\n      /**\n       *\
    \ @brief RXOVERRIE field\n       *\n       * Rx FIFO overrun error interrupt\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 5, 1>\
    \ rxoverrie;\n      /**\n       * @brief TXUNDERRIE field\n       *\n       *\
    \ Tx FIFO underrun error interrupt\n       *               enable\n       */\n\
    \      BitFieldModel<uint32_t, 4, 1> txunderrie;\n      /**\n       * @brief DTIMEOUTIE\
    \ field\n       *\n       * Data timeout interrupt\n       *               enable\n\
    \       */\n      BitFieldModel<uint32_t, 3, 1> dtimeoutie;\n      /**\n     \
    \  * @brief CTIMEOUTIE field\n       *\n       * Command timeout interrupt\n \
    \      *               enable\n       */\n      BitFieldModel<uint32_t, 2, 1>\
    \ ctimeoutie;\n      /**\n       * @brief DCRCFAILIE field\n       *\n       *\
    \ Data CRC fail interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dcrcfailie;\n      /**\n       * @brief CCRCFAILIE field\n       *\n \
    \      * Command CRC fail interrupt\n       *               enable\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> ccrcfailie;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief MASK register\n   *\n   * mask register\n   */\n  using mask = MaskReg<BaseAddress\
    \ + 0x003C>;\n\nprivate:\n  template<unsigned int address>\n  class FifocntReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ FIFOCOUNT field\n     *\n     * Remaining number of words to be written\n  \
    \   *               to or read from the FIFO.\n     */\n    using fifocount =\
    \ FieldModel<uint32_t, address, 0, 24>;\n\n  public:\n    /**\n     * @brief Register\
    \ union\n     *\n     * Can be used to create a local register variable for easy\
    \ bit manipulation.\n     * Useful for read-modify-write operations.\n     */\n\
    \    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief FIFOCOUNT\
    \ field\n       *\n       * Remaining number of words to be written\n       *\
    \               to or read from the FIFO.\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 24> fifocount;\n    };\n  };\n\npublic:\n  /**\n   * @brief FIFOCNT register\n\
    \   *\n   * FIFO counter register\n   */\n  using fifocnt = FifocntReg<BaseAddress\
    \ + 0x0048>;\n\nprivate:\n  template<unsigned int address>\n  class FifoReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ FIFODATA field\n     *\n     * Receive and transmit FIFO\n     *           \
    \    data\n     */\n    using fifodata = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief FIFODATA field\n       *\n       * Receive\
    \ and transmit FIFO\n       *               data\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> fifodata;\n    };\n  };\n\npublic:\n  /**\n   * @brief FIFO register\n\
    \   *\n   * data FIFO register\n   */\n  using fifo = FifoReg<BaseAddress + 0x0080>;\n\
    \n};\n\n}\n\n#endif /* DRAL_STM32F411_SDIO_H */"
  name: SDIO
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_SYSCFG_H\n#define DRAL_STM32F411_SYSCFG_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ SYSCFG peripheral\n *\n * System configuration controller\n */\nclass syscfg\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40013800; /**< Peripheral\
    \ base address */\n\nprivate:\n  template<unsigned int address>\n  class MemrmReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ MEM_MODE field\n     *\n     * MEM_MODE\n     */\n    using mem_mode = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief MEM_MODE field\n      \
    \ *\n       * MEM_MODE\n       */\n      BitFieldModel<uint32_t, 0, 2> mem_mode;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief MEMRM register\n   *\n   * memory\
    \ remap register\n   */\n  using memrm = MemrmReg<BaseAddress + 0x0000>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class PmcReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief ADC1DC2 field\n     *\n   \
    \  * ADC1DC2\n     */\n    using adc1dc2 = FieldModel<uint32_t, address, 16, 1>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief ADC1DC2 field\n       *\n       * ADC1DC2\n\
    \       */\n      BitFieldModel<uint32_t, 16, 1> adc1dc2;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief PMC register\n   *\n   * peripheral mode configuration\n \
    \  *           register\n   */\n  using pmc = PmcReg<BaseAddress + 0x0004>;\n\n\
    private:\n  template<unsigned int address>\n  class Exticr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief EXTI3 field\n     *\n     *\
    \ EXTI x configuration (x = 0 to\n     *               3)\n     */\n    using\
    \ exti3 = FieldModel<uint32_t, address, 12, 4>;\n    /**\n     * @brief EXTI2\
    \ field\n     *\n     * EXTI x configuration (x = 0 to\n     *               3)\n\
    \     */\n    using exti2 = FieldModel<uint32_t, address, 8, 4>;\n    /**\n  \
    \   * @brief EXTI1 field\n     *\n     * EXTI x configuration (x = 0 to\n    \
    \ *               3)\n     */\n    using exti1 = FieldModel<uint32_t, address,\
    \ 4, 4>;\n    /**\n     * @brief EXTI0 field\n     *\n     * EXTI x configuration\
    \ (x = 0 to\n     *               3)\n     */\n    using exti0 = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief EXTI3 field\n       *\n\
    \       * EXTI x configuration (x = 0 to\n       *               3)\n       */\n\
    \      BitFieldModel<uint32_t, 12, 4> exti3;\n      /**\n       * @brief EXTI2\
    \ field\n       *\n       * EXTI x configuration (x = 0 to\n       *         \
    \      3)\n       */\n      BitFieldModel<uint32_t, 8, 4> exti2;\n      /**\n\
    \       * @brief EXTI1 field\n       *\n       * EXTI x configuration (x = 0 to\n\
    \       *               3)\n       */\n      BitFieldModel<uint32_t, 4, 4> exti1;\n\
    \      /**\n       * @brief EXTI0 field\n       *\n       * EXTI x configuration\
    \ (x = 0 to\n       *               3)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> exti0;\n    };\n  };\n\npublic:\n  /**\n   * @brief EXTICR1 register\n\
    \   *\n   * external interrupt configuration register\n   *           1\n   */\n\
    \  using exticr1 = Exticr1Reg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Exticr2Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief EXTI7 field\n     *\n     * EXTI x configuration\
    \ (x = 4 to\n     *               7)\n     */\n    using exti7 = FieldModel<uint32_t,\
    \ address, 12, 4>;\n    /**\n     * @brief EXTI6 field\n     *\n     * EXTI x\
    \ configuration (x = 4 to\n     *               7)\n     */\n    using exti6 =\
    \ FieldModel<uint32_t, address, 8, 4>;\n    /**\n     * @brief EXTI5 field\n \
    \    *\n     * EXTI x configuration (x = 4 to\n     *               7)\n     */\n\
    \    using exti5 = FieldModel<uint32_t, address, 4, 4>;\n    /**\n     * @brief\
    \ EXTI4 field\n     *\n     * EXTI x configuration (x = 4 to\n     *         \
    \      7)\n     */\n    using exti4 = FieldModel<uint32_t, address, 0, 4>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief EXTI7 field\n       *\n       * EXTI x configuration\
    \ (x = 4 to\n       *               7)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 4> exti7;\n      /**\n       * @brief EXTI6 field\n       *\n       * EXTI\
    \ x configuration (x = 4 to\n       *               7)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 4> exti6;\n      /**\n       * @brief EXTI5 field\n       *\n       * EXTI\
    \ x configuration (x = 4 to\n       *               7)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 4> exti5;\n      /**\n       * @brief EXTI4 field\n       *\n       * EXTI\
    \ x configuration (x = 4 to\n       *               7)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> exti4;\n    };\n  };\n\npublic:\n  /**\n   * @brief EXTICR2 register\n\
    \   *\n   * external interrupt configuration register\n   *           2\n   */\n\
    \  using exticr2 = Exticr2Reg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Exticr3Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief EXTI11 field\n     *\n     * EXTI x configuration\
    \ (x = 8 to\n     *               11)\n     */\n    using exti11 = FieldModel<uint32_t,\
    \ address, 12, 4>;\n    /**\n     * @brief EXTI10 field\n     *\n     * EXTI10\n\
    \     */\n    using exti10 = FieldModel<uint32_t, address, 8, 4>;\n    /**\n \
    \    * @brief EXTI9 field\n     *\n     * EXTI x configuration (x = 8 to\n   \
    \  *               11)\n     */\n    using exti9 = FieldModel<uint32_t, address,\
    \ 4, 4>;\n    /**\n     * @brief EXTI8 field\n     *\n     * EXTI x configuration\
    \ (x = 8 to\n     *               11)\n     */\n    using exti8 = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief EXTI11 field\n       *\n\
    \       * EXTI x configuration (x = 8 to\n       *               11)\n       */\n\
    \      BitFieldModel<uint32_t, 12, 4> exti11;\n      /**\n       * @brief EXTI10\
    \ field\n       *\n       * EXTI10\n       */\n      BitFieldModel<uint32_t, 8,\
    \ 4> exti10;\n      /**\n       * @brief EXTI9 field\n       *\n       * EXTI\
    \ x configuration (x = 8 to\n       *               11)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 4> exti9;\n      /**\n       * @brief EXTI8 field\n       *\n       * EXTI\
    \ x configuration (x = 8 to\n       *               11)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> exti8;\n    };\n  };\n\npublic:\n  /**\n   * @brief EXTICR3 register\n\
    \   *\n   * external interrupt configuration register\n   *           3\n   */\n\
    \  using exticr3 = Exticr3Reg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Exticr4Reg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief EXTI15 field\n     *\n     * EXTI x configuration\
    \ (x = 12 to\n     *               15)\n     */\n    using exti15 = FieldModel<uint32_t,\
    \ address, 12, 4>;\n    /**\n     * @brief EXTI14 field\n     *\n     * EXTI x\
    \ configuration (x = 12 to\n     *               15)\n     */\n    using exti14\
    \ = FieldModel<uint32_t, address, 8, 4>;\n    /**\n     * @brief EXTI13 field\n\
    \     *\n     * EXTI x configuration (x = 12 to\n     *               15)\n  \
    \   */\n    using exti13 = FieldModel<uint32_t, address, 4, 4>;\n    /**\n   \
    \  * @brief EXTI12 field\n     *\n     * EXTI x configuration (x = 12 to\n   \
    \  *               15)\n     */\n    using exti12 = FieldModel<uint32_t, address,\
    \ 0, 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief EXTI15 field\n       *\n  \
    \     * EXTI x configuration (x = 12 to\n       *               15)\n       */\n\
    \      BitFieldModel<uint32_t, 12, 4> exti15;\n      /**\n       * @brief EXTI14\
    \ field\n       *\n       * EXTI x configuration (x = 12 to\n       *        \
    \       15)\n       */\n      BitFieldModel<uint32_t, 8, 4> exti14;\n      /**\n\
    \       * @brief EXTI13 field\n       *\n       * EXTI x configuration (x = 12\
    \ to\n       *               15)\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 4> exti13;\n      /**\n       * @brief EXTI12 field\n       *\n       * EXTI\
    \ x configuration (x = 12 to\n       *               15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> exti12;\n    };\n  };\n\npublic:\n  /**\n   * @brief EXTICR4 register\n\
    \   *\n   * external interrupt configuration register\n   *           4\n   */\n\
    \  using exticr4 = Exticr4Reg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CmpcrReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief READY field\n     *\n     * READY\n   \
    \  */\n    using ready = FieldModel<uint32_t, address, 8, 1>;\n    /**\n     *\
    \ @brief CMP_PD field\n     *\n     * Compensation cell\n     *              \
    \ power-down\n     */\n    using cmp_pd = FieldModel<uint32_t, address, 0, 1>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief READY field\n       *\n       * READY\n \
    \      */\n      BitFieldModel<uint32_t, 8, 1> ready;\n      /**\n       * @brief\
    \ CMP_PD field\n       *\n       * Compensation cell\n       *               power-down\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> cmp_pd;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CMPCR register\n   *\n   * Compensation cell control\n   *\
    \           register\n   */\n  using cmpcr = CmpcrReg<BaseAddress + 0x0020>;\n\
    \n};\n\n}\n\n#endif /* DRAL_STM32F411_SYSCFG_H */"
  name: SYSCFG
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_TIM1_H\n#define DRAL_STM32F411_TIM1_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ TIM1 peripheral\n *\n * Advanced-timers\n */\nclass tim1\n{\npublic:\n  static\
    \ constexpr unsigned int BaseAddress = 0x40010000; /**< Peripheral base address\
    \ */\n\nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CKD field\n     *\n     * Clock\
    \ division\n     */\n    using ckd = FieldModel<uint32_t, address, 8, 2>;\n  \
    \  /**\n     * @brief ARPE field\n     *\n     * Auto-reload preload enable\n\
    \     */\n    using arpe = FieldModel<uint32_t, address, 7, 1>;\n    /**\n   \
    \  * @brief CMS field\n     *\n     * Center-aligned mode\n     *            \
    \   selection\n     */\n    using cms = FieldModel<uint32_t, address, 5, 2>;\n\
    \    /**\n     * @brief DIR field\n     *\n     * Direction\n     */\n    using\
    \ dir = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief OPM field\n\
    \     *\n     * One-pulse mode\n     */\n    using opm = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief URS field\n     *\n     * Update request\
    \ source\n     */\n    using urs = FieldModel<uint32_t, address, 2, 1>;\n    /**\n\
    \     * @brief UDIS field\n     *\n     * Update disable\n     */\n    using udis\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief CEN field\n \
    \    *\n     * Counter enable\n     */\n    using cen = FieldModel<uint32_t, address,\
    \ 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief CKD field\n       *\n     \
    \  * Clock division\n       */\n      BitFieldModel<uint32_t, 8, 2> ckd;\n   \
    \   /**\n       * @brief ARPE field\n       *\n       * Auto-reload preload enable\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> arpe;\n      /**\n       * @brief\
    \ CMS field\n       *\n       * Center-aligned mode\n       *               selection\n\
    \       */\n      BitFieldModel<uint32_t, 5, 2> cms;\n      /**\n       * @brief\
    \ DIR field\n       *\n       * Direction\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> dir;\n      /**\n       * @brief OPM field\n       *\n       * One-pulse\
    \ mode\n       */\n      BitFieldModel<uint32_t, 3, 1> opm;\n      /**\n     \
    \  * @brief URS field\n       *\n       * Update request source\n       */\n \
    \     BitFieldModel<uint32_t, 2, 1> urs;\n      /**\n       * @brief UDIS field\n\
    \       *\n       * Update disable\n       */\n      BitFieldModel<uint32_t, 1,\
    \ 1> udis;\n      /**\n       * @brief CEN field\n       *\n       * Counter enable\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> cen;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR1 register\n   *\n   * control register 1\n   */\n  using\
    \ cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief OIS4 field\n     *\n     * Output Idle state 4\n     */\n\
    \    using ois4 = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief\
    \ OIS3N field\n     *\n     * Output Idle state 3\n     */\n    using ois3n =\
    \ FieldModel<uint32_t, address, 13, 1>;\n    /**\n     * @brief OIS3 field\n \
    \    *\n     * Output Idle state 3\n     */\n    using ois3 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief OIS2N field\n     *\n     * Output\
    \ Idle state 2\n     */\n    using ois2n = FieldModel<uint32_t, address, 11, 1>;\n\
    \    /**\n     * @brief OIS2 field\n     *\n     * Output Idle state 2\n     */\n\
    \    using ois2 = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief\
    \ OIS1N field\n     *\n     * Output Idle state 1\n     */\n    using ois1n =\
    \ FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief OIS1 field\n  \
    \   *\n     * Output Idle state 1\n     */\n    using ois1 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief TI1S field\n     *\n     * TI1 selection\n\
    \     */\n    using ti1s = FieldModel<uint32_t, address, 7, 1>;\n    /**\n   \
    \  * @brief MMS field\n     *\n     * Master mode selection\n     */\n    using\
    \ mms = FieldModel<uint32_t, address, 4, 3>;\n    /**\n     * @brief CCDS field\n\
    \     *\n     * Capture/compare DMA\n     *               selection\n     */\n\
    \    using ccds = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief\
    \ CCUS field\n     *\n     * Capture/compare control update\n     *          \
    \     selection\n     */\n    using ccus = FieldModel<uint32_t, address, 2, 1>;\n\
    \    /**\n     * @brief CCPC field\n     *\n     * Capture/compare preloaded\n\
    \     *               control\n     */\n    using ccpc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OIS4 field\n       *\n\
    \       * Output Idle state 4\n       */\n      BitFieldModel<uint32_t, 14, 1>\
    \ ois4;\n      /**\n       * @brief OIS3N field\n       *\n       * Output Idle\
    \ state 3\n       */\n      BitFieldModel<uint32_t, 13, 1> ois3n;\n      /**\n\
    \       * @brief OIS3 field\n       *\n       * Output Idle state 3\n       */\n\
    \      BitFieldModel<uint32_t, 12, 1> ois3;\n      /**\n       * @brief OIS2N\
    \ field\n       *\n       * Output Idle state 2\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> ois2n;\n      /**\n       * @brief OIS2 field\n       *\n       * Output\
    \ Idle state 2\n       */\n      BitFieldModel<uint32_t, 10, 1> ois2;\n      /**\n\
    \       * @brief OIS1N field\n       *\n       * Output Idle state 1\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> ois1n;\n      /**\n       * @brief OIS1 field\n\
    \       *\n       * Output Idle state 1\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> ois1;\n      /**\n       * @brief TI1S field\n       *\n       * TI1 selection\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> ti1s;\n      /**\n       * @brief\
    \ MMS field\n       *\n       * Master mode selection\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 3> mms;\n      /**\n       * @brief CCDS field\n       *\n       * Capture/compare\
    \ DMA\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> ccds;\n      /**\n       * @brief CCUS field\n       *\n       * Capture/compare\
    \ control update\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> ccus;\n      /**\n       * @brief CCPC field\n       *\n       * Capture/compare\
    \ preloaded\n       *               control\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> ccpc;\n    };\n  };\n\npublic:\n  /**\n   * @brief CR2 register\n   *\n\
    \   * control register 2\n   */\n  using cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class SmcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief ETP field\n     *\n     * External\
    \ trigger polarity\n     */\n    using etp = FieldModel<uint32_t, address, 15,\
    \ 1>;\n    /**\n     * @brief ECE field\n     *\n     * External clock enable\n\
    \     */\n    using ece = FieldModel<uint32_t, address, 14, 1>;\n    /**\n   \
    \  * @brief ETPS field\n     *\n     * External trigger prescaler\n     */\n \
    \   using etps = FieldModel<uint32_t, address, 12, 2>;\n    /**\n     * @brief\
    \ ETF field\n     *\n     * External trigger filter\n     */\n    using etf =\
    \ FieldModel<uint32_t, address, 8, 4>;\n    /**\n     * @brief MSM field\n   \
    \  *\n     * Master/Slave mode\n     */\n    using msm = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief TS field\n     *\n     * Trigger selection\n\
    \     */\n    using ts = FieldModel<uint32_t, address, 4, 3>;\n    /**\n     *\
    \ @brief SMS field\n     *\n     * Slave mode selection\n     */\n    using sms\
    \ = FieldModel<uint32_t, address, 0, 3>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ ETP field\n       *\n       * External trigger polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> etp;\n      /**\n       * @brief ECE field\n       *\n       * External\
    \ clock enable\n       */\n      BitFieldModel<uint32_t, 14, 1> ece;\n      /**\n\
    \       * @brief ETPS field\n       *\n       * External trigger prescaler\n \
    \      */\n      BitFieldModel<uint32_t, 12, 2> etps;\n      /**\n       * @brief\
    \ ETF field\n       *\n       * External trigger filter\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 4> etf;\n      /**\n       * @brief MSM field\n       *\n       * Master/Slave\
    \ mode\n       */\n      BitFieldModel<uint32_t, 7, 1> msm;\n      /**\n     \
    \  * @brief TS field\n       *\n       * Trigger selection\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 3> ts;\n      /**\n       * @brief SMS field\n       *\n       * Slave mode\
    \ selection\n       */\n      BitFieldModel<uint32_t, 0, 3> sms;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief SMCR register\n   *\n   * slave mode control register\n\
    \   */\n  using smcr = SmcrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DierReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief TDE field\n     *\n     * Trigger DMA request\
    \ enable\n     */\n    using tde = FieldModel<uint32_t, address, 14, 1>;\n   \
    \ /**\n     * @brief COMDE field\n     *\n     * COM DMA request enable\n    \
    \ */\n    using comde = FieldModel<uint32_t, address, 13, 1>;\n    /**\n     *\
    \ @brief CC4DE field\n     *\n     * Capture/Compare 4 DMA request\n     *   \
    \            enable\n     */\n    using cc4de = FieldModel<uint32_t, address,\
    \ 12, 1>;\n    /**\n     * @brief CC3DE field\n     *\n     * Capture/Compare\
    \ 3 DMA request\n     *               enable\n     */\n    using cc3de = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief CC2DE field\n     *\n     * Capture/Compare\
    \ 2 DMA request\n     *               enable\n     */\n    using cc2de = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief CC1DE field\n     *\n     * Capture/Compare\
    \ 1 DMA request\n     *               enable\n     */\n    using cc1de = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief UDE field\n     *\n     * Update DMA\
    \ request enable\n     */\n    using ude = FieldModel<uint32_t, address, 8, 1>;\n\
    \    /**\n     * @brief BIE field\n     *\n     * Break interrupt enable\n   \
    \  */\n    using bie = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief\
    \ TIE field\n     *\n     * Trigger interrupt enable\n     */\n    using tie =\
    \ FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief COMIE field\n \
    \    *\n     * COM interrupt enable\n     */\n    using comie = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief CC4IE field\n     *\n     * Capture/Compare\
    \ 4 interrupt\n     *               enable\n     */\n    using cc4ie = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief CC3IE field\n     *\n     * Capture/Compare\
    \ 3 interrupt\n     *               enable\n     */\n    using cc3ie = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief CC2IE field\n     *\n     * Capture/Compare\
    \ 2 interrupt\n     *               enable\n     */\n    using cc2ie = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1IE field\n     *\n     * Capture/Compare\
    \ 1 interrupt\n     *               enable\n     */\n    using cc1ie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UIE field\n     *\n     * Update interrupt\
    \ enable\n     */\n    using uie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief TDE field\n       *\n       * Trigger DMA request enable\n  \
    \     */\n      BitFieldModel<uint32_t, 14, 1> tde;\n      /**\n       * @brief\
    \ COMDE field\n       *\n       * COM DMA request enable\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> comde;\n      /**\n       * @brief CC4DE field\n       *\n       * Capture/Compare\
    \ 4 DMA request\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> cc4de;\n      /**\n       * @brief CC3DE field\n       *\n       * Capture/Compare\
    \ 3 DMA request\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> cc3de;\n      /**\n       * @brief CC2DE field\n       *\n       * Capture/Compare\
    \ 2 DMA request\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> cc2de;\n      /**\n       * @brief CC1DE field\n       *\n       * Capture/Compare\
    \ 1 DMA request\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc1de;\n      /**\n       * @brief UDE field\n       *\n       * Update\
    \ DMA request enable\n       */\n      BitFieldModel<uint32_t, 8, 1> ude;\n  \
    \    /**\n       * @brief BIE field\n       *\n       * Break interrupt enable\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> bie;\n      /**\n       * @brief\
    \ TIE field\n       *\n       * Trigger interrupt enable\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> tie;\n      /**\n       * @brief COMIE field\n       *\n       * COM interrupt\
    \ enable\n       */\n      BitFieldModel<uint32_t, 5, 1> comie;\n      /**\n \
    \      * @brief CC4IE field\n       *\n       * Capture/Compare 4 interrupt\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 4, 1>\
    \ cc4ie;\n      /**\n       * @brief CC3IE field\n       *\n       * Capture/Compare\
    \ 3 interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3ie;\n      /**\n       * @brief CC2IE field\n       *\n       * Capture/Compare\
    \ 2 interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cc2ie;\n      /**\n       * @brief CC1IE field\n       *\n       * Capture/Compare\
    \ 1 interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1ie;\n      /**\n       * @brief UIE field\n       *\n       * Update\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 0, 1> uie;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief DIER register\n   *\n   * DMA/Interrupt enable\
    \ register\n   */\n  using dier = DierReg<BaseAddress + 0x000C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CC4OF field\n     *\n     *\
    \ Capture/Compare 4 overcapture\n     *               flag\n     */\n    using\
    \ cc4of = FieldModel<uint32_t, address, 12, 1>;\n    /**\n     * @brief CC3OF\
    \ field\n     *\n     * Capture/Compare 3 overcapture\n     *               flag\n\
    \     */\n    using cc3of = FieldModel<uint32_t, address, 11, 1>;\n    /**\n \
    \    * @brief CC2OF field\n     *\n     * Capture/compare 2 overcapture\n    \
    \ *               flag\n     */\n    using cc2of = FieldModel<uint32_t, address,\
    \ 10, 1>;\n    /**\n     * @brief CC1OF field\n     *\n     * Capture/Compare\
    \ 1 overcapture\n     *               flag\n     */\n    using cc1of = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief BIF field\n     *\n     * Break interrupt\
    \ flag\n     */\n    using bif = FieldModel<uint32_t, address, 7, 1>;\n    /**\n\
    \     * @brief TIF field\n     *\n     * Trigger interrupt flag\n     */\n   \
    \ using tif = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief COMIF\
    \ field\n     *\n     * COM interrupt flag\n     */\n    using comif = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief CC4IF field\n     *\n     * Capture/Compare\
    \ 4 interrupt\n     *               flag\n     */\n    using cc4if = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief CC3IF field\n     *\n     * Capture/Compare\
    \ 3 interrupt\n     *               flag\n     */\n    using cc3if = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief CC2IF field\n     *\n     * Capture/Compare\
    \ 2 interrupt\n     *               flag\n     */\n    using cc2if = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1IF field\n     *\n     * Capture/compare\
    \ 1 interrupt\n     *               flag\n     */\n    using cc1if = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UIF field\n     *\n     * Update interrupt\
    \ flag\n     */\n    using uif = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CC4OF field\n       *\n       * Capture/Compare 4 overcapture\n\
    \       *               flag\n       */\n      BitFieldModel<uint32_t, 12, 1>\
    \ cc4of;\n      /**\n       * @brief CC3OF field\n       *\n       * Capture/Compare\
    \ 3 overcapture\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> cc3of;\n      /**\n       * @brief CC2OF field\n       *\n       * Capture/compare\
    \ 2 overcapture\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> cc2of;\n      /**\n       * @brief CC1OF field\n       *\n       * Capture/Compare\
    \ 1 overcapture\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc1of;\n      /**\n       * @brief BIF field\n       *\n       * Break\
    \ interrupt flag\n       */\n      BitFieldModel<uint32_t, 7, 1> bif;\n      /**\n\
    \       * @brief TIF field\n       *\n       * Trigger interrupt flag\n      \
    \ */\n      BitFieldModel<uint32_t, 6, 1> tif;\n      /**\n       * @brief COMIF\
    \ field\n       *\n       * COM interrupt flag\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> comif;\n      /**\n       * @brief CC4IF field\n       *\n       * Capture/Compare\
    \ 4 interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> cc4if;\n      /**\n       * @brief CC3IF field\n       *\n       * Capture/Compare\
    \ 3 interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3if;\n      /**\n       * @brief CC2IF field\n       *\n       * Capture/Compare\
    \ 2 interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cc2if;\n      /**\n       * @brief CC1IF field\n       *\n       * Capture/compare\
    \ 1 interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1if;\n      /**\n       * @brief UIF field\n       *\n       * Update\
    \ interrupt flag\n       */\n      BitFieldModel<uint32_t, 0, 1> uif;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief SR register\n   *\n   * status register\n\
    \   */\n  using sr = SrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class EgrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief BG field\n     *\n     * Break generation\n\
    \     */\n    using bg = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     *\
    \ @brief TG field\n     *\n     * Trigger generation\n     */\n    using tg =\
    \ FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief COMG field\n  \
    \   *\n     * Capture/Compare control update\n     *               generation\n\
    \     */\n    using comg = FieldModel<uint32_t, address, 5, 1>;\n    /**\n   \
    \  * @brief CC4G field\n     *\n     * Capture/compare 4\n     *             \
    \  generation\n     */\n    using cc4g = FieldModel<uint32_t, address, 4, 1>;\n\
    \    /**\n     * @brief CC3G field\n     *\n     * Capture/compare 3\n     * \
    \              generation\n     */\n    using cc3g = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief CC2G field\n     *\n     * Capture/compare 2\n\
    \     *               generation\n     */\n    using cc2g = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1G field\n     *\n     * Capture/compare\
    \ 1\n     *               generation\n     */\n    using cc1g = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UG field\n     *\n     * Update generation\n\
    \     */\n    using ug = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n \
    \   /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BG field\n       *\n       * Break generation\n       */\n  \
    \    BitFieldModel<uint32_t, 7, 1> bg;\n      /**\n       * @brief TG field\n\
    \       *\n       * Trigger generation\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> tg;\n      /**\n       * @brief COMG field\n       *\n       * Capture/Compare\
    \ control update\n       *               generation\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> comg;\n      /**\n       * @brief CC4G field\n       *\n       * Capture/compare\
    \ 4\n       *               generation\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> cc4g;\n      /**\n       * @brief CC3G field\n       *\n       * Capture/compare\
    \ 3\n       *               generation\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3g;\n      /**\n       * @brief CC2G field\n       *\n       * Capture/compare\
    \ 2\n       *               generation\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cc2g;\n      /**\n       * @brief CC1G field\n       *\n       * Capture/compare\
    \ 1\n       *               generation\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1g;\n      /**\n       * @brief UG field\n       *\n       * Update\
    \ generation\n       */\n      BitFieldModel<uint32_t, 0, 1> ug;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief EGR register\n   *\n   * event generation register\n\
    \   */\n  using egr = EgrReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr1_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief OC2CE field\n     *\n     * Output Compare\
    \ 2 clear\n     *               enable\n     */\n    using oc2ce = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief OC2M field\n     *\n     * Output Compare\
    \ 2 mode\n     */\n    using oc2m = FieldModel<uint32_t, address, 12, 3>;\n  \
    \  /**\n     * @brief OC2PE field\n     *\n     * Output Compare 2 preload\n \
    \    *               enable\n     */\n    using oc2pe = FieldModel<uint32_t, address,\
    \ 11, 1>;\n    /**\n     * @brief OC2FE field\n     *\n     * Output Compare 2\
    \ fast\n     *               enable\n     */\n    using oc2fe = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief CC2S field\n     *\n     * Capture/Compare\
    \ 2\n     *               selection\n     */\n    using cc2s = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief OC1CE field\n     *\n     * Output Compare\
    \ 1 clear\n     *               enable\n     */\n    using oc1ce = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief OC1M field\n     *\n     * Output Compare\
    \ 1 mode\n     */\n    using oc1m = FieldModel<uint32_t, address, 4, 3>;\n   \
    \ /**\n     * @brief OC1PE field\n     *\n     * Output Compare 1 preload\n  \
    \   *               enable\n     */\n    using oc1pe = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief OC1FE field\n     *\n     * Output Compare 1\
    \ fast\n     *               enable\n     */\n    using oc1fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1S field\n     *\n     * Capture/Compare\
    \ 1\n     *               selection\n     */\n    using cc1s = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OC2CE field\n       *\n\
    \       * Output Compare 2 clear\n       *               enable\n       */\n \
    \     BitFieldModel<uint32_t, 15, 1> oc2ce;\n      /**\n       * @brief OC2M field\n\
    \       *\n       * Output Compare 2 mode\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 3> oc2m;\n      /**\n       * @brief OC2PE field\n       *\n       * Output\
    \ Compare 2 preload\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> oc2pe;\n      /**\n       * @brief OC2FE field\n       *\n       * Output\
    \ Compare 2 fast\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> oc2fe;\n      /**\n       * @brief CC2S field\n       *\n       * Capture/Compare\
    \ 2\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc2s;\n      /**\n       * @brief OC1CE field\n       *\n       * Output\
    \ Compare 1 clear\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> oc1ce;\n      /**\n       * @brief OC1M field\n       *\n       * Output\
    \ Compare 1 mode\n       */\n      BitFieldModel<uint32_t, 4, 3> oc1m;\n     \
    \ /**\n       * @brief OC1PE field\n       *\n       * Output Compare 1 preload\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 3, 1>\
    \ oc1pe;\n      /**\n       * @brief OC1FE field\n       *\n       * Output Compare\
    \ 1 fast\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc1fe;\n      /**\n       * @brief CC1S field\n       *\n       * Capture/Compare\
    \ 1\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc1s;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCMR1_OUTPUT register\n\
    \   *\n   * capture/compare mode register 1 (output\n   *           mode)\n  \
    \ */\n  using ccmr1_output = Ccmr1_outputReg<BaseAddress + 0x0018>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Ccmr1_inputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief IC2F field\n     *\n     *\
    \ Input capture 2 filter\n     */\n    using ic2f = FieldModel<uint32_t, address,\
    \ 12, 4>;\n    /**\n     * @brief IC2PCS field\n     *\n     * Input capture 2\
    \ prescaler\n     */\n    using ic2pcs = FieldModel<uint32_t, address, 10, 2>;\n\
    \    /**\n     * @brief CC2S field\n     *\n     * Capture/Compare 2\n     * \
    \              selection\n     */\n    using cc2s = FieldModel<uint32_t, address,\
    \ 8, 2>;\n    /**\n     * @brief IC1F field\n     *\n     * Input capture 1 filter\n\
    \     */\n    using ic1f = FieldModel<uint32_t, address, 4, 4>;\n    /**\n   \
    \  * @brief ICPCS field\n     *\n     * Input capture 1 prescaler\n     */\n \
    \   using icpcs = FieldModel<uint32_t, address, 2, 2>;\n    /**\n     * @brief\
    \ CC1S field\n     *\n     * Capture/Compare 1\n     *               selection\n\
    \     */\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief IC2F field\n       *\n       * Input capture 2 filter\n     \
    \  */\n      BitFieldModel<uint32_t, 12, 4> ic2f;\n      /**\n       * @brief\
    \ IC2PCS field\n       *\n       * Input capture 2 prescaler\n       */\n    \
    \  BitFieldModel<uint32_t, 10, 2> ic2pcs;\n      /**\n       * @brief CC2S field\n\
    \       *\n       * Capture/Compare 2\n       *               selection\n    \
    \   */\n      BitFieldModel<uint32_t, 8, 2> cc2s;\n      /**\n       * @brief\
    \ IC1F field\n       *\n       * Input capture 1 filter\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 4> ic1f;\n      /**\n       * @brief ICPCS field\n       *\n       * Input\
    \ capture 1 prescaler\n       */\n      BitFieldModel<uint32_t, 2, 2> icpcs;\n\
    \      /**\n       * @brief CC1S field\n       *\n       * Capture/Compare 1\n\
    \       *               selection\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 2> cc1s;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCMR1_INPUT register\n\
    \   *\n   * capture/compare mode register 1 (input\n   *           mode)\n   */\n\
    \  using ccmr1_input = Ccmr1_inputReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr2_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief OC4CE field\n     *\n     * Output compare\
    \ 4 clear\n     *               enable\n     */\n    using oc4ce = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief OC4M field\n     *\n     * Output compare\
    \ 4 mode\n     */\n    using oc4m = FieldModel<uint32_t, address, 12, 3>;\n  \
    \  /**\n     * @brief OC4PE field\n     *\n     * Output compare 4 preload\n \
    \    *               enable\n     */\n    using oc4pe = FieldModel<uint32_t, address,\
    \ 11, 1>;\n    /**\n     * @brief OC4FE field\n     *\n     * Output compare 4\
    \ fast\n     *               enable\n     */\n    using oc4fe = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief CC4S field\n     *\n     * Capture/Compare\
    \ 4\n     *               selection\n     */\n    using cc4s = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief OC3CE field\n     *\n     * Output compare\
    \ 3 clear\n     *               enable\n     */\n    using oc3ce = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief OC3M field\n     *\n     * Output compare\
    \ 3 mode\n     */\n    using oc3m = FieldModel<uint32_t, address, 4, 3>;\n   \
    \ /**\n     * @brief OC3PE field\n     *\n     * Output compare 3 preload\n  \
    \   *               enable\n     */\n    using oc3pe = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief OC3FE field\n     *\n     * Output compare 3\
    \ fast\n     *               enable\n     */\n    using oc3fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC3S field\n     *\n     * Capture/Compare\
    \ 3\n     *               selection\n     */\n    using cc3s = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OC4CE field\n       *\n\
    \       * Output compare 4 clear\n       *               enable\n       */\n \
    \     BitFieldModel<uint32_t, 15, 1> oc4ce;\n      /**\n       * @brief OC4M field\n\
    \       *\n       * Output compare 4 mode\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 3> oc4m;\n      /**\n       * @brief OC4PE field\n       *\n       * Output\
    \ compare 4 preload\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> oc4pe;\n      /**\n       * @brief OC4FE field\n       *\n       * Output\
    \ compare 4 fast\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> oc4fe;\n      /**\n       * @brief CC4S field\n       *\n       * Capture/Compare\
    \ 4\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc4s;\n      /**\n       * @brief OC3CE field\n       *\n       * Output\
    \ compare 3 clear\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> oc3ce;\n      /**\n       * @brief OC3M field\n       *\n       * Output\
    \ compare 3 mode\n       */\n      BitFieldModel<uint32_t, 4, 3> oc3m;\n     \
    \ /**\n       * @brief OC3PE field\n       *\n       * Output compare 3 preload\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 3, 1>\
    \ oc3pe;\n      /**\n       * @brief OC3FE field\n       *\n       * Output compare\
    \ 3 fast\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc3fe;\n      /**\n       * @brief CC3S field\n       *\n       * Capture/Compare\
    \ 3\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc3s;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCMR2_OUTPUT register\n\
    \   *\n   * capture/compare mode register 2 (output\n   *           mode)\n  \
    \ */\n  using ccmr2_output = Ccmr2_outputReg<BaseAddress + 0x001C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Ccmr2_inputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief IC4F field\n     *\n     *\
    \ Input capture 4 filter\n     */\n    using ic4f = FieldModel<uint32_t, address,\
    \ 12, 4>;\n    /**\n     * @brief IC4PSC field\n     *\n     * Input capture 4\
    \ prescaler\n     */\n    using ic4psc = FieldModel<uint32_t, address, 10, 2>;\n\
    \    /**\n     * @brief CC4S field\n     *\n     * Capture/Compare 4\n     * \
    \              selection\n     */\n    using cc4s = FieldModel<uint32_t, address,\
    \ 8, 2>;\n    /**\n     * @brief IC3F field\n     *\n     * Input capture 3 filter\n\
    \     */\n    using ic3f = FieldModel<uint32_t, address, 4, 4>;\n    /**\n   \
    \  * @brief IC3PSC field\n     *\n     * Input capture 3 prescaler\n     */\n\
    \    using ic3psc = FieldModel<uint32_t, address, 2, 2>;\n    /**\n     * @brief\
    \ CC3S field\n     *\n     * Capture/compare 3\n     *               selection\n\
    \     */\n    using cc3s = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief IC4F field\n       *\n       * Input capture 4 filter\n     \
    \  */\n      BitFieldModel<uint32_t, 12, 4> ic4f;\n      /**\n       * @brief\
    \ IC4PSC field\n       *\n       * Input capture 4 prescaler\n       */\n    \
    \  BitFieldModel<uint32_t, 10, 2> ic4psc;\n      /**\n       * @brief CC4S field\n\
    \       *\n       * Capture/Compare 4\n       *               selection\n    \
    \   */\n      BitFieldModel<uint32_t, 8, 2> cc4s;\n      /**\n       * @brief\
    \ IC3F field\n       *\n       * Input capture 3 filter\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 4> ic3f;\n      /**\n       * @brief IC3PSC field\n       *\n       * Input\
    \ capture 3 prescaler\n       */\n      BitFieldModel<uint32_t, 2, 2> ic3psc;\n\
    \      /**\n       * @brief CC3S field\n       *\n       * Capture/compare 3\n\
    \       *               selection\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 2> cc3s;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCMR2_INPUT register\n\
    \   *\n   * capture/compare mode register 2 (input\n   *           mode)\n   */\n\
    \  using ccmr2_input = Ccmr2_inputReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CcerReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief CC4P field\n     *\n     * Capture/Compare\
    \ 3 output\n     *               Polarity\n     */\n    using cc4p = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief CC4E field\n     *\n     * Capture/Compare\
    \ 4 output\n     *               enable\n     */\n    using cc4e = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief CC3NP field\n     *\n     * Capture/Compare\
    \ 3 output\n     *               Polarity\n     */\n    using cc3np = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief CC3NE field\n     *\n     * Capture/Compare\
    \ 3 complementary output\n     *               enable\n     */\n    using cc3ne\
    \ = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief CC3P field\n\
    \     *\n     * Capture/Compare 3 output\n     *               Polarity\n    \
    \ */\n    using cc3p = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief\
    \ CC3E field\n     *\n     * Capture/Compare 3 output\n     *               enable\n\
    \     */\n    using cc3e = FieldModel<uint32_t, address, 8, 1>;\n    /**\n   \
    \  * @brief CC2NP field\n     *\n     * Capture/Compare 2 output\n     *     \
    \          Polarity\n     */\n    using cc2np = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    /**\n     * @brief CC2NE field\n     *\n     * Capture/Compare 2\
    \ complementary output\n     *               enable\n     */\n    using cc2ne\
    \ = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief CC2P field\n\
    \     *\n     * Capture/Compare 2 output\n     *               Polarity\n    \
    \ */\n    using cc2p = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief\
    \ CC2E field\n     *\n     * Capture/Compare 2 output\n     *               enable\n\
    \     */\n    using cc2e = FieldModel<uint32_t, address, 4, 1>;\n    /**\n   \
    \  * @brief CC1NP field\n     *\n     * Capture/Compare 1 output\n     *     \
    \          Polarity\n     */\n    using cc1np = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief CC1NE field\n     *\n     * Capture/Compare 1\
    \ complementary output\n     *               enable\n     */\n    using cc1ne\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief CC1P field\n\
    \     *\n     * Capture/Compare 1 output\n     *               Polarity\n    \
    \ */\n    using cc1p = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief\
    \ CC1E field\n     *\n     * Capture/Compare 1 output\n     *               enable\n\
    \     */\n    using cc1e = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CC4P field\n       *\n       * Capture/Compare 3 output\n   \
    \    *               Polarity\n       */\n      BitFieldModel<uint32_t, 13, 1>\
    \ cc4p;\n      /**\n       * @brief CC4E field\n       *\n       * Capture/Compare\
    \ 4 output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> cc4e;\n      /**\n       * @brief CC3NP field\n       *\n       * Capture/Compare\
    \ 3 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> cc3np;\n      /**\n       * @brief CC3NE field\n       *\n       * Capture/Compare\
    \ 3 complementary output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> cc3ne;\n      /**\n       * @brief CC3P field\n       *\n       * Capture/Compare\
    \ 3 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc3p;\n      /**\n       * @brief CC3E field\n       *\n       * Capture/Compare\
    \ 3 output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> cc3e;\n      /**\n       * @brief CC2NP field\n       *\n       * Capture/Compare\
    \ 2 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> cc2np;\n      /**\n       * @brief CC2NE field\n       *\n       * Capture/Compare\
    \ 2 complementary output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> cc2ne;\n      /**\n       * @brief CC2P field\n       *\n       * Capture/Compare\
    \ 2 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> cc2p;\n      /**\n       * @brief CC2E field\n       *\n       * Capture/Compare\
    \ 2 output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> cc2e;\n      /**\n       * @brief CC1NP field\n       *\n       * Capture/Compare\
    \ 1 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc1np;\n      /**\n       * @brief CC1NE field\n       *\n       * Capture/Compare\
    \ 1 complementary output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cc1ne;\n      /**\n       * @brief CC1P field\n       *\n       * Capture/Compare\
    \ 1 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1p;\n      /**\n       * @brief CC1E field\n       *\n       * Capture/Compare\
    \ 1 output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> cc1e;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCER register\n   *\n\
    \   * capture/compare enable\n   *           register\n   */\n  using ccer = CcerReg<BaseAddress\
    \ + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n  class CntReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CNT\
    \ field\n     *\n     * counter value\n     */\n    using cnt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CNT field\n       *\n \
    \      * counter value\n       */\n      BitFieldModel<uint32_t, 0, 16> cnt;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief CNT register\n   *\n   * counter\n\
    \   */\n  using cnt = CntReg<BaseAddress + 0x0024>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class PscReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief PSC field\n     *\n     * Prescaler value\n\
    \     */\n    using psc = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief PSC field\n       *\n       * Prescaler value\n       */\n  \
    \    BitFieldModel<uint32_t, 0, 16> psc;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief PSC register\n   *\n   * prescaler\n   */\n  using psc = PscReg<BaseAddress\
    \ + 0x0028>;\n\nprivate:\n  template<unsigned int address>\n  class ArrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief ARR\
    \ field\n     *\n     * Auto-reload value\n     */\n    using arr = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief ARR field\n       *\n \
    \      * Auto-reload value\n       */\n      BitFieldModel<uint32_t, 0, 16> arr;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief ARR register\n   *\n   * auto-reload\
    \ register\n   */\n  using arr = ArrReg<BaseAddress + 0x002C>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Ccr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CCR1 field\n     *\n     *\
    \ Capture/Compare 1 value\n     */\n    using ccr1 = FieldModel<uint32_t, address,\
    \ 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CCR1 field\n       *\n\
    \       * Capture/Compare 1 value\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 16> ccr1;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCR1 register\n   *\n\
    \   * capture/compare register 1\n   */\n  using ccr1 = Ccr1Reg<BaseAddress +\
    \ 0x0034>;\n\nprivate:\n  template<unsigned int address>\n  class Ccr2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CCR2\
    \ field\n     *\n     * Capture/Compare 2 value\n     */\n    using ccr2 = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CCR2 field\n       *\n\
    \       * Capture/Compare 2 value\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 16> ccr2;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCR2 register\n   *\n\
    \   * capture/compare register 2\n   */\n  using ccr2 = Ccr2Reg<BaseAddress +\
    \ 0x0038>;\n\nprivate:\n  template<unsigned int address>\n  class Ccr3Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CCR3\
    \ field\n     *\n     * Capture/Compare value\n     */\n    using ccr3 = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CCR3 field\n       *\n\
    \       * Capture/Compare value\n       */\n      BitFieldModel<uint32_t, 0, 16>\
    \ ccr3;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCR3 register\n   *\n   *\
    \ capture/compare register 3\n   */\n  using ccr3 = Ccr3Reg<BaseAddress + 0x003C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Ccr4Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CCR4 field\n     *\n     *\
    \ Capture/Compare value\n     */\n    using ccr4 = FieldModel<uint32_t, address,\
    \ 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CCR4 field\n       *\n\
    \       * Capture/Compare value\n       */\n      BitFieldModel<uint32_t, 0, 16>\
    \ ccr4;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCR4 register\n   *\n   *\
    \ capture/compare register 4\n   */\n  using ccr4 = Ccr4Reg<BaseAddress + 0x0040>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief DBL field\n     *\n     * DMA\
    \ burst length\n     */\n    using dbl = FieldModel<uint32_t, address, 8, 5>;\n\
    \    /**\n     * @brief DBA field\n     *\n     * DMA base address\n     */\n\
    \    using dba = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ DBL field\n       *\n       * DMA burst length\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 5> dbl;\n      /**\n       * @brief DBA field\n       *\n       * DMA base\
    \ address\n       */\n      BitFieldModel<uint32_t, 0, 5> dba;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief DCR register\n   *\n   * DMA control register\n\
    \   */\n  using dcr = DcrReg<BaseAddress + 0x0048>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DmarReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief DMAB field\n     *\n     * DMA register for\
    \ burst\n     *               accesses\n     */\n    using dmab = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief DMAB field\n       *\n\
    \       * DMA register for burst\n       *               accesses\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> dmab;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief DMAR register\n   *\n   * DMA address for full transfer\n   */\n\
    \  using dmar = DmarReg<BaseAddress + 0x004C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class RcrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief REP field\n     *\n     * Repetition counter\
    \ value\n     */\n    using rep = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief REP field\n       *\n       * Repetition counter value\n    \
    \   */\n      BitFieldModel<uint32_t, 0, 8> rep;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief RCR register\n   *\n   * repetition counter register\n   */\n  using\
    \ rcr = RcrReg<BaseAddress + 0x0030>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class BdtrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief MOE field\n     *\n     * Main output enable\n     */\n\
    \    using moe = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief\
    \ AOE field\n     *\n     * Automatic output enable\n     */\n    using aoe =\
    \ FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief BKP field\n  \
    \   *\n     * Break polarity\n     */\n    using bkp = FieldModel<uint32_t, address,\
    \ 13, 1>;\n    /**\n     * @brief BKE field\n     *\n     * Break enable\n   \
    \  */\n    using bke = FieldModel<uint32_t, address, 12, 1>;\n    /**\n     *\
    \ @brief OSSR field\n     *\n     * Off-state selection for Run\n     *      \
    \         mode\n     */\n    using ossr = FieldModel<uint32_t, address, 11, 1>;\n\
    \    /**\n     * @brief OSSI field\n     *\n     * Off-state selection for Idle\n\
    \     *               mode\n     */\n    using ossi = FieldModel<uint32_t, address,\
    \ 10, 1>;\n    /**\n     * @brief LOCK field\n     *\n     * Lock configuration\n\
    \     */\n    using lock = FieldModel<uint32_t, address, 8, 2>;\n    /**\n   \
    \  * @brief DTG field\n     *\n     * Dead-time generator setup\n     */\n   \
    \ using dtg = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n    /**\n   \
    \  * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ MOE field\n       *\n       * Main output enable\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> moe;\n      /**\n       * @brief AOE field\n       *\n       * Automatic\
    \ output enable\n       */\n      BitFieldModel<uint32_t, 14, 1> aoe;\n      /**\n\
    \       * @brief BKP field\n       *\n       * Break polarity\n       */\n   \
    \   BitFieldModel<uint32_t, 13, 1> bkp;\n      /**\n       * @brief BKE field\n\
    \       *\n       * Break enable\n       */\n      BitFieldModel<uint32_t, 12,\
    \ 1> bke;\n      /**\n       * @brief OSSR field\n       *\n       * Off-state\
    \ selection for Run\n       *               mode\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> ossr;\n      /**\n       * @brief OSSI field\n       *\n       * Off-state\
    \ selection for Idle\n       *               mode\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> ossi;\n      /**\n       * @brief LOCK field\n       *\n       * Lock\
    \ configuration\n       */\n      BitFieldModel<uint32_t, 8, 2> lock;\n      /**\n\
    \       * @brief DTG field\n       *\n       * Dead-time generator setup\n   \
    \    */\n      BitFieldModel<uint32_t, 0, 8> dtg;\n    };\n  };\n\npublic:\n \
    \ /**\n   * @brief BDTR register\n   *\n   * break and dead-time register\n  \
    \ */\n  using bdtr = BdtrReg<BaseAddress + 0x0044>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_TIM1_H\
    \ */"
  name: TIM1
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_TIM8_H\n#define DRAL_STM32F411_TIM8_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ TIM8 peripheral\n *\n * Advanced-timers\n */\nclass tim8\n{\npublic:\n  static\
    \ constexpr unsigned int BaseAddress = 0x40010400; /**< Peripheral base address\
    \ */\n\nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CKD field\n     *\n     * Clock\
    \ division\n     */\n    using ckd = FieldModel<uint32_t, address, 8, 2>;\n  \
    \  /**\n     * @brief ARPE field\n     *\n     * Auto-reload preload enable\n\
    \     */\n    using arpe = FieldModel<uint32_t, address, 7, 1>;\n    /**\n   \
    \  * @brief CMS field\n     *\n     * Center-aligned mode\n     *            \
    \   selection\n     */\n    using cms = FieldModel<uint32_t, address, 5, 2>;\n\
    \    /**\n     * @brief DIR field\n     *\n     * Direction\n     */\n    using\
    \ dir = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief OPM field\n\
    \     *\n     * One-pulse mode\n     */\n    using opm = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief URS field\n     *\n     * Update request\
    \ source\n     */\n    using urs = FieldModel<uint32_t, address, 2, 1>;\n    /**\n\
    \     * @brief UDIS field\n     *\n     * Update disable\n     */\n    using udis\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief CEN field\n \
    \    *\n     * Counter enable\n     */\n    using cen = FieldModel<uint32_t, address,\
    \ 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief CKD field\n       *\n     \
    \  * Clock division\n       */\n      BitFieldModel<uint32_t, 8, 2> ckd;\n   \
    \   /**\n       * @brief ARPE field\n       *\n       * Auto-reload preload enable\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> arpe;\n      /**\n       * @brief\
    \ CMS field\n       *\n       * Center-aligned mode\n       *               selection\n\
    \       */\n      BitFieldModel<uint32_t, 5, 2> cms;\n      /**\n       * @brief\
    \ DIR field\n       *\n       * Direction\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> dir;\n      /**\n       * @brief OPM field\n       *\n       * One-pulse\
    \ mode\n       */\n      BitFieldModel<uint32_t, 3, 1> opm;\n      /**\n     \
    \  * @brief URS field\n       *\n       * Update request source\n       */\n \
    \     BitFieldModel<uint32_t, 2, 1> urs;\n      /**\n       * @brief UDIS field\n\
    \       *\n       * Update disable\n       */\n      BitFieldModel<uint32_t, 1,\
    \ 1> udis;\n      /**\n       * @brief CEN field\n       *\n       * Counter enable\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> cen;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR1 register\n   *\n   * control register 1\n   */\n  using\
    \ cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief OIS4 field\n     *\n     * Output Idle state 4\n     */\n\
    \    using ois4 = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief\
    \ OIS3N field\n     *\n     * Output Idle state 3\n     */\n    using ois3n =\
    \ FieldModel<uint32_t, address, 13, 1>;\n    /**\n     * @brief OIS3 field\n \
    \    *\n     * Output Idle state 3\n     */\n    using ois3 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief OIS2N field\n     *\n     * Output\
    \ Idle state 2\n     */\n    using ois2n = FieldModel<uint32_t, address, 11, 1>;\n\
    \    /**\n     * @brief OIS2 field\n     *\n     * Output Idle state 2\n     */\n\
    \    using ois2 = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief\
    \ OIS1N field\n     *\n     * Output Idle state 1\n     */\n    using ois1n =\
    \ FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief OIS1 field\n  \
    \   *\n     * Output Idle state 1\n     */\n    using ois1 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief TI1S field\n     *\n     * TI1 selection\n\
    \     */\n    using ti1s = FieldModel<uint32_t, address, 7, 1>;\n    /**\n   \
    \  * @brief MMS field\n     *\n     * Master mode selection\n     */\n    using\
    \ mms = FieldModel<uint32_t, address, 4, 3>;\n    /**\n     * @brief CCDS field\n\
    \     *\n     * Capture/compare DMA\n     *               selection\n     */\n\
    \    using ccds = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief\
    \ CCUS field\n     *\n     * Capture/compare control update\n     *          \
    \     selection\n     */\n    using ccus = FieldModel<uint32_t, address, 2, 1>;\n\
    \    /**\n     * @brief CCPC field\n     *\n     * Capture/compare preloaded\n\
    \     *               control\n     */\n    using ccpc = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OIS4 field\n       *\n\
    \       * Output Idle state 4\n       */\n      BitFieldModel<uint32_t, 14, 1>\
    \ ois4;\n      /**\n       * @brief OIS3N field\n       *\n       * Output Idle\
    \ state 3\n       */\n      BitFieldModel<uint32_t, 13, 1> ois3n;\n      /**\n\
    \       * @brief OIS3 field\n       *\n       * Output Idle state 3\n       */\n\
    \      BitFieldModel<uint32_t, 12, 1> ois3;\n      /**\n       * @brief OIS2N\
    \ field\n       *\n       * Output Idle state 2\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> ois2n;\n      /**\n       * @brief OIS2 field\n       *\n       * Output\
    \ Idle state 2\n       */\n      BitFieldModel<uint32_t, 10, 1> ois2;\n      /**\n\
    \       * @brief OIS1N field\n       *\n       * Output Idle state 1\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> ois1n;\n      /**\n       * @brief OIS1 field\n\
    \       *\n       * Output Idle state 1\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> ois1;\n      /**\n       * @brief TI1S field\n       *\n       * TI1 selection\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> ti1s;\n      /**\n       * @brief\
    \ MMS field\n       *\n       * Master mode selection\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 3> mms;\n      /**\n       * @brief CCDS field\n       *\n       * Capture/compare\
    \ DMA\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> ccds;\n      /**\n       * @brief CCUS field\n       *\n       * Capture/compare\
    \ control update\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> ccus;\n      /**\n       * @brief CCPC field\n       *\n       * Capture/compare\
    \ preloaded\n       *               control\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> ccpc;\n    };\n  };\n\npublic:\n  /**\n   * @brief CR2 register\n   *\n\
    \   * control register 2\n   */\n  using cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class SmcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief ETP field\n     *\n     * External\
    \ trigger polarity\n     */\n    using etp = FieldModel<uint32_t, address, 15,\
    \ 1>;\n    /**\n     * @brief ECE field\n     *\n     * External clock enable\n\
    \     */\n    using ece = FieldModel<uint32_t, address, 14, 1>;\n    /**\n   \
    \  * @brief ETPS field\n     *\n     * External trigger prescaler\n     */\n \
    \   using etps = FieldModel<uint32_t, address, 12, 2>;\n    /**\n     * @brief\
    \ ETF field\n     *\n     * External trigger filter\n     */\n    using etf =\
    \ FieldModel<uint32_t, address, 8, 4>;\n    /**\n     * @brief MSM field\n   \
    \  *\n     * Master/Slave mode\n     */\n    using msm = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief TS field\n     *\n     * Trigger selection\n\
    \     */\n    using ts = FieldModel<uint32_t, address, 4, 3>;\n    /**\n     *\
    \ @brief SMS field\n     *\n     * Slave mode selection\n     */\n    using sms\
    \ = FieldModel<uint32_t, address, 0, 3>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ ETP field\n       *\n       * External trigger polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> etp;\n      /**\n       * @brief ECE field\n       *\n       * External\
    \ clock enable\n       */\n      BitFieldModel<uint32_t, 14, 1> ece;\n      /**\n\
    \       * @brief ETPS field\n       *\n       * External trigger prescaler\n \
    \      */\n      BitFieldModel<uint32_t, 12, 2> etps;\n      /**\n       * @brief\
    \ ETF field\n       *\n       * External trigger filter\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 4> etf;\n      /**\n       * @brief MSM field\n       *\n       * Master/Slave\
    \ mode\n       */\n      BitFieldModel<uint32_t, 7, 1> msm;\n      /**\n     \
    \  * @brief TS field\n       *\n       * Trigger selection\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 3> ts;\n      /**\n       * @brief SMS field\n       *\n       * Slave mode\
    \ selection\n       */\n      BitFieldModel<uint32_t, 0, 3> sms;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief SMCR register\n   *\n   * slave mode control register\n\
    \   */\n  using smcr = SmcrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DierReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief TDE field\n     *\n     * Trigger DMA request\
    \ enable\n     */\n    using tde = FieldModel<uint32_t, address, 14, 1>;\n   \
    \ /**\n     * @brief COMDE field\n     *\n     * COM DMA request enable\n    \
    \ */\n    using comde = FieldModel<uint32_t, address, 13, 1>;\n    /**\n     *\
    \ @brief CC4DE field\n     *\n     * Capture/Compare 4 DMA request\n     *   \
    \            enable\n     */\n    using cc4de = FieldModel<uint32_t, address,\
    \ 12, 1>;\n    /**\n     * @brief CC3DE field\n     *\n     * Capture/Compare\
    \ 3 DMA request\n     *               enable\n     */\n    using cc3de = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief CC2DE field\n     *\n     * Capture/Compare\
    \ 2 DMA request\n     *               enable\n     */\n    using cc2de = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief CC1DE field\n     *\n     * Capture/Compare\
    \ 1 DMA request\n     *               enable\n     */\n    using cc1de = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief UDE field\n     *\n     * Update DMA\
    \ request enable\n     */\n    using ude = FieldModel<uint32_t, address, 8, 1>;\n\
    \    /**\n     * @brief BIE field\n     *\n     * Break interrupt enable\n   \
    \  */\n    using bie = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief\
    \ TIE field\n     *\n     * Trigger interrupt enable\n     */\n    using tie =\
    \ FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief COMIE field\n \
    \    *\n     * COM interrupt enable\n     */\n    using comie = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief CC4IE field\n     *\n     * Capture/Compare\
    \ 4 interrupt\n     *               enable\n     */\n    using cc4ie = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief CC3IE field\n     *\n     * Capture/Compare\
    \ 3 interrupt\n     *               enable\n     */\n    using cc3ie = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief CC2IE field\n     *\n     * Capture/Compare\
    \ 2 interrupt\n     *               enable\n     */\n    using cc2ie = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1IE field\n     *\n     * Capture/Compare\
    \ 1 interrupt\n     *               enable\n     */\n    using cc1ie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UIE field\n     *\n     * Update interrupt\
    \ enable\n     */\n    using uie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief TDE field\n       *\n       * Trigger DMA request enable\n  \
    \     */\n      BitFieldModel<uint32_t, 14, 1> tde;\n      /**\n       * @brief\
    \ COMDE field\n       *\n       * COM DMA request enable\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> comde;\n      /**\n       * @brief CC4DE field\n       *\n       * Capture/Compare\
    \ 4 DMA request\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> cc4de;\n      /**\n       * @brief CC3DE field\n       *\n       * Capture/Compare\
    \ 3 DMA request\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> cc3de;\n      /**\n       * @brief CC2DE field\n       *\n       * Capture/Compare\
    \ 2 DMA request\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> cc2de;\n      /**\n       * @brief CC1DE field\n       *\n       * Capture/Compare\
    \ 1 DMA request\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc1de;\n      /**\n       * @brief UDE field\n       *\n       * Update\
    \ DMA request enable\n       */\n      BitFieldModel<uint32_t, 8, 1> ude;\n  \
    \    /**\n       * @brief BIE field\n       *\n       * Break interrupt enable\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> bie;\n      /**\n       * @brief\
    \ TIE field\n       *\n       * Trigger interrupt enable\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> tie;\n      /**\n       * @brief COMIE field\n       *\n       * COM interrupt\
    \ enable\n       */\n      BitFieldModel<uint32_t, 5, 1> comie;\n      /**\n \
    \      * @brief CC4IE field\n       *\n       * Capture/Compare 4 interrupt\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 4, 1>\
    \ cc4ie;\n      /**\n       * @brief CC3IE field\n       *\n       * Capture/Compare\
    \ 3 interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3ie;\n      /**\n       * @brief CC2IE field\n       *\n       * Capture/Compare\
    \ 2 interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cc2ie;\n      /**\n       * @brief CC1IE field\n       *\n       * Capture/Compare\
    \ 1 interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1ie;\n      /**\n       * @brief UIE field\n       *\n       * Update\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 0, 1> uie;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief DIER register\n   *\n   * DMA/Interrupt enable\
    \ register\n   */\n  using dier = DierReg<BaseAddress + 0x000C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CC4OF field\n     *\n     *\
    \ Capture/Compare 4 overcapture\n     *               flag\n     */\n    using\
    \ cc4of = FieldModel<uint32_t, address, 12, 1>;\n    /**\n     * @brief CC3OF\
    \ field\n     *\n     * Capture/Compare 3 overcapture\n     *               flag\n\
    \     */\n    using cc3of = FieldModel<uint32_t, address, 11, 1>;\n    /**\n \
    \    * @brief CC2OF field\n     *\n     * Capture/compare 2 overcapture\n    \
    \ *               flag\n     */\n    using cc2of = FieldModel<uint32_t, address,\
    \ 10, 1>;\n    /**\n     * @brief CC1OF field\n     *\n     * Capture/Compare\
    \ 1 overcapture\n     *               flag\n     */\n    using cc1of = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief BIF field\n     *\n     * Break interrupt\
    \ flag\n     */\n    using bif = FieldModel<uint32_t, address, 7, 1>;\n    /**\n\
    \     * @brief TIF field\n     *\n     * Trigger interrupt flag\n     */\n   \
    \ using tif = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief COMIF\
    \ field\n     *\n     * COM interrupt flag\n     */\n    using comif = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief CC4IF field\n     *\n     * Capture/Compare\
    \ 4 interrupt\n     *               flag\n     */\n    using cc4if = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief CC3IF field\n     *\n     * Capture/Compare\
    \ 3 interrupt\n     *               flag\n     */\n    using cc3if = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief CC2IF field\n     *\n     * Capture/Compare\
    \ 2 interrupt\n     *               flag\n     */\n    using cc2if = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1IF field\n     *\n     * Capture/compare\
    \ 1 interrupt\n     *               flag\n     */\n    using cc1if = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UIF field\n     *\n     * Update interrupt\
    \ flag\n     */\n    using uif = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CC4OF field\n       *\n       * Capture/Compare 4 overcapture\n\
    \       *               flag\n       */\n      BitFieldModel<uint32_t, 12, 1>\
    \ cc4of;\n      /**\n       * @brief CC3OF field\n       *\n       * Capture/Compare\
    \ 3 overcapture\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> cc3of;\n      /**\n       * @brief CC2OF field\n       *\n       * Capture/compare\
    \ 2 overcapture\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> cc2of;\n      /**\n       * @brief CC1OF field\n       *\n       * Capture/Compare\
    \ 1 overcapture\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc1of;\n      /**\n       * @brief BIF field\n       *\n       * Break\
    \ interrupt flag\n       */\n      BitFieldModel<uint32_t, 7, 1> bif;\n      /**\n\
    \       * @brief TIF field\n       *\n       * Trigger interrupt flag\n      \
    \ */\n      BitFieldModel<uint32_t, 6, 1> tif;\n      /**\n       * @brief COMIF\
    \ field\n       *\n       * COM interrupt flag\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> comif;\n      /**\n       * @brief CC4IF field\n       *\n       * Capture/Compare\
    \ 4 interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> cc4if;\n      /**\n       * @brief CC3IF field\n       *\n       * Capture/Compare\
    \ 3 interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3if;\n      /**\n       * @brief CC2IF field\n       *\n       * Capture/Compare\
    \ 2 interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cc2if;\n      /**\n       * @brief CC1IF field\n       *\n       * Capture/compare\
    \ 1 interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1if;\n      /**\n       * @brief UIF field\n       *\n       * Update\
    \ interrupt flag\n       */\n      BitFieldModel<uint32_t, 0, 1> uif;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief SR register\n   *\n   * status register\n\
    \   */\n  using sr = SrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class EgrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief BG field\n     *\n     * Break generation\n\
    \     */\n    using bg = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     *\
    \ @brief TG field\n     *\n     * Trigger generation\n     */\n    using tg =\
    \ FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief COMG field\n  \
    \   *\n     * Capture/Compare control update\n     *               generation\n\
    \     */\n    using comg = FieldModel<uint32_t, address, 5, 1>;\n    /**\n   \
    \  * @brief CC4G field\n     *\n     * Capture/compare 4\n     *             \
    \  generation\n     */\n    using cc4g = FieldModel<uint32_t, address, 4, 1>;\n\
    \    /**\n     * @brief CC3G field\n     *\n     * Capture/compare 3\n     * \
    \              generation\n     */\n    using cc3g = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief CC2G field\n     *\n     * Capture/compare 2\n\
    \     *               generation\n     */\n    using cc2g = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1G field\n     *\n     * Capture/compare\
    \ 1\n     *               generation\n     */\n    using cc1g = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UG field\n     *\n     * Update generation\n\
    \     */\n    using ug = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n \
    \   /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BG field\n       *\n       * Break generation\n       */\n  \
    \    BitFieldModel<uint32_t, 7, 1> bg;\n      /**\n       * @brief TG field\n\
    \       *\n       * Trigger generation\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> tg;\n      /**\n       * @brief COMG field\n       *\n       * Capture/Compare\
    \ control update\n       *               generation\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> comg;\n      /**\n       * @brief CC4G field\n       *\n       * Capture/compare\
    \ 4\n       *               generation\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> cc4g;\n      /**\n       * @brief CC3G field\n       *\n       * Capture/compare\
    \ 3\n       *               generation\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3g;\n      /**\n       * @brief CC2G field\n       *\n       * Capture/compare\
    \ 2\n       *               generation\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cc2g;\n      /**\n       * @brief CC1G field\n       *\n       * Capture/compare\
    \ 1\n       *               generation\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1g;\n      /**\n       * @brief UG field\n       *\n       * Update\
    \ generation\n       */\n      BitFieldModel<uint32_t, 0, 1> ug;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief EGR register\n   *\n   * event generation register\n\
    \   */\n  using egr = EgrReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr1_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief OC2CE field\n     *\n     * Output Compare\
    \ 2 clear\n     *               enable\n     */\n    using oc2ce = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief OC2M field\n     *\n     * Output Compare\
    \ 2 mode\n     */\n    using oc2m = FieldModel<uint32_t, address, 12, 3>;\n  \
    \  /**\n     * @brief OC2PE field\n     *\n     * Output Compare 2 preload\n \
    \    *               enable\n     */\n    using oc2pe = FieldModel<uint32_t, address,\
    \ 11, 1>;\n    /**\n     * @brief OC2FE field\n     *\n     * Output Compare 2\
    \ fast\n     *               enable\n     */\n    using oc2fe = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief CC2S field\n     *\n     * Capture/Compare\
    \ 2\n     *               selection\n     */\n    using cc2s = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief OC1CE field\n     *\n     * Output Compare\
    \ 1 clear\n     *               enable\n     */\n    using oc1ce = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief OC1M field\n     *\n     * Output Compare\
    \ 1 mode\n     */\n    using oc1m = FieldModel<uint32_t, address, 4, 3>;\n   \
    \ /**\n     * @brief OC1PE field\n     *\n     * Output Compare 1 preload\n  \
    \   *               enable\n     */\n    using oc1pe = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief OC1FE field\n     *\n     * Output Compare 1\
    \ fast\n     *               enable\n     */\n    using oc1fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1S field\n     *\n     * Capture/Compare\
    \ 1\n     *               selection\n     */\n    using cc1s = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OC2CE field\n       *\n\
    \       * Output Compare 2 clear\n       *               enable\n       */\n \
    \     BitFieldModel<uint32_t, 15, 1> oc2ce;\n      /**\n       * @brief OC2M field\n\
    \       *\n       * Output Compare 2 mode\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 3> oc2m;\n      /**\n       * @brief OC2PE field\n       *\n       * Output\
    \ Compare 2 preload\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> oc2pe;\n      /**\n       * @brief OC2FE field\n       *\n       * Output\
    \ Compare 2 fast\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> oc2fe;\n      /**\n       * @brief CC2S field\n       *\n       * Capture/Compare\
    \ 2\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc2s;\n      /**\n       * @brief OC1CE field\n       *\n       * Output\
    \ Compare 1 clear\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> oc1ce;\n      /**\n       * @brief OC1M field\n       *\n       * Output\
    \ Compare 1 mode\n       */\n      BitFieldModel<uint32_t, 4, 3> oc1m;\n     \
    \ /**\n       * @brief OC1PE field\n       *\n       * Output Compare 1 preload\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 3, 1>\
    \ oc1pe;\n      /**\n       * @brief OC1FE field\n       *\n       * Output Compare\
    \ 1 fast\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc1fe;\n      /**\n       * @brief CC1S field\n       *\n       * Capture/Compare\
    \ 1\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc1s;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCMR1_OUTPUT register\n\
    \   *\n   * capture/compare mode register 1 (output\n   *           mode)\n  \
    \ */\n  using ccmr1_output = Ccmr1_outputReg<BaseAddress + 0x0018>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Ccmr1_inputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief IC2F field\n     *\n     *\
    \ Input capture 2 filter\n     */\n    using ic2f = FieldModel<uint32_t, address,\
    \ 12, 4>;\n    /**\n     * @brief IC2PCS field\n     *\n     * Input capture 2\
    \ prescaler\n     */\n    using ic2pcs = FieldModel<uint32_t, address, 10, 2>;\n\
    \    /**\n     * @brief CC2S field\n     *\n     * Capture/Compare 2\n     * \
    \              selection\n     */\n    using cc2s = FieldModel<uint32_t, address,\
    \ 8, 2>;\n    /**\n     * @brief IC1F field\n     *\n     * Input capture 1 filter\n\
    \     */\n    using ic1f = FieldModel<uint32_t, address, 4, 4>;\n    /**\n   \
    \  * @brief ICPCS field\n     *\n     * Input capture 1 prescaler\n     */\n \
    \   using icpcs = FieldModel<uint32_t, address, 2, 2>;\n    /**\n     * @brief\
    \ CC1S field\n     *\n     * Capture/Compare 1\n     *               selection\n\
    \     */\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief IC2F field\n       *\n       * Input capture 2 filter\n     \
    \  */\n      BitFieldModel<uint32_t, 12, 4> ic2f;\n      /**\n       * @brief\
    \ IC2PCS field\n       *\n       * Input capture 2 prescaler\n       */\n    \
    \  BitFieldModel<uint32_t, 10, 2> ic2pcs;\n      /**\n       * @brief CC2S field\n\
    \       *\n       * Capture/Compare 2\n       *               selection\n    \
    \   */\n      BitFieldModel<uint32_t, 8, 2> cc2s;\n      /**\n       * @brief\
    \ IC1F field\n       *\n       * Input capture 1 filter\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 4> ic1f;\n      /**\n       * @brief ICPCS field\n       *\n       * Input\
    \ capture 1 prescaler\n       */\n      BitFieldModel<uint32_t, 2, 2> icpcs;\n\
    \      /**\n       * @brief CC1S field\n       *\n       * Capture/Compare 1\n\
    \       *               selection\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 2> cc1s;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCMR1_INPUT register\n\
    \   *\n   * capture/compare mode register 1 (input\n   *           mode)\n   */\n\
    \  using ccmr1_input = Ccmr1_inputReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr2_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief OC4CE field\n     *\n     * Output compare\
    \ 4 clear\n     *               enable\n     */\n    using oc4ce = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief OC4M field\n     *\n     * Output compare\
    \ 4 mode\n     */\n    using oc4m = FieldModel<uint32_t, address, 12, 3>;\n  \
    \  /**\n     * @brief OC4PE field\n     *\n     * Output compare 4 preload\n \
    \    *               enable\n     */\n    using oc4pe = FieldModel<uint32_t, address,\
    \ 11, 1>;\n    /**\n     * @brief OC4FE field\n     *\n     * Output compare 4\
    \ fast\n     *               enable\n     */\n    using oc4fe = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief CC4S field\n     *\n     * Capture/Compare\
    \ 4\n     *               selection\n     */\n    using cc4s = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief OC3CE field\n     *\n     * Output compare\
    \ 3 clear\n     *               enable\n     */\n    using oc3ce = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief OC3M field\n     *\n     * Output compare\
    \ 3 mode\n     */\n    using oc3m = FieldModel<uint32_t, address, 4, 3>;\n   \
    \ /**\n     * @brief OC3PE field\n     *\n     * Output compare 3 preload\n  \
    \   *               enable\n     */\n    using oc3pe = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief OC3FE field\n     *\n     * Output compare 3\
    \ fast\n     *               enable\n     */\n    using oc3fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC3S field\n     *\n     * Capture/Compare\
    \ 3\n     *               selection\n     */\n    using cc3s = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OC4CE field\n       *\n\
    \       * Output compare 4 clear\n       *               enable\n       */\n \
    \     BitFieldModel<uint32_t, 15, 1> oc4ce;\n      /**\n       * @brief OC4M field\n\
    \       *\n       * Output compare 4 mode\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 3> oc4m;\n      /**\n       * @brief OC4PE field\n       *\n       * Output\
    \ compare 4 preload\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> oc4pe;\n      /**\n       * @brief OC4FE field\n       *\n       * Output\
    \ compare 4 fast\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> oc4fe;\n      /**\n       * @brief CC4S field\n       *\n       * Capture/Compare\
    \ 4\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc4s;\n      /**\n       * @brief OC3CE field\n       *\n       * Output\
    \ compare 3 clear\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> oc3ce;\n      /**\n       * @brief OC3M field\n       *\n       * Output\
    \ compare 3 mode\n       */\n      BitFieldModel<uint32_t, 4, 3> oc3m;\n     \
    \ /**\n       * @brief OC3PE field\n       *\n       * Output compare 3 preload\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 3, 1>\
    \ oc3pe;\n      /**\n       * @brief OC3FE field\n       *\n       * Output compare\
    \ 3 fast\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc3fe;\n      /**\n       * @brief CC3S field\n       *\n       * Capture/Compare\
    \ 3\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc3s;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCMR2_OUTPUT register\n\
    \   *\n   * capture/compare mode register 2 (output\n   *           mode)\n  \
    \ */\n  using ccmr2_output = Ccmr2_outputReg<BaseAddress + 0x001C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Ccmr2_inputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief IC4F field\n     *\n     *\
    \ Input capture 4 filter\n     */\n    using ic4f = FieldModel<uint32_t, address,\
    \ 12, 4>;\n    /**\n     * @brief IC4PSC field\n     *\n     * Input capture 4\
    \ prescaler\n     */\n    using ic4psc = FieldModel<uint32_t, address, 10, 2>;\n\
    \    /**\n     * @brief CC4S field\n     *\n     * Capture/Compare 4\n     * \
    \              selection\n     */\n    using cc4s = FieldModel<uint32_t, address,\
    \ 8, 2>;\n    /**\n     * @brief IC3F field\n     *\n     * Input capture 3 filter\n\
    \     */\n    using ic3f = FieldModel<uint32_t, address, 4, 4>;\n    /**\n   \
    \  * @brief IC3PSC field\n     *\n     * Input capture 3 prescaler\n     */\n\
    \    using ic3psc = FieldModel<uint32_t, address, 2, 2>;\n    /**\n     * @brief\
    \ CC3S field\n     *\n     * Capture/compare 3\n     *               selection\n\
    \     */\n    using cc3s = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief IC4F field\n       *\n       * Input capture 4 filter\n     \
    \  */\n      BitFieldModel<uint32_t, 12, 4> ic4f;\n      /**\n       * @brief\
    \ IC4PSC field\n       *\n       * Input capture 4 prescaler\n       */\n    \
    \  BitFieldModel<uint32_t, 10, 2> ic4psc;\n      /**\n       * @brief CC4S field\n\
    \       *\n       * Capture/Compare 4\n       *               selection\n    \
    \   */\n      BitFieldModel<uint32_t, 8, 2> cc4s;\n      /**\n       * @brief\
    \ IC3F field\n       *\n       * Input capture 3 filter\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 4> ic3f;\n      /**\n       * @brief IC3PSC field\n       *\n       * Input\
    \ capture 3 prescaler\n       */\n      BitFieldModel<uint32_t, 2, 2> ic3psc;\n\
    \      /**\n       * @brief CC3S field\n       *\n       * Capture/compare 3\n\
    \       *               selection\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 2> cc3s;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCMR2_INPUT register\n\
    \   *\n   * capture/compare mode register 2 (input\n   *           mode)\n   */\n\
    \  using ccmr2_input = Ccmr2_inputReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CcerReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief CC4P field\n     *\n     * Capture/Compare\
    \ 3 output\n     *               Polarity\n     */\n    using cc4p = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief CC4E field\n     *\n     * Capture/Compare\
    \ 4 output\n     *               enable\n     */\n    using cc4e = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief CC3NP field\n     *\n     * Capture/Compare\
    \ 3 output\n     *               Polarity\n     */\n    using cc3np = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief CC3NE field\n     *\n     * Capture/Compare\
    \ 3 complementary output\n     *               enable\n     */\n    using cc3ne\
    \ = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief CC3P field\n\
    \     *\n     * Capture/Compare 3 output\n     *               Polarity\n    \
    \ */\n    using cc3p = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief\
    \ CC3E field\n     *\n     * Capture/Compare 3 output\n     *               enable\n\
    \     */\n    using cc3e = FieldModel<uint32_t, address, 8, 1>;\n    /**\n   \
    \  * @brief CC2NP field\n     *\n     * Capture/Compare 2 output\n     *     \
    \          Polarity\n     */\n    using cc2np = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    /**\n     * @brief CC2NE field\n     *\n     * Capture/Compare 2\
    \ complementary output\n     *               enable\n     */\n    using cc2ne\
    \ = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief CC2P field\n\
    \     *\n     * Capture/Compare 2 output\n     *               Polarity\n    \
    \ */\n    using cc2p = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief\
    \ CC2E field\n     *\n     * Capture/Compare 2 output\n     *               enable\n\
    \     */\n    using cc2e = FieldModel<uint32_t, address, 4, 1>;\n    /**\n   \
    \  * @brief CC1NP field\n     *\n     * Capture/Compare 1 output\n     *     \
    \          Polarity\n     */\n    using cc1np = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief CC1NE field\n     *\n     * Capture/Compare 1\
    \ complementary output\n     *               enable\n     */\n    using cc1ne\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief CC1P field\n\
    \     *\n     * Capture/Compare 1 output\n     *               Polarity\n    \
    \ */\n    using cc1p = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief\
    \ CC1E field\n     *\n     * Capture/Compare 1 output\n     *               enable\n\
    \     */\n    using cc1e = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CC4P field\n       *\n       * Capture/Compare 3 output\n   \
    \    *               Polarity\n       */\n      BitFieldModel<uint32_t, 13, 1>\
    \ cc4p;\n      /**\n       * @brief CC4E field\n       *\n       * Capture/Compare\
    \ 4 output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> cc4e;\n      /**\n       * @brief CC3NP field\n       *\n       * Capture/Compare\
    \ 3 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> cc3np;\n      /**\n       * @brief CC3NE field\n       *\n       * Capture/Compare\
    \ 3 complementary output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> cc3ne;\n      /**\n       * @brief CC3P field\n       *\n       * Capture/Compare\
    \ 3 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc3p;\n      /**\n       * @brief CC3E field\n       *\n       * Capture/Compare\
    \ 3 output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> cc3e;\n      /**\n       * @brief CC2NP field\n       *\n       * Capture/Compare\
    \ 2 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> cc2np;\n      /**\n       * @brief CC2NE field\n       *\n       * Capture/Compare\
    \ 2 complementary output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> cc2ne;\n      /**\n       * @brief CC2P field\n       *\n       * Capture/Compare\
    \ 2 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> cc2p;\n      /**\n       * @brief CC2E field\n       *\n       * Capture/Compare\
    \ 2 output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> cc2e;\n      /**\n       * @brief CC1NP field\n       *\n       * Capture/Compare\
    \ 1 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc1np;\n      /**\n       * @brief CC1NE field\n       *\n       * Capture/Compare\
    \ 1 complementary output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cc1ne;\n      /**\n       * @brief CC1P field\n       *\n       * Capture/Compare\
    \ 1 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1p;\n      /**\n       * @brief CC1E field\n       *\n       * Capture/Compare\
    \ 1 output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> cc1e;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCER register\n   *\n\
    \   * capture/compare enable\n   *           register\n   */\n  using ccer = CcerReg<BaseAddress\
    \ + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n  class CntReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CNT\
    \ field\n     *\n     * counter value\n     */\n    using cnt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CNT field\n       *\n \
    \      * counter value\n       */\n      BitFieldModel<uint32_t, 0, 16> cnt;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief CNT register\n   *\n   * counter\n\
    \   */\n  using cnt = CntReg<BaseAddress + 0x0024>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class PscReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief PSC field\n     *\n     * Prescaler value\n\
    \     */\n    using psc = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief PSC field\n       *\n       * Prescaler value\n       */\n  \
    \    BitFieldModel<uint32_t, 0, 16> psc;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief PSC register\n   *\n   * prescaler\n   */\n  using psc = PscReg<BaseAddress\
    \ + 0x0028>;\n\nprivate:\n  template<unsigned int address>\n  class ArrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief ARR\
    \ field\n     *\n     * Auto-reload value\n     */\n    using arr = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief ARR field\n       *\n \
    \      * Auto-reload value\n       */\n      BitFieldModel<uint32_t, 0, 16> arr;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief ARR register\n   *\n   * auto-reload\
    \ register\n   */\n  using arr = ArrReg<BaseAddress + 0x002C>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Ccr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CCR1 field\n     *\n     *\
    \ Capture/Compare 1 value\n     */\n    using ccr1 = FieldModel<uint32_t, address,\
    \ 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CCR1 field\n       *\n\
    \       * Capture/Compare 1 value\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 16> ccr1;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCR1 register\n   *\n\
    \   * capture/compare register 1\n   */\n  using ccr1 = Ccr1Reg<BaseAddress +\
    \ 0x0034>;\n\nprivate:\n  template<unsigned int address>\n  class Ccr2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CCR2\
    \ field\n     *\n     * Capture/Compare 2 value\n     */\n    using ccr2 = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CCR2 field\n       *\n\
    \       * Capture/Compare 2 value\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 16> ccr2;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCR2 register\n   *\n\
    \   * capture/compare register 2\n   */\n  using ccr2 = Ccr2Reg<BaseAddress +\
    \ 0x0038>;\n\nprivate:\n  template<unsigned int address>\n  class Ccr3Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CCR3\
    \ field\n     *\n     * Capture/Compare value\n     */\n    using ccr3 = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CCR3 field\n       *\n\
    \       * Capture/Compare value\n       */\n      BitFieldModel<uint32_t, 0, 16>\
    \ ccr3;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCR3 register\n   *\n   *\
    \ capture/compare register 3\n   */\n  using ccr3 = Ccr3Reg<BaseAddress + 0x003C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Ccr4Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CCR4 field\n     *\n     *\
    \ Capture/Compare value\n     */\n    using ccr4 = FieldModel<uint32_t, address,\
    \ 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CCR4 field\n       *\n\
    \       * Capture/Compare value\n       */\n      BitFieldModel<uint32_t, 0, 16>\
    \ ccr4;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCR4 register\n   *\n   *\
    \ capture/compare register 4\n   */\n  using ccr4 = Ccr4Reg<BaseAddress + 0x0040>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief DBL field\n     *\n     * DMA\
    \ burst length\n     */\n    using dbl = FieldModel<uint32_t, address, 8, 5>;\n\
    \    /**\n     * @brief DBA field\n     *\n     * DMA base address\n     */\n\
    \    using dba = FieldModel<uint32_t, address, 0, 5>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ DBL field\n       *\n       * DMA burst length\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 5> dbl;\n      /**\n       * @brief DBA field\n       *\n       * DMA base\
    \ address\n       */\n      BitFieldModel<uint32_t, 0, 5> dba;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief DCR register\n   *\n   * DMA control register\n\
    \   */\n  using dcr = DcrReg<BaseAddress + 0x0048>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DmarReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief DMAB field\n     *\n     * DMA register for\
    \ burst\n     *               accesses\n     */\n    using dmab = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief DMAB field\n       *\n\
    \       * DMA register for burst\n       *               accesses\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> dmab;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief DMAR register\n   *\n   * DMA address for full transfer\n   */\n\
    \  using dmar = DmarReg<BaseAddress + 0x004C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class RcrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief REP field\n     *\n     * Repetition counter\
    \ value\n     */\n    using rep = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief REP field\n       *\n       * Repetition counter value\n    \
    \   */\n      BitFieldModel<uint32_t, 0, 8> rep;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief RCR register\n   *\n   * repetition counter register\n   */\n  using\
    \ rcr = RcrReg<BaseAddress + 0x0030>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class BdtrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief MOE field\n     *\n     * Main output enable\n     */\n\
    \    using moe = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief\
    \ AOE field\n     *\n     * Automatic output enable\n     */\n    using aoe =\
    \ FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief BKP field\n  \
    \   *\n     * Break polarity\n     */\n    using bkp = FieldModel<uint32_t, address,\
    \ 13, 1>;\n    /**\n     * @brief BKE field\n     *\n     * Break enable\n   \
    \  */\n    using bke = FieldModel<uint32_t, address, 12, 1>;\n    /**\n     *\
    \ @brief OSSR field\n     *\n     * Off-state selection for Run\n     *      \
    \         mode\n     */\n    using ossr = FieldModel<uint32_t, address, 11, 1>;\n\
    \    /**\n     * @brief OSSI field\n     *\n     * Off-state selection for Idle\n\
    \     *               mode\n     */\n    using ossi = FieldModel<uint32_t, address,\
    \ 10, 1>;\n    /**\n     * @brief LOCK field\n     *\n     * Lock configuration\n\
    \     */\n    using lock = FieldModel<uint32_t, address, 8, 2>;\n    /**\n   \
    \  * @brief DTG field\n     *\n     * Dead-time generator setup\n     */\n   \
    \ using dtg = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n    /**\n   \
    \  * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ MOE field\n       *\n       * Main output enable\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> moe;\n      /**\n       * @brief AOE field\n       *\n       * Automatic\
    \ output enable\n       */\n      BitFieldModel<uint32_t, 14, 1> aoe;\n      /**\n\
    \       * @brief BKP field\n       *\n       * Break polarity\n       */\n   \
    \   BitFieldModel<uint32_t, 13, 1> bkp;\n      /**\n       * @brief BKE field\n\
    \       *\n       * Break enable\n       */\n      BitFieldModel<uint32_t, 12,\
    \ 1> bke;\n      /**\n       * @brief OSSR field\n       *\n       * Off-state\
    \ selection for Run\n       *               mode\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> ossr;\n      /**\n       * @brief OSSI field\n       *\n       * Off-state\
    \ selection for Idle\n       *               mode\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> ossi;\n      /**\n       * @brief LOCK field\n       *\n       * Lock\
    \ configuration\n       */\n      BitFieldModel<uint32_t, 8, 2> lock;\n      /**\n\
    \       * @brief DTG field\n       *\n       * Dead-time generator setup\n   \
    \    */\n      BitFieldModel<uint32_t, 0, 8> dtg;\n    };\n  };\n\npublic:\n \
    \ /**\n   * @brief BDTR register\n   *\n   * break and dead-time register\n  \
    \ */\n  using bdtr = BdtrReg<BaseAddress + 0x0044>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_TIM8_H\
    \ */"
  name: TIM8
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_TIM10_H\n#define DRAL_STM32F411_TIM10_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ TIM10 peripheral\n *\n * General-purpose-timers\n */\nclass tim10\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40014400; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CKD\
    \ field\n     *\n     * Clock division\n     */\n    using ckd = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief ARPE field\n     *\n     * Auto-reload\
    \ preload enable\n     */\n    using arpe = FieldModel<uint32_t, address, 7, 1>;\n\
    \    /**\n     * @brief URS field\n     *\n     * Update request source\n    \
    \ */\n    using urs = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief\
    \ UDIS field\n     *\n     * Update disable\n     */\n    using udis = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief CEN field\n     *\n     * Counter enable\n\
    \     */\n    using cen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CKD field\n       *\n       * Clock division\n       */\n   \
    \   BitFieldModel<uint32_t, 8, 2> ckd;\n      /**\n       * @brief ARPE field\n\
    \       *\n       * Auto-reload preload enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> arpe;\n      /**\n       * @brief URS field\n       *\n       * Update\
    \ request source\n       */\n      BitFieldModel<uint32_t, 2, 1> urs;\n      /**\n\
    \       * @brief UDIS field\n       *\n       * Update disable\n       */\n  \
    \    BitFieldModel<uint32_t, 1, 1> udis;\n      /**\n       * @brief CEN field\n\
    \       *\n       * Counter enable\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 1> cen;\n    };\n  };\n\npublic:\n  /**\n   * @brief CR1 register\n   *\n  \
    \ * control register 1\n   */\n  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\n\
    private:\n  template<unsigned int address>\n  class DierReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CC1IE field\n     *\n     *\
    \ Capture/Compare 1 interrupt\n     *               enable\n     */\n    using\
    \ cc1ie = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief UIE field\n\
    \     *\n     * Update interrupt enable\n     */\n    using uie = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CC1IE field\n       *\n\
    \       * Capture/Compare 1 interrupt\n       *               enable\n       */\n\
    \      BitFieldModel<uint32_t, 1, 1> cc1ie;\n      /**\n       * @brief UIE field\n\
    \       *\n       * Update interrupt enable\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> uie;\n    };\n  };\n\npublic:\n  /**\n   * @brief DIER register\n   *\n\
    \   * DMA/Interrupt enable register\n   */\n  using dier = DierReg<BaseAddress\
    \ + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class SrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CC1OF\
    \ field\n     *\n     * Capture/Compare 1 overcapture\n     *               flag\n\
    \     */\n    using cc1of = FieldModel<uint32_t, address, 9, 1>;\n    /**\n  \
    \   * @brief CC1IF field\n     *\n     * Capture/compare 1 interrupt\n     * \
    \              flag\n     */\n    using cc1if = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    /**\n     * @brief UIF field\n     *\n     * Update interrupt flag\n\
    \     */\n    using uif = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CC1OF field\n       *\n       * Capture/Compare 1 overcapture\n\
    \       *               flag\n       */\n      BitFieldModel<uint32_t, 9, 1> cc1of;\n\
    \      /**\n       * @brief CC1IF field\n       *\n       * Capture/compare 1\
    \ interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1if;\n      /**\n       * @brief UIF field\n       *\n       * Update\
    \ interrupt flag\n       */\n      BitFieldModel<uint32_t, 0, 1> uif;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief SR register\n   *\n   * status register\n\
    \   */\n  using sr = SrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class EgrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief CC1G field\n     *\n     * Capture/compare\
    \ 1\n     *               generation\n     */\n    using cc1g = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UG field\n     *\n     * Update generation\n\
    \     */\n    using ug = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n \
    \   /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CC1G field\n       *\n       * Capture/compare 1\n       *  \
    \             generation\n       */\n      BitFieldModel<uint32_t, 1, 1> cc1g;\n\
    \      /**\n       * @brief UG field\n       *\n       * Update generation\n \
    \      */\n      BitFieldModel<uint32_t, 0, 1> ug;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief EGR register\n   *\n   * event generation register\n   */\n\
    \  using egr = EgrReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr1_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief OC1M field\n     *\n     * Output Compare\
    \ 1 mode\n     */\n    using oc1m = FieldModel<uint32_t, address, 4, 3>;\n   \
    \ /**\n     * @brief OC1PE field\n     *\n     * Output Compare 1 preload\n  \
    \   *               enable\n     */\n    using oc1pe = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief OC1FE field\n     *\n     * Output Compare 1\
    \ fast\n     *               enable\n     */\n    using oc1fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1S field\n     *\n     * Capture/Compare\
    \ 1\n     *               selection\n     */\n    using cc1s = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OC1M field\n       *\n\
    \       * Output Compare 1 mode\n       */\n      BitFieldModel<uint32_t, 4, 3>\
    \ oc1m;\n      /**\n       * @brief OC1PE field\n       *\n       * Output Compare\
    \ 1 preload\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> oc1pe;\n      /**\n       * @brief OC1FE field\n       *\n       * Output\
    \ Compare 1 fast\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc1fe;\n      /**\n       * @brief CC1S field\n       *\n       * Capture/Compare\
    \ 1\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc1s;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCMR1_OUTPUT register\n\
    \   *\n   * capture/compare mode register 1 (output\n   *           mode)\n  \
    \ */\n  using ccmr1_output = Ccmr1_outputReg<BaseAddress + 0x0018>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Ccmr1_inputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief IC1F field\n     *\n     *\
    \ Input capture 1 filter\n     */\n    using ic1f = FieldModel<uint32_t, address,\
    \ 4, 4>;\n    /**\n     * @brief ICPCS field\n     *\n     * Input capture 1 prescaler\n\
    \     */\n    using icpcs = FieldModel<uint32_t, address, 2, 2>;\n    /**\n  \
    \   * @brief CC1S field\n     *\n     * Capture/Compare 1\n     *            \
    \   selection\n     */\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief IC1F field\n       *\n       * Input capture\
    \ 1 filter\n       */\n      BitFieldModel<uint32_t, 4, 4> ic1f;\n      /**\n\
    \       * @brief ICPCS field\n       *\n       * Input capture 1 prescaler\n \
    \      */\n      BitFieldModel<uint32_t, 2, 2> icpcs;\n      /**\n       * @brief\
    \ CC1S field\n       *\n       * Capture/Compare 1\n       *               selection\n\
    \       */\n      BitFieldModel<uint32_t, 0, 2> cc1s;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CCMR1_INPUT register\n   *\n   * capture/compare mode register\
    \ 1 (input\n   *           mode)\n   */\n  using ccmr1_input = Ccmr1_inputReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class CcerReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ CC1NP field\n     *\n     * Capture/Compare 1 output\n     *               Polarity\n\
    \     */\n    using cc1np = FieldModel<uint32_t, address, 3, 1>;\n    /**\n  \
    \   * @brief CC1P field\n     *\n     * Capture/Compare 1 output\n     *     \
    \          Polarity\n     */\n    using cc1p = FieldModel<uint32_t, address, 1,\
    \ 1>;\n    /**\n     * @brief CC1E field\n     *\n     * Capture/Compare 1 output\n\
    \     *               enable\n     */\n    using cc1e = FieldModel<uint32_t, address,\
    \ 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief CC1NP field\n       *\n   \
    \    * Capture/Compare 1 output\n       *               Polarity\n       */\n\
    \      BitFieldModel<uint32_t, 3, 1> cc1np;\n      /**\n       * @brief CC1P field\n\
    \       *\n       * Capture/Compare 1 output\n       *               Polarity\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> cc1p;\n      /**\n       * @brief\
    \ CC1E field\n       *\n       * Capture/Compare 1 output\n       *          \
    \     enable\n       */\n      BitFieldModel<uint32_t, 0, 1> cc1e;\n    };\n \
    \ };\n\npublic:\n  /**\n   * @brief CCER register\n   *\n   * capture/compare\
    \ enable\n   *           register\n   */\n  using ccer = CcerReg<BaseAddress +\
    \ 0x0020>;\n\nprivate:\n  template<unsigned int address>\n  class CntReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CNT\
    \ field\n     *\n     * counter value\n     */\n    using cnt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CNT field\n       *\n \
    \      * counter value\n       */\n      BitFieldModel<uint32_t, 0, 16> cnt;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief CNT register\n   *\n   * counter\n\
    \   */\n  using cnt = CntReg<BaseAddress + 0x0024>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class PscReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief PSC field\n     *\n     * Prescaler value\n\
    \     */\n    using psc = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief PSC field\n       *\n       * Prescaler value\n       */\n  \
    \    BitFieldModel<uint32_t, 0, 16> psc;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief PSC register\n   *\n   * prescaler\n   */\n  using psc = PscReg<BaseAddress\
    \ + 0x0028>;\n\nprivate:\n  template<unsigned int address>\n  class ArrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief ARR\
    \ field\n     *\n     * Auto-reload value\n     */\n    using arr = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief ARR field\n       *\n \
    \      * Auto-reload value\n       */\n      BitFieldModel<uint32_t, 0, 16> arr;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief ARR register\n   *\n   * auto-reload\
    \ register\n   */\n  using arr = ArrReg<BaseAddress + 0x002C>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Ccr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CCR1 field\n     *\n     *\
    \ Capture/Compare 1 value\n     */\n    using ccr1 = FieldModel<uint32_t, address,\
    \ 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CCR1 field\n       *\n\
    \       * Capture/Compare 1 value\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 16> ccr1;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCR1 register\n   *\n\
    \   * capture/compare register 1\n   */\n  using ccr1 = Ccr1Reg<BaseAddress +\
    \ 0x0034>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_TIM10_H */"
  name: TIM10
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_TIM11_H\n#define DRAL_STM32F411_TIM11_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ TIM11 peripheral\n *\n * General-purpose-timers\n */\nclass tim11\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40014800; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CKD\
    \ field\n     *\n     * Clock division\n     */\n    using ckd = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief ARPE field\n     *\n     * Auto-reload\
    \ preload enable\n     */\n    using arpe = FieldModel<uint32_t, address, 7, 1>;\n\
    \    /**\n     * @brief URS field\n     *\n     * Update request source\n    \
    \ */\n    using urs = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief\
    \ UDIS field\n     *\n     * Update disable\n     */\n    using udis = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief CEN field\n     *\n     * Counter enable\n\
    \     */\n    using cen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CKD field\n       *\n       * Clock division\n       */\n   \
    \   BitFieldModel<uint32_t, 8, 2> ckd;\n      /**\n       * @brief ARPE field\n\
    \       *\n       * Auto-reload preload enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> arpe;\n      /**\n       * @brief URS field\n       *\n       * Update\
    \ request source\n       */\n      BitFieldModel<uint32_t, 2, 1> urs;\n      /**\n\
    \       * @brief UDIS field\n       *\n       * Update disable\n       */\n  \
    \    BitFieldModel<uint32_t, 1, 1> udis;\n      /**\n       * @brief CEN field\n\
    \       *\n       * Counter enable\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 1> cen;\n    };\n  };\n\npublic:\n  /**\n   * @brief CR1 register\n   *\n  \
    \ * control register 1\n   */\n  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\n\
    private:\n  template<unsigned int address>\n  class DierReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CC1IE field\n     *\n     *\
    \ Capture/Compare 1 interrupt\n     *               enable\n     */\n    using\
    \ cc1ie = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief UIE field\n\
    \     *\n     * Update interrupt enable\n     */\n    using uie = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CC1IE field\n       *\n\
    \       * Capture/Compare 1 interrupt\n       *               enable\n       */\n\
    \      BitFieldModel<uint32_t, 1, 1> cc1ie;\n      /**\n       * @brief UIE field\n\
    \       *\n       * Update interrupt enable\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> uie;\n    };\n  };\n\npublic:\n  /**\n   * @brief DIER register\n   *\n\
    \   * DMA/Interrupt enable register\n   */\n  using dier = DierReg<BaseAddress\
    \ + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class SrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CC1OF\
    \ field\n     *\n     * Capture/Compare 1 overcapture\n     *               flag\n\
    \     */\n    using cc1of = FieldModel<uint32_t, address, 9, 1>;\n    /**\n  \
    \   * @brief CC1IF field\n     *\n     * Capture/compare 1 interrupt\n     * \
    \              flag\n     */\n    using cc1if = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    /**\n     * @brief UIF field\n     *\n     * Update interrupt flag\n\
    \     */\n    using uif = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CC1OF field\n       *\n       * Capture/Compare 1 overcapture\n\
    \       *               flag\n       */\n      BitFieldModel<uint32_t, 9, 1> cc1of;\n\
    \      /**\n       * @brief CC1IF field\n       *\n       * Capture/compare 1\
    \ interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1if;\n      /**\n       * @brief UIF field\n       *\n       * Update\
    \ interrupt flag\n       */\n      BitFieldModel<uint32_t, 0, 1> uif;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief SR register\n   *\n   * status register\n\
    \   */\n  using sr = SrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class EgrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief CC1G field\n     *\n     * Capture/compare\
    \ 1\n     *               generation\n     */\n    using cc1g = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UG field\n     *\n     * Update generation\n\
    \     */\n    using ug = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n \
    \   /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CC1G field\n       *\n       * Capture/compare 1\n       *  \
    \             generation\n       */\n      BitFieldModel<uint32_t, 1, 1> cc1g;\n\
    \      /**\n       * @brief UG field\n       *\n       * Update generation\n \
    \      */\n      BitFieldModel<uint32_t, 0, 1> ug;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief EGR register\n   *\n   * event generation register\n   */\n\
    \  using egr = EgrReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr1_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief OC1M field\n     *\n     * Output Compare\
    \ 1 mode\n     */\n    using oc1m = FieldModel<uint32_t, address, 4, 3>;\n   \
    \ /**\n     * @brief OC1PE field\n     *\n     * Output Compare 1 preload\n  \
    \   *               enable\n     */\n    using oc1pe = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief OC1FE field\n     *\n     * Output Compare 1\
    \ fast\n     *               enable\n     */\n    using oc1fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1S field\n     *\n     * Capture/Compare\
    \ 1\n     *               selection\n     */\n    using cc1s = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OC1M field\n       *\n\
    \       * Output Compare 1 mode\n       */\n      BitFieldModel<uint32_t, 4, 3>\
    \ oc1m;\n      /**\n       * @brief OC1PE field\n       *\n       * Output Compare\
    \ 1 preload\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> oc1pe;\n      /**\n       * @brief OC1FE field\n       *\n       * Output\
    \ Compare 1 fast\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc1fe;\n      /**\n       * @brief CC1S field\n       *\n       * Capture/Compare\
    \ 1\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc1s;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCMR1_OUTPUT register\n\
    \   *\n   * capture/compare mode register 1 (output\n   *           mode)\n  \
    \ */\n  using ccmr1_output = Ccmr1_outputReg<BaseAddress + 0x0018>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Ccmr1_inputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief IC1F field\n     *\n     *\
    \ Input capture 1 filter\n     */\n    using ic1f = FieldModel<uint32_t, address,\
    \ 4, 4>;\n    /**\n     * @brief ICPCS field\n     *\n     * Input capture 1 prescaler\n\
    \     */\n    using icpcs = FieldModel<uint32_t, address, 2, 2>;\n    /**\n  \
    \   * @brief CC1S field\n     *\n     * Capture/Compare 1\n     *            \
    \   selection\n     */\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief IC1F field\n       *\n       * Input capture\
    \ 1 filter\n       */\n      BitFieldModel<uint32_t, 4, 4> ic1f;\n      /**\n\
    \       * @brief ICPCS field\n       *\n       * Input capture 1 prescaler\n \
    \      */\n      BitFieldModel<uint32_t, 2, 2> icpcs;\n      /**\n       * @brief\
    \ CC1S field\n       *\n       * Capture/Compare 1\n       *               selection\n\
    \       */\n      BitFieldModel<uint32_t, 0, 2> cc1s;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CCMR1_INPUT register\n   *\n   * capture/compare mode register\
    \ 1 (input\n   *           mode)\n   */\n  using ccmr1_input = Ccmr1_inputReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class CcerReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ CC1NP field\n     *\n     * Capture/Compare 1 output\n     *               Polarity\n\
    \     */\n    using cc1np = FieldModel<uint32_t, address, 3, 1>;\n    /**\n  \
    \   * @brief CC1P field\n     *\n     * Capture/Compare 1 output\n     *     \
    \          Polarity\n     */\n    using cc1p = FieldModel<uint32_t, address, 1,\
    \ 1>;\n    /**\n     * @brief CC1E field\n     *\n     * Capture/Compare 1 output\n\
    \     *               enable\n     */\n    using cc1e = FieldModel<uint32_t, address,\
    \ 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief CC1NP field\n       *\n   \
    \    * Capture/Compare 1 output\n       *               Polarity\n       */\n\
    \      BitFieldModel<uint32_t, 3, 1> cc1np;\n      /**\n       * @brief CC1P field\n\
    \       *\n       * Capture/Compare 1 output\n       *               Polarity\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> cc1p;\n      /**\n       * @brief\
    \ CC1E field\n       *\n       * Capture/Compare 1 output\n       *          \
    \     enable\n       */\n      BitFieldModel<uint32_t, 0, 1> cc1e;\n    };\n \
    \ };\n\npublic:\n  /**\n   * @brief CCER register\n   *\n   * capture/compare\
    \ enable\n   *           register\n   */\n  using ccer = CcerReg<BaseAddress +\
    \ 0x0020>;\n\nprivate:\n  template<unsigned int address>\n  class CntReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CNT\
    \ field\n     *\n     * counter value\n     */\n    using cnt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CNT field\n       *\n \
    \      * counter value\n       */\n      BitFieldModel<uint32_t, 0, 16> cnt;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief CNT register\n   *\n   * counter\n\
    \   */\n  using cnt = CntReg<BaseAddress + 0x0024>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class PscReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief PSC field\n     *\n     * Prescaler value\n\
    \     */\n    using psc = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief PSC field\n       *\n       * Prescaler value\n       */\n  \
    \    BitFieldModel<uint32_t, 0, 16> psc;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief PSC register\n   *\n   * prescaler\n   */\n  using psc = PscReg<BaseAddress\
    \ + 0x0028>;\n\nprivate:\n  template<unsigned int address>\n  class ArrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief ARR\
    \ field\n     *\n     * Auto-reload value\n     */\n    using arr = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief ARR field\n       *\n \
    \      * Auto-reload value\n       */\n      BitFieldModel<uint32_t, 0, 16> arr;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief ARR register\n   *\n   * auto-reload\
    \ register\n   */\n  using arr = ArrReg<BaseAddress + 0x002C>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Ccr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CCR1 field\n     *\n     *\
    \ Capture/Compare 1 value\n     */\n    using ccr1 = FieldModel<uint32_t, address,\
    \ 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CCR1 field\n       *\n\
    \       * Capture/Compare 1 value\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 16> ccr1;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCR1 register\n   *\n\
    \   * capture/compare register 1\n   */\n  using ccr1 = Ccr1Reg<BaseAddress +\
    \ 0x0034>;\n\nprivate:\n  template<unsigned int address>\n  class OrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief RMP\
    \ field\n     *\n     * Input 1 remapping\n     *               capability\n \
    \    */\n    using rmp = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n \
    \   /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief RMP field\n       *\n       * Input 1 remapping\n       *   \
    \            capability\n       */\n      BitFieldModel<uint32_t, 0, 2> rmp;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief OR register\n   *\n   * option register\n\
    \   */\n  using or_ = OrReg<BaseAddress + 0x0050>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_TIM11_H\
    \ */"
  name: TIM11
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_TIM2_H\n#define DRAL_STM32F411_TIM2_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ TIM2 peripheral\n *\n * General purpose timers\n */\nclass tim2\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40000000; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CKD\
    \ field\n     *\n     * Clock division\n     */\n    using ckd = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief ARPE field\n     *\n     * Auto-reload\
    \ preload enable\n     */\n    using arpe = FieldModel<uint32_t, address, 7, 1>;\n\
    \    /**\n     * @brief CMS field\n     *\n     * Center-aligned mode\n     *\
    \               selection\n     */\n    using cms = FieldModel<uint32_t, address,\
    \ 5, 2>;\n    /**\n     * @brief DIR field\n     *\n     * Direction\n     */\n\
    \    using dir = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief\
    \ OPM field\n     *\n     * One-pulse mode\n     */\n    using opm = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief URS field\n     *\n     * Update request\
    \ source\n     */\n    using urs = FieldModel<uint32_t, address, 2, 1>;\n    /**\n\
    \     * @brief UDIS field\n     *\n     * Update disable\n     */\n    using udis\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief CEN field\n \
    \    *\n     * Counter enable\n     */\n    using cen = FieldModel<uint32_t, address,\
    \ 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief CKD field\n       *\n     \
    \  * Clock division\n       */\n      BitFieldModel<uint32_t, 8, 2> ckd;\n   \
    \   /**\n       * @brief ARPE field\n       *\n       * Auto-reload preload enable\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> arpe;\n      /**\n       * @brief\
    \ CMS field\n       *\n       * Center-aligned mode\n       *               selection\n\
    \       */\n      BitFieldModel<uint32_t, 5, 2> cms;\n      /**\n       * @brief\
    \ DIR field\n       *\n       * Direction\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> dir;\n      /**\n       * @brief OPM field\n       *\n       * One-pulse\
    \ mode\n       */\n      BitFieldModel<uint32_t, 3, 1> opm;\n      /**\n     \
    \  * @brief URS field\n       *\n       * Update request source\n       */\n \
    \     BitFieldModel<uint32_t, 2, 1> urs;\n      /**\n       * @brief UDIS field\n\
    \       *\n       * Update disable\n       */\n      BitFieldModel<uint32_t, 1,\
    \ 1> udis;\n      /**\n       * @brief CEN field\n       *\n       * Counter enable\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> cen;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR1 register\n   *\n   * control register 1\n   */\n  using\
    \ cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief TI1S field\n     *\n     * TI1 selection\n     */\n    using\
    \ ti1s = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief MMS field\n\
    \     *\n     * Master mode selection\n     */\n    using mms = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    /**\n     * @brief CCDS field\n     *\n     * Capture/compare\
    \ DMA\n     *               selection\n     */\n    using ccds = FieldModel<uint32_t,\
    \ address, 3, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief TI1S field\n       *\n\
    \       * TI1 selection\n       */\n      BitFieldModel<uint32_t, 7, 1> ti1s;\n\
    \      /**\n       * @brief MMS field\n       *\n       * Master mode selection\n\
    \       */\n      BitFieldModel<uint32_t, 4, 3> mms;\n      /**\n       * @brief\
    \ CCDS field\n       *\n       * Capture/compare DMA\n       *               selection\n\
    \       */\n      BitFieldModel<uint32_t, 3, 1> ccds;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR2 register\n   *\n   * control register 2\n   */\n  using\
    \ cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class SmcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief ETP field\n     *\n     * External trigger polarity\n \
    \    */\n    using etp = FieldModel<uint32_t, address, 15, 1>;\n    /**\n    \
    \ * @brief ECE field\n     *\n     * External clock enable\n     */\n    using\
    \ ece = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief ETPS field\n\
    \     *\n     * External trigger prescaler\n     */\n    using etps = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    /**\n     * @brief ETF field\n     *\n     * External\
    \ trigger filter\n     */\n    using etf = FieldModel<uint32_t, address, 8, 4>;\n\
    \    /**\n     * @brief MSM field\n     *\n     * Master/Slave mode\n     */\n\
    \    using msm = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief\
    \ TS field\n     *\n     * Trigger selection\n     */\n    using ts = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    /**\n     * @brief SMS field\n     *\n     * Slave mode\
    \ selection\n     */\n    using sms = FieldModel<uint32_t, address, 0, 3>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief ETP field\n       *\n       * External trigger\
    \ polarity\n       */\n      BitFieldModel<uint32_t, 15, 1> etp;\n      /**\n\
    \       * @brief ECE field\n       *\n       * External clock enable\n       */\n\
    \      BitFieldModel<uint32_t, 14, 1> ece;\n      /**\n       * @brief ETPS field\n\
    \       *\n       * External trigger prescaler\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 2> etps;\n      /**\n       * @brief ETF field\n       *\n       * External\
    \ trigger filter\n       */\n      BitFieldModel<uint32_t, 8, 4> etf;\n      /**\n\
    \       * @brief MSM field\n       *\n       * Master/Slave mode\n       */\n\
    \      BitFieldModel<uint32_t, 7, 1> msm;\n      /**\n       * @brief TS field\n\
    \       *\n       * Trigger selection\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 3> ts;\n      /**\n       * @brief SMS field\n       *\n       * Slave mode\
    \ selection\n       */\n      BitFieldModel<uint32_t, 0, 3> sms;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief SMCR register\n   *\n   * slave mode control register\n\
    \   */\n  using smcr = SmcrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DierReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief TDE field\n     *\n     * Trigger DMA request\
    \ enable\n     */\n    using tde = FieldModel<uint32_t, address, 14, 1>;\n   \
    \ /**\n     * @brief CC4DE field\n     *\n     * Capture/Compare 4 DMA request\n\
    \     *               enable\n     */\n    using cc4de = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief CC3DE field\n     *\n     * Capture/Compare\
    \ 3 DMA request\n     *               enable\n     */\n    using cc3de = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief CC2DE field\n     *\n     * Capture/Compare\
    \ 2 DMA request\n     *               enable\n     */\n    using cc2de = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief CC1DE field\n     *\n     * Capture/Compare\
    \ 1 DMA request\n     *               enable\n     */\n    using cc1de = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief UDE field\n     *\n     * Update DMA\
    \ request enable\n     */\n    using ude = FieldModel<uint32_t, address, 8, 1>;\n\
    \    /**\n     * @brief TIE field\n     *\n     * Trigger interrupt enable\n \
    \    */\n    using tie = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     *\
    \ @brief CC4IE field\n     *\n     * Capture/Compare 4 interrupt\n     *     \
    \          enable\n     */\n    using cc4ie = FieldModel<uint32_t, address, 4,\
    \ 1>;\n    /**\n     * @brief CC3IE field\n     *\n     * Capture/Compare 3 interrupt\n\
    \     *               enable\n     */\n    using cc3ie = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief CC2IE field\n     *\n     * Capture/Compare\
    \ 2 interrupt\n     *               enable\n     */\n    using cc2ie = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1IE field\n     *\n     * Capture/Compare\
    \ 1 interrupt\n     *               enable\n     */\n    using cc1ie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UIE field\n     *\n     * Update interrupt\
    \ enable\n     */\n    using uie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief TDE field\n       *\n       * Trigger DMA request enable\n  \
    \     */\n      BitFieldModel<uint32_t, 14, 1> tde;\n      /**\n       * @brief\
    \ CC4DE field\n       *\n       * Capture/Compare 4 DMA request\n       *    \
    \           enable\n       */\n      BitFieldModel<uint32_t, 12, 1> cc4de;\n \
    \     /**\n       * @brief CC3DE field\n       *\n       * Capture/Compare 3 DMA\
    \ request\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> cc3de;\n      /**\n       * @brief CC2DE field\n       *\n       * Capture/Compare\
    \ 2 DMA request\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> cc2de;\n      /**\n       * @brief CC1DE field\n       *\n       * Capture/Compare\
    \ 1 DMA request\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc1de;\n      /**\n       * @brief UDE field\n       *\n       * Update\
    \ DMA request enable\n       */\n      BitFieldModel<uint32_t, 8, 1> ude;\n  \
    \    /**\n       * @brief TIE field\n       *\n       * Trigger interrupt enable\n\
    \       */\n      BitFieldModel<uint32_t, 6, 1> tie;\n      /**\n       * @brief\
    \ CC4IE field\n       *\n       * Capture/Compare 4 interrupt\n       *      \
    \         enable\n       */\n      BitFieldModel<uint32_t, 4, 1> cc4ie;\n    \
    \  /**\n       * @brief CC3IE field\n       *\n       * Capture/Compare 3 interrupt\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 3, 1>\
    \ cc3ie;\n      /**\n       * @brief CC2IE field\n       *\n       * Capture/Compare\
    \ 2 interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cc2ie;\n      /**\n       * @brief CC1IE field\n       *\n       * Capture/Compare\
    \ 1 interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1ie;\n      /**\n       * @brief UIE field\n       *\n       * Update\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 0, 1> uie;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief DIER register\n   *\n   * DMA/Interrupt enable\
    \ register\n   */\n  using dier = DierReg<BaseAddress + 0x000C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CC4OF field\n     *\n     *\
    \ Capture/Compare 4 overcapture\n     *               flag\n     */\n    using\
    \ cc4of = FieldModel<uint32_t, address, 12, 1>;\n    /**\n     * @brief CC3OF\
    \ field\n     *\n     * Capture/Compare 3 overcapture\n     *               flag\n\
    \     */\n    using cc3of = FieldModel<uint32_t, address, 11, 1>;\n    /**\n \
    \    * @brief CC2OF field\n     *\n     * Capture/compare 2 overcapture\n    \
    \ *               flag\n     */\n    using cc2of = FieldModel<uint32_t, address,\
    \ 10, 1>;\n    /**\n     * @brief CC1OF field\n     *\n     * Capture/Compare\
    \ 1 overcapture\n     *               flag\n     */\n    using cc1of = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief TIF field\n     *\n     * Trigger interrupt\
    \ flag\n     */\n    using tif = FieldModel<uint32_t, address, 6, 1>;\n    /**\n\
    \     * @brief CC4IF field\n     *\n     * Capture/Compare 4 interrupt\n     *\
    \               flag\n     */\n    using cc4if = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief CC3IF field\n     *\n     * Capture/Compare 3\
    \ interrupt\n     *               flag\n     */\n    using cc3if = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief CC2IF field\n     *\n     * Capture/Compare\
    \ 2 interrupt\n     *               flag\n     */\n    using cc2if = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1IF field\n     *\n     * Capture/compare\
    \ 1 interrupt\n     *               flag\n     */\n    using cc1if = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UIF field\n     *\n     * Update interrupt\
    \ flag\n     */\n    using uif = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CC4OF field\n       *\n       * Capture/Compare 4 overcapture\n\
    \       *               flag\n       */\n      BitFieldModel<uint32_t, 12, 1>\
    \ cc4of;\n      /**\n       * @brief CC3OF field\n       *\n       * Capture/Compare\
    \ 3 overcapture\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> cc3of;\n      /**\n       * @brief CC2OF field\n       *\n       * Capture/compare\
    \ 2 overcapture\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> cc2of;\n      /**\n       * @brief CC1OF field\n       *\n       * Capture/Compare\
    \ 1 overcapture\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc1of;\n      /**\n       * @brief TIF field\n       *\n       * Trigger\
    \ interrupt flag\n       */\n      BitFieldModel<uint32_t, 6, 1> tif;\n      /**\n\
    \       * @brief CC4IF field\n       *\n       * Capture/Compare 4 interrupt\n\
    \       *               flag\n       */\n      BitFieldModel<uint32_t, 4, 1> cc4if;\n\
    \      /**\n       * @brief CC3IF field\n       *\n       * Capture/Compare 3\
    \ interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3if;\n      /**\n       * @brief CC2IF field\n       *\n       * Capture/Compare\
    \ 2 interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cc2if;\n      /**\n       * @brief CC1IF field\n       *\n       * Capture/compare\
    \ 1 interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1if;\n      /**\n       * @brief UIF field\n       *\n       * Update\
    \ interrupt flag\n       */\n      BitFieldModel<uint32_t, 0, 1> uif;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief SR register\n   *\n   * status register\n\
    \   */\n  using sr = SrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class EgrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief TG field\n     *\n     * Trigger generation\n\
    \     */\n    using tg = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     *\
    \ @brief CC4G field\n     *\n     * Capture/compare 4\n     *               generation\n\
    \     */\n    using cc4g = FieldModel<uint32_t, address, 4, 1>;\n    /**\n   \
    \  * @brief CC3G field\n     *\n     * Capture/compare 3\n     *             \
    \  generation\n     */\n    using cc3g = FieldModel<uint32_t, address, 3, 1>;\n\
    \    /**\n     * @brief CC2G field\n     *\n     * Capture/compare 2\n     * \
    \              generation\n     */\n    using cc2g = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief CC1G field\n     *\n     * Capture/compare 1\n\
    \     *               generation\n     */\n    using cc1g = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UG field\n     *\n     * Update generation\n\
    \     */\n    using ug = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n \
    \   /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief TG field\n       *\n       * Trigger generation\n       */\n\
    \      BitFieldModel<uint32_t, 6, 1> tg;\n      /**\n       * @brief CC4G field\n\
    \       *\n       * Capture/compare 4\n       *               generation\n   \
    \    */\n      BitFieldModel<uint32_t, 4, 1> cc4g;\n      /**\n       * @brief\
    \ CC3G field\n       *\n       * Capture/compare 3\n       *               generation\n\
    \       */\n      BitFieldModel<uint32_t, 3, 1> cc3g;\n      /**\n       * @brief\
    \ CC2G field\n       *\n       * Capture/compare 2\n       *               generation\n\
    \       */\n      BitFieldModel<uint32_t, 2, 1> cc2g;\n      /**\n       * @brief\
    \ CC1G field\n       *\n       * Capture/compare 1\n       *               generation\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> cc1g;\n      /**\n       * @brief\
    \ UG field\n       *\n       * Update generation\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> ug;\n    };\n  };\n\npublic:\n  /**\n   * @brief EGR register\n   *\n\
    \   * event generation register\n   */\n  using egr = EgrReg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Ccmr1_outputReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief OC2CE\
    \ field\n     *\n     * OC2CE\n     */\n    using oc2ce = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief OC2M field\n     *\n     * OC2M\n \
    \    */\n    using oc2m = FieldModel<uint32_t, address, 12, 3>;\n    /**\n   \
    \  * @brief OC2PE field\n     *\n     * OC2PE\n     */\n    using oc2pe = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief OC2FE field\n     *\n     * OC2FE\n\
    \     */\n    using oc2fe = FieldModel<uint32_t, address, 10, 1>;\n    /**\n \
    \    * @brief CC2S field\n     *\n     * CC2S\n     */\n    using cc2s = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief OC1CE field\n     *\n     * OC1CE\n\
    \     */\n    using oc1ce = FieldModel<uint32_t, address, 7, 1>;\n    /**\n  \
    \   * @brief OC1M field\n     *\n     * OC1M\n     */\n    using oc1m = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    /**\n     * @brief OC1PE field\n     *\n     * OC1PE\n\
    \     */\n    using oc1pe = FieldModel<uint32_t, address, 3, 1>;\n    /**\n  \
    \   * @brief OC1FE field\n     *\n     * OC1FE\n     */\n    using oc1fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1S field\n     *\n     * CC1S\n  \
    \   */\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n \
    \   /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief OC2CE field\n       *\n       * OC2CE\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> oc2ce;\n      /**\n       * @brief OC2M field\n       *\n       * OC2M\n\
    \       */\n      BitFieldModel<uint32_t, 12, 3> oc2m;\n      /**\n       * @brief\
    \ OC2PE field\n       *\n       * OC2PE\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> oc2pe;\n      /**\n       * @brief OC2FE field\n       *\n       * OC2FE\n\
    \       */\n      BitFieldModel<uint32_t, 10, 1> oc2fe;\n      /**\n       * @brief\
    \ CC2S field\n       *\n       * CC2S\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc2s;\n      /**\n       * @brief OC1CE field\n       *\n       * OC1CE\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> oc1ce;\n      /**\n       * @brief\
    \ OC1M field\n       *\n       * OC1M\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 3> oc1m;\n      /**\n       * @brief OC1PE field\n       *\n       * OC1PE\n\
    \       */\n      BitFieldModel<uint32_t, 3, 1> oc1pe;\n      /**\n       * @brief\
    \ OC1FE field\n       *\n       * OC1FE\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc1fe;\n      /**\n       * @brief CC1S field\n       *\n       * CC1S\n\
    \       */\n      BitFieldModel<uint32_t, 0, 2> cc1s;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CCMR1_OUTPUT register\n   *\n   * capture/compare mode register\
    \ 1 (output\n   *           mode)\n   */\n  using ccmr1_output = Ccmr1_outputReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class Ccmr1_inputReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ IC2F field\n     *\n     * Input capture 2 filter\n     */\n    using ic2f =\
    \ FieldModel<uint32_t, address, 12, 4>;\n    /**\n     * @brief IC2PCS field\n\
    \     *\n     * Input capture 2 prescaler\n     */\n    using ic2pcs = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    /**\n     * @brief CC2S field\n     *\n     * Capture/Compare\
    \ 2\n     *               selection\n     */\n    using cc2s = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief IC1F field\n     *\n     * Input capture\
    \ 1 filter\n     */\n    using ic1f = FieldModel<uint32_t, address, 4, 4>;\n \
    \   /**\n     * @brief ICPCS field\n     *\n     * Input capture 1 prescaler\n\
    \     */\n    using icpcs = FieldModel<uint32_t, address, 2, 2>;\n    /**\n  \
    \   * @brief CC1S field\n     *\n     * Capture/Compare 1\n     *            \
    \   selection\n     */\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief IC2F field\n       *\n       * Input capture\
    \ 2 filter\n       */\n      BitFieldModel<uint32_t, 12, 4> ic2f;\n      /**\n\
    \       * @brief IC2PCS field\n       *\n       * Input capture 2 prescaler\n\
    \       */\n      BitFieldModel<uint32_t, 10, 2> ic2pcs;\n      /**\n       *\
    \ @brief CC2S field\n       *\n       * Capture/Compare 2\n       *          \
    \     selection\n       */\n      BitFieldModel<uint32_t, 8, 2> cc2s;\n      /**\n\
    \       * @brief IC1F field\n       *\n       * Input capture 1 filter\n     \
    \  */\n      BitFieldModel<uint32_t, 4, 4> ic1f;\n      /**\n       * @brief ICPCS\
    \ field\n       *\n       * Input capture 1 prescaler\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 2> icpcs;\n      /**\n       * @brief CC1S field\n       *\n       * Capture/Compare\
    \ 1\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc1s;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCMR1_INPUT register\n\
    \   *\n   * capture/compare mode register 1 (input\n   *           mode)\n   */\n\
    \  using ccmr1_input = Ccmr1_inputReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr2_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief OC4CE field\n     *\n     * OC4CE\n  \
    \   */\n    using oc4ce = FieldModel<uint32_t, address, 15, 1>;\n    /**\n   \
    \  * @brief OC4M field\n     *\n     * OC4M\n     */\n    using oc4m = FieldModel<uint32_t,\
    \ address, 12, 3>;\n    /**\n     * @brief OC4PE field\n     *\n     * OC4PE\n\
    \     */\n    using oc4pe = FieldModel<uint32_t, address, 11, 1>;\n    /**\n \
    \    * @brief OC4FE field\n     *\n     * OC4FE\n     */\n    using oc4fe = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief CC4S field\n     *\n     * CC4S\n \
    \    */\n    using cc4s = FieldModel<uint32_t, address, 8, 2>;\n    /**\n    \
    \ * @brief OC3CE field\n     *\n     * OC3CE\n     */\n    using oc3ce = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief OC3M field\n     *\n     * OC3M\n  \
    \   */\n    using oc3m = FieldModel<uint32_t, address, 4, 3>;\n    /**\n     *\
    \ @brief OC3PE field\n     *\n     * OC3PE\n     */\n    using oc3pe = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief OC3FE field\n     *\n     * OC3FE\n\
    \     */\n    using oc3fe = FieldModel<uint32_t, address, 2, 1>;\n    /**\n  \
    \   * @brief CC3S field\n     *\n     * CC3S\n     */\n    using cc3s = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OC4CE field\n       *\n\
    \       * OC4CE\n       */\n      BitFieldModel<uint32_t, 15, 1> oc4ce;\n    \
    \  /**\n       * @brief OC4M field\n       *\n       * OC4M\n       */\n     \
    \ BitFieldModel<uint32_t, 12, 3> oc4m;\n      /**\n       * @brief OC4PE field\n\
    \       *\n       * OC4PE\n       */\n      BitFieldModel<uint32_t, 11, 1> oc4pe;\n\
    \      /**\n       * @brief OC4FE field\n       *\n       * OC4FE\n       */\n\
    \      BitFieldModel<uint32_t, 10, 1> oc4fe;\n      /**\n       * @brief CC4S\
    \ field\n       *\n       * CC4S\n       */\n      BitFieldModel<uint32_t, 8,\
    \ 2> cc4s;\n      /**\n       * @brief OC3CE field\n       *\n       * OC3CE\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> oc3ce;\n      /**\n       * @brief\
    \ OC3M field\n       *\n       * OC3M\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 3> oc3m;\n      /**\n       * @brief OC3PE field\n       *\n       * OC3PE\n\
    \       */\n      BitFieldModel<uint32_t, 3, 1> oc3pe;\n      /**\n       * @brief\
    \ OC3FE field\n       *\n       * OC3FE\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc3fe;\n      /**\n       * @brief CC3S field\n       *\n       * CC3S\n\
    \       */\n      BitFieldModel<uint32_t, 0, 2> cc3s;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CCMR2_OUTPUT register\n   *\n   * capture/compare mode register\
    \ 2 (output\n   *           mode)\n   */\n  using ccmr2_output = Ccmr2_outputReg<BaseAddress\
    \ + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class Ccmr2_inputReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ IC4F field\n     *\n     * Input capture 4 filter\n     */\n    using ic4f =\
    \ FieldModel<uint32_t, address, 12, 4>;\n    /**\n     * @brief IC4PSC field\n\
    \     *\n     * Input capture 4 prescaler\n     */\n    using ic4psc = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    /**\n     * @brief CC4S field\n     *\n     * Capture/Compare\
    \ 4\n     *               selection\n     */\n    using cc4s = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief IC3F field\n     *\n     * Input capture\
    \ 3 filter\n     */\n    using ic3f = FieldModel<uint32_t, address, 4, 4>;\n \
    \   /**\n     * @brief IC3PSC field\n     *\n     * Input capture 3 prescaler\n\
    \     */\n    using ic3psc = FieldModel<uint32_t, address, 2, 2>;\n    /**\n \
    \    * @brief CC3S field\n     *\n     * Capture/compare 3\n     *           \
    \    selection\n     */\n    using cc3s = FieldModel<uint32_t, address, 0, 2>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief IC4F field\n       *\n       * Input capture\
    \ 4 filter\n       */\n      BitFieldModel<uint32_t, 12, 4> ic4f;\n      /**\n\
    \       * @brief IC4PSC field\n       *\n       * Input capture 4 prescaler\n\
    \       */\n      BitFieldModel<uint32_t, 10, 2> ic4psc;\n      /**\n       *\
    \ @brief CC4S field\n       *\n       * Capture/Compare 4\n       *          \
    \     selection\n       */\n      BitFieldModel<uint32_t, 8, 2> cc4s;\n      /**\n\
    \       * @brief IC3F field\n       *\n       * Input capture 3 filter\n     \
    \  */\n      BitFieldModel<uint32_t, 4, 4> ic3f;\n      /**\n       * @brief IC3PSC\
    \ field\n       *\n       * Input capture 3 prescaler\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 2> ic3psc;\n      /**\n       * @brief CC3S field\n       *\n       * Capture/compare\
    \ 3\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc3s;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCMR2_INPUT register\n\
    \   *\n   * capture/compare mode register 2 (input\n   *           mode)\n   */\n\
    \  using ccmr2_input = Ccmr2_inputReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CcerReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief CC4NP field\n     *\n     * Capture/Compare\
    \ 4 output\n     *               Polarity\n     */\n    using cc4np = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief CC4P field\n     *\n     * Capture/Compare\
    \ 3 output\n     *               Polarity\n     */\n    using cc4p = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief CC4E field\n     *\n     * Capture/Compare\
    \ 4 output\n     *               enable\n     */\n    using cc4e = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief CC3NP field\n     *\n     * Capture/Compare\
    \ 3 output\n     *               Polarity\n     */\n    using cc3np = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief CC3P field\n     *\n     * Capture/Compare\
    \ 3 output\n     *               Polarity\n     */\n    using cc3p = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief CC3E field\n     *\n     * Capture/Compare\
    \ 3 output\n     *               enable\n     */\n    using cc3e = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief CC2NP field\n     *\n     * Capture/Compare\
    \ 2 output\n     *               Polarity\n     */\n    using cc2np = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief CC2P field\n     *\n     * Capture/Compare\
    \ 2 output\n     *               Polarity\n     */\n    using cc2p = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief CC2E field\n     *\n     * Capture/Compare\
    \ 2 output\n     *               enable\n     */\n    using cc2e = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief CC1NP field\n     *\n     * Capture/Compare\
    \ 1 output\n     *               Polarity\n     */\n    using cc1np = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief CC1P field\n     *\n     * Capture/Compare\
    \ 1 output\n     *               Polarity\n     */\n    using cc1p = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief CC1E field\n     *\n     * Capture/Compare\
    \ 1 output\n     *               enable\n     */\n    using cc1e = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CC4NP field\n       *\n\
    \       * Capture/Compare 4 output\n       *               Polarity\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> cc4np;\n      /**\n       * @brief CC4P\
    \ field\n       *\n       * Capture/Compare 3 output\n       *               Polarity\n\
    \       */\n      BitFieldModel<uint32_t, 13, 1> cc4p;\n      /**\n       * @brief\
    \ CC4E field\n       *\n       * Capture/Compare 4 output\n       *          \
    \     enable\n       */\n      BitFieldModel<uint32_t, 12, 1> cc4e;\n      /**\n\
    \       * @brief CC3NP field\n       *\n       * Capture/Compare 3 output\n  \
    \     *               Polarity\n       */\n      BitFieldModel<uint32_t, 11, 1>\
    \ cc3np;\n      /**\n       * @brief CC3P field\n       *\n       * Capture/Compare\
    \ 3 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc3p;\n      /**\n       * @brief CC3E field\n       *\n       * Capture/Compare\
    \ 3 output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> cc3e;\n      /**\n       * @brief CC2NP field\n       *\n       * Capture/Compare\
    \ 2 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> cc2np;\n      /**\n       * @brief CC2P field\n       *\n       * Capture/Compare\
    \ 2 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> cc2p;\n      /**\n       * @brief CC2E field\n       *\n       * Capture/Compare\
    \ 2 output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> cc2e;\n      /**\n       * @brief CC1NP field\n       *\n       * Capture/Compare\
    \ 1 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc1np;\n      /**\n       * @brief CC1P field\n       *\n       * Capture/Compare\
    \ 1 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1p;\n      /**\n       * @brief CC1E field\n       *\n       * Capture/Compare\
    \ 1 output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> cc1e;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCER register\n   *\n\
    \   * capture/compare enable\n   *           register\n   */\n  using ccer = CcerReg<BaseAddress\
    \ + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n  class CntReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CNT_H\
    \ field\n     *\n     * High counter value\n     */\n    using cnt_h = FieldModel<uint32_t,\
    \ address, 16, 16>;\n    /**\n     * @brief CNT_L field\n     *\n     * Low counter\
    \ value\n     */\n    using cnt_l = FieldModel<uint32_t, address, 0, 16>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief CNT_H field\n       *\n       * High counter\
    \ value\n       */\n      BitFieldModel<uint32_t, 16, 16> cnt_h;\n      /**\n\
    \       * @brief CNT_L field\n       *\n       * Low counter value\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> cnt_l;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief CNT register\n   *\n   * counter\n   */\n  using cnt = CntReg<BaseAddress\
    \ + 0x0024>;\n\nprivate:\n  template<unsigned int address>\n  class PscReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief PSC\
    \ field\n     *\n     * Prescaler value\n     */\n    using psc = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief PSC field\n       *\n \
    \      * Prescaler value\n       */\n      BitFieldModel<uint32_t, 0, 16> psc;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief PSC register\n   *\n   * prescaler\n\
    \   */\n  using psc = PscReg<BaseAddress + 0x0028>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class ArrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief ARR_H field\n     *\n     * High Auto-reload\
    \ value\n     */\n    using arr_h = FieldModel<uint32_t, address, 16, 16>;\n \
    \   /**\n     * @brief ARR_L field\n     *\n     * Low Auto-reload value\n   \
    \  */\n    using arr_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief ARR_H field\n       *\n       * High Auto-reload value\n    \
    \   */\n      BitFieldModel<uint32_t, 16, 16> arr_h;\n      /**\n       * @brief\
    \ ARR_L field\n       *\n       * Low Auto-reload value\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> arr_l;\n    };\n  };\n\npublic:\n  /**\n   * @brief ARR register\n  \
    \ *\n   * auto-reload register\n   */\n  using arr = ArrReg<BaseAddress + 0x002C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Ccr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CCR1_H field\n     *\n    \
    \ * High Capture/Compare 1\n     *               value\n     */\n    using ccr1_h\
    \ = FieldModel<uint32_t, address, 16, 16>;\n    /**\n     * @brief CCR1_L field\n\
    \     *\n     * Low Capture/Compare 1\n     *               value\n     */\n \
    \   using ccr1_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CCR1_H field\n       *\n       * High Capture/Compare 1\n       *          \
    \     value\n       */\n      BitFieldModel<uint32_t, 16, 16> ccr1_h;\n      /**\n\
    \       * @brief CCR1_L field\n       *\n       * Low Capture/Compare 1\n    \
    \   *               value\n       */\n      BitFieldModel<uint32_t, 0, 16> ccr1_l;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief CCR1 register\n   *\n   * capture/compare\
    \ register 1\n   */\n  using ccr1 = Ccr1Reg<BaseAddress + 0x0034>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Ccr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CCR2_H field\n     *\n    \
    \ * High Capture/Compare 2\n     *               value\n     */\n    using ccr2_h\
    \ = FieldModel<uint32_t, address, 16, 16>;\n    /**\n     * @brief CCR2_L field\n\
    \     *\n     * Low Capture/Compare 2\n     *               value\n     */\n \
    \   using ccr2_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CCR2_H field\n       *\n       * High Capture/Compare 2\n       *          \
    \     value\n       */\n      BitFieldModel<uint32_t, 16, 16> ccr2_h;\n      /**\n\
    \       * @brief CCR2_L field\n       *\n       * Low Capture/Compare 2\n    \
    \   *               value\n       */\n      BitFieldModel<uint32_t, 0, 16> ccr2_l;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief CCR2 register\n   *\n   * capture/compare\
    \ register 2\n   */\n  using ccr2 = Ccr2Reg<BaseAddress + 0x0038>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Ccr3Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CCR3_H field\n     *\n    \
    \ * High Capture/Compare value\n     */\n    using ccr3_h = FieldModel<uint32_t,\
    \ address, 16, 16>;\n    /**\n     * @brief CCR3_L field\n     *\n     * Low Capture/Compare\
    \ value\n     */\n    using ccr3_l = FieldModel<uint32_t, address, 0, 16>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief CCR3_H field\n       *\n       * High Capture/Compare\
    \ value\n       */\n      BitFieldModel<uint32_t, 16, 16> ccr3_h;\n      /**\n\
    \       * @brief CCR3_L field\n       *\n       * Low Capture/Compare value\n\
    \       */\n      BitFieldModel<uint32_t, 0, 16> ccr3_l;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CCR3 register\n   *\n   * capture/compare register 3\n   */\n\
    \  using ccr3 = Ccr3Reg<BaseAddress + 0x003C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccr4Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief CCR4_H field\n     *\n     * High Capture/Compare\
    \ value\n     */\n    using ccr4_h = FieldModel<uint32_t, address, 16, 16>;\n\
    \    /**\n     * @brief CCR4_L field\n     *\n     * Low Capture/Compare value\n\
    \     */\n    using ccr4_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CCR4_H field\n       *\n       * High Capture/Compare value\n\
    \       */\n      BitFieldModel<uint32_t, 16, 16> ccr4_h;\n      /**\n       *\
    \ @brief CCR4_L field\n       *\n       * Low Capture/Compare value\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ccr4_l;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief CCR4 register\n   *\n   * capture/compare register 4\n   */\n  using\
    \ ccr4 = Ccr4Reg<BaseAddress + 0x0040>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class DcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief DBL field\n     *\n     * DMA burst length\n     */\n  \
    \  using dbl = FieldModel<uint32_t, address, 8, 5>;\n    /**\n     * @brief DBA\
    \ field\n     *\n     * DMA base address\n     */\n    using dba = FieldModel<uint32_t,\
    \ address, 0, 5>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief DBL field\n       *\n \
    \      * DMA burst length\n       */\n      BitFieldModel<uint32_t, 8, 5> dbl;\n\
    \      /**\n       * @brief DBA field\n       *\n       * DMA base address\n \
    \      */\n      BitFieldModel<uint32_t, 0, 5> dba;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief DCR register\n   *\n   * DMA control register\n   */\n  using\
    \ dcr = DcrReg<BaseAddress + 0x0048>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class DmarReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief DMAB field\n     *\n     * DMA register for burst\n   \
    \  *               accesses\n     */\n    using dmab = FieldModel<uint32_t, address,\
    \ 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief DMAB field\n       *\n\
    \       * DMA register for burst\n       *               accesses\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> dmab;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief DMAR register\n   *\n   * DMA address for full transfer\n   */\n\
    \  using dmar = DmarReg<BaseAddress + 0x004C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class OrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief ITR1_RMP field\n     *\n     * Timer Input\
    \ 4 remap\n     */\n    using itr1_rmp = FieldModel<uint32_t, address, 10, 2>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief ITR1_RMP field\n       *\n       * Timer\
    \ Input 4 remap\n       */\n      BitFieldModel<uint32_t, 10, 2> itr1_rmp;\n \
    \   };\n  };\n\npublic:\n  /**\n   * @brief OR register\n   *\n   * TIM5 option\
    \ register\n   */\n  using or_ = OrReg<BaseAddress + 0x0050>;\n\n};\n\n}\n\n#endif\
    \ /* DRAL_STM32F411_TIM2_H */"
  name: TIM2
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_TIM3_H\n#define DRAL_STM32F411_TIM3_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ TIM3 peripheral\n *\n * General purpose timers\n */\nclass tim3\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40000400; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CKD\
    \ field\n     *\n     * Clock division\n     */\n    using ckd = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief ARPE field\n     *\n     * Auto-reload\
    \ preload enable\n     */\n    using arpe = FieldModel<uint32_t, address, 7, 1>;\n\
    \    /**\n     * @brief CMS field\n     *\n     * Center-aligned mode\n     *\
    \               selection\n     */\n    using cms = FieldModel<uint32_t, address,\
    \ 5, 2>;\n    /**\n     * @brief DIR field\n     *\n     * Direction\n     */\n\
    \    using dir = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief\
    \ OPM field\n     *\n     * One-pulse mode\n     */\n    using opm = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief URS field\n     *\n     * Update request\
    \ source\n     */\n    using urs = FieldModel<uint32_t, address, 2, 1>;\n    /**\n\
    \     * @brief UDIS field\n     *\n     * Update disable\n     */\n    using udis\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief CEN field\n \
    \    *\n     * Counter enable\n     */\n    using cen = FieldModel<uint32_t, address,\
    \ 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief CKD field\n       *\n     \
    \  * Clock division\n       */\n      BitFieldModel<uint32_t, 8, 2> ckd;\n   \
    \   /**\n       * @brief ARPE field\n       *\n       * Auto-reload preload enable\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> arpe;\n      /**\n       * @brief\
    \ CMS field\n       *\n       * Center-aligned mode\n       *               selection\n\
    \       */\n      BitFieldModel<uint32_t, 5, 2> cms;\n      /**\n       * @brief\
    \ DIR field\n       *\n       * Direction\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> dir;\n      /**\n       * @brief OPM field\n       *\n       * One-pulse\
    \ mode\n       */\n      BitFieldModel<uint32_t, 3, 1> opm;\n      /**\n     \
    \  * @brief URS field\n       *\n       * Update request source\n       */\n \
    \     BitFieldModel<uint32_t, 2, 1> urs;\n      /**\n       * @brief UDIS field\n\
    \       *\n       * Update disable\n       */\n      BitFieldModel<uint32_t, 1,\
    \ 1> udis;\n      /**\n       * @brief CEN field\n       *\n       * Counter enable\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> cen;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR1 register\n   *\n   * control register 1\n   */\n  using\
    \ cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief TI1S field\n     *\n     * TI1 selection\n     */\n    using\
    \ ti1s = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief MMS field\n\
    \     *\n     * Master mode selection\n     */\n    using mms = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    /**\n     * @brief CCDS field\n     *\n     * Capture/compare\
    \ DMA\n     *               selection\n     */\n    using ccds = FieldModel<uint32_t,\
    \ address, 3, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief TI1S field\n       *\n\
    \       * TI1 selection\n       */\n      BitFieldModel<uint32_t, 7, 1> ti1s;\n\
    \      /**\n       * @brief MMS field\n       *\n       * Master mode selection\n\
    \       */\n      BitFieldModel<uint32_t, 4, 3> mms;\n      /**\n       * @brief\
    \ CCDS field\n       *\n       * Capture/compare DMA\n       *               selection\n\
    \       */\n      BitFieldModel<uint32_t, 3, 1> ccds;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR2 register\n   *\n   * control register 2\n   */\n  using\
    \ cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class SmcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief ETP field\n     *\n     * External trigger polarity\n \
    \    */\n    using etp = FieldModel<uint32_t, address, 15, 1>;\n    /**\n    \
    \ * @brief ECE field\n     *\n     * External clock enable\n     */\n    using\
    \ ece = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief ETPS field\n\
    \     *\n     * External trigger prescaler\n     */\n    using etps = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    /**\n     * @brief ETF field\n     *\n     * External\
    \ trigger filter\n     */\n    using etf = FieldModel<uint32_t, address, 8, 4>;\n\
    \    /**\n     * @brief MSM field\n     *\n     * Master/Slave mode\n     */\n\
    \    using msm = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief\
    \ TS field\n     *\n     * Trigger selection\n     */\n    using ts = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    /**\n     * @brief SMS field\n     *\n     * Slave mode\
    \ selection\n     */\n    using sms = FieldModel<uint32_t, address, 0, 3>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief ETP field\n       *\n       * External trigger\
    \ polarity\n       */\n      BitFieldModel<uint32_t, 15, 1> etp;\n      /**\n\
    \       * @brief ECE field\n       *\n       * External clock enable\n       */\n\
    \      BitFieldModel<uint32_t, 14, 1> ece;\n      /**\n       * @brief ETPS field\n\
    \       *\n       * External trigger prescaler\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 2> etps;\n      /**\n       * @brief ETF field\n       *\n       * External\
    \ trigger filter\n       */\n      BitFieldModel<uint32_t, 8, 4> etf;\n      /**\n\
    \       * @brief MSM field\n       *\n       * Master/Slave mode\n       */\n\
    \      BitFieldModel<uint32_t, 7, 1> msm;\n      /**\n       * @brief TS field\n\
    \       *\n       * Trigger selection\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 3> ts;\n      /**\n       * @brief SMS field\n       *\n       * Slave mode\
    \ selection\n       */\n      BitFieldModel<uint32_t, 0, 3> sms;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief SMCR register\n   *\n   * slave mode control register\n\
    \   */\n  using smcr = SmcrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DierReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief TDE field\n     *\n     * Trigger DMA request\
    \ enable\n     */\n    using tde = FieldModel<uint32_t, address, 14, 1>;\n   \
    \ /**\n     * @brief CC4DE field\n     *\n     * Capture/Compare 4 DMA request\n\
    \     *               enable\n     */\n    using cc4de = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief CC3DE field\n     *\n     * Capture/Compare\
    \ 3 DMA request\n     *               enable\n     */\n    using cc3de = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief CC2DE field\n     *\n     * Capture/Compare\
    \ 2 DMA request\n     *               enable\n     */\n    using cc2de = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief CC1DE field\n     *\n     * Capture/Compare\
    \ 1 DMA request\n     *               enable\n     */\n    using cc1de = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief UDE field\n     *\n     * Update DMA\
    \ request enable\n     */\n    using ude = FieldModel<uint32_t, address, 8, 1>;\n\
    \    /**\n     * @brief TIE field\n     *\n     * Trigger interrupt enable\n \
    \    */\n    using tie = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     *\
    \ @brief CC4IE field\n     *\n     * Capture/Compare 4 interrupt\n     *     \
    \          enable\n     */\n    using cc4ie = FieldModel<uint32_t, address, 4,\
    \ 1>;\n    /**\n     * @brief CC3IE field\n     *\n     * Capture/Compare 3 interrupt\n\
    \     *               enable\n     */\n    using cc3ie = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief CC2IE field\n     *\n     * Capture/Compare\
    \ 2 interrupt\n     *               enable\n     */\n    using cc2ie = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1IE field\n     *\n     * Capture/Compare\
    \ 1 interrupt\n     *               enable\n     */\n    using cc1ie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UIE field\n     *\n     * Update interrupt\
    \ enable\n     */\n    using uie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief TDE field\n       *\n       * Trigger DMA request enable\n  \
    \     */\n      BitFieldModel<uint32_t, 14, 1> tde;\n      /**\n       * @brief\
    \ CC4DE field\n       *\n       * Capture/Compare 4 DMA request\n       *    \
    \           enable\n       */\n      BitFieldModel<uint32_t, 12, 1> cc4de;\n \
    \     /**\n       * @brief CC3DE field\n       *\n       * Capture/Compare 3 DMA\
    \ request\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> cc3de;\n      /**\n       * @brief CC2DE field\n       *\n       * Capture/Compare\
    \ 2 DMA request\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> cc2de;\n      /**\n       * @brief CC1DE field\n       *\n       * Capture/Compare\
    \ 1 DMA request\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc1de;\n      /**\n       * @brief UDE field\n       *\n       * Update\
    \ DMA request enable\n       */\n      BitFieldModel<uint32_t, 8, 1> ude;\n  \
    \    /**\n       * @brief TIE field\n       *\n       * Trigger interrupt enable\n\
    \       */\n      BitFieldModel<uint32_t, 6, 1> tie;\n      /**\n       * @brief\
    \ CC4IE field\n       *\n       * Capture/Compare 4 interrupt\n       *      \
    \         enable\n       */\n      BitFieldModel<uint32_t, 4, 1> cc4ie;\n    \
    \  /**\n       * @brief CC3IE field\n       *\n       * Capture/Compare 3 interrupt\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 3, 1>\
    \ cc3ie;\n      /**\n       * @brief CC2IE field\n       *\n       * Capture/Compare\
    \ 2 interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cc2ie;\n      /**\n       * @brief CC1IE field\n       *\n       * Capture/Compare\
    \ 1 interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1ie;\n      /**\n       * @brief UIE field\n       *\n       * Update\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 0, 1> uie;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief DIER register\n   *\n   * DMA/Interrupt enable\
    \ register\n   */\n  using dier = DierReg<BaseAddress + 0x000C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CC4OF field\n     *\n     *\
    \ Capture/Compare 4 overcapture\n     *               flag\n     */\n    using\
    \ cc4of = FieldModel<uint32_t, address, 12, 1>;\n    /**\n     * @brief CC3OF\
    \ field\n     *\n     * Capture/Compare 3 overcapture\n     *               flag\n\
    \     */\n    using cc3of = FieldModel<uint32_t, address, 11, 1>;\n    /**\n \
    \    * @brief CC2OF field\n     *\n     * Capture/compare 2 overcapture\n    \
    \ *               flag\n     */\n    using cc2of = FieldModel<uint32_t, address,\
    \ 10, 1>;\n    /**\n     * @brief CC1OF field\n     *\n     * Capture/Compare\
    \ 1 overcapture\n     *               flag\n     */\n    using cc1of = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief TIF field\n     *\n     * Trigger interrupt\
    \ flag\n     */\n    using tif = FieldModel<uint32_t, address, 6, 1>;\n    /**\n\
    \     * @brief CC4IF field\n     *\n     * Capture/Compare 4 interrupt\n     *\
    \               flag\n     */\n    using cc4if = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief CC3IF field\n     *\n     * Capture/Compare 3\
    \ interrupt\n     *               flag\n     */\n    using cc3if = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief CC2IF field\n     *\n     * Capture/Compare\
    \ 2 interrupt\n     *               flag\n     */\n    using cc2if = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1IF field\n     *\n     * Capture/compare\
    \ 1 interrupt\n     *               flag\n     */\n    using cc1if = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UIF field\n     *\n     * Update interrupt\
    \ flag\n     */\n    using uif = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CC4OF field\n       *\n       * Capture/Compare 4 overcapture\n\
    \       *               flag\n       */\n      BitFieldModel<uint32_t, 12, 1>\
    \ cc4of;\n      /**\n       * @brief CC3OF field\n       *\n       * Capture/Compare\
    \ 3 overcapture\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> cc3of;\n      /**\n       * @brief CC2OF field\n       *\n       * Capture/compare\
    \ 2 overcapture\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> cc2of;\n      /**\n       * @brief CC1OF field\n       *\n       * Capture/Compare\
    \ 1 overcapture\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc1of;\n      /**\n       * @brief TIF field\n       *\n       * Trigger\
    \ interrupt flag\n       */\n      BitFieldModel<uint32_t, 6, 1> tif;\n      /**\n\
    \       * @brief CC4IF field\n       *\n       * Capture/Compare 4 interrupt\n\
    \       *               flag\n       */\n      BitFieldModel<uint32_t, 4, 1> cc4if;\n\
    \      /**\n       * @brief CC3IF field\n       *\n       * Capture/Compare 3\
    \ interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3if;\n      /**\n       * @brief CC2IF field\n       *\n       * Capture/Compare\
    \ 2 interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cc2if;\n      /**\n       * @brief CC1IF field\n       *\n       * Capture/compare\
    \ 1 interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1if;\n      /**\n       * @brief UIF field\n       *\n       * Update\
    \ interrupt flag\n       */\n      BitFieldModel<uint32_t, 0, 1> uif;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief SR register\n   *\n   * status register\n\
    \   */\n  using sr = SrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class EgrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief TG field\n     *\n     * Trigger generation\n\
    \     */\n    using tg = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     *\
    \ @brief CC4G field\n     *\n     * Capture/compare 4\n     *               generation\n\
    \     */\n    using cc4g = FieldModel<uint32_t, address, 4, 1>;\n    /**\n   \
    \  * @brief CC3G field\n     *\n     * Capture/compare 3\n     *             \
    \  generation\n     */\n    using cc3g = FieldModel<uint32_t, address, 3, 1>;\n\
    \    /**\n     * @brief CC2G field\n     *\n     * Capture/compare 2\n     * \
    \              generation\n     */\n    using cc2g = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief CC1G field\n     *\n     * Capture/compare 1\n\
    \     *               generation\n     */\n    using cc1g = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UG field\n     *\n     * Update generation\n\
    \     */\n    using ug = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n \
    \   /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief TG field\n       *\n       * Trigger generation\n       */\n\
    \      BitFieldModel<uint32_t, 6, 1> tg;\n      /**\n       * @brief CC4G field\n\
    \       *\n       * Capture/compare 4\n       *               generation\n   \
    \    */\n      BitFieldModel<uint32_t, 4, 1> cc4g;\n      /**\n       * @brief\
    \ CC3G field\n       *\n       * Capture/compare 3\n       *               generation\n\
    \       */\n      BitFieldModel<uint32_t, 3, 1> cc3g;\n      /**\n       * @brief\
    \ CC2G field\n       *\n       * Capture/compare 2\n       *               generation\n\
    \       */\n      BitFieldModel<uint32_t, 2, 1> cc2g;\n      /**\n       * @brief\
    \ CC1G field\n       *\n       * Capture/compare 1\n       *               generation\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> cc1g;\n      /**\n       * @brief\
    \ UG field\n       *\n       * Update generation\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> ug;\n    };\n  };\n\npublic:\n  /**\n   * @brief EGR register\n   *\n\
    \   * event generation register\n   */\n  using egr = EgrReg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Ccmr1_outputReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief OC2CE\
    \ field\n     *\n     * OC2CE\n     */\n    using oc2ce = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief OC2M field\n     *\n     * OC2M\n \
    \    */\n    using oc2m = FieldModel<uint32_t, address, 12, 3>;\n    /**\n   \
    \  * @brief OC2PE field\n     *\n     * OC2PE\n     */\n    using oc2pe = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief OC2FE field\n     *\n     * OC2FE\n\
    \     */\n    using oc2fe = FieldModel<uint32_t, address, 10, 1>;\n    /**\n \
    \    * @brief CC2S field\n     *\n     * CC2S\n     */\n    using cc2s = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief OC1CE field\n     *\n     * OC1CE\n\
    \     */\n    using oc1ce = FieldModel<uint32_t, address, 7, 1>;\n    /**\n  \
    \   * @brief OC1M field\n     *\n     * OC1M\n     */\n    using oc1m = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    /**\n     * @brief OC1PE field\n     *\n     * OC1PE\n\
    \     */\n    using oc1pe = FieldModel<uint32_t, address, 3, 1>;\n    /**\n  \
    \   * @brief OC1FE field\n     *\n     * OC1FE\n     */\n    using oc1fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1S field\n     *\n     * CC1S\n  \
    \   */\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n \
    \   /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief OC2CE field\n       *\n       * OC2CE\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> oc2ce;\n      /**\n       * @brief OC2M field\n       *\n       * OC2M\n\
    \       */\n      BitFieldModel<uint32_t, 12, 3> oc2m;\n      /**\n       * @brief\
    \ OC2PE field\n       *\n       * OC2PE\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> oc2pe;\n      /**\n       * @brief OC2FE field\n       *\n       * OC2FE\n\
    \       */\n      BitFieldModel<uint32_t, 10, 1> oc2fe;\n      /**\n       * @brief\
    \ CC2S field\n       *\n       * CC2S\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc2s;\n      /**\n       * @brief OC1CE field\n       *\n       * OC1CE\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> oc1ce;\n      /**\n       * @brief\
    \ OC1M field\n       *\n       * OC1M\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 3> oc1m;\n      /**\n       * @brief OC1PE field\n       *\n       * OC1PE\n\
    \       */\n      BitFieldModel<uint32_t, 3, 1> oc1pe;\n      /**\n       * @brief\
    \ OC1FE field\n       *\n       * OC1FE\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc1fe;\n      /**\n       * @brief CC1S field\n       *\n       * CC1S\n\
    \       */\n      BitFieldModel<uint32_t, 0, 2> cc1s;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CCMR1_OUTPUT register\n   *\n   * capture/compare mode register\
    \ 1 (output\n   *           mode)\n   */\n  using ccmr1_output = Ccmr1_outputReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class Ccmr1_inputReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ IC2F field\n     *\n     * Input capture 2 filter\n     */\n    using ic2f =\
    \ FieldModel<uint32_t, address, 12, 4>;\n    /**\n     * @brief IC2PCS field\n\
    \     *\n     * Input capture 2 prescaler\n     */\n    using ic2pcs = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    /**\n     * @brief CC2S field\n     *\n     * Capture/Compare\
    \ 2\n     *               selection\n     */\n    using cc2s = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief IC1F field\n     *\n     * Input capture\
    \ 1 filter\n     */\n    using ic1f = FieldModel<uint32_t, address, 4, 4>;\n \
    \   /**\n     * @brief ICPCS field\n     *\n     * Input capture 1 prescaler\n\
    \     */\n    using icpcs = FieldModel<uint32_t, address, 2, 2>;\n    /**\n  \
    \   * @brief CC1S field\n     *\n     * Capture/Compare 1\n     *            \
    \   selection\n     */\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief IC2F field\n       *\n       * Input capture\
    \ 2 filter\n       */\n      BitFieldModel<uint32_t, 12, 4> ic2f;\n      /**\n\
    \       * @brief IC2PCS field\n       *\n       * Input capture 2 prescaler\n\
    \       */\n      BitFieldModel<uint32_t, 10, 2> ic2pcs;\n      /**\n       *\
    \ @brief CC2S field\n       *\n       * Capture/Compare 2\n       *          \
    \     selection\n       */\n      BitFieldModel<uint32_t, 8, 2> cc2s;\n      /**\n\
    \       * @brief IC1F field\n       *\n       * Input capture 1 filter\n     \
    \  */\n      BitFieldModel<uint32_t, 4, 4> ic1f;\n      /**\n       * @brief ICPCS\
    \ field\n       *\n       * Input capture 1 prescaler\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 2> icpcs;\n      /**\n       * @brief CC1S field\n       *\n       * Capture/Compare\
    \ 1\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc1s;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCMR1_INPUT register\n\
    \   *\n   * capture/compare mode register 1 (input\n   *           mode)\n   */\n\
    \  using ccmr1_input = Ccmr1_inputReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr2_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief OC4CE field\n     *\n     * OC4CE\n  \
    \   */\n    using oc4ce = FieldModel<uint32_t, address, 15, 1>;\n    /**\n   \
    \  * @brief OC4M field\n     *\n     * OC4M\n     */\n    using oc4m = FieldModel<uint32_t,\
    \ address, 12, 3>;\n    /**\n     * @brief OC4PE field\n     *\n     * OC4PE\n\
    \     */\n    using oc4pe = FieldModel<uint32_t, address, 11, 1>;\n    /**\n \
    \    * @brief OC4FE field\n     *\n     * OC4FE\n     */\n    using oc4fe = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief CC4S field\n     *\n     * CC4S\n \
    \    */\n    using cc4s = FieldModel<uint32_t, address, 8, 2>;\n    /**\n    \
    \ * @brief OC3CE field\n     *\n     * OC3CE\n     */\n    using oc3ce = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief OC3M field\n     *\n     * OC3M\n  \
    \   */\n    using oc3m = FieldModel<uint32_t, address, 4, 3>;\n    /**\n     *\
    \ @brief OC3PE field\n     *\n     * OC3PE\n     */\n    using oc3pe = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief OC3FE field\n     *\n     * OC3FE\n\
    \     */\n    using oc3fe = FieldModel<uint32_t, address, 2, 1>;\n    /**\n  \
    \   * @brief CC3S field\n     *\n     * CC3S\n     */\n    using cc3s = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OC4CE field\n       *\n\
    \       * OC4CE\n       */\n      BitFieldModel<uint32_t, 15, 1> oc4ce;\n    \
    \  /**\n       * @brief OC4M field\n       *\n       * OC4M\n       */\n     \
    \ BitFieldModel<uint32_t, 12, 3> oc4m;\n      /**\n       * @brief OC4PE field\n\
    \       *\n       * OC4PE\n       */\n      BitFieldModel<uint32_t, 11, 1> oc4pe;\n\
    \      /**\n       * @brief OC4FE field\n       *\n       * OC4FE\n       */\n\
    \      BitFieldModel<uint32_t, 10, 1> oc4fe;\n      /**\n       * @brief CC4S\
    \ field\n       *\n       * CC4S\n       */\n      BitFieldModel<uint32_t, 8,\
    \ 2> cc4s;\n      /**\n       * @brief OC3CE field\n       *\n       * OC3CE\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> oc3ce;\n      /**\n       * @brief\
    \ OC3M field\n       *\n       * OC3M\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 3> oc3m;\n      /**\n       * @brief OC3PE field\n       *\n       * OC3PE\n\
    \       */\n      BitFieldModel<uint32_t, 3, 1> oc3pe;\n      /**\n       * @brief\
    \ OC3FE field\n       *\n       * OC3FE\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc3fe;\n      /**\n       * @brief CC3S field\n       *\n       * CC3S\n\
    \       */\n      BitFieldModel<uint32_t, 0, 2> cc3s;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CCMR2_OUTPUT register\n   *\n   * capture/compare mode register\
    \ 2 (output\n   *           mode)\n   */\n  using ccmr2_output = Ccmr2_outputReg<BaseAddress\
    \ + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class Ccmr2_inputReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ IC4F field\n     *\n     * Input capture 4 filter\n     */\n    using ic4f =\
    \ FieldModel<uint32_t, address, 12, 4>;\n    /**\n     * @brief IC4PSC field\n\
    \     *\n     * Input capture 4 prescaler\n     */\n    using ic4psc = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    /**\n     * @brief CC4S field\n     *\n     * Capture/Compare\
    \ 4\n     *               selection\n     */\n    using cc4s = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief IC3F field\n     *\n     * Input capture\
    \ 3 filter\n     */\n    using ic3f = FieldModel<uint32_t, address, 4, 4>;\n \
    \   /**\n     * @brief IC3PSC field\n     *\n     * Input capture 3 prescaler\n\
    \     */\n    using ic3psc = FieldModel<uint32_t, address, 2, 2>;\n    /**\n \
    \    * @brief CC3S field\n     *\n     * Capture/compare 3\n     *           \
    \    selection\n     */\n    using cc3s = FieldModel<uint32_t, address, 0, 2>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief IC4F field\n       *\n       * Input capture\
    \ 4 filter\n       */\n      BitFieldModel<uint32_t, 12, 4> ic4f;\n      /**\n\
    \       * @brief IC4PSC field\n       *\n       * Input capture 4 prescaler\n\
    \       */\n      BitFieldModel<uint32_t, 10, 2> ic4psc;\n      /**\n       *\
    \ @brief CC4S field\n       *\n       * Capture/Compare 4\n       *          \
    \     selection\n       */\n      BitFieldModel<uint32_t, 8, 2> cc4s;\n      /**\n\
    \       * @brief IC3F field\n       *\n       * Input capture 3 filter\n     \
    \  */\n      BitFieldModel<uint32_t, 4, 4> ic3f;\n      /**\n       * @brief IC3PSC\
    \ field\n       *\n       * Input capture 3 prescaler\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 2> ic3psc;\n      /**\n       * @brief CC3S field\n       *\n       * Capture/compare\
    \ 3\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc3s;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCMR2_INPUT register\n\
    \   *\n   * capture/compare mode register 2 (input\n   *           mode)\n   */\n\
    \  using ccmr2_input = Ccmr2_inputReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CcerReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief CC4NP field\n     *\n     * Capture/Compare\
    \ 4 output\n     *               Polarity\n     */\n    using cc4np = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief CC4P field\n     *\n     * Capture/Compare\
    \ 3 output\n     *               Polarity\n     */\n    using cc4p = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief CC4E field\n     *\n     * Capture/Compare\
    \ 4 output\n     *               enable\n     */\n    using cc4e = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief CC3NP field\n     *\n     * Capture/Compare\
    \ 3 output\n     *               Polarity\n     */\n    using cc3np = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief CC3P field\n     *\n     * Capture/Compare\
    \ 3 output\n     *               Polarity\n     */\n    using cc3p = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief CC3E field\n     *\n     * Capture/Compare\
    \ 3 output\n     *               enable\n     */\n    using cc3e = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief CC2NP field\n     *\n     * Capture/Compare\
    \ 2 output\n     *               Polarity\n     */\n    using cc2np = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief CC2P field\n     *\n     * Capture/Compare\
    \ 2 output\n     *               Polarity\n     */\n    using cc2p = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief CC2E field\n     *\n     * Capture/Compare\
    \ 2 output\n     *               enable\n     */\n    using cc2e = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief CC1NP field\n     *\n     * Capture/Compare\
    \ 1 output\n     *               Polarity\n     */\n    using cc1np = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief CC1P field\n     *\n     * Capture/Compare\
    \ 1 output\n     *               Polarity\n     */\n    using cc1p = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief CC1E field\n     *\n     * Capture/Compare\
    \ 1 output\n     *               enable\n     */\n    using cc1e = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CC4NP field\n       *\n\
    \       * Capture/Compare 4 output\n       *               Polarity\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> cc4np;\n      /**\n       * @brief CC4P\
    \ field\n       *\n       * Capture/Compare 3 output\n       *               Polarity\n\
    \       */\n      BitFieldModel<uint32_t, 13, 1> cc4p;\n      /**\n       * @brief\
    \ CC4E field\n       *\n       * Capture/Compare 4 output\n       *          \
    \     enable\n       */\n      BitFieldModel<uint32_t, 12, 1> cc4e;\n      /**\n\
    \       * @brief CC3NP field\n       *\n       * Capture/Compare 3 output\n  \
    \     *               Polarity\n       */\n      BitFieldModel<uint32_t, 11, 1>\
    \ cc3np;\n      /**\n       * @brief CC3P field\n       *\n       * Capture/Compare\
    \ 3 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc3p;\n      /**\n       * @brief CC3E field\n       *\n       * Capture/Compare\
    \ 3 output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> cc3e;\n      /**\n       * @brief CC2NP field\n       *\n       * Capture/Compare\
    \ 2 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> cc2np;\n      /**\n       * @brief CC2P field\n       *\n       * Capture/Compare\
    \ 2 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> cc2p;\n      /**\n       * @brief CC2E field\n       *\n       * Capture/Compare\
    \ 2 output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> cc2e;\n      /**\n       * @brief CC1NP field\n       *\n       * Capture/Compare\
    \ 1 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc1np;\n      /**\n       * @brief CC1P field\n       *\n       * Capture/Compare\
    \ 1 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1p;\n      /**\n       * @brief CC1E field\n       *\n       * Capture/Compare\
    \ 1 output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> cc1e;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCER register\n   *\n\
    \   * capture/compare enable\n   *           register\n   */\n  using ccer = CcerReg<BaseAddress\
    \ + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n  class CntReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CNT_H\
    \ field\n     *\n     * High counter value\n     */\n    using cnt_h = FieldModel<uint32_t,\
    \ address, 16, 16>;\n    /**\n     * @brief CNT_L field\n     *\n     * Low counter\
    \ value\n     */\n    using cnt_l = FieldModel<uint32_t, address, 0, 16>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief CNT_H field\n       *\n       * High counter\
    \ value\n       */\n      BitFieldModel<uint32_t, 16, 16> cnt_h;\n      /**\n\
    \       * @brief CNT_L field\n       *\n       * Low counter value\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> cnt_l;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief CNT register\n   *\n   * counter\n   */\n  using cnt = CntReg<BaseAddress\
    \ + 0x0024>;\n\nprivate:\n  template<unsigned int address>\n  class PscReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief PSC\
    \ field\n     *\n     * Prescaler value\n     */\n    using psc = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief PSC field\n       *\n \
    \      * Prescaler value\n       */\n      BitFieldModel<uint32_t, 0, 16> psc;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief PSC register\n   *\n   * prescaler\n\
    \   */\n  using psc = PscReg<BaseAddress + 0x0028>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class ArrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief ARR_H field\n     *\n     * High Auto-reload\
    \ value\n     */\n    using arr_h = FieldModel<uint32_t, address, 16, 16>;\n \
    \   /**\n     * @brief ARR_L field\n     *\n     * Low Auto-reload value\n   \
    \  */\n    using arr_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief ARR_H field\n       *\n       * High Auto-reload value\n    \
    \   */\n      BitFieldModel<uint32_t, 16, 16> arr_h;\n      /**\n       * @brief\
    \ ARR_L field\n       *\n       * Low Auto-reload value\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> arr_l;\n    };\n  };\n\npublic:\n  /**\n   * @brief ARR register\n  \
    \ *\n   * auto-reload register\n   */\n  using arr = ArrReg<BaseAddress + 0x002C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Ccr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CCR1_H field\n     *\n    \
    \ * High Capture/Compare 1\n     *               value\n     */\n    using ccr1_h\
    \ = FieldModel<uint32_t, address, 16, 16>;\n    /**\n     * @brief CCR1_L field\n\
    \     *\n     * Low Capture/Compare 1\n     *               value\n     */\n \
    \   using ccr1_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CCR1_H field\n       *\n       * High Capture/Compare 1\n       *          \
    \     value\n       */\n      BitFieldModel<uint32_t, 16, 16> ccr1_h;\n      /**\n\
    \       * @brief CCR1_L field\n       *\n       * Low Capture/Compare 1\n    \
    \   *               value\n       */\n      BitFieldModel<uint32_t, 0, 16> ccr1_l;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief CCR1 register\n   *\n   * capture/compare\
    \ register 1\n   */\n  using ccr1 = Ccr1Reg<BaseAddress + 0x0034>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Ccr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CCR2_H field\n     *\n    \
    \ * High Capture/Compare 2\n     *               value\n     */\n    using ccr2_h\
    \ = FieldModel<uint32_t, address, 16, 16>;\n    /**\n     * @brief CCR2_L field\n\
    \     *\n     * Low Capture/Compare 2\n     *               value\n     */\n \
    \   using ccr2_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CCR2_H field\n       *\n       * High Capture/Compare 2\n       *          \
    \     value\n       */\n      BitFieldModel<uint32_t, 16, 16> ccr2_h;\n      /**\n\
    \       * @brief CCR2_L field\n       *\n       * Low Capture/Compare 2\n    \
    \   *               value\n       */\n      BitFieldModel<uint32_t, 0, 16> ccr2_l;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief CCR2 register\n   *\n   * capture/compare\
    \ register 2\n   */\n  using ccr2 = Ccr2Reg<BaseAddress + 0x0038>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Ccr3Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CCR3_H field\n     *\n    \
    \ * High Capture/Compare value\n     */\n    using ccr3_h = FieldModel<uint32_t,\
    \ address, 16, 16>;\n    /**\n     * @brief CCR3_L field\n     *\n     * Low Capture/Compare\
    \ value\n     */\n    using ccr3_l = FieldModel<uint32_t, address, 0, 16>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief CCR3_H field\n       *\n       * High Capture/Compare\
    \ value\n       */\n      BitFieldModel<uint32_t, 16, 16> ccr3_h;\n      /**\n\
    \       * @brief CCR3_L field\n       *\n       * Low Capture/Compare value\n\
    \       */\n      BitFieldModel<uint32_t, 0, 16> ccr3_l;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CCR3 register\n   *\n   * capture/compare register 3\n   */\n\
    \  using ccr3 = Ccr3Reg<BaseAddress + 0x003C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccr4Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief CCR4_H field\n     *\n     * High Capture/Compare\
    \ value\n     */\n    using ccr4_h = FieldModel<uint32_t, address, 16, 16>;\n\
    \    /**\n     * @brief CCR4_L field\n     *\n     * Low Capture/Compare value\n\
    \     */\n    using ccr4_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CCR4_H field\n       *\n       * High Capture/Compare value\n\
    \       */\n      BitFieldModel<uint32_t, 16, 16> ccr4_h;\n      /**\n       *\
    \ @brief CCR4_L field\n       *\n       * Low Capture/Compare value\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ccr4_l;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief CCR4 register\n   *\n   * capture/compare register 4\n   */\n  using\
    \ ccr4 = Ccr4Reg<BaseAddress + 0x0040>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class DcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief DBL field\n     *\n     * DMA burst length\n     */\n  \
    \  using dbl = FieldModel<uint32_t, address, 8, 5>;\n    /**\n     * @brief DBA\
    \ field\n     *\n     * DMA base address\n     */\n    using dba = FieldModel<uint32_t,\
    \ address, 0, 5>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief DBL field\n       *\n \
    \      * DMA burst length\n       */\n      BitFieldModel<uint32_t, 8, 5> dbl;\n\
    \      /**\n       * @brief DBA field\n       *\n       * DMA base address\n \
    \      */\n      BitFieldModel<uint32_t, 0, 5> dba;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief DCR register\n   *\n   * DMA control register\n   */\n  using\
    \ dcr = DcrReg<BaseAddress + 0x0048>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class DmarReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief DMAB field\n     *\n     * DMA register for burst\n   \
    \  *               accesses\n     */\n    using dmab = FieldModel<uint32_t, address,\
    \ 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief DMAB field\n       *\n\
    \       * DMA register for burst\n       *               accesses\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> dmab;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief DMAR register\n   *\n   * DMA address for full transfer\n   */\n\
    \  using dmar = DmarReg<BaseAddress + 0x004C>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_TIM3_H\
    \ */"
  name: TIM3
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_TIM4_H\n#define DRAL_STM32F411_TIM4_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ TIM4 peripheral\n *\n * General purpose timers\n */\nclass tim4\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40000800; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CKD\
    \ field\n     *\n     * Clock division\n     */\n    using ckd = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief ARPE field\n     *\n     * Auto-reload\
    \ preload enable\n     */\n    using arpe = FieldModel<uint32_t, address, 7, 1>;\n\
    \    /**\n     * @brief CMS field\n     *\n     * Center-aligned mode\n     *\
    \               selection\n     */\n    using cms = FieldModel<uint32_t, address,\
    \ 5, 2>;\n    /**\n     * @brief DIR field\n     *\n     * Direction\n     */\n\
    \    using dir = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief\
    \ OPM field\n     *\n     * One-pulse mode\n     */\n    using opm = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief URS field\n     *\n     * Update request\
    \ source\n     */\n    using urs = FieldModel<uint32_t, address, 2, 1>;\n    /**\n\
    \     * @brief UDIS field\n     *\n     * Update disable\n     */\n    using udis\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief CEN field\n \
    \    *\n     * Counter enable\n     */\n    using cen = FieldModel<uint32_t, address,\
    \ 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief CKD field\n       *\n     \
    \  * Clock division\n       */\n      BitFieldModel<uint32_t, 8, 2> ckd;\n   \
    \   /**\n       * @brief ARPE field\n       *\n       * Auto-reload preload enable\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> arpe;\n      /**\n       * @brief\
    \ CMS field\n       *\n       * Center-aligned mode\n       *               selection\n\
    \       */\n      BitFieldModel<uint32_t, 5, 2> cms;\n      /**\n       * @brief\
    \ DIR field\n       *\n       * Direction\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> dir;\n      /**\n       * @brief OPM field\n       *\n       * One-pulse\
    \ mode\n       */\n      BitFieldModel<uint32_t, 3, 1> opm;\n      /**\n     \
    \  * @brief URS field\n       *\n       * Update request source\n       */\n \
    \     BitFieldModel<uint32_t, 2, 1> urs;\n      /**\n       * @brief UDIS field\n\
    \       *\n       * Update disable\n       */\n      BitFieldModel<uint32_t, 1,\
    \ 1> udis;\n      /**\n       * @brief CEN field\n       *\n       * Counter enable\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> cen;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR1 register\n   *\n   * control register 1\n   */\n  using\
    \ cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief TI1S field\n     *\n     * TI1 selection\n     */\n    using\
    \ ti1s = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief MMS field\n\
    \     *\n     * Master mode selection\n     */\n    using mms = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    /**\n     * @brief CCDS field\n     *\n     * Capture/compare\
    \ DMA\n     *               selection\n     */\n    using ccds = FieldModel<uint32_t,\
    \ address, 3, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief TI1S field\n       *\n\
    \       * TI1 selection\n       */\n      BitFieldModel<uint32_t, 7, 1> ti1s;\n\
    \      /**\n       * @brief MMS field\n       *\n       * Master mode selection\n\
    \       */\n      BitFieldModel<uint32_t, 4, 3> mms;\n      /**\n       * @brief\
    \ CCDS field\n       *\n       * Capture/compare DMA\n       *               selection\n\
    \       */\n      BitFieldModel<uint32_t, 3, 1> ccds;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR2 register\n   *\n   * control register 2\n   */\n  using\
    \ cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class SmcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief ETP field\n     *\n     * External trigger polarity\n \
    \    */\n    using etp = FieldModel<uint32_t, address, 15, 1>;\n    /**\n    \
    \ * @brief ECE field\n     *\n     * External clock enable\n     */\n    using\
    \ ece = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief ETPS field\n\
    \     *\n     * External trigger prescaler\n     */\n    using etps = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    /**\n     * @brief ETF field\n     *\n     * External\
    \ trigger filter\n     */\n    using etf = FieldModel<uint32_t, address, 8, 4>;\n\
    \    /**\n     * @brief MSM field\n     *\n     * Master/Slave mode\n     */\n\
    \    using msm = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief\
    \ TS field\n     *\n     * Trigger selection\n     */\n    using ts = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    /**\n     * @brief SMS field\n     *\n     * Slave mode\
    \ selection\n     */\n    using sms = FieldModel<uint32_t, address, 0, 3>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief ETP field\n       *\n       * External trigger\
    \ polarity\n       */\n      BitFieldModel<uint32_t, 15, 1> etp;\n      /**\n\
    \       * @brief ECE field\n       *\n       * External clock enable\n       */\n\
    \      BitFieldModel<uint32_t, 14, 1> ece;\n      /**\n       * @brief ETPS field\n\
    \       *\n       * External trigger prescaler\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 2> etps;\n      /**\n       * @brief ETF field\n       *\n       * External\
    \ trigger filter\n       */\n      BitFieldModel<uint32_t, 8, 4> etf;\n      /**\n\
    \       * @brief MSM field\n       *\n       * Master/Slave mode\n       */\n\
    \      BitFieldModel<uint32_t, 7, 1> msm;\n      /**\n       * @brief TS field\n\
    \       *\n       * Trigger selection\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 3> ts;\n      /**\n       * @brief SMS field\n       *\n       * Slave mode\
    \ selection\n       */\n      BitFieldModel<uint32_t, 0, 3> sms;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief SMCR register\n   *\n   * slave mode control register\n\
    \   */\n  using smcr = SmcrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DierReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief TDE field\n     *\n     * Trigger DMA request\
    \ enable\n     */\n    using tde = FieldModel<uint32_t, address, 14, 1>;\n   \
    \ /**\n     * @brief CC4DE field\n     *\n     * Capture/Compare 4 DMA request\n\
    \     *               enable\n     */\n    using cc4de = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief CC3DE field\n     *\n     * Capture/Compare\
    \ 3 DMA request\n     *               enable\n     */\n    using cc3de = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief CC2DE field\n     *\n     * Capture/Compare\
    \ 2 DMA request\n     *               enable\n     */\n    using cc2de = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief CC1DE field\n     *\n     * Capture/Compare\
    \ 1 DMA request\n     *               enable\n     */\n    using cc1de = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief UDE field\n     *\n     * Update DMA\
    \ request enable\n     */\n    using ude = FieldModel<uint32_t, address, 8, 1>;\n\
    \    /**\n     * @brief TIE field\n     *\n     * Trigger interrupt enable\n \
    \    */\n    using tie = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     *\
    \ @brief CC4IE field\n     *\n     * Capture/Compare 4 interrupt\n     *     \
    \          enable\n     */\n    using cc4ie = FieldModel<uint32_t, address, 4,\
    \ 1>;\n    /**\n     * @brief CC3IE field\n     *\n     * Capture/Compare 3 interrupt\n\
    \     *               enable\n     */\n    using cc3ie = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief CC2IE field\n     *\n     * Capture/Compare\
    \ 2 interrupt\n     *               enable\n     */\n    using cc2ie = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1IE field\n     *\n     * Capture/Compare\
    \ 1 interrupt\n     *               enable\n     */\n    using cc1ie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UIE field\n     *\n     * Update interrupt\
    \ enable\n     */\n    using uie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief TDE field\n       *\n       * Trigger DMA request enable\n  \
    \     */\n      BitFieldModel<uint32_t, 14, 1> tde;\n      /**\n       * @brief\
    \ CC4DE field\n       *\n       * Capture/Compare 4 DMA request\n       *    \
    \           enable\n       */\n      BitFieldModel<uint32_t, 12, 1> cc4de;\n \
    \     /**\n       * @brief CC3DE field\n       *\n       * Capture/Compare 3 DMA\
    \ request\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> cc3de;\n      /**\n       * @brief CC2DE field\n       *\n       * Capture/Compare\
    \ 2 DMA request\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> cc2de;\n      /**\n       * @brief CC1DE field\n       *\n       * Capture/Compare\
    \ 1 DMA request\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc1de;\n      /**\n       * @brief UDE field\n       *\n       * Update\
    \ DMA request enable\n       */\n      BitFieldModel<uint32_t, 8, 1> ude;\n  \
    \    /**\n       * @brief TIE field\n       *\n       * Trigger interrupt enable\n\
    \       */\n      BitFieldModel<uint32_t, 6, 1> tie;\n      /**\n       * @brief\
    \ CC4IE field\n       *\n       * Capture/Compare 4 interrupt\n       *      \
    \         enable\n       */\n      BitFieldModel<uint32_t, 4, 1> cc4ie;\n    \
    \  /**\n       * @brief CC3IE field\n       *\n       * Capture/Compare 3 interrupt\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 3, 1>\
    \ cc3ie;\n      /**\n       * @brief CC2IE field\n       *\n       * Capture/Compare\
    \ 2 interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cc2ie;\n      /**\n       * @brief CC1IE field\n       *\n       * Capture/Compare\
    \ 1 interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1ie;\n      /**\n       * @brief UIE field\n       *\n       * Update\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 0, 1> uie;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief DIER register\n   *\n   * DMA/Interrupt enable\
    \ register\n   */\n  using dier = DierReg<BaseAddress + 0x000C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CC4OF field\n     *\n     *\
    \ Capture/Compare 4 overcapture\n     *               flag\n     */\n    using\
    \ cc4of = FieldModel<uint32_t, address, 12, 1>;\n    /**\n     * @brief CC3OF\
    \ field\n     *\n     * Capture/Compare 3 overcapture\n     *               flag\n\
    \     */\n    using cc3of = FieldModel<uint32_t, address, 11, 1>;\n    /**\n \
    \    * @brief CC2OF field\n     *\n     * Capture/compare 2 overcapture\n    \
    \ *               flag\n     */\n    using cc2of = FieldModel<uint32_t, address,\
    \ 10, 1>;\n    /**\n     * @brief CC1OF field\n     *\n     * Capture/Compare\
    \ 1 overcapture\n     *               flag\n     */\n    using cc1of = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief TIF field\n     *\n     * Trigger interrupt\
    \ flag\n     */\n    using tif = FieldModel<uint32_t, address, 6, 1>;\n    /**\n\
    \     * @brief CC4IF field\n     *\n     * Capture/Compare 4 interrupt\n     *\
    \               flag\n     */\n    using cc4if = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief CC3IF field\n     *\n     * Capture/Compare 3\
    \ interrupt\n     *               flag\n     */\n    using cc3if = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief CC2IF field\n     *\n     * Capture/Compare\
    \ 2 interrupt\n     *               flag\n     */\n    using cc2if = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1IF field\n     *\n     * Capture/compare\
    \ 1 interrupt\n     *               flag\n     */\n    using cc1if = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UIF field\n     *\n     * Update interrupt\
    \ flag\n     */\n    using uif = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CC4OF field\n       *\n       * Capture/Compare 4 overcapture\n\
    \       *               flag\n       */\n      BitFieldModel<uint32_t, 12, 1>\
    \ cc4of;\n      /**\n       * @brief CC3OF field\n       *\n       * Capture/Compare\
    \ 3 overcapture\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> cc3of;\n      /**\n       * @brief CC2OF field\n       *\n       * Capture/compare\
    \ 2 overcapture\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> cc2of;\n      /**\n       * @brief CC1OF field\n       *\n       * Capture/Compare\
    \ 1 overcapture\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc1of;\n      /**\n       * @brief TIF field\n       *\n       * Trigger\
    \ interrupt flag\n       */\n      BitFieldModel<uint32_t, 6, 1> tif;\n      /**\n\
    \       * @brief CC4IF field\n       *\n       * Capture/Compare 4 interrupt\n\
    \       *               flag\n       */\n      BitFieldModel<uint32_t, 4, 1> cc4if;\n\
    \      /**\n       * @brief CC3IF field\n       *\n       * Capture/Compare 3\
    \ interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3if;\n      /**\n       * @brief CC2IF field\n       *\n       * Capture/Compare\
    \ 2 interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cc2if;\n      /**\n       * @brief CC1IF field\n       *\n       * Capture/compare\
    \ 1 interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1if;\n      /**\n       * @brief UIF field\n       *\n       * Update\
    \ interrupt flag\n       */\n      BitFieldModel<uint32_t, 0, 1> uif;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief SR register\n   *\n   * status register\n\
    \   */\n  using sr = SrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class EgrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief TG field\n     *\n     * Trigger generation\n\
    \     */\n    using tg = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     *\
    \ @brief CC4G field\n     *\n     * Capture/compare 4\n     *               generation\n\
    \     */\n    using cc4g = FieldModel<uint32_t, address, 4, 1>;\n    /**\n   \
    \  * @brief CC3G field\n     *\n     * Capture/compare 3\n     *             \
    \  generation\n     */\n    using cc3g = FieldModel<uint32_t, address, 3, 1>;\n\
    \    /**\n     * @brief CC2G field\n     *\n     * Capture/compare 2\n     * \
    \              generation\n     */\n    using cc2g = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief CC1G field\n     *\n     * Capture/compare 1\n\
    \     *               generation\n     */\n    using cc1g = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UG field\n     *\n     * Update generation\n\
    \     */\n    using ug = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n \
    \   /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief TG field\n       *\n       * Trigger generation\n       */\n\
    \      BitFieldModel<uint32_t, 6, 1> tg;\n      /**\n       * @brief CC4G field\n\
    \       *\n       * Capture/compare 4\n       *               generation\n   \
    \    */\n      BitFieldModel<uint32_t, 4, 1> cc4g;\n      /**\n       * @brief\
    \ CC3G field\n       *\n       * Capture/compare 3\n       *               generation\n\
    \       */\n      BitFieldModel<uint32_t, 3, 1> cc3g;\n      /**\n       * @brief\
    \ CC2G field\n       *\n       * Capture/compare 2\n       *               generation\n\
    \       */\n      BitFieldModel<uint32_t, 2, 1> cc2g;\n      /**\n       * @brief\
    \ CC1G field\n       *\n       * Capture/compare 1\n       *               generation\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> cc1g;\n      /**\n       * @brief\
    \ UG field\n       *\n       * Update generation\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> ug;\n    };\n  };\n\npublic:\n  /**\n   * @brief EGR register\n   *\n\
    \   * event generation register\n   */\n  using egr = EgrReg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Ccmr1_outputReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief OC2CE\
    \ field\n     *\n     * OC2CE\n     */\n    using oc2ce = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief OC2M field\n     *\n     * OC2M\n \
    \    */\n    using oc2m = FieldModel<uint32_t, address, 12, 3>;\n    /**\n   \
    \  * @brief OC2PE field\n     *\n     * OC2PE\n     */\n    using oc2pe = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief OC2FE field\n     *\n     * OC2FE\n\
    \     */\n    using oc2fe = FieldModel<uint32_t, address, 10, 1>;\n    /**\n \
    \    * @brief CC2S field\n     *\n     * CC2S\n     */\n    using cc2s = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief OC1CE field\n     *\n     * OC1CE\n\
    \     */\n    using oc1ce = FieldModel<uint32_t, address, 7, 1>;\n    /**\n  \
    \   * @brief OC1M field\n     *\n     * OC1M\n     */\n    using oc1m = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    /**\n     * @brief OC1PE field\n     *\n     * OC1PE\n\
    \     */\n    using oc1pe = FieldModel<uint32_t, address, 3, 1>;\n    /**\n  \
    \   * @brief OC1FE field\n     *\n     * OC1FE\n     */\n    using oc1fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1S field\n     *\n     * CC1S\n  \
    \   */\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n \
    \   /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief OC2CE field\n       *\n       * OC2CE\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> oc2ce;\n      /**\n       * @brief OC2M field\n       *\n       * OC2M\n\
    \       */\n      BitFieldModel<uint32_t, 12, 3> oc2m;\n      /**\n       * @brief\
    \ OC2PE field\n       *\n       * OC2PE\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> oc2pe;\n      /**\n       * @brief OC2FE field\n       *\n       * OC2FE\n\
    \       */\n      BitFieldModel<uint32_t, 10, 1> oc2fe;\n      /**\n       * @brief\
    \ CC2S field\n       *\n       * CC2S\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc2s;\n      /**\n       * @brief OC1CE field\n       *\n       * OC1CE\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> oc1ce;\n      /**\n       * @brief\
    \ OC1M field\n       *\n       * OC1M\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 3> oc1m;\n      /**\n       * @brief OC1PE field\n       *\n       * OC1PE\n\
    \       */\n      BitFieldModel<uint32_t, 3, 1> oc1pe;\n      /**\n       * @brief\
    \ OC1FE field\n       *\n       * OC1FE\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc1fe;\n      /**\n       * @brief CC1S field\n       *\n       * CC1S\n\
    \       */\n      BitFieldModel<uint32_t, 0, 2> cc1s;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CCMR1_OUTPUT register\n   *\n   * capture/compare mode register\
    \ 1 (output\n   *           mode)\n   */\n  using ccmr1_output = Ccmr1_outputReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class Ccmr1_inputReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ IC2F field\n     *\n     * Input capture 2 filter\n     */\n    using ic2f =\
    \ FieldModel<uint32_t, address, 12, 4>;\n    /**\n     * @brief IC2PCS field\n\
    \     *\n     * Input capture 2 prescaler\n     */\n    using ic2pcs = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    /**\n     * @brief CC2S field\n     *\n     * Capture/Compare\
    \ 2\n     *               selection\n     */\n    using cc2s = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief IC1F field\n     *\n     * Input capture\
    \ 1 filter\n     */\n    using ic1f = FieldModel<uint32_t, address, 4, 4>;\n \
    \   /**\n     * @brief ICPCS field\n     *\n     * Input capture 1 prescaler\n\
    \     */\n    using icpcs = FieldModel<uint32_t, address, 2, 2>;\n    /**\n  \
    \   * @brief CC1S field\n     *\n     * Capture/Compare 1\n     *            \
    \   selection\n     */\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief IC2F field\n       *\n       * Input capture\
    \ 2 filter\n       */\n      BitFieldModel<uint32_t, 12, 4> ic2f;\n      /**\n\
    \       * @brief IC2PCS field\n       *\n       * Input capture 2 prescaler\n\
    \       */\n      BitFieldModel<uint32_t, 10, 2> ic2pcs;\n      /**\n       *\
    \ @brief CC2S field\n       *\n       * Capture/Compare 2\n       *          \
    \     selection\n       */\n      BitFieldModel<uint32_t, 8, 2> cc2s;\n      /**\n\
    \       * @brief IC1F field\n       *\n       * Input capture 1 filter\n     \
    \  */\n      BitFieldModel<uint32_t, 4, 4> ic1f;\n      /**\n       * @brief ICPCS\
    \ field\n       *\n       * Input capture 1 prescaler\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 2> icpcs;\n      /**\n       * @brief CC1S field\n       *\n       * Capture/Compare\
    \ 1\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc1s;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCMR1_INPUT register\n\
    \   *\n   * capture/compare mode register 1 (input\n   *           mode)\n   */\n\
    \  using ccmr1_input = Ccmr1_inputReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr2_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief OC4CE field\n     *\n     * OC4CE\n  \
    \   */\n    using oc4ce = FieldModel<uint32_t, address, 15, 1>;\n    /**\n   \
    \  * @brief OC4M field\n     *\n     * OC4M\n     */\n    using oc4m = FieldModel<uint32_t,\
    \ address, 12, 3>;\n    /**\n     * @brief OC4PE field\n     *\n     * OC4PE\n\
    \     */\n    using oc4pe = FieldModel<uint32_t, address, 11, 1>;\n    /**\n \
    \    * @brief OC4FE field\n     *\n     * OC4FE\n     */\n    using oc4fe = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief CC4S field\n     *\n     * CC4S\n \
    \    */\n    using cc4s = FieldModel<uint32_t, address, 8, 2>;\n    /**\n    \
    \ * @brief OC3CE field\n     *\n     * OC3CE\n     */\n    using oc3ce = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief OC3M field\n     *\n     * OC3M\n  \
    \   */\n    using oc3m = FieldModel<uint32_t, address, 4, 3>;\n    /**\n     *\
    \ @brief OC3PE field\n     *\n     * OC3PE\n     */\n    using oc3pe = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief OC3FE field\n     *\n     * OC3FE\n\
    \     */\n    using oc3fe = FieldModel<uint32_t, address, 2, 1>;\n    /**\n  \
    \   * @brief CC3S field\n     *\n     * CC3S\n     */\n    using cc3s = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OC4CE field\n       *\n\
    \       * OC4CE\n       */\n      BitFieldModel<uint32_t, 15, 1> oc4ce;\n    \
    \  /**\n       * @brief OC4M field\n       *\n       * OC4M\n       */\n     \
    \ BitFieldModel<uint32_t, 12, 3> oc4m;\n      /**\n       * @brief OC4PE field\n\
    \       *\n       * OC4PE\n       */\n      BitFieldModel<uint32_t, 11, 1> oc4pe;\n\
    \      /**\n       * @brief OC4FE field\n       *\n       * OC4FE\n       */\n\
    \      BitFieldModel<uint32_t, 10, 1> oc4fe;\n      /**\n       * @brief CC4S\
    \ field\n       *\n       * CC4S\n       */\n      BitFieldModel<uint32_t, 8,\
    \ 2> cc4s;\n      /**\n       * @brief OC3CE field\n       *\n       * OC3CE\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> oc3ce;\n      /**\n       * @brief\
    \ OC3M field\n       *\n       * OC3M\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 3> oc3m;\n      /**\n       * @brief OC3PE field\n       *\n       * OC3PE\n\
    \       */\n      BitFieldModel<uint32_t, 3, 1> oc3pe;\n      /**\n       * @brief\
    \ OC3FE field\n       *\n       * OC3FE\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc3fe;\n      /**\n       * @brief CC3S field\n       *\n       * CC3S\n\
    \       */\n      BitFieldModel<uint32_t, 0, 2> cc3s;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CCMR2_OUTPUT register\n   *\n   * capture/compare mode register\
    \ 2 (output\n   *           mode)\n   */\n  using ccmr2_output = Ccmr2_outputReg<BaseAddress\
    \ + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class Ccmr2_inputReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ IC4F field\n     *\n     * Input capture 4 filter\n     */\n    using ic4f =\
    \ FieldModel<uint32_t, address, 12, 4>;\n    /**\n     * @brief IC4PSC field\n\
    \     *\n     * Input capture 4 prescaler\n     */\n    using ic4psc = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    /**\n     * @brief CC4S field\n     *\n     * Capture/Compare\
    \ 4\n     *               selection\n     */\n    using cc4s = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief IC3F field\n     *\n     * Input capture\
    \ 3 filter\n     */\n    using ic3f = FieldModel<uint32_t, address, 4, 4>;\n \
    \   /**\n     * @brief IC3PSC field\n     *\n     * Input capture 3 prescaler\n\
    \     */\n    using ic3psc = FieldModel<uint32_t, address, 2, 2>;\n    /**\n \
    \    * @brief CC3S field\n     *\n     * Capture/compare 3\n     *           \
    \    selection\n     */\n    using cc3s = FieldModel<uint32_t, address, 0, 2>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief IC4F field\n       *\n       * Input capture\
    \ 4 filter\n       */\n      BitFieldModel<uint32_t, 12, 4> ic4f;\n      /**\n\
    \       * @brief IC4PSC field\n       *\n       * Input capture 4 prescaler\n\
    \       */\n      BitFieldModel<uint32_t, 10, 2> ic4psc;\n      /**\n       *\
    \ @brief CC4S field\n       *\n       * Capture/Compare 4\n       *          \
    \     selection\n       */\n      BitFieldModel<uint32_t, 8, 2> cc4s;\n      /**\n\
    \       * @brief IC3F field\n       *\n       * Input capture 3 filter\n     \
    \  */\n      BitFieldModel<uint32_t, 4, 4> ic3f;\n      /**\n       * @brief IC3PSC\
    \ field\n       *\n       * Input capture 3 prescaler\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 2> ic3psc;\n      /**\n       * @brief CC3S field\n       *\n       * Capture/compare\
    \ 3\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc3s;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCMR2_INPUT register\n\
    \   *\n   * capture/compare mode register 2 (input\n   *           mode)\n   */\n\
    \  using ccmr2_input = Ccmr2_inputReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CcerReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief CC4NP field\n     *\n     * Capture/Compare\
    \ 4 output\n     *               Polarity\n     */\n    using cc4np = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief CC4P field\n     *\n     * Capture/Compare\
    \ 3 output\n     *               Polarity\n     */\n    using cc4p = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief CC4E field\n     *\n     * Capture/Compare\
    \ 4 output\n     *               enable\n     */\n    using cc4e = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief CC3NP field\n     *\n     * Capture/Compare\
    \ 3 output\n     *               Polarity\n     */\n    using cc3np = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief CC3P field\n     *\n     * Capture/Compare\
    \ 3 output\n     *               Polarity\n     */\n    using cc3p = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief CC3E field\n     *\n     * Capture/Compare\
    \ 3 output\n     *               enable\n     */\n    using cc3e = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief CC2NP field\n     *\n     * Capture/Compare\
    \ 2 output\n     *               Polarity\n     */\n    using cc2np = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief CC2P field\n     *\n     * Capture/Compare\
    \ 2 output\n     *               Polarity\n     */\n    using cc2p = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief CC2E field\n     *\n     * Capture/Compare\
    \ 2 output\n     *               enable\n     */\n    using cc2e = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief CC1NP field\n     *\n     * Capture/Compare\
    \ 1 output\n     *               Polarity\n     */\n    using cc1np = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief CC1P field\n     *\n     * Capture/Compare\
    \ 1 output\n     *               Polarity\n     */\n    using cc1p = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief CC1E field\n     *\n     * Capture/Compare\
    \ 1 output\n     *               enable\n     */\n    using cc1e = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CC4NP field\n       *\n\
    \       * Capture/Compare 4 output\n       *               Polarity\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> cc4np;\n      /**\n       * @brief CC4P\
    \ field\n       *\n       * Capture/Compare 3 output\n       *               Polarity\n\
    \       */\n      BitFieldModel<uint32_t, 13, 1> cc4p;\n      /**\n       * @brief\
    \ CC4E field\n       *\n       * Capture/Compare 4 output\n       *          \
    \     enable\n       */\n      BitFieldModel<uint32_t, 12, 1> cc4e;\n      /**\n\
    \       * @brief CC3NP field\n       *\n       * Capture/Compare 3 output\n  \
    \     *               Polarity\n       */\n      BitFieldModel<uint32_t, 11, 1>\
    \ cc3np;\n      /**\n       * @brief CC3P field\n       *\n       * Capture/Compare\
    \ 3 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc3p;\n      /**\n       * @brief CC3E field\n       *\n       * Capture/Compare\
    \ 3 output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> cc3e;\n      /**\n       * @brief CC2NP field\n       *\n       * Capture/Compare\
    \ 2 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> cc2np;\n      /**\n       * @brief CC2P field\n       *\n       * Capture/Compare\
    \ 2 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> cc2p;\n      /**\n       * @brief CC2E field\n       *\n       * Capture/Compare\
    \ 2 output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> cc2e;\n      /**\n       * @brief CC1NP field\n       *\n       * Capture/Compare\
    \ 1 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc1np;\n      /**\n       * @brief CC1P field\n       *\n       * Capture/Compare\
    \ 1 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1p;\n      /**\n       * @brief CC1E field\n       *\n       * Capture/Compare\
    \ 1 output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> cc1e;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCER register\n   *\n\
    \   * capture/compare enable\n   *           register\n   */\n  using ccer = CcerReg<BaseAddress\
    \ + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n  class CntReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CNT_H\
    \ field\n     *\n     * High counter value\n     */\n    using cnt_h = FieldModel<uint32_t,\
    \ address, 16, 16>;\n    /**\n     * @brief CNT_L field\n     *\n     * Low counter\
    \ value\n     */\n    using cnt_l = FieldModel<uint32_t, address, 0, 16>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief CNT_H field\n       *\n       * High counter\
    \ value\n       */\n      BitFieldModel<uint32_t, 16, 16> cnt_h;\n      /**\n\
    \       * @brief CNT_L field\n       *\n       * Low counter value\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> cnt_l;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief CNT register\n   *\n   * counter\n   */\n  using cnt = CntReg<BaseAddress\
    \ + 0x0024>;\n\nprivate:\n  template<unsigned int address>\n  class PscReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief PSC\
    \ field\n     *\n     * Prescaler value\n     */\n    using psc = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief PSC field\n       *\n \
    \      * Prescaler value\n       */\n      BitFieldModel<uint32_t, 0, 16> psc;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief PSC register\n   *\n   * prescaler\n\
    \   */\n  using psc = PscReg<BaseAddress + 0x0028>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class ArrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief ARR_H field\n     *\n     * High Auto-reload\
    \ value\n     */\n    using arr_h = FieldModel<uint32_t, address, 16, 16>;\n \
    \   /**\n     * @brief ARR_L field\n     *\n     * Low Auto-reload value\n   \
    \  */\n    using arr_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief ARR_H field\n       *\n       * High Auto-reload value\n    \
    \   */\n      BitFieldModel<uint32_t, 16, 16> arr_h;\n      /**\n       * @brief\
    \ ARR_L field\n       *\n       * Low Auto-reload value\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> arr_l;\n    };\n  };\n\npublic:\n  /**\n   * @brief ARR register\n  \
    \ *\n   * auto-reload register\n   */\n  using arr = ArrReg<BaseAddress + 0x002C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Ccr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CCR1_H field\n     *\n    \
    \ * High Capture/Compare 1\n     *               value\n     */\n    using ccr1_h\
    \ = FieldModel<uint32_t, address, 16, 16>;\n    /**\n     * @brief CCR1_L field\n\
    \     *\n     * Low Capture/Compare 1\n     *               value\n     */\n \
    \   using ccr1_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CCR1_H field\n       *\n       * High Capture/Compare 1\n       *          \
    \     value\n       */\n      BitFieldModel<uint32_t, 16, 16> ccr1_h;\n      /**\n\
    \       * @brief CCR1_L field\n       *\n       * Low Capture/Compare 1\n    \
    \   *               value\n       */\n      BitFieldModel<uint32_t, 0, 16> ccr1_l;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief CCR1 register\n   *\n   * capture/compare\
    \ register 1\n   */\n  using ccr1 = Ccr1Reg<BaseAddress + 0x0034>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Ccr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CCR2_H field\n     *\n    \
    \ * High Capture/Compare 2\n     *               value\n     */\n    using ccr2_h\
    \ = FieldModel<uint32_t, address, 16, 16>;\n    /**\n     * @brief CCR2_L field\n\
    \     *\n     * Low Capture/Compare 2\n     *               value\n     */\n \
    \   using ccr2_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CCR2_H field\n       *\n       * High Capture/Compare 2\n       *          \
    \     value\n       */\n      BitFieldModel<uint32_t, 16, 16> ccr2_h;\n      /**\n\
    \       * @brief CCR2_L field\n       *\n       * Low Capture/Compare 2\n    \
    \   *               value\n       */\n      BitFieldModel<uint32_t, 0, 16> ccr2_l;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief CCR2 register\n   *\n   * capture/compare\
    \ register 2\n   */\n  using ccr2 = Ccr2Reg<BaseAddress + 0x0038>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Ccr3Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CCR3_H field\n     *\n    \
    \ * High Capture/Compare value\n     */\n    using ccr3_h = FieldModel<uint32_t,\
    \ address, 16, 16>;\n    /**\n     * @brief CCR3_L field\n     *\n     * Low Capture/Compare\
    \ value\n     */\n    using ccr3_l = FieldModel<uint32_t, address, 0, 16>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief CCR3_H field\n       *\n       * High Capture/Compare\
    \ value\n       */\n      BitFieldModel<uint32_t, 16, 16> ccr3_h;\n      /**\n\
    \       * @brief CCR3_L field\n       *\n       * Low Capture/Compare value\n\
    \       */\n      BitFieldModel<uint32_t, 0, 16> ccr3_l;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CCR3 register\n   *\n   * capture/compare register 3\n   */\n\
    \  using ccr3 = Ccr3Reg<BaseAddress + 0x003C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccr4Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief CCR4_H field\n     *\n     * High Capture/Compare\
    \ value\n     */\n    using ccr4_h = FieldModel<uint32_t, address, 16, 16>;\n\
    \    /**\n     * @brief CCR4_L field\n     *\n     * Low Capture/Compare value\n\
    \     */\n    using ccr4_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CCR4_H field\n       *\n       * High Capture/Compare value\n\
    \       */\n      BitFieldModel<uint32_t, 16, 16> ccr4_h;\n      /**\n       *\
    \ @brief CCR4_L field\n       *\n       * Low Capture/Compare value\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ccr4_l;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief CCR4 register\n   *\n   * capture/compare register 4\n   */\n  using\
    \ ccr4 = Ccr4Reg<BaseAddress + 0x0040>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class DcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief DBL field\n     *\n     * DMA burst length\n     */\n  \
    \  using dbl = FieldModel<uint32_t, address, 8, 5>;\n    /**\n     * @brief DBA\
    \ field\n     *\n     * DMA base address\n     */\n    using dba = FieldModel<uint32_t,\
    \ address, 0, 5>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief DBL field\n       *\n \
    \      * DMA burst length\n       */\n      BitFieldModel<uint32_t, 8, 5> dbl;\n\
    \      /**\n       * @brief DBA field\n       *\n       * DMA base address\n \
    \      */\n      BitFieldModel<uint32_t, 0, 5> dba;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief DCR register\n   *\n   * DMA control register\n   */\n  using\
    \ dcr = DcrReg<BaseAddress + 0x0048>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class DmarReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief DMAB field\n     *\n     * DMA register for burst\n   \
    \  *               accesses\n     */\n    using dmab = FieldModel<uint32_t, address,\
    \ 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief DMAB field\n       *\n\
    \       * DMA register for burst\n       *               accesses\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> dmab;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief DMAR register\n   *\n   * DMA address for full transfer\n   */\n\
    \  using dmar = DmarReg<BaseAddress + 0x004C>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_TIM4_H\
    \ */"
  name: TIM4
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_TIM5_H\n#define DRAL_STM32F411_TIM5_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ TIM5 peripheral\n *\n * General-purpose-timers\n */\nclass tim5\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40000C00; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CKD\
    \ field\n     *\n     * Clock division\n     */\n    using ckd = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief ARPE field\n     *\n     * Auto-reload\
    \ preload enable\n     */\n    using arpe = FieldModel<uint32_t, address, 7, 1>;\n\
    \    /**\n     * @brief CMS field\n     *\n     * Center-aligned mode\n     *\
    \               selection\n     */\n    using cms = FieldModel<uint32_t, address,\
    \ 5, 2>;\n    /**\n     * @brief DIR field\n     *\n     * Direction\n     */\n\
    \    using dir = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief\
    \ OPM field\n     *\n     * One-pulse mode\n     */\n    using opm = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief URS field\n     *\n     * Update request\
    \ source\n     */\n    using urs = FieldModel<uint32_t, address, 2, 1>;\n    /**\n\
    \     * @brief UDIS field\n     *\n     * Update disable\n     */\n    using udis\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief CEN field\n \
    \    *\n     * Counter enable\n     */\n    using cen = FieldModel<uint32_t, address,\
    \ 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief CKD field\n       *\n     \
    \  * Clock division\n       */\n      BitFieldModel<uint32_t, 8, 2> ckd;\n   \
    \   /**\n       * @brief ARPE field\n       *\n       * Auto-reload preload enable\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> arpe;\n      /**\n       * @brief\
    \ CMS field\n       *\n       * Center-aligned mode\n       *               selection\n\
    \       */\n      BitFieldModel<uint32_t, 5, 2> cms;\n      /**\n       * @brief\
    \ DIR field\n       *\n       * Direction\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> dir;\n      /**\n       * @brief OPM field\n       *\n       * One-pulse\
    \ mode\n       */\n      BitFieldModel<uint32_t, 3, 1> opm;\n      /**\n     \
    \  * @brief URS field\n       *\n       * Update request source\n       */\n \
    \     BitFieldModel<uint32_t, 2, 1> urs;\n      /**\n       * @brief UDIS field\n\
    \       *\n       * Update disable\n       */\n      BitFieldModel<uint32_t, 1,\
    \ 1> udis;\n      /**\n       * @brief CEN field\n       *\n       * Counter enable\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> cen;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR1 register\n   *\n   * control register 1\n   */\n  using\
    \ cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief TI1S field\n     *\n     * TI1 selection\n     */\n    using\
    \ ti1s = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief MMS field\n\
    \     *\n     * Master mode selection\n     */\n    using mms = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    /**\n     * @brief CCDS field\n     *\n     * Capture/compare\
    \ DMA\n     *               selection\n     */\n    using ccds = FieldModel<uint32_t,\
    \ address, 3, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief TI1S field\n       *\n\
    \       * TI1 selection\n       */\n      BitFieldModel<uint32_t, 7, 1> ti1s;\n\
    \      /**\n       * @brief MMS field\n       *\n       * Master mode selection\n\
    \       */\n      BitFieldModel<uint32_t, 4, 3> mms;\n      /**\n       * @brief\
    \ CCDS field\n       *\n       * Capture/compare DMA\n       *               selection\n\
    \       */\n      BitFieldModel<uint32_t, 3, 1> ccds;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR2 register\n   *\n   * control register 2\n   */\n  using\
    \ cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class SmcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief ETP field\n     *\n     * External trigger polarity\n \
    \    */\n    using etp = FieldModel<uint32_t, address, 15, 1>;\n    /**\n    \
    \ * @brief ECE field\n     *\n     * External clock enable\n     */\n    using\
    \ ece = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief ETPS field\n\
    \     *\n     * External trigger prescaler\n     */\n    using etps = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    /**\n     * @brief ETF field\n     *\n     * External\
    \ trigger filter\n     */\n    using etf = FieldModel<uint32_t, address, 8, 4>;\n\
    \    /**\n     * @brief MSM field\n     *\n     * Master/Slave mode\n     */\n\
    \    using msm = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief\
    \ TS field\n     *\n     * Trigger selection\n     */\n    using ts = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    /**\n     * @brief SMS field\n     *\n     * Slave mode\
    \ selection\n     */\n    using sms = FieldModel<uint32_t, address, 0, 3>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief ETP field\n       *\n       * External trigger\
    \ polarity\n       */\n      BitFieldModel<uint32_t, 15, 1> etp;\n      /**\n\
    \       * @brief ECE field\n       *\n       * External clock enable\n       */\n\
    \      BitFieldModel<uint32_t, 14, 1> ece;\n      /**\n       * @brief ETPS field\n\
    \       *\n       * External trigger prescaler\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 2> etps;\n      /**\n       * @brief ETF field\n       *\n       * External\
    \ trigger filter\n       */\n      BitFieldModel<uint32_t, 8, 4> etf;\n      /**\n\
    \       * @brief MSM field\n       *\n       * Master/Slave mode\n       */\n\
    \      BitFieldModel<uint32_t, 7, 1> msm;\n      /**\n       * @brief TS field\n\
    \       *\n       * Trigger selection\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 3> ts;\n      /**\n       * @brief SMS field\n       *\n       * Slave mode\
    \ selection\n       */\n      BitFieldModel<uint32_t, 0, 3> sms;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief SMCR register\n   *\n   * slave mode control register\n\
    \   */\n  using smcr = SmcrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class DierReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief TDE field\n     *\n     * Trigger DMA request\
    \ enable\n     */\n    using tde = FieldModel<uint32_t, address, 14, 1>;\n   \
    \ /**\n     * @brief CC4DE field\n     *\n     * Capture/Compare 4 DMA request\n\
    \     *               enable\n     */\n    using cc4de = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief CC3DE field\n     *\n     * Capture/Compare\
    \ 3 DMA request\n     *               enable\n     */\n    using cc3de = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief CC2DE field\n     *\n     * Capture/Compare\
    \ 2 DMA request\n     *               enable\n     */\n    using cc2de = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief CC1DE field\n     *\n     * Capture/Compare\
    \ 1 DMA request\n     *               enable\n     */\n    using cc1de = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief UDE field\n     *\n     * Update DMA\
    \ request enable\n     */\n    using ude = FieldModel<uint32_t, address, 8, 1>;\n\
    \    /**\n     * @brief TIE field\n     *\n     * Trigger interrupt enable\n \
    \    */\n    using tie = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     *\
    \ @brief CC4IE field\n     *\n     * Capture/Compare 4 interrupt\n     *     \
    \          enable\n     */\n    using cc4ie = FieldModel<uint32_t, address, 4,\
    \ 1>;\n    /**\n     * @brief CC3IE field\n     *\n     * Capture/Compare 3 interrupt\n\
    \     *               enable\n     */\n    using cc3ie = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief CC2IE field\n     *\n     * Capture/Compare\
    \ 2 interrupt\n     *               enable\n     */\n    using cc2ie = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1IE field\n     *\n     * Capture/Compare\
    \ 1 interrupt\n     *               enable\n     */\n    using cc1ie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UIE field\n     *\n     * Update interrupt\
    \ enable\n     */\n    using uie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief TDE field\n       *\n       * Trigger DMA request enable\n  \
    \     */\n      BitFieldModel<uint32_t, 14, 1> tde;\n      /**\n       * @brief\
    \ CC4DE field\n       *\n       * Capture/Compare 4 DMA request\n       *    \
    \           enable\n       */\n      BitFieldModel<uint32_t, 12, 1> cc4de;\n \
    \     /**\n       * @brief CC3DE field\n       *\n       * Capture/Compare 3 DMA\
    \ request\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> cc3de;\n      /**\n       * @brief CC2DE field\n       *\n       * Capture/Compare\
    \ 2 DMA request\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> cc2de;\n      /**\n       * @brief CC1DE field\n       *\n       * Capture/Compare\
    \ 1 DMA request\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc1de;\n      /**\n       * @brief UDE field\n       *\n       * Update\
    \ DMA request enable\n       */\n      BitFieldModel<uint32_t, 8, 1> ude;\n  \
    \    /**\n       * @brief TIE field\n       *\n       * Trigger interrupt enable\n\
    \       */\n      BitFieldModel<uint32_t, 6, 1> tie;\n      /**\n       * @brief\
    \ CC4IE field\n       *\n       * Capture/Compare 4 interrupt\n       *      \
    \         enable\n       */\n      BitFieldModel<uint32_t, 4, 1> cc4ie;\n    \
    \  /**\n       * @brief CC3IE field\n       *\n       * Capture/Compare 3 interrupt\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 3, 1>\
    \ cc3ie;\n      /**\n       * @brief CC2IE field\n       *\n       * Capture/Compare\
    \ 2 interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cc2ie;\n      /**\n       * @brief CC1IE field\n       *\n       * Capture/Compare\
    \ 1 interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1ie;\n      /**\n       * @brief UIE field\n       *\n       * Update\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 0, 1> uie;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief DIER register\n   *\n   * DMA/Interrupt enable\
    \ register\n   */\n  using dier = DierReg<BaseAddress + 0x000C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CC4OF field\n     *\n     *\
    \ Capture/Compare 4 overcapture\n     *               flag\n     */\n    using\
    \ cc4of = FieldModel<uint32_t, address, 12, 1>;\n    /**\n     * @brief CC3OF\
    \ field\n     *\n     * Capture/Compare 3 overcapture\n     *               flag\n\
    \     */\n    using cc3of = FieldModel<uint32_t, address, 11, 1>;\n    /**\n \
    \    * @brief CC2OF field\n     *\n     * Capture/compare 2 overcapture\n    \
    \ *               flag\n     */\n    using cc2of = FieldModel<uint32_t, address,\
    \ 10, 1>;\n    /**\n     * @brief CC1OF field\n     *\n     * Capture/Compare\
    \ 1 overcapture\n     *               flag\n     */\n    using cc1of = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief TIF field\n     *\n     * Trigger interrupt\
    \ flag\n     */\n    using tif = FieldModel<uint32_t, address, 6, 1>;\n    /**\n\
    \     * @brief CC4IF field\n     *\n     * Capture/Compare 4 interrupt\n     *\
    \               flag\n     */\n    using cc4if = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief CC3IF field\n     *\n     * Capture/Compare 3\
    \ interrupt\n     *               flag\n     */\n    using cc3if = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief CC2IF field\n     *\n     * Capture/Compare\
    \ 2 interrupt\n     *               flag\n     */\n    using cc2if = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1IF field\n     *\n     * Capture/compare\
    \ 1 interrupt\n     *               flag\n     */\n    using cc1if = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UIF field\n     *\n     * Update interrupt\
    \ flag\n     */\n    using uif = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CC4OF field\n       *\n       * Capture/Compare 4 overcapture\n\
    \       *               flag\n       */\n      BitFieldModel<uint32_t, 12, 1>\
    \ cc4of;\n      /**\n       * @brief CC3OF field\n       *\n       * Capture/Compare\
    \ 3 overcapture\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> cc3of;\n      /**\n       * @brief CC2OF field\n       *\n       * Capture/compare\
    \ 2 overcapture\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> cc2of;\n      /**\n       * @brief CC1OF field\n       *\n       * Capture/Compare\
    \ 1 overcapture\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc1of;\n      /**\n       * @brief TIF field\n       *\n       * Trigger\
    \ interrupt flag\n       */\n      BitFieldModel<uint32_t, 6, 1> tif;\n      /**\n\
    \       * @brief CC4IF field\n       *\n       * Capture/Compare 4 interrupt\n\
    \       *               flag\n       */\n      BitFieldModel<uint32_t, 4, 1> cc4if;\n\
    \      /**\n       * @brief CC3IF field\n       *\n       * Capture/Compare 3\
    \ interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc3if;\n      /**\n       * @brief CC2IF field\n       *\n       * Capture/Compare\
    \ 2 interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cc2if;\n      /**\n       * @brief CC1IF field\n       *\n       * Capture/compare\
    \ 1 interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1if;\n      /**\n       * @brief UIF field\n       *\n       * Update\
    \ interrupt flag\n       */\n      BitFieldModel<uint32_t, 0, 1> uif;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief SR register\n   *\n   * status register\n\
    \   */\n  using sr = SrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class EgrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief TG field\n     *\n     * Trigger generation\n\
    \     */\n    using tg = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     *\
    \ @brief CC4G field\n     *\n     * Capture/compare 4\n     *               generation\n\
    \     */\n    using cc4g = FieldModel<uint32_t, address, 4, 1>;\n    /**\n   \
    \  * @brief CC3G field\n     *\n     * Capture/compare 3\n     *             \
    \  generation\n     */\n    using cc3g = FieldModel<uint32_t, address, 3, 1>;\n\
    \    /**\n     * @brief CC2G field\n     *\n     * Capture/compare 2\n     * \
    \              generation\n     */\n    using cc2g = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief CC1G field\n     *\n     * Capture/compare 1\n\
    \     *               generation\n     */\n    using cc1g = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UG field\n     *\n     * Update generation\n\
    \     */\n    using ug = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n \
    \   /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief TG field\n       *\n       * Trigger generation\n       */\n\
    \      BitFieldModel<uint32_t, 6, 1> tg;\n      /**\n       * @brief CC4G field\n\
    \       *\n       * Capture/compare 4\n       *               generation\n   \
    \    */\n      BitFieldModel<uint32_t, 4, 1> cc4g;\n      /**\n       * @brief\
    \ CC3G field\n       *\n       * Capture/compare 3\n       *               generation\n\
    \       */\n      BitFieldModel<uint32_t, 3, 1> cc3g;\n      /**\n       * @brief\
    \ CC2G field\n       *\n       * Capture/compare 2\n       *               generation\n\
    \       */\n      BitFieldModel<uint32_t, 2, 1> cc2g;\n      /**\n       * @brief\
    \ CC1G field\n       *\n       * Capture/compare 1\n       *               generation\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> cc1g;\n      /**\n       * @brief\
    \ UG field\n       *\n       * Update generation\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> ug;\n    };\n  };\n\npublic:\n  /**\n   * @brief EGR register\n   *\n\
    \   * event generation register\n   */\n  using egr = EgrReg<BaseAddress + 0x0014>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Ccmr1_outputReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief OC2CE\
    \ field\n     *\n     * OC2CE\n     */\n    using oc2ce = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief OC2M field\n     *\n     * OC2M\n \
    \    */\n    using oc2m = FieldModel<uint32_t, address, 12, 3>;\n    /**\n   \
    \  * @brief OC2PE field\n     *\n     * OC2PE\n     */\n    using oc2pe = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief OC2FE field\n     *\n     * OC2FE\n\
    \     */\n    using oc2fe = FieldModel<uint32_t, address, 10, 1>;\n    /**\n \
    \    * @brief CC2S field\n     *\n     * CC2S\n     */\n    using cc2s = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief OC1CE field\n     *\n     * OC1CE\n\
    \     */\n    using oc1ce = FieldModel<uint32_t, address, 7, 1>;\n    /**\n  \
    \   * @brief OC1M field\n     *\n     * OC1M\n     */\n    using oc1m = FieldModel<uint32_t,\
    \ address, 4, 3>;\n    /**\n     * @brief OC1PE field\n     *\n     * OC1PE\n\
    \     */\n    using oc1pe = FieldModel<uint32_t, address, 3, 1>;\n    /**\n  \
    \   * @brief OC1FE field\n     *\n     * OC1FE\n     */\n    using oc1fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1S field\n     *\n     * CC1S\n  \
    \   */\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n \
    \   /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief OC2CE field\n       *\n       * OC2CE\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> oc2ce;\n      /**\n       * @brief OC2M field\n       *\n       * OC2M\n\
    \       */\n      BitFieldModel<uint32_t, 12, 3> oc2m;\n      /**\n       * @brief\
    \ OC2PE field\n       *\n       * OC2PE\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> oc2pe;\n      /**\n       * @brief OC2FE field\n       *\n       * OC2FE\n\
    \       */\n      BitFieldModel<uint32_t, 10, 1> oc2fe;\n      /**\n       * @brief\
    \ CC2S field\n       *\n       * CC2S\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc2s;\n      /**\n       * @brief OC1CE field\n       *\n       * OC1CE\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> oc1ce;\n      /**\n       * @brief\
    \ OC1M field\n       *\n       * OC1M\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 3> oc1m;\n      /**\n       * @brief OC1PE field\n       *\n       * OC1PE\n\
    \       */\n      BitFieldModel<uint32_t, 3, 1> oc1pe;\n      /**\n       * @brief\
    \ OC1FE field\n       *\n       * OC1FE\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc1fe;\n      /**\n       * @brief CC1S field\n       *\n       * CC1S\n\
    \       */\n      BitFieldModel<uint32_t, 0, 2> cc1s;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CCMR1_OUTPUT register\n   *\n   * capture/compare mode register\
    \ 1 (output\n   *           mode)\n   */\n  using ccmr1_output = Ccmr1_outputReg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class Ccmr1_inputReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ IC2F field\n     *\n     * Input capture 2 filter\n     */\n    using ic2f =\
    \ FieldModel<uint32_t, address, 12, 4>;\n    /**\n     * @brief IC2PCS field\n\
    \     *\n     * Input capture 2 prescaler\n     */\n    using ic2pcs = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    /**\n     * @brief CC2S field\n     *\n     * Capture/Compare\
    \ 2\n     *               selection\n     */\n    using cc2s = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief IC1F field\n     *\n     * Input capture\
    \ 1 filter\n     */\n    using ic1f = FieldModel<uint32_t, address, 4, 4>;\n \
    \   /**\n     * @brief ICPCS field\n     *\n     * Input capture 1 prescaler\n\
    \     */\n    using icpcs = FieldModel<uint32_t, address, 2, 2>;\n    /**\n  \
    \   * @brief CC1S field\n     *\n     * Capture/Compare 1\n     *            \
    \   selection\n     */\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief IC2F field\n       *\n       * Input capture\
    \ 2 filter\n       */\n      BitFieldModel<uint32_t, 12, 4> ic2f;\n      /**\n\
    \       * @brief IC2PCS field\n       *\n       * Input capture 2 prescaler\n\
    \       */\n      BitFieldModel<uint32_t, 10, 2> ic2pcs;\n      /**\n       *\
    \ @brief CC2S field\n       *\n       * Capture/Compare 2\n       *          \
    \     selection\n       */\n      BitFieldModel<uint32_t, 8, 2> cc2s;\n      /**\n\
    \       * @brief IC1F field\n       *\n       * Input capture 1 filter\n     \
    \  */\n      BitFieldModel<uint32_t, 4, 4> ic1f;\n      /**\n       * @brief ICPCS\
    \ field\n       *\n       * Input capture 1 prescaler\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 2> icpcs;\n      /**\n       * @brief CC1S field\n       *\n       * Capture/Compare\
    \ 1\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc1s;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCMR1_INPUT register\n\
    \   *\n   * capture/compare mode register 1 (input\n   *           mode)\n   */\n\
    \  using ccmr1_input = Ccmr1_inputReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr2_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief OC4CE field\n     *\n     * OC4CE\n  \
    \   */\n    using oc4ce = FieldModel<uint32_t, address, 15, 1>;\n    /**\n   \
    \  * @brief OC4M field\n     *\n     * OC4M\n     */\n    using oc4m = FieldModel<uint32_t,\
    \ address, 12, 3>;\n    /**\n     * @brief OC4PE field\n     *\n     * OC4PE\n\
    \     */\n    using oc4pe = FieldModel<uint32_t, address, 11, 1>;\n    /**\n \
    \    * @brief OC4FE field\n     *\n     * OC4FE\n     */\n    using oc4fe = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief CC4S field\n     *\n     * CC4S\n \
    \    */\n    using cc4s = FieldModel<uint32_t, address, 8, 2>;\n    /**\n    \
    \ * @brief OC3CE field\n     *\n     * OC3CE\n     */\n    using oc3ce = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief OC3M field\n     *\n     * OC3M\n  \
    \   */\n    using oc3m = FieldModel<uint32_t, address, 4, 3>;\n    /**\n     *\
    \ @brief OC3PE field\n     *\n     * OC3PE\n     */\n    using oc3pe = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief OC3FE field\n     *\n     * OC3FE\n\
    \     */\n    using oc3fe = FieldModel<uint32_t, address, 2, 1>;\n    /**\n  \
    \   * @brief CC3S field\n     *\n     * CC3S\n     */\n    using cc3s = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OC4CE field\n       *\n\
    \       * OC4CE\n       */\n      BitFieldModel<uint32_t, 15, 1> oc4ce;\n    \
    \  /**\n       * @brief OC4M field\n       *\n       * OC4M\n       */\n     \
    \ BitFieldModel<uint32_t, 12, 3> oc4m;\n      /**\n       * @brief OC4PE field\n\
    \       *\n       * OC4PE\n       */\n      BitFieldModel<uint32_t, 11, 1> oc4pe;\n\
    \      /**\n       * @brief OC4FE field\n       *\n       * OC4FE\n       */\n\
    \      BitFieldModel<uint32_t, 10, 1> oc4fe;\n      /**\n       * @brief CC4S\
    \ field\n       *\n       * CC4S\n       */\n      BitFieldModel<uint32_t, 8,\
    \ 2> cc4s;\n      /**\n       * @brief OC3CE field\n       *\n       * OC3CE\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> oc3ce;\n      /**\n       * @brief\
    \ OC3M field\n       *\n       * OC3M\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 3> oc3m;\n      /**\n       * @brief OC3PE field\n       *\n       * OC3PE\n\
    \       */\n      BitFieldModel<uint32_t, 3, 1> oc3pe;\n      /**\n       * @brief\
    \ OC3FE field\n       *\n       * OC3FE\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc3fe;\n      /**\n       * @brief CC3S field\n       *\n       * CC3S\n\
    \       */\n      BitFieldModel<uint32_t, 0, 2> cc3s;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CCMR2_OUTPUT register\n   *\n   * capture/compare mode register\
    \ 2 (output\n   *           mode)\n   */\n  using ccmr2_output = Ccmr2_outputReg<BaseAddress\
    \ + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n  class Ccmr2_inputReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ IC4F field\n     *\n     * Input capture 4 filter\n     */\n    using ic4f =\
    \ FieldModel<uint32_t, address, 12, 4>;\n    /**\n     * @brief IC4PSC field\n\
    \     *\n     * Input capture 4 prescaler\n     */\n    using ic4psc = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    /**\n     * @brief CC4S field\n     *\n     * Capture/Compare\
    \ 4\n     *               selection\n     */\n    using cc4s = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief IC3F field\n     *\n     * Input capture\
    \ 3 filter\n     */\n    using ic3f = FieldModel<uint32_t, address, 4, 4>;\n \
    \   /**\n     * @brief IC3PSC field\n     *\n     * Input capture 3 prescaler\n\
    \     */\n    using ic3psc = FieldModel<uint32_t, address, 2, 2>;\n    /**\n \
    \    * @brief CC3S field\n     *\n     * Capture/compare 3\n     *           \
    \    selection\n     */\n    using cc3s = FieldModel<uint32_t, address, 0, 2>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief IC4F field\n       *\n       * Input capture\
    \ 4 filter\n       */\n      BitFieldModel<uint32_t, 12, 4> ic4f;\n      /**\n\
    \       * @brief IC4PSC field\n       *\n       * Input capture 4 prescaler\n\
    \       */\n      BitFieldModel<uint32_t, 10, 2> ic4psc;\n      /**\n       *\
    \ @brief CC4S field\n       *\n       * Capture/Compare 4\n       *          \
    \     selection\n       */\n      BitFieldModel<uint32_t, 8, 2> cc4s;\n      /**\n\
    \       * @brief IC3F field\n       *\n       * Input capture 3 filter\n     \
    \  */\n      BitFieldModel<uint32_t, 4, 4> ic3f;\n      /**\n       * @brief IC3PSC\
    \ field\n       *\n       * Input capture 3 prescaler\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 2> ic3psc;\n      /**\n       * @brief CC3S field\n       *\n       * Capture/compare\
    \ 3\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc3s;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCMR2_INPUT register\n\
    \   *\n   * capture/compare mode register 2 (input\n   *           mode)\n   */\n\
    \  using ccmr2_input = Ccmr2_inputReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CcerReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief CC4NP field\n     *\n     * Capture/Compare\
    \ 4 output\n     *               Polarity\n     */\n    using cc4np = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief CC4P field\n     *\n     * Capture/Compare\
    \ 3 output\n     *               Polarity\n     */\n    using cc4p = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief CC4E field\n     *\n     * Capture/Compare\
    \ 4 output\n     *               enable\n     */\n    using cc4e = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief CC3NP field\n     *\n     * Capture/Compare\
    \ 3 output\n     *               Polarity\n     */\n    using cc3np = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief CC3P field\n     *\n     * Capture/Compare\
    \ 3 output\n     *               Polarity\n     */\n    using cc3p = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief CC3E field\n     *\n     * Capture/Compare\
    \ 3 output\n     *               enable\n     */\n    using cc3e = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief CC2NP field\n     *\n     * Capture/Compare\
    \ 2 output\n     *               Polarity\n     */\n    using cc2np = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief CC2P field\n     *\n     * Capture/Compare\
    \ 2 output\n     *               Polarity\n     */\n    using cc2p = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief CC2E field\n     *\n     * Capture/Compare\
    \ 2 output\n     *               enable\n     */\n    using cc2e = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief CC1NP field\n     *\n     * Capture/Compare\
    \ 1 output\n     *               Polarity\n     */\n    using cc1np = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief CC1P field\n     *\n     * Capture/Compare\
    \ 1 output\n     *               Polarity\n     */\n    using cc1p = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief CC1E field\n     *\n     * Capture/Compare\
    \ 1 output\n     *               enable\n     */\n    using cc1e = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CC4NP field\n       *\n\
    \       * Capture/Compare 4 output\n       *               Polarity\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> cc4np;\n      /**\n       * @brief CC4P\
    \ field\n       *\n       * Capture/Compare 3 output\n       *               Polarity\n\
    \       */\n      BitFieldModel<uint32_t, 13, 1> cc4p;\n      /**\n       * @brief\
    \ CC4E field\n       *\n       * Capture/Compare 4 output\n       *          \
    \     enable\n       */\n      BitFieldModel<uint32_t, 12, 1> cc4e;\n      /**\n\
    \       * @brief CC3NP field\n       *\n       * Capture/Compare 3 output\n  \
    \     *               Polarity\n       */\n      BitFieldModel<uint32_t, 11, 1>\
    \ cc3np;\n      /**\n       * @brief CC3P field\n       *\n       * Capture/Compare\
    \ 3 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc3p;\n      /**\n       * @brief CC3E field\n       *\n       * Capture/Compare\
    \ 3 output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> cc3e;\n      /**\n       * @brief CC2NP field\n       *\n       * Capture/Compare\
    \ 2 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> cc2np;\n      /**\n       * @brief CC2P field\n       *\n       * Capture/Compare\
    \ 2 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> cc2p;\n      /**\n       * @brief CC2E field\n       *\n       * Capture/Compare\
    \ 2 output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> cc2e;\n      /**\n       * @brief CC1NP field\n       *\n       * Capture/Compare\
    \ 1 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> cc1np;\n      /**\n       * @brief CC1P field\n       *\n       * Capture/Compare\
    \ 1 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1p;\n      /**\n       * @brief CC1E field\n       *\n       * Capture/Compare\
    \ 1 output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> cc1e;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCER register\n   *\n\
    \   * capture/compare enable\n   *           register\n   */\n  using ccer = CcerReg<BaseAddress\
    \ + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n  class CntReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CNT_H\
    \ field\n     *\n     * High counter value\n     */\n    using cnt_h = FieldModel<uint32_t,\
    \ address, 16, 16>;\n    /**\n     * @brief CNT_L field\n     *\n     * Low counter\
    \ value\n     */\n    using cnt_l = FieldModel<uint32_t, address, 0, 16>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief CNT_H field\n       *\n       * High counter\
    \ value\n       */\n      BitFieldModel<uint32_t, 16, 16> cnt_h;\n      /**\n\
    \       * @brief CNT_L field\n       *\n       * Low counter value\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> cnt_l;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief CNT register\n   *\n   * counter\n   */\n  using cnt = CntReg<BaseAddress\
    \ + 0x0024>;\n\nprivate:\n  template<unsigned int address>\n  class PscReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief PSC\
    \ field\n     *\n     * Prescaler value\n     */\n    using psc = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief PSC field\n       *\n \
    \      * Prescaler value\n       */\n      BitFieldModel<uint32_t, 0, 16> psc;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief PSC register\n   *\n   * prescaler\n\
    \   */\n  using psc = PscReg<BaseAddress + 0x0028>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class ArrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief ARR_H field\n     *\n     * High Auto-reload\
    \ value\n     */\n    using arr_h = FieldModel<uint32_t, address, 16, 16>;\n \
    \   /**\n     * @brief ARR_L field\n     *\n     * Low Auto-reload value\n   \
    \  */\n    using arr_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief ARR_H field\n       *\n       * High Auto-reload value\n    \
    \   */\n      BitFieldModel<uint32_t, 16, 16> arr_h;\n      /**\n       * @brief\
    \ ARR_L field\n       *\n       * Low Auto-reload value\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> arr_l;\n    };\n  };\n\npublic:\n  /**\n   * @brief ARR register\n  \
    \ *\n   * auto-reload register\n   */\n  using arr = ArrReg<BaseAddress + 0x002C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Ccr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CCR1_H field\n     *\n    \
    \ * High Capture/Compare 1\n     *               value\n     */\n    using ccr1_h\
    \ = FieldModel<uint32_t, address, 16, 16>;\n    /**\n     * @brief CCR1_L field\n\
    \     *\n     * Low Capture/Compare 1\n     *               value\n     */\n \
    \   using ccr1_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CCR1_H field\n       *\n       * High Capture/Compare 1\n       *          \
    \     value\n       */\n      BitFieldModel<uint32_t, 16, 16> ccr1_h;\n      /**\n\
    \       * @brief CCR1_L field\n       *\n       * Low Capture/Compare 1\n    \
    \   *               value\n       */\n      BitFieldModel<uint32_t, 0, 16> ccr1_l;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief CCR1 register\n   *\n   * capture/compare\
    \ register 1\n   */\n  using ccr1 = Ccr1Reg<BaseAddress + 0x0034>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Ccr2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CCR2_H field\n     *\n    \
    \ * High Capture/Compare 2\n     *               value\n     */\n    using ccr2_h\
    \ = FieldModel<uint32_t, address, 16, 16>;\n    /**\n     * @brief CCR2_L field\n\
    \     *\n     * Low Capture/Compare 2\n     *               value\n     */\n \
    \   using ccr2_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CCR2_H field\n       *\n       * High Capture/Compare 2\n       *          \
    \     value\n       */\n      BitFieldModel<uint32_t, 16, 16> ccr2_h;\n      /**\n\
    \       * @brief CCR2_L field\n       *\n       * Low Capture/Compare 2\n    \
    \   *               value\n       */\n      BitFieldModel<uint32_t, 0, 16> ccr2_l;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief CCR2 register\n   *\n   * capture/compare\
    \ register 2\n   */\n  using ccr2 = Ccr2Reg<BaseAddress + 0x0038>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Ccr3Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CCR3_H field\n     *\n    \
    \ * High Capture/Compare value\n     */\n    using ccr3_h = FieldModel<uint32_t,\
    \ address, 16, 16>;\n    /**\n     * @brief CCR3_L field\n     *\n     * Low Capture/Compare\
    \ value\n     */\n    using ccr3_l = FieldModel<uint32_t, address, 0, 16>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief CCR3_H field\n       *\n       * High Capture/Compare\
    \ value\n       */\n      BitFieldModel<uint32_t, 16, 16> ccr3_h;\n      /**\n\
    \       * @brief CCR3_L field\n       *\n       * Low Capture/Compare value\n\
    \       */\n      BitFieldModel<uint32_t, 0, 16> ccr3_l;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CCR3 register\n   *\n   * capture/compare register 3\n   */\n\
    \  using ccr3 = Ccr3Reg<BaseAddress + 0x003C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccr4Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief CCR4_H field\n     *\n     * High Capture/Compare\
    \ value\n     */\n    using ccr4_h = FieldModel<uint32_t, address, 16, 16>;\n\
    \    /**\n     * @brief CCR4_L field\n     *\n     * Low Capture/Compare value\n\
    \     */\n    using ccr4_l = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CCR4_H field\n       *\n       * High Capture/Compare value\n\
    \       */\n      BitFieldModel<uint32_t, 16, 16> ccr4_h;\n      /**\n       *\
    \ @brief CCR4_L field\n       *\n       * Low Capture/Compare value\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ccr4_l;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief CCR4 register\n   *\n   * capture/compare register 4\n   */\n  using\
    \ ccr4 = Ccr4Reg<BaseAddress + 0x0040>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class DcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief DBL field\n     *\n     * DMA burst length\n     */\n  \
    \  using dbl = FieldModel<uint32_t, address, 8, 5>;\n    /**\n     * @brief DBA\
    \ field\n     *\n     * DMA base address\n     */\n    using dba = FieldModel<uint32_t,\
    \ address, 0, 5>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief DBL field\n       *\n \
    \      * DMA burst length\n       */\n      BitFieldModel<uint32_t, 8, 5> dbl;\n\
    \      /**\n       * @brief DBA field\n       *\n       * DMA base address\n \
    \      */\n      BitFieldModel<uint32_t, 0, 5> dba;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief DCR register\n   *\n   * DMA control register\n   */\n  using\
    \ dcr = DcrReg<BaseAddress + 0x0048>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class DmarReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief DMAB field\n     *\n     * DMA register for burst\n   \
    \  *               accesses\n     */\n    using dmab = FieldModel<uint32_t, address,\
    \ 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief DMAB field\n       *\n\
    \       * DMA register for burst\n       *               accesses\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> dmab;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief DMAR register\n   *\n   * DMA address for full transfer\n   */\n\
    \  using dmar = DmarReg<BaseAddress + 0x004C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class OrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief IT4_RMP field\n     *\n     * Timer Input 4\
    \ remap\n     */\n    using it4_rmp = FieldModel<uint32_t, address, 6, 2>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief IT4_RMP field\n       *\n       * Timer Input\
    \ 4 remap\n       */\n      BitFieldModel<uint32_t, 6, 2> it4_rmp;\n    };\n \
    \ };\n\npublic:\n  /**\n   * @brief OR register\n   *\n   * TIM5 option register\n\
    \   */\n  using or_ = OrReg<BaseAddress + 0x0050>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_TIM5_H\
    \ */"
  name: TIM5
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_TIM9_H\n#define DRAL_STM32F411_TIM9_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ TIM9 peripheral\n *\n * General purpose timers\n */\nclass tim9\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40014000; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CKD\
    \ field\n     *\n     * Clock division\n     */\n    using ckd = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief ARPE field\n     *\n     * Auto-reload\
    \ preload enable\n     */\n    using arpe = FieldModel<uint32_t, address, 7, 1>;\n\
    \    /**\n     * @brief OPM field\n     *\n     * One-pulse mode\n     */\n  \
    \  using opm = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief URS\
    \ field\n     *\n     * Update request source\n     */\n    using urs = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief UDIS field\n     *\n     * Update disable\n\
    \     */\n    using udis = FieldModel<uint32_t, address, 1, 1>;\n    /**\n   \
    \  * @brief CEN field\n     *\n     * Counter enable\n     */\n    using cen =\
    \ FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register\
    \ union\n     *\n     * Can be used to create a local register variable for easy\
    \ bit manipulation.\n     * Useful for read-modify-write operations.\n     */\n\
    \    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief CKD field\n\
    \       *\n       * Clock division\n       */\n      BitFieldModel<uint32_t, 8,\
    \ 2> ckd;\n      /**\n       * @brief ARPE field\n       *\n       * Auto-reload\
    \ preload enable\n       */\n      BitFieldModel<uint32_t, 7, 1> arpe;\n     \
    \ /**\n       * @brief OPM field\n       *\n       * One-pulse mode\n       */\n\
    \      BitFieldModel<uint32_t, 3, 1> opm;\n      /**\n       * @brief URS field\n\
    \       *\n       * Update request source\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> urs;\n      /**\n       * @brief UDIS field\n       *\n       * Update\
    \ disable\n       */\n      BitFieldModel<uint32_t, 1, 1> udis;\n      /**\n \
    \      * @brief CEN field\n       *\n       * Counter enable\n       */\n    \
    \  BitFieldModel<uint32_t, 0, 1> cen;\n    };\n  };\n\npublic:\n  /**\n   * @brief\
    \ CR1 register\n   *\n   * control register 1\n   */\n  using cr1 = Cr1Reg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class Cr2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief MMS\
    \ field\n     *\n     * Master mode selection\n     */\n    using mms = FieldModel<uint32_t,\
    \ address, 4, 3>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief MMS field\n       *\n \
    \      * Master mode selection\n       */\n      BitFieldModel<uint32_t, 4, 3>\
    \ mms;\n    };\n  };\n\npublic:\n  /**\n   * @brief CR2 register\n   *\n   * control\
    \ register 2\n   */\n  using cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class SmcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief MSM field\n     *\n     * Master/Slave\
    \ mode\n     */\n    using msm = FieldModel<uint32_t, address, 7, 1>;\n    /**\n\
    \     * @brief TS field\n     *\n     * Trigger selection\n     */\n    using\
    \ ts = FieldModel<uint32_t, address, 4, 3>;\n    /**\n     * @brief SMS field\n\
    \     *\n     * Slave mode selection\n     */\n    using sms = FieldModel<uint32_t,\
    \ address, 0, 3>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief MSM field\n       *\n \
    \      * Master/Slave mode\n       */\n      BitFieldModel<uint32_t, 7, 1> msm;\n\
    \      /**\n       * @brief TS field\n       *\n       * Trigger selection\n \
    \      */\n      BitFieldModel<uint32_t, 4, 3> ts;\n      /**\n       * @brief\
    \ SMS field\n       *\n       * Slave mode selection\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 3> sms;\n    };\n  };\n\npublic:\n  /**\n   * @brief SMCR register\n   *\n\
    \   * slave mode control register\n   */\n  using smcr = SmcrReg<BaseAddress +\
    \ 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class DierReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief TIE\
    \ field\n     *\n     * Trigger interrupt enable\n     */\n    using tie = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief CC2IE field\n     *\n     * Capture/Compare\
    \ 2 interrupt\n     *               enable\n     */\n    using cc2ie = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1IE field\n     *\n     * Capture/Compare\
    \ 1 interrupt\n     *               enable\n     */\n    using cc1ie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UIE field\n     *\n     * Update interrupt\
    \ enable\n     */\n    using uie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief TIE field\n       *\n       * Trigger interrupt enable\n    \
    \   */\n      BitFieldModel<uint32_t, 6, 1> tie;\n      /**\n       * @brief CC2IE\
    \ field\n       *\n       * Capture/Compare 2 interrupt\n       *            \
    \   enable\n       */\n      BitFieldModel<uint32_t, 2, 1> cc2ie;\n      /**\n\
    \       * @brief CC1IE field\n       *\n       * Capture/Compare 1 interrupt\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 1, 1>\
    \ cc1ie;\n      /**\n       * @brief UIE field\n       *\n       * Update interrupt\
    \ enable\n       */\n      BitFieldModel<uint32_t, 0, 1> uie;\n    };\n  };\n\n\
    public:\n  /**\n   * @brief DIER register\n   *\n   * DMA/Interrupt enable register\n\
    \   */\n  using dier = DierReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class SrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief CC2OF field\n     *\n     * Capture/compare\
    \ 2 overcapture\n     *               flag\n     */\n    using cc2of = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief CC1OF field\n     *\n     * Capture/Compare\
    \ 1 overcapture\n     *               flag\n     */\n    using cc1of = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief TIF field\n     *\n     * Trigger interrupt\
    \ flag\n     */\n    using tif = FieldModel<uint32_t, address, 6, 1>;\n    /**\n\
    \     * @brief CC2IF field\n     *\n     * Capture/Compare 2 interrupt\n     *\
    \               flag\n     */\n    using cc2if = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief CC1IF field\n     *\n     * Capture/compare 1\
    \ interrupt\n     *               flag\n     */\n    using cc1if = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief UIF field\n     *\n     * Update interrupt\
    \ flag\n     */\n    using uif = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief CC2OF field\n       *\n       * Capture/compare 2 overcapture\n\
    \       *               flag\n       */\n      BitFieldModel<uint32_t, 10, 1>\
    \ cc2of;\n      /**\n       * @brief CC1OF field\n       *\n       * Capture/Compare\
    \ 1 overcapture\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cc1of;\n      /**\n       * @brief TIF field\n       *\n       * Trigger\
    \ interrupt flag\n       */\n      BitFieldModel<uint32_t, 6, 1> tif;\n      /**\n\
    \       * @brief CC2IF field\n       *\n       * Capture/Compare 2 interrupt\n\
    \       *               flag\n       */\n      BitFieldModel<uint32_t, 2, 1> cc2if;\n\
    \      /**\n       * @brief CC1IF field\n       *\n       * Capture/compare 1\
    \ interrupt\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1if;\n      /**\n       * @brief UIF field\n       *\n       * Update\
    \ interrupt flag\n       */\n      BitFieldModel<uint32_t, 0, 1> uif;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief SR register\n   *\n   * status register\n\
    \   */\n  using sr = SrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class EgrReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief TG field\n     *\n     * Trigger generation\n\
    \     */\n    using tg = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     *\
    \ @brief CC2G field\n     *\n     * Capture/compare 2\n     *               generation\n\
    \     */\n    using cc2g = FieldModel<uint32_t, address, 2, 1>;\n    /**\n   \
    \  * @brief CC1G field\n     *\n     * Capture/compare 1\n     *             \
    \  generation\n     */\n    using cc1g = FieldModel<uint32_t, address, 1, 1>;\n\
    \    /**\n     * @brief UG field\n     *\n     * Update generation\n     */\n\
    \    using ug = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n \
    \    * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ TG field\n       *\n       * Trigger generation\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> tg;\n      /**\n       * @brief CC2G field\n       *\n       * Capture/compare\
    \ 2\n       *               generation\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cc2g;\n      /**\n       * @brief CC1G field\n       *\n       * Capture/compare\
    \ 1\n       *               generation\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1g;\n      /**\n       * @brief UG field\n       *\n       * Update\
    \ generation\n       */\n      BitFieldModel<uint32_t, 0, 1> ug;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief EGR register\n   *\n   * event generation register\n\
    \   */\n  using egr = EgrReg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ccmr1_outputReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief OC2M field\n     *\n     * Output Compare\
    \ 2 mode\n     */\n    using oc2m = FieldModel<uint32_t, address, 12, 3>;\n  \
    \  /**\n     * @brief OC2PE field\n     *\n     * Output Compare 2 preload\n \
    \    *               enable\n     */\n    using oc2pe = FieldModel<uint32_t, address,\
    \ 11, 1>;\n    /**\n     * @brief OC2FE field\n     *\n     * Output Compare 2\
    \ fast\n     *               enable\n     */\n    using oc2fe = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief CC2S field\n     *\n     * Capture/Compare\
    \ 2\n     *               selection\n     */\n    using cc2s = FieldModel<uint32_t,\
    \ address, 8, 2>;\n    /**\n     * @brief OC1M field\n     *\n     * Output Compare\
    \ 1 mode\n     */\n    using oc1m = FieldModel<uint32_t, address, 4, 3>;\n   \
    \ /**\n     * @brief OC1PE field\n     *\n     * Output Compare 1 preload\n  \
    \   *               enable\n     */\n    using oc1pe = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief OC1FE field\n     *\n     * Output Compare 1\
    \ fast\n     *               enable\n     */\n    using oc1fe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CC1S field\n     *\n     * Capture/Compare\
    \ 1\n     *               selection\n     */\n    using cc1s = FieldModel<uint32_t,\
    \ address, 0, 2>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OC2M field\n       *\n\
    \       * Output Compare 2 mode\n       */\n      BitFieldModel<uint32_t, 12,\
    \ 3> oc2m;\n      /**\n       * @brief OC2PE field\n       *\n       * Output\
    \ Compare 2 preload\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> oc2pe;\n      /**\n       * @brief OC2FE field\n       *\n       * Output\
    \ Compare 2 fast\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> oc2fe;\n      /**\n       * @brief CC2S field\n       *\n       * Capture/Compare\
    \ 2\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 2> cc2s;\n      /**\n       * @brief OC1M field\n       *\n       * Output\
    \ Compare 1 mode\n       */\n      BitFieldModel<uint32_t, 4, 3> oc1m;\n     \
    \ /**\n       * @brief OC1PE field\n       *\n       * Output Compare 1 preload\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 3, 1>\
    \ oc1pe;\n      /**\n       * @brief OC1FE field\n       *\n       * Output Compare\
    \ 1 fast\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> oc1fe;\n      /**\n       * @brief CC1S field\n       *\n       * Capture/Compare\
    \ 1\n       *               selection\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> cc1s;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCMR1_OUTPUT register\n\
    \   *\n   * capture/compare mode register 1 (output\n   *           mode)\n  \
    \ */\n  using ccmr1_output = Ccmr1_outputReg<BaseAddress + 0x0018>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class Ccmr1_inputReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief IC2F field\n     *\n     *\
    \ Input capture 2 filter\n     */\n    using ic2f = FieldModel<uint32_t, address,\
    \ 12, 3>;\n    /**\n     * @brief IC2PCS field\n     *\n     * Input capture 2\
    \ prescaler\n     */\n    using ic2pcs = FieldModel<uint32_t, address, 10, 2>;\n\
    \    /**\n     * @brief CC2S field\n     *\n     * Capture/Compare 2\n     * \
    \              selection\n     */\n    using cc2s = FieldModel<uint32_t, address,\
    \ 8, 2>;\n    /**\n     * @brief IC1F field\n     *\n     * Input capture 1 filter\n\
    \     */\n    using ic1f = FieldModel<uint32_t, address, 4, 3>;\n    /**\n   \
    \  * @brief ICPCS field\n     *\n     * Input capture 1 prescaler\n     */\n \
    \   using icpcs = FieldModel<uint32_t, address, 2, 2>;\n    /**\n     * @brief\
    \ CC1S field\n     *\n     * Capture/Compare 1\n     *               selection\n\
    \     */\n    using cc1s = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief IC2F field\n       *\n       * Input capture 2 filter\n     \
    \  */\n      BitFieldModel<uint32_t, 12, 3> ic2f;\n      /**\n       * @brief\
    \ IC2PCS field\n       *\n       * Input capture 2 prescaler\n       */\n    \
    \  BitFieldModel<uint32_t, 10, 2> ic2pcs;\n      /**\n       * @brief CC2S field\n\
    \       *\n       * Capture/Compare 2\n       *               selection\n    \
    \   */\n      BitFieldModel<uint32_t, 8, 2> cc2s;\n      /**\n       * @brief\
    \ IC1F field\n       *\n       * Input capture 1 filter\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 3> ic1f;\n      /**\n       * @brief ICPCS field\n       *\n       * Input\
    \ capture 1 prescaler\n       */\n      BitFieldModel<uint32_t, 2, 2> icpcs;\n\
    \      /**\n       * @brief CC1S field\n       *\n       * Capture/Compare 1\n\
    \       *               selection\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 2> cc1s;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCMR1_INPUT register\n\
    \   *\n   * capture/compare mode register 1 (input\n   *           mode)\n   */\n\
    \  using ccmr1_input = Ccmr1_inputReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class CcerReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief CC2NP field\n     *\n     * Capture/Compare\
    \ 2 output\n     *               Polarity\n     */\n    using cc2np = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief CC2P field\n     *\n     * Capture/Compare\
    \ 2 output\n     *               Polarity\n     */\n    using cc2p = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief CC2E field\n     *\n     * Capture/Compare\
    \ 2 output\n     *               enable\n     */\n    using cc2e = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief CC1NP field\n     *\n     * Capture/Compare\
    \ 1 output\n     *               Polarity\n     */\n    using cc1np = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief CC1P field\n     *\n     * Capture/Compare\
    \ 1 output\n     *               Polarity\n     */\n    using cc1p = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief CC1E field\n     *\n     * Capture/Compare\
    \ 1 output\n     *               enable\n     */\n    using cc1e = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CC2NP field\n       *\n\
    \       * Capture/Compare 2 output\n       *               Polarity\n       */\n\
    \      BitFieldModel<uint32_t, 7, 1> cc2np;\n      /**\n       * @brief CC2P field\n\
    \       *\n       * Capture/Compare 2 output\n       *               Polarity\n\
    \       */\n      BitFieldModel<uint32_t, 5, 1> cc2p;\n      /**\n       * @brief\
    \ CC2E field\n       *\n       * Capture/Compare 2 output\n       *          \
    \     enable\n       */\n      BitFieldModel<uint32_t, 4, 1> cc2e;\n      /**\n\
    \       * @brief CC1NP field\n       *\n       * Capture/Compare 1 output\n  \
    \     *               Polarity\n       */\n      BitFieldModel<uint32_t, 3, 1>\
    \ cc1np;\n      /**\n       * @brief CC1P field\n       *\n       * Capture/Compare\
    \ 1 output\n       *               Polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> cc1p;\n      /**\n       * @brief CC1E field\n       *\n       * Capture/Compare\
    \ 1 output\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> cc1e;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCER register\n   *\n\
    \   * capture/compare enable\n   *           register\n   */\n  using ccer = CcerReg<BaseAddress\
    \ + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n  class CntReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CNT\
    \ field\n     *\n     * counter value\n     */\n    using cnt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CNT field\n       *\n \
    \      * counter value\n       */\n      BitFieldModel<uint32_t, 0, 16> cnt;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief CNT register\n   *\n   * counter\n\
    \   */\n  using cnt = CntReg<BaseAddress + 0x0024>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class PscReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief PSC field\n     *\n     * Prescaler value\n\
    \     */\n    using psc = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief PSC field\n       *\n       * Prescaler value\n       */\n  \
    \    BitFieldModel<uint32_t, 0, 16> psc;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief PSC register\n   *\n   * prescaler\n   */\n  using psc = PscReg<BaseAddress\
    \ + 0x0028>;\n\nprivate:\n  template<unsigned int address>\n  class ArrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief ARR\
    \ field\n     *\n     * Auto-reload value\n     */\n    using arr = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief ARR field\n       *\n \
    \      * Auto-reload value\n       */\n      BitFieldModel<uint32_t, 0, 16> arr;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief ARR register\n   *\n   * auto-reload\
    \ register\n   */\n  using arr = ArrReg<BaseAddress + 0x002C>;\n\nprivate:\n \
    \ template<unsigned int address>\n  class Ccr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CCR1 field\n     *\n     *\
    \ Capture/Compare 1 value\n     */\n    using ccr1 = FieldModel<uint32_t, address,\
    \ 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CCR1 field\n       *\n\
    \       * Capture/Compare 1 value\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 16> ccr1;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCR1 register\n   *\n\
    \   * capture/compare register 1\n   */\n  using ccr1 = Ccr1Reg<BaseAddress +\
    \ 0x0034>;\n\nprivate:\n  template<unsigned int address>\n  class Ccr2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CCR2\
    \ field\n     *\n     * Capture/Compare 2 value\n     */\n    using ccr2 = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CCR2 field\n       *\n\
    \       * Capture/Compare 2 value\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 16> ccr2;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCR2 register\n   *\n\
    \   * capture/compare register 2\n   */\n  using ccr2 = Ccr2Reg<BaseAddress +\
    \ 0x0038>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_TIM9_H */"
  name: TIM9
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_USART1_H\n#define DRAL_STM32F411_USART1_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ USART1 peripheral\n *\n * Universal synchronous asynchronous receiver\n *  \
    \     transmitter\n */\nclass usart1\n{\npublic:\n  static constexpr unsigned\
    \ int BaseAddress = 0x40011000; /**< Peripheral base address */\n\nprivate:\n\
    \  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CTS field\n     *\n     * CTS\
    \ flag\n     */\n    using cts = FieldModel<uint32_t, address, 9, 1>;\n    /**\n\
    \     * @brief LBD field\n     *\n     * LIN break detection flag\n     */\n \
    \   using lbd = FieldModel<uint32_t, address, 8, 1>;\n    /**\n     * @brief TXE\
    \ field\n     *\n     * Transmit data register\n     *               empty\n \
    \    */\n    using txe = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     *\
    \ @brief TC field\n     *\n     * Transmission complete\n     */\n    using tc\
    \ = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief RXNE field\n\
    \     *\n     * Read data register not\n     *               empty\n     */\n\
    \    using rxne = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief\
    \ IDLE field\n     *\n     * IDLE line detected\n     */\n    using idle = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ORE field\n     *\n     * Overrun error\n\
    \     */\n    using ore = FieldModel<uint32_t, address, 3, 1>;\n    /**\n    \
    \ * @brief NF field\n     *\n     * Noise detected flag\n     */\n    using nf\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief FE field\n  \
    \   *\n     * Framing error\n     */\n    using fe = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    /**\n     * @brief PE field\n     *\n     * Parity error\n     */\n\
    \    using pe = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n \
    \    * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CTS field\n       *\n       * CTS flag\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cts;\n      /**\n       * @brief LBD field\n       *\n       * LIN break\
    \ detection flag\n       */\n      BitFieldModel<uint32_t, 8, 1> lbd;\n      /**\n\
    \       * @brief TXE field\n       *\n       * Transmit data register\n      \
    \ *               empty\n       */\n      BitFieldModel<uint32_t, 7, 1> txe;\n\
    \      /**\n       * @brief TC field\n       *\n       * Transmission complete\n\
    \       */\n      BitFieldModel<uint32_t, 6, 1> tc;\n      /**\n       * @brief\
    \ RXNE field\n       *\n       * Read data register not\n       *            \
    \   empty\n       */\n      BitFieldModel<uint32_t, 5, 1> rxne;\n      /**\n \
    \      * @brief IDLE field\n       *\n       * IDLE line detected\n       */\n\
    \      BitFieldModel<uint32_t, 4, 1> idle;\n      /**\n       * @brief ORE field\n\
    \       *\n       * Overrun error\n       */\n      BitFieldModel<uint32_t, 3,\
    \ 1> ore;\n      /**\n       * @brief NF field\n       *\n       * Noise detected\
    \ flag\n       */\n      BitFieldModel<uint32_t, 2, 1> nf;\n      /**\n      \
    \ * @brief FE field\n       *\n       * Framing error\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> fe;\n      /**\n       * @brief PE field\n       *\n       * Parity error\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> pe;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief SR register\n   *\n   * Status register\n   */\n  using sr\
    \ = SrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class DrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ /**\n     * @brief DR field\n     *\n     * Data value\n     */\n    using dr\
    \ = FieldModel<uint32_t, address, 0, 9>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ DR field\n       *\n       * Data value\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 9> dr;\n    };\n  };\n\npublic:\n  /**\n   * @brief DR register\n   *\n \
    \  * Data register\n   */\n  using dr = DrReg<BaseAddress + 0x0004>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class BrrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief DIV_MANTISSA field\n     *\n\
    \     * mantissa of USARTDIV\n     */\n    using div_mantissa = FieldModel<uint32_t,\
    \ address, 4, 12>;\n    /**\n     * @brief DIV_FRACTION field\n     *\n     *\
    \ fraction of USARTDIV\n     */\n    using div_fraction = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief DIV_MANTISSA field\n  \
    \     *\n       * mantissa of USARTDIV\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 12> div_mantissa;\n      /**\n       * @brief DIV_FRACTION field\n      \
    \ *\n       * fraction of USARTDIV\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 4> div_fraction;\n    };\n  };\n\npublic:\n  /**\n   * @brief BRR register\n\
    \   *\n   * Baud rate register\n   */\n  using brr = BrrReg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief OVER8 field\n     *\n     *\
    \ Oversampling mode\n     */\n    using over8 = FieldModel<uint32_t, address,\
    \ 15, 1>;\n    /**\n     * @brief UE field\n     *\n     * USART enable\n    \
    \ */\n    using ue = FieldModel<uint32_t, address, 13, 1>;\n    /**\n     * @brief\
    \ M field\n     *\n     * Word length\n     */\n    using m = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief WAKE field\n     *\n     * Wakeup method\n\
    \     */\n    using wake = FieldModel<uint32_t, address, 11, 1>;\n    /**\n  \
    \   * @brief PCE field\n     *\n     * Parity control enable\n     */\n    using\
    \ pce = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief PS field\n\
    \     *\n     * Parity selection\n     */\n    using ps = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief PEIE field\n     *\n     * PE interrupt\
    \ enable\n     */\n    using peie = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ /**\n     * @brief TXEIE field\n     *\n     * TXE interrupt enable\n     */\n\
    \    using txeie = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief\
    \ TCIE field\n     *\n     * Transmission complete interrupt\n     *         \
    \      enable\n     */\n    using tcie = FieldModel<uint32_t, address, 6, 1>;\n\
    \    /**\n     * @brief RXNEIE field\n     *\n     * RXNE interrupt enable\n \
    \    */\n    using rxneie = FieldModel<uint32_t, address, 5, 1>;\n    /**\n  \
    \   * @brief IDLEIE field\n     *\n     * IDLE interrupt enable\n     */\n   \
    \ using idleie = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief\
    \ TE field\n     *\n     * Transmitter enable\n     */\n    using te = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief RE field\n     *\n     * Receiver enable\n\
    \     */\n    using re = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     *\
    \ @brief RWU field\n     *\n     * Receiver wakeup\n     */\n    using rwu = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief SBK field\n     *\n     * Send break\n\
    \     */\n    using sbk = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief OVER8 field\n       *\n       * Oversampling mode\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> over8;\n      /**\n       * @brief UE field\n\
    \       *\n       * USART enable\n       */\n      BitFieldModel<uint32_t, 13,\
    \ 1> ue;\n      /**\n       * @brief M field\n       *\n       * Word length\n\
    \       */\n      BitFieldModel<uint32_t, 12, 1> m;\n      /**\n       * @brief\
    \ WAKE field\n       *\n       * Wakeup method\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> wake;\n      /**\n       * @brief PCE field\n       *\n       * Parity\
    \ control enable\n       */\n      BitFieldModel<uint32_t, 10, 1> pce;\n     \
    \ /**\n       * @brief PS field\n       *\n       * Parity selection\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> ps;\n      /**\n       * @brief PEIE field\n\
    \       *\n       * PE interrupt enable\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> peie;\n      /**\n       * @brief TXEIE field\n       *\n       * TXE\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 7, 1> txeie;\n  \
    \    /**\n       * @brief TCIE field\n       *\n       * Transmission complete\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> tcie;\n      /**\n       * @brief RXNEIE field\n       *\n       * RXNE\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 5, 1> rxneie;\n \
    \     /**\n       * @brief IDLEIE field\n       *\n       * IDLE interrupt enable\n\
    \       */\n      BitFieldModel<uint32_t, 4, 1> idleie;\n      /**\n       * @brief\
    \ TE field\n       *\n       * Transmitter enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> te;\n      /**\n       * @brief RE field\n       *\n       * Receiver\
    \ enable\n       */\n      BitFieldModel<uint32_t, 2, 1> re;\n      /**\n    \
    \   * @brief RWU field\n       *\n       * Receiver wakeup\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> rwu;\n      /**\n       * @brief SBK field\n       *\n       * Send break\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> sbk;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR1 register\n   *\n   * Control register 1\n   */\n  using\
    \ cr1 = Cr1Reg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief LINEN field\n     *\n     * LIN mode enable\n     */\n \
    \   using linen = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief\
    \ STOP field\n     *\n     * STOP bits\n     */\n    using stop = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    /**\n     * @brief CLKEN field\n     *\n     * Clock enable\n\
    \     */\n    using clken = FieldModel<uint32_t, address, 11, 1>;\n    /**\n \
    \    * @brief CPOL field\n     *\n     * Clock polarity\n     */\n    using cpol\
    \ = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief CPHA field\n\
    \     *\n     * Clock phase\n     */\n    using cpha = FieldModel<uint32_t, address,\
    \ 9, 1>;\n    /**\n     * @brief LBCL field\n     *\n     * Last bit clock pulse\n\
    \     */\n    using lbcl = FieldModel<uint32_t, address, 8, 1>;\n    /**\n   \
    \  * @brief LBDIE field\n     *\n     * LIN break detection interrupt\n     *\
    \               enable\n     */\n    using lbdie = FieldModel<uint32_t, address,\
    \ 6, 1>;\n    /**\n     * @brief LBDL field\n     *\n     * lin break detection\
    \ length\n     */\n    using lbdl = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ /**\n     * @brief ADD field\n     *\n     * Address of the USART node\n   \
    \  */\n    using add = FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n   \
    \ /**\n     * @brief Register union\n     *\n     * Can be used to create a local\
    \ register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief LINEN field\n       *\n       * LIN mode enable\n       */\n\
    \      BitFieldModel<uint32_t, 14, 1> linen;\n      /**\n       * @brief STOP\
    \ field\n       *\n       * STOP bits\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 2> stop;\n      /**\n       * @brief CLKEN field\n       *\n       * Clock\
    \ enable\n       */\n      BitFieldModel<uint32_t, 11, 1> clken;\n      /**\n\
    \       * @brief CPOL field\n       *\n       * Clock polarity\n       */\n  \
    \    BitFieldModel<uint32_t, 10, 1> cpol;\n      /**\n       * @brief CPHA field\n\
    \       *\n       * Clock phase\n       */\n      BitFieldModel<uint32_t, 9, 1>\
    \ cpha;\n      /**\n       * @brief LBCL field\n       *\n       * Last bit clock\
    \ pulse\n       */\n      BitFieldModel<uint32_t, 8, 1> lbcl;\n      /**\n   \
    \    * @brief LBDIE field\n       *\n       * LIN break detection interrupt\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 6, 1>\
    \ lbdie;\n      /**\n       * @brief LBDL field\n       *\n       * lin break\
    \ detection length\n       */\n      BitFieldModel<uint32_t, 5, 1> lbdl;\n   \
    \   /**\n       * @brief ADD field\n       *\n       * Address of the USART node\n\
    \       */\n      BitFieldModel<uint32_t, 0, 4> add;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR2 register\n   *\n   * Control register 2\n   */\n  using\
    \ cr2 = Cr2Reg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Cr3Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief ONEBIT field\n     *\n     * One sample bit method\n   \
    \  *               enable\n     */\n    using onebit = FieldModel<uint32_t, address,\
    \ 11, 1>;\n    /**\n     * @brief CTSIE field\n     *\n     * CTS interrupt enable\n\
    \     */\n    using ctsie = FieldModel<uint32_t, address, 10, 1>;\n    /**\n \
    \    * @brief CTSE field\n     *\n     * CTS enable\n     */\n    using ctse =\
    \ FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief RTSE field\n  \
    \   *\n     * RTS enable\n     */\n    using rtse = FieldModel<uint32_t, address,\
    \ 8, 1>;\n    /**\n     * @brief DMAT field\n     *\n     * DMA enable transmitter\n\
    \     */\n    using dmat = FieldModel<uint32_t, address, 7, 1>;\n    /**\n   \
    \  * @brief DMAR field\n     *\n     * DMA enable receiver\n     */\n    using\
    \ dmar = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief SCEN field\n\
    \     *\n     * Smartcard mode enable\n     */\n    using scen = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief NACK field\n     *\n     * Smartcard\
    \ NACK enable\n     */\n    using nack = FieldModel<uint32_t, address, 4, 1>;\n\
    \    /**\n     * @brief HDSEL field\n     *\n     * Half-duplex selection\n  \
    \   */\n    using hdsel = FieldModel<uint32_t, address, 3, 1>;\n    /**\n    \
    \ * @brief IRLP field\n     *\n     * IrDA low-power\n     */\n    using irlp\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief IREN field\n\
    \     *\n     * IrDA mode enable\n     */\n    using iren = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief EIE field\n     *\n     * Error interrupt\
    \ enable\n     */\n    using eie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief ONEBIT field\n       *\n       * One sample bit method\n    \
    \   *               enable\n       */\n      BitFieldModel<uint32_t, 11, 1> onebit;\n\
    \      /**\n       * @brief CTSIE field\n       *\n       * CTS interrupt enable\n\
    \       */\n      BitFieldModel<uint32_t, 10, 1> ctsie;\n      /**\n       * @brief\
    \ CTSE field\n       *\n       * CTS enable\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> ctse;\n      /**\n       * @brief RTSE field\n       *\n       * RTS enable\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> rtse;\n      /**\n       * @brief\
    \ DMAT field\n       *\n       * DMA enable transmitter\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> dmat;\n      /**\n       * @brief DMAR field\n       *\n       * DMA enable\
    \ receiver\n       */\n      BitFieldModel<uint32_t, 6, 1> dmar;\n      /**\n\
    \       * @brief SCEN field\n       *\n       * Smartcard mode enable\n      \
    \ */\n      BitFieldModel<uint32_t, 5, 1> scen;\n      /**\n       * @brief NACK\
    \ field\n       *\n       * Smartcard NACK enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> nack;\n      /**\n       * @brief HDSEL field\n       *\n       * Half-duplex\
    \ selection\n       */\n      BitFieldModel<uint32_t, 3, 1> hdsel;\n      /**\n\
    \       * @brief IRLP field\n       *\n       * IrDA low-power\n       */\n  \
    \    BitFieldModel<uint32_t, 2, 1> irlp;\n      /**\n       * @brief IREN field\n\
    \       *\n       * IrDA mode enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> iren;\n      /**\n       * @brief EIE field\n       *\n       * Error\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 0, 1> eie;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief CR3 register\n   *\n   * Control register\
    \ 3\n   */\n  using cr3 = Cr3Reg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class GtprReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief GT field\n     *\n     * Guard time value\n\
    \     */\n    using gt = FieldModel<uint32_t, address, 8, 8>;\n    /**\n     *\
    \ @brief PSC field\n     *\n     * Prescaler value\n     */\n    using psc = FieldModel<uint32_t,\
    \ address, 0, 8>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief GT field\n       *\n  \
    \     * Guard time value\n       */\n      BitFieldModel<uint32_t, 8, 8> gt;\n\
    \      /**\n       * @brief PSC field\n       *\n       * Prescaler value\n  \
    \     */\n      BitFieldModel<uint32_t, 0, 8> psc;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief GTPR register\n   *\n   * Guard time and prescaler\n   * \
    \          register\n   */\n  using gtpr = GtprReg<BaseAddress + 0x0018>;\n\n\
    };\n\n}\n\n#endif /* DRAL_STM32F411_USART1_H */"
  name: USART1
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_USART2_H\n#define DRAL_STM32F411_USART2_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ USART2 peripheral\n *\n * Universal synchronous asynchronous receiver\n *  \
    \     transmitter\n */\nclass usart2\n{\npublic:\n  static constexpr unsigned\
    \ int BaseAddress = 0x40004400; /**< Peripheral base address */\n\nprivate:\n\
    \  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CTS field\n     *\n     * CTS\
    \ flag\n     */\n    using cts = FieldModel<uint32_t, address, 9, 1>;\n    /**\n\
    \     * @brief LBD field\n     *\n     * LIN break detection flag\n     */\n \
    \   using lbd = FieldModel<uint32_t, address, 8, 1>;\n    /**\n     * @brief TXE\
    \ field\n     *\n     * Transmit data register\n     *               empty\n \
    \    */\n    using txe = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     *\
    \ @brief TC field\n     *\n     * Transmission complete\n     */\n    using tc\
    \ = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief RXNE field\n\
    \     *\n     * Read data register not\n     *               empty\n     */\n\
    \    using rxne = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief\
    \ IDLE field\n     *\n     * IDLE line detected\n     */\n    using idle = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ORE field\n     *\n     * Overrun error\n\
    \     */\n    using ore = FieldModel<uint32_t, address, 3, 1>;\n    /**\n    \
    \ * @brief NF field\n     *\n     * Noise detected flag\n     */\n    using nf\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief FE field\n  \
    \   *\n     * Framing error\n     */\n    using fe = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    /**\n     * @brief PE field\n     *\n     * Parity error\n     */\n\
    \    using pe = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n \
    \    * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CTS field\n       *\n       * CTS flag\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cts;\n      /**\n       * @brief LBD field\n       *\n       * LIN break\
    \ detection flag\n       */\n      BitFieldModel<uint32_t, 8, 1> lbd;\n      /**\n\
    \       * @brief TXE field\n       *\n       * Transmit data register\n      \
    \ *               empty\n       */\n      BitFieldModel<uint32_t, 7, 1> txe;\n\
    \      /**\n       * @brief TC field\n       *\n       * Transmission complete\n\
    \       */\n      BitFieldModel<uint32_t, 6, 1> tc;\n      /**\n       * @brief\
    \ RXNE field\n       *\n       * Read data register not\n       *            \
    \   empty\n       */\n      BitFieldModel<uint32_t, 5, 1> rxne;\n      /**\n \
    \      * @brief IDLE field\n       *\n       * IDLE line detected\n       */\n\
    \      BitFieldModel<uint32_t, 4, 1> idle;\n      /**\n       * @brief ORE field\n\
    \       *\n       * Overrun error\n       */\n      BitFieldModel<uint32_t, 3,\
    \ 1> ore;\n      /**\n       * @brief NF field\n       *\n       * Noise detected\
    \ flag\n       */\n      BitFieldModel<uint32_t, 2, 1> nf;\n      /**\n      \
    \ * @brief FE field\n       *\n       * Framing error\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> fe;\n      /**\n       * @brief PE field\n       *\n       * Parity error\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> pe;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief SR register\n   *\n   * Status register\n   */\n  using sr\
    \ = SrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class DrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ /**\n     * @brief DR field\n     *\n     * Data value\n     */\n    using dr\
    \ = FieldModel<uint32_t, address, 0, 9>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ DR field\n       *\n       * Data value\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 9> dr;\n    };\n  };\n\npublic:\n  /**\n   * @brief DR register\n   *\n \
    \  * Data register\n   */\n  using dr = DrReg<BaseAddress + 0x0004>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class BrrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief DIV_MANTISSA field\n     *\n\
    \     * mantissa of USARTDIV\n     */\n    using div_mantissa = FieldModel<uint32_t,\
    \ address, 4, 12>;\n    /**\n     * @brief DIV_FRACTION field\n     *\n     *\
    \ fraction of USARTDIV\n     */\n    using div_fraction = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief DIV_MANTISSA field\n  \
    \     *\n       * mantissa of USARTDIV\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 12> div_mantissa;\n      /**\n       * @brief DIV_FRACTION field\n      \
    \ *\n       * fraction of USARTDIV\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 4> div_fraction;\n    };\n  };\n\npublic:\n  /**\n   * @brief BRR register\n\
    \   *\n   * Baud rate register\n   */\n  using brr = BrrReg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief OVER8 field\n     *\n     *\
    \ Oversampling mode\n     */\n    using over8 = FieldModel<uint32_t, address,\
    \ 15, 1>;\n    /**\n     * @brief UE field\n     *\n     * USART enable\n    \
    \ */\n    using ue = FieldModel<uint32_t, address, 13, 1>;\n    /**\n     * @brief\
    \ M field\n     *\n     * Word length\n     */\n    using m = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief WAKE field\n     *\n     * Wakeup method\n\
    \     */\n    using wake = FieldModel<uint32_t, address, 11, 1>;\n    /**\n  \
    \   * @brief PCE field\n     *\n     * Parity control enable\n     */\n    using\
    \ pce = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief PS field\n\
    \     *\n     * Parity selection\n     */\n    using ps = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief PEIE field\n     *\n     * PE interrupt\
    \ enable\n     */\n    using peie = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ /**\n     * @brief TXEIE field\n     *\n     * TXE interrupt enable\n     */\n\
    \    using txeie = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief\
    \ TCIE field\n     *\n     * Transmission complete interrupt\n     *         \
    \      enable\n     */\n    using tcie = FieldModel<uint32_t, address, 6, 1>;\n\
    \    /**\n     * @brief RXNEIE field\n     *\n     * RXNE interrupt enable\n \
    \    */\n    using rxneie = FieldModel<uint32_t, address, 5, 1>;\n    /**\n  \
    \   * @brief IDLEIE field\n     *\n     * IDLE interrupt enable\n     */\n   \
    \ using idleie = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief\
    \ TE field\n     *\n     * Transmitter enable\n     */\n    using te = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief RE field\n     *\n     * Receiver enable\n\
    \     */\n    using re = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     *\
    \ @brief RWU field\n     *\n     * Receiver wakeup\n     */\n    using rwu = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief SBK field\n     *\n     * Send break\n\
    \     */\n    using sbk = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief OVER8 field\n       *\n       * Oversampling mode\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> over8;\n      /**\n       * @brief UE field\n\
    \       *\n       * USART enable\n       */\n      BitFieldModel<uint32_t, 13,\
    \ 1> ue;\n      /**\n       * @brief M field\n       *\n       * Word length\n\
    \       */\n      BitFieldModel<uint32_t, 12, 1> m;\n      /**\n       * @brief\
    \ WAKE field\n       *\n       * Wakeup method\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> wake;\n      /**\n       * @brief PCE field\n       *\n       * Parity\
    \ control enable\n       */\n      BitFieldModel<uint32_t, 10, 1> pce;\n     \
    \ /**\n       * @brief PS field\n       *\n       * Parity selection\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> ps;\n      /**\n       * @brief PEIE field\n\
    \       *\n       * PE interrupt enable\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> peie;\n      /**\n       * @brief TXEIE field\n       *\n       * TXE\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 7, 1> txeie;\n  \
    \    /**\n       * @brief TCIE field\n       *\n       * Transmission complete\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> tcie;\n      /**\n       * @brief RXNEIE field\n       *\n       * RXNE\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 5, 1> rxneie;\n \
    \     /**\n       * @brief IDLEIE field\n       *\n       * IDLE interrupt enable\n\
    \       */\n      BitFieldModel<uint32_t, 4, 1> idleie;\n      /**\n       * @brief\
    \ TE field\n       *\n       * Transmitter enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> te;\n      /**\n       * @brief RE field\n       *\n       * Receiver\
    \ enable\n       */\n      BitFieldModel<uint32_t, 2, 1> re;\n      /**\n    \
    \   * @brief RWU field\n       *\n       * Receiver wakeup\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> rwu;\n      /**\n       * @brief SBK field\n       *\n       * Send break\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> sbk;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR1 register\n   *\n   * Control register 1\n   */\n  using\
    \ cr1 = Cr1Reg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief LINEN field\n     *\n     * LIN mode enable\n     */\n \
    \   using linen = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief\
    \ STOP field\n     *\n     * STOP bits\n     */\n    using stop = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    /**\n     * @brief CLKEN field\n     *\n     * Clock enable\n\
    \     */\n    using clken = FieldModel<uint32_t, address, 11, 1>;\n    /**\n \
    \    * @brief CPOL field\n     *\n     * Clock polarity\n     */\n    using cpol\
    \ = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief CPHA field\n\
    \     *\n     * Clock phase\n     */\n    using cpha = FieldModel<uint32_t, address,\
    \ 9, 1>;\n    /**\n     * @brief LBCL field\n     *\n     * Last bit clock pulse\n\
    \     */\n    using lbcl = FieldModel<uint32_t, address, 8, 1>;\n    /**\n   \
    \  * @brief LBDIE field\n     *\n     * LIN break detection interrupt\n     *\
    \               enable\n     */\n    using lbdie = FieldModel<uint32_t, address,\
    \ 6, 1>;\n    /**\n     * @brief LBDL field\n     *\n     * lin break detection\
    \ length\n     */\n    using lbdl = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ /**\n     * @brief ADD field\n     *\n     * Address of the USART node\n   \
    \  */\n    using add = FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n   \
    \ /**\n     * @brief Register union\n     *\n     * Can be used to create a local\
    \ register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief LINEN field\n       *\n       * LIN mode enable\n       */\n\
    \      BitFieldModel<uint32_t, 14, 1> linen;\n      /**\n       * @brief STOP\
    \ field\n       *\n       * STOP bits\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 2> stop;\n      /**\n       * @brief CLKEN field\n       *\n       * Clock\
    \ enable\n       */\n      BitFieldModel<uint32_t, 11, 1> clken;\n      /**\n\
    \       * @brief CPOL field\n       *\n       * Clock polarity\n       */\n  \
    \    BitFieldModel<uint32_t, 10, 1> cpol;\n      /**\n       * @brief CPHA field\n\
    \       *\n       * Clock phase\n       */\n      BitFieldModel<uint32_t, 9, 1>\
    \ cpha;\n      /**\n       * @brief LBCL field\n       *\n       * Last bit clock\
    \ pulse\n       */\n      BitFieldModel<uint32_t, 8, 1> lbcl;\n      /**\n   \
    \    * @brief LBDIE field\n       *\n       * LIN break detection interrupt\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 6, 1>\
    \ lbdie;\n      /**\n       * @brief LBDL field\n       *\n       * lin break\
    \ detection length\n       */\n      BitFieldModel<uint32_t, 5, 1> lbdl;\n   \
    \   /**\n       * @brief ADD field\n       *\n       * Address of the USART node\n\
    \       */\n      BitFieldModel<uint32_t, 0, 4> add;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR2 register\n   *\n   * Control register 2\n   */\n  using\
    \ cr2 = Cr2Reg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Cr3Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief ONEBIT field\n     *\n     * One sample bit method\n   \
    \  *               enable\n     */\n    using onebit = FieldModel<uint32_t, address,\
    \ 11, 1>;\n    /**\n     * @brief CTSIE field\n     *\n     * CTS interrupt enable\n\
    \     */\n    using ctsie = FieldModel<uint32_t, address, 10, 1>;\n    /**\n \
    \    * @brief CTSE field\n     *\n     * CTS enable\n     */\n    using ctse =\
    \ FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief RTSE field\n  \
    \   *\n     * RTS enable\n     */\n    using rtse = FieldModel<uint32_t, address,\
    \ 8, 1>;\n    /**\n     * @brief DMAT field\n     *\n     * DMA enable transmitter\n\
    \     */\n    using dmat = FieldModel<uint32_t, address, 7, 1>;\n    /**\n   \
    \  * @brief DMAR field\n     *\n     * DMA enable receiver\n     */\n    using\
    \ dmar = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief SCEN field\n\
    \     *\n     * Smartcard mode enable\n     */\n    using scen = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief NACK field\n     *\n     * Smartcard\
    \ NACK enable\n     */\n    using nack = FieldModel<uint32_t, address, 4, 1>;\n\
    \    /**\n     * @brief HDSEL field\n     *\n     * Half-duplex selection\n  \
    \   */\n    using hdsel = FieldModel<uint32_t, address, 3, 1>;\n    /**\n    \
    \ * @brief IRLP field\n     *\n     * IrDA low-power\n     */\n    using irlp\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief IREN field\n\
    \     *\n     * IrDA mode enable\n     */\n    using iren = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief EIE field\n     *\n     * Error interrupt\
    \ enable\n     */\n    using eie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief ONEBIT field\n       *\n       * One sample bit method\n    \
    \   *               enable\n       */\n      BitFieldModel<uint32_t, 11, 1> onebit;\n\
    \      /**\n       * @brief CTSIE field\n       *\n       * CTS interrupt enable\n\
    \       */\n      BitFieldModel<uint32_t, 10, 1> ctsie;\n      /**\n       * @brief\
    \ CTSE field\n       *\n       * CTS enable\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> ctse;\n      /**\n       * @brief RTSE field\n       *\n       * RTS enable\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> rtse;\n      /**\n       * @brief\
    \ DMAT field\n       *\n       * DMA enable transmitter\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> dmat;\n      /**\n       * @brief DMAR field\n       *\n       * DMA enable\
    \ receiver\n       */\n      BitFieldModel<uint32_t, 6, 1> dmar;\n      /**\n\
    \       * @brief SCEN field\n       *\n       * Smartcard mode enable\n      \
    \ */\n      BitFieldModel<uint32_t, 5, 1> scen;\n      /**\n       * @brief NACK\
    \ field\n       *\n       * Smartcard NACK enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> nack;\n      /**\n       * @brief HDSEL field\n       *\n       * Half-duplex\
    \ selection\n       */\n      BitFieldModel<uint32_t, 3, 1> hdsel;\n      /**\n\
    \       * @brief IRLP field\n       *\n       * IrDA low-power\n       */\n  \
    \    BitFieldModel<uint32_t, 2, 1> irlp;\n      /**\n       * @brief IREN field\n\
    \       *\n       * IrDA mode enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> iren;\n      /**\n       * @brief EIE field\n       *\n       * Error\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 0, 1> eie;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief CR3 register\n   *\n   * Control register\
    \ 3\n   */\n  using cr3 = Cr3Reg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class GtprReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief GT field\n     *\n     * Guard time value\n\
    \     */\n    using gt = FieldModel<uint32_t, address, 8, 8>;\n    /**\n     *\
    \ @brief PSC field\n     *\n     * Prescaler value\n     */\n    using psc = FieldModel<uint32_t,\
    \ address, 0, 8>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief GT field\n       *\n  \
    \     * Guard time value\n       */\n      BitFieldModel<uint32_t, 8, 8> gt;\n\
    \      /**\n       * @brief PSC field\n       *\n       * Prescaler value\n  \
    \     */\n      BitFieldModel<uint32_t, 0, 8> psc;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief GTPR register\n   *\n   * Guard time and prescaler\n   * \
    \          register\n   */\n  using gtpr = GtprReg<BaseAddress + 0x0018>;\n\n\
    };\n\n}\n\n#endif /* DRAL_STM32F411_USART2_H */"
  name: USART2
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_USART6_H\n#define DRAL_STM32F411_USART6_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ USART6 peripheral\n *\n * Universal synchronous asynchronous receiver\n *  \
    \     transmitter\n */\nclass usart6\n{\npublic:\n  static constexpr unsigned\
    \ int BaseAddress = 0x40011400; /**< Peripheral base address */\n\nprivate:\n\
    \  template<unsigned int address>\n  class SrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CTS field\n     *\n     * CTS\
    \ flag\n     */\n    using cts = FieldModel<uint32_t, address, 9, 1>;\n    /**\n\
    \     * @brief LBD field\n     *\n     * LIN break detection flag\n     */\n \
    \   using lbd = FieldModel<uint32_t, address, 8, 1>;\n    /**\n     * @brief TXE\
    \ field\n     *\n     * Transmit data register\n     *               empty\n \
    \    */\n    using txe = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     *\
    \ @brief TC field\n     *\n     * Transmission complete\n     */\n    using tc\
    \ = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief RXNE field\n\
    \     *\n     * Read data register not\n     *               empty\n     */\n\
    \    using rxne = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief\
    \ IDLE field\n     *\n     * IDLE line detected\n     */\n    using idle = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ORE field\n     *\n     * Overrun error\n\
    \     */\n    using ore = FieldModel<uint32_t, address, 3, 1>;\n    /**\n    \
    \ * @brief NF field\n     *\n     * Noise detected flag\n     */\n    using nf\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief FE field\n  \
    \   *\n     * Framing error\n     */\n    using fe = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    /**\n     * @brief PE field\n     *\n     * Parity error\n     */\n\
    \    using pe = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n \
    \    * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CTS field\n       *\n       * CTS flag\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cts;\n      /**\n       * @brief LBD field\n       *\n       * LIN break\
    \ detection flag\n       */\n      BitFieldModel<uint32_t, 8, 1> lbd;\n      /**\n\
    \       * @brief TXE field\n       *\n       * Transmit data register\n      \
    \ *               empty\n       */\n      BitFieldModel<uint32_t, 7, 1> txe;\n\
    \      /**\n       * @brief TC field\n       *\n       * Transmission complete\n\
    \       */\n      BitFieldModel<uint32_t, 6, 1> tc;\n      /**\n       * @brief\
    \ RXNE field\n       *\n       * Read data register not\n       *            \
    \   empty\n       */\n      BitFieldModel<uint32_t, 5, 1> rxne;\n      /**\n \
    \      * @brief IDLE field\n       *\n       * IDLE line detected\n       */\n\
    \      BitFieldModel<uint32_t, 4, 1> idle;\n      /**\n       * @brief ORE field\n\
    \       *\n       * Overrun error\n       */\n      BitFieldModel<uint32_t, 3,\
    \ 1> ore;\n      /**\n       * @brief NF field\n       *\n       * Noise detected\
    \ flag\n       */\n      BitFieldModel<uint32_t, 2, 1> nf;\n      /**\n      \
    \ * @brief FE field\n       *\n       * Framing error\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> fe;\n      /**\n       * @brief PE field\n       *\n       * Parity error\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> pe;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief SR register\n   *\n   * Status register\n   */\n  using sr\
    \ = SrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class DrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ /**\n     * @brief DR field\n     *\n     * Data value\n     */\n    using dr\
    \ = FieldModel<uint32_t, address, 0, 9>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ DR field\n       *\n       * Data value\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 9> dr;\n    };\n  };\n\npublic:\n  /**\n   * @brief DR register\n   *\n \
    \  * Data register\n   */\n  using dr = DrReg<BaseAddress + 0x0004>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class BrrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief DIV_MANTISSA field\n     *\n\
    \     * mantissa of USARTDIV\n     */\n    using div_mantissa = FieldModel<uint32_t,\
    \ address, 4, 12>;\n    /**\n     * @brief DIV_FRACTION field\n     *\n     *\
    \ fraction of USARTDIV\n     */\n    using div_fraction = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief DIV_MANTISSA field\n  \
    \     *\n       * mantissa of USARTDIV\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 12> div_mantissa;\n      /**\n       * @brief DIV_FRACTION field\n      \
    \ *\n       * fraction of USARTDIV\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 4> div_fraction;\n    };\n  };\n\npublic:\n  /**\n   * @brief BRR register\n\
    \   *\n   * Baud rate register\n   */\n  using brr = BrrReg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief OVER8 field\n     *\n     *\
    \ Oversampling mode\n     */\n    using over8 = FieldModel<uint32_t, address,\
    \ 15, 1>;\n    /**\n     * @brief UE field\n     *\n     * USART enable\n    \
    \ */\n    using ue = FieldModel<uint32_t, address, 13, 1>;\n    /**\n     * @brief\
    \ M field\n     *\n     * Word length\n     */\n    using m = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief WAKE field\n     *\n     * Wakeup method\n\
    \     */\n    using wake = FieldModel<uint32_t, address, 11, 1>;\n    /**\n  \
    \   * @brief PCE field\n     *\n     * Parity control enable\n     */\n    using\
    \ pce = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief PS field\n\
    \     *\n     * Parity selection\n     */\n    using ps = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief PEIE field\n     *\n     * PE interrupt\
    \ enable\n     */\n    using peie = FieldModel<uint32_t, address, 8, 1>;\n   \
    \ /**\n     * @brief TXEIE field\n     *\n     * TXE interrupt enable\n     */\n\
    \    using txeie = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief\
    \ TCIE field\n     *\n     * Transmission complete interrupt\n     *         \
    \      enable\n     */\n    using tcie = FieldModel<uint32_t, address, 6, 1>;\n\
    \    /**\n     * @brief RXNEIE field\n     *\n     * RXNE interrupt enable\n \
    \    */\n    using rxneie = FieldModel<uint32_t, address, 5, 1>;\n    /**\n  \
    \   * @brief IDLEIE field\n     *\n     * IDLE interrupt enable\n     */\n   \
    \ using idleie = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief\
    \ TE field\n     *\n     * Transmitter enable\n     */\n    using te = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief RE field\n     *\n     * Receiver enable\n\
    \     */\n    using re = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     *\
    \ @brief RWU field\n     *\n     * Receiver wakeup\n     */\n    using rwu = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief SBK field\n     *\n     * Send break\n\
    \     */\n    using sbk = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief OVER8 field\n       *\n       * Oversampling mode\n       */\n\
    \      BitFieldModel<uint32_t, 15, 1> over8;\n      /**\n       * @brief UE field\n\
    \       *\n       * USART enable\n       */\n      BitFieldModel<uint32_t, 13,\
    \ 1> ue;\n      /**\n       * @brief M field\n       *\n       * Word length\n\
    \       */\n      BitFieldModel<uint32_t, 12, 1> m;\n      /**\n       * @brief\
    \ WAKE field\n       *\n       * Wakeup method\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> wake;\n      /**\n       * @brief PCE field\n       *\n       * Parity\
    \ control enable\n       */\n      BitFieldModel<uint32_t, 10, 1> pce;\n     \
    \ /**\n       * @brief PS field\n       *\n       * Parity selection\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> ps;\n      /**\n       * @brief PEIE field\n\
    \       *\n       * PE interrupt enable\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> peie;\n      /**\n       * @brief TXEIE field\n       *\n       * TXE\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 7, 1> txeie;\n  \
    \    /**\n       * @brief TCIE field\n       *\n       * Transmission complete\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> tcie;\n      /**\n       * @brief RXNEIE field\n       *\n       * RXNE\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 5, 1> rxneie;\n \
    \     /**\n       * @brief IDLEIE field\n       *\n       * IDLE interrupt enable\n\
    \       */\n      BitFieldModel<uint32_t, 4, 1> idleie;\n      /**\n       * @brief\
    \ TE field\n       *\n       * Transmitter enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> te;\n      /**\n       * @brief RE field\n       *\n       * Receiver\
    \ enable\n       */\n      BitFieldModel<uint32_t, 2, 1> re;\n      /**\n    \
    \   * @brief RWU field\n       *\n       * Receiver wakeup\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> rwu;\n      /**\n       * @brief SBK field\n       *\n       * Send break\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> sbk;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR1 register\n   *\n   * Control register 1\n   */\n  using\
    \ cr1 = Cr1Reg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief LINEN field\n     *\n     * LIN mode enable\n     */\n \
    \   using linen = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief\
    \ STOP field\n     *\n     * STOP bits\n     */\n    using stop = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    /**\n     * @brief CLKEN field\n     *\n     * Clock enable\n\
    \     */\n    using clken = FieldModel<uint32_t, address, 11, 1>;\n    /**\n \
    \    * @brief CPOL field\n     *\n     * Clock polarity\n     */\n    using cpol\
    \ = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief CPHA field\n\
    \     *\n     * Clock phase\n     */\n    using cpha = FieldModel<uint32_t, address,\
    \ 9, 1>;\n    /**\n     * @brief LBCL field\n     *\n     * Last bit clock pulse\n\
    \     */\n    using lbcl = FieldModel<uint32_t, address, 8, 1>;\n    /**\n   \
    \  * @brief LBDIE field\n     *\n     * LIN break detection interrupt\n     *\
    \               enable\n     */\n    using lbdie = FieldModel<uint32_t, address,\
    \ 6, 1>;\n    /**\n     * @brief LBDL field\n     *\n     * lin break detection\
    \ length\n     */\n    using lbdl = FieldModel<uint32_t, address, 5, 1>;\n   \
    \ /**\n     * @brief ADD field\n     *\n     * Address of the USART node\n   \
    \  */\n    using add = FieldModel<uint32_t, address, 0, 4>;\n\n  public:\n   \
    \ /**\n     * @brief Register union\n     *\n     * Can be used to create a local\
    \ register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief LINEN field\n       *\n       * LIN mode enable\n       */\n\
    \      BitFieldModel<uint32_t, 14, 1> linen;\n      /**\n       * @brief STOP\
    \ field\n       *\n       * STOP bits\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 2> stop;\n      /**\n       * @brief CLKEN field\n       *\n       * Clock\
    \ enable\n       */\n      BitFieldModel<uint32_t, 11, 1> clken;\n      /**\n\
    \       * @brief CPOL field\n       *\n       * Clock polarity\n       */\n  \
    \    BitFieldModel<uint32_t, 10, 1> cpol;\n      /**\n       * @brief CPHA field\n\
    \       *\n       * Clock phase\n       */\n      BitFieldModel<uint32_t, 9, 1>\
    \ cpha;\n      /**\n       * @brief LBCL field\n       *\n       * Last bit clock\
    \ pulse\n       */\n      BitFieldModel<uint32_t, 8, 1> lbcl;\n      /**\n   \
    \    * @brief LBDIE field\n       *\n       * LIN break detection interrupt\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 6, 1>\
    \ lbdie;\n      /**\n       * @brief LBDL field\n       *\n       * lin break\
    \ detection length\n       */\n      BitFieldModel<uint32_t, 5, 1> lbdl;\n   \
    \   /**\n       * @brief ADD field\n       *\n       * Address of the USART node\n\
    \       */\n      BitFieldModel<uint32_t, 0, 4> add;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR2 register\n   *\n   * Control register 2\n   */\n  using\
    \ cr2 = Cr2Reg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Cr3Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief ONEBIT field\n     *\n     * One sample bit method\n   \
    \  *               enable\n     */\n    using onebit = FieldModel<uint32_t, address,\
    \ 11, 1>;\n    /**\n     * @brief CTSIE field\n     *\n     * CTS interrupt enable\n\
    \     */\n    using ctsie = FieldModel<uint32_t, address, 10, 1>;\n    /**\n \
    \    * @brief CTSE field\n     *\n     * CTS enable\n     */\n    using ctse =\
    \ FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief RTSE field\n  \
    \   *\n     * RTS enable\n     */\n    using rtse = FieldModel<uint32_t, address,\
    \ 8, 1>;\n    /**\n     * @brief DMAT field\n     *\n     * DMA enable transmitter\n\
    \     */\n    using dmat = FieldModel<uint32_t, address, 7, 1>;\n    /**\n   \
    \  * @brief DMAR field\n     *\n     * DMA enable receiver\n     */\n    using\
    \ dmar = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief SCEN field\n\
    \     *\n     * Smartcard mode enable\n     */\n    using scen = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief NACK field\n     *\n     * Smartcard\
    \ NACK enable\n     */\n    using nack = FieldModel<uint32_t, address, 4, 1>;\n\
    \    /**\n     * @brief HDSEL field\n     *\n     * Half-duplex selection\n  \
    \   */\n    using hdsel = FieldModel<uint32_t, address, 3, 1>;\n    /**\n    \
    \ * @brief IRLP field\n     *\n     * IrDA low-power\n     */\n    using irlp\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief IREN field\n\
    \     *\n     * IrDA mode enable\n     */\n    using iren = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief EIE field\n     *\n     * Error interrupt\
    \ enable\n     */\n    using eie = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief ONEBIT field\n       *\n       * One sample bit method\n    \
    \   *               enable\n       */\n      BitFieldModel<uint32_t, 11, 1> onebit;\n\
    \      /**\n       * @brief CTSIE field\n       *\n       * CTS interrupt enable\n\
    \       */\n      BitFieldModel<uint32_t, 10, 1> ctsie;\n      /**\n       * @brief\
    \ CTSE field\n       *\n       * CTS enable\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> ctse;\n      /**\n       * @brief RTSE field\n       *\n       * RTS enable\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> rtse;\n      /**\n       * @brief\
    \ DMAT field\n       *\n       * DMA enable transmitter\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> dmat;\n      /**\n       * @brief DMAR field\n       *\n       * DMA enable\
    \ receiver\n       */\n      BitFieldModel<uint32_t, 6, 1> dmar;\n      /**\n\
    \       * @brief SCEN field\n       *\n       * Smartcard mode enable\n      \
    \ */\n      BitFieldModel<uint32_t, 5, 1> scen;\n      /**\n       * @brief NACK\
    \ field\n       *\n       * Smartcard NACK enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> nack;\n      /**\n       * @brief HDSEL field\n       *\n       * Half-duplex\
    \ selection\n       */\n      BitFieldModel<uint32_t, 3, 1> hdsel;\n      /**\n\
    \       * @brief IRLP field\n       *\n       * IrDA low-power\n       */\n  \
    \    BitFieldModel<uint32_t, 2, 1> irlp;\n      /**\n       * @brief IREN field\n\
    \       *\n       * IrDA mode enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> iren;\n      /**\n       * @brief EIE field\n       *\n       * Error\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 0, 1> eie;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief CR3 register\n   *\n   * Control register\
    \ 3\n   */\n  using cr3 = Cr3Reg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class GtprReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief GT field\n     *\n     * Guard time value\n\
    \     */\n    using gt = FieldModel<uint32_t, address, 8, 8>;\n    /**\n     *\
    \ @brief PSC field\n     *\n     * Prescaler value\n     */\n    using psc = FieldModel<uint32_t,\
    \ address, 0, 8>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief GT field\n       *\n  \
    \     * Guard time value\n       */\n      BitFieldModel<uint32_t, 8, 8> gt;\n\
    \      /**\n       * @brief PSC field\n       *\n       * Prescaler value\n  \
    \     */\n      BitFieldModel<uint32_t, 0, 8> psc;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief GTPR register\n   *\n   * Guard time and prescaler\n   * \
    \          register\n   */\n  using gtpr = GtprReg<BaseAddress + 0x0018>;\n\n\
    };\n\n}\n\n#endif /* DRAL_STM32F411_USART6_H */"
  name: USART6
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_WWDG_H\n#define DRAL_STM32F411_WWDG_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ WWDG peripheral\n *\n * Window watchdog\n */\nclass wwdg\n{\npublic:\n  static\
    \ constexpr unsigned int BaseAddress = 0x40002C00; /**< Peripheral base address\
    \ */\n\nprivate:\n  template<unsigned int address>\n  class CrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief WDGA field\n     *\n     *\
    \ Activation bit\n     */\n    using wdga = FieldModel<uint32_t, address, 7, 1>;\n\
    \    /**\n     * @brief T field\n     *\n     * 7-bit counter (MSB to LSB)\n \
    \    */\n    using t = FieldModel<uint32_t, address, 0, 7>;\n\n  public:\n   \
    \ /**\n     * @brief Register union\n     *\n     * Can be used to create a local\
    \ register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief WDGA field\n       *\n       * Activation bit\n       */\n  \
    \    BitFieldModel<uint32_t, 7, 1> wdga;\n      /**\n       * @brief T field\n\
    \       *\n       * 7-bit counter (MSB to LSB)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 7> t;\n    };\n  };\n\npublic:\n  /**\n   * @brief CR register\n   *\n  \
    \ * Control register\n   */\n  using cr = CrReg<BaseAddress + 0x0000>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class CfrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief EWI field\n     *\n     * Early\
    \ wakeup interrupt\n     */\n    using ewi = FieldModel<uint32_t, address, 9,\
    \ 1>;\n    /**\n     * @brief WDGTB1 field\n     *\n     * Timer base\n     */\n\
    \    using wdgtb1 = FieldModel<uint32_t, address, 8, 1>;\n    /**\n     * @brief\
    \ WDGTB0 field\n     *\n     * Timer base\n     */\n    using wdgtb0 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief W field\n     *\n     * 7-bit window\
    \ value\n     */\n    using w = FieldModel<uint32_t, address, 0, 7>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief EWI field\n       *\n       * Early wakeup interrupt\n      \
    \ */\n      BitFieldModel<uint32_t, 9, 1> ewi;\n      /**\n       * @brief WDGTB1\
    \ field\n       *\n       * Timer base\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> wdgtb1;\n      /**\n       * @brief WDGTB0 field\n       *\n       * Timer\
    \ base\n       */\n      BitFieldModel<uint32_t, 7, 1> wdgtb0;\n      /**\n  \
    \     * @brief W field\n       *\n       * 7-bit window value\n       */\n   \
    \   BitFieldModel<uint32_t, 0, 7> w;\n    };\n  };\n\npublic:\n  /**\n   * @brief\
    \ CFR register\n   *\n   * Configuration register\n   */\n  using cfr = CfrReg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class SrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief EWIF\
    \ field\n     *\n     * Early wakeup interrupt\n     *               flag\n  \
    \   */\n    using ewif = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n \
    \   /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief EWIF field\n       *\n       * Early wakeup interrupt\n     \
    \  *               flag\n       */\n      BitFieldModel<uint32_t, 0, 1> ewif;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief SR register\n   *\n   * Status register\n\
    \   */\n  using sr = SrReg<BaseAddress + 0x0008>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_WWDG_H\
    \ */"
  name: WWDG
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_DMA2_H\n#define DRAL_STM32F411_DMA2_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ DMA2 peripheral\n *\n * DMA controller\n */\nclass dma2\n{\npublic:\n  static\
    \ constexpr unsigned int BaseAddress = 0x40026400; /**< Peripheral base address\
    \ */\n\nprivate:\n  template<unsigned int address>\n  class LisrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief TCIF3 field\n     *\n     *\
    \ Stream x transfer complete interrupt\n     *               flag (x = 3..0)\n\
    \     */\n    using tcif3 = FieldModel<uint32_t, address, 27, 1>;\n    /**\n \
    \    * @brief HTIF3 field\n     *\n     * Stream x half transfer interrupt flag\n\
    \     *               (x=3..0)\n     */\n    using htif3 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    /**\n     * @brief TEIF3 field\n     *\n     * Stream\
    \ x transfer error interrupt flag\n     *               (x=3..0)\n     */\n  \
    \  using teif3 = FieldModel<uint32_t, address, 25, 1>;\n    /**\n     * @brief\
    \ DMEIF3 field\n     *\n     * Stream x direct mode error interrupt\n     *  \
    \             flag (x=3..0)\n     */\n    using dmeif3 = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    /**\n     * @brief FEIF3 field\n     *\n     * Stream\
    \ x FIFO error interrupt flag\n     *               (x=3..0)\n     */\n    using\
    \ feif3 = FieldModel<uint32_t, address, 22, 1>;\n    /**\n     * @brief TCIF2\
    \ field\n     *\n     * Stream x transfer complete interrupt\n     *         \
    \      flag (x = 3..0)\n     */\n    using tcif2 = FieldModel<uint32_t, address,\
    \ 21, 1>;\n    /**\n     * @brief HTIF2 field\n     *\n     * Stream x half transfer\
    \ interrupt flag\n     *               (x=3..0)\n     */\n    using htif2 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief TEIF2 field\n     *\n     * Stream\
    \ x transfer error interrupt flag\n     *               (x=3..0)\n     */\n  \
    \  using teif2 = FieldModel<uint32_t, address, 19, 1>;\n    /**\n     * @brief\
    \ DMEIF2 field\n     *\n     * Stream x direct mode error interrupt\n     *  \
    \             flag (x=3..0)\n     */\n    using dmeif2 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    /**\n     * @brief FEIF2 field\n     *\n     * Stream\
    \ x FIFO error interrupt flag\n     *               (x=3..0)\n     */\n    using\
    \ feif2 = FieldModel<uint32_t, address, 16, 1>;\n    /**\n     * @brief TCIF1\
    \ field\n     *\n     * Stream x transfer complete interrupt\n     *         \
    \      flag (x = 3..0)\n     */\n    using tcif1 = FieldModel<uint32_t, address,\
    \ 11, 1>;\n    /**\n     * @brief HTIF1 field\n     *\n     * Stream x half transfer\
    \ interrupt flag\n     *               (x=3..0)\n     */\n    using htif1 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief TEIF1 field\n     *\n     * Stream\
    \ x transfer error interrupt flag\n     *               (x=3..0)\n     */\n  \
    \  using teif1 = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief\
    \ DMEIF1 field\n     *\n     * Stream x direct mode error interrupt\n     *  \
    \             flag (x=3..0)\n     */\n    using dmeif1 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief FEIF1 field\n     *\n     * Stream x\
    \ FIFO error interrupt flag\n     *               (x=3..0)\n     */\n    using\
    \ feif1 = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief TCIF0 field\n\
    \     *\n     * Stream x transfer complete interrupt\n     *               flag\
    \ (x = 3..0)\n     */\n    using tcif0 = FieldModel<uint32_t, address, 5, 1>;\n\
    \    /**\n     * @brief HTIF0 field\n     *\n     * Stream x half transfer interrupt\
    \ flag\n     *               (x=3..0)\n     */\n    using htif0 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief TEIF0 field\n     *\n     * Stream x\
    \ transfer error interrupt flag\n     *               (x=3..0)\n     */\n    using\
    \ teif0 = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief DMEIF0\
    \ field\n     *\n     * Stream x direct mode error interrupt\n     *         \
    \      flag (x=3..0)\n     */\n    using dmeif0 = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief FEIF0 field\n     *\n     * Stream x FIFO error\
    \ interrupt flag\n     *               (x=3..0)\n     */\n    using feif0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief TCIF3 field\n       *\n\
    \       * Stream x transfer complete interrupt\n       *               flag (x\
    \ = 3..0)\n       */\n      BitFieldModel<uint32_t, 27, 1> tcif3;\n      /**\n\
    \       * @brief HTIF3 field\n       *\n       * Stream x half transfer interrupt\
    \ flag\n       *               (x=3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 26, 1> htif3;\n      /**\n       * @brief TEIF3 field\n       *\n       * Stream\
    \ x transfer error interrupt flag\n       *               (x=3..0)\n       */\n\
    \      BitFieldModel<uint32_t, 25, 1> teif3;\n      /**\n       * @brief DMEIF3\
    \ field\n       *\n       * Stream x direct mode error interrupt\n       *   \
    \            flag (x=3..0)\n       */\n      BitFieldModel<uint32_t, 24, 1> dmeif3;\n\
    \      /**\n       * @brief FEIF3 field\n       *\n       * Stream x FIFO error\
    \ interrupt flag\n       *               (x=3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> feif3;\n      /**\n       * @brief TCIF2 field\n       *\n       * Stream\
    \ x transfer complete interrupt\n       *               flag (x = 3..0)\n    \
    \   */\n      BitFieldModel<uint32_t, 21, 1> tcif2;\n      /**\n       * @brief\
    \ HTIF2 field\n       *\n       * Stream x half transfer interrupt flag\n    \
    \   *               (x=3..0)\n       */\n      BitFieldModel<uint32_t, 20, 1>\
    \ htif2;\n      /**\n       * @brief TEIF2 field\n       *\n       * Stream x\
    \ transfer error interrupt flag\n       *               (x=3..0)\n       */\n\
    \      BitFieldModel<uint32_t, 19, 1> teif2;\n      /**\n       * @brief DMEIF2\
    \ field\n       *\n       * Stream x direct mode error interrupt\n       *   \
    \            flag (x=3..0)\n       */\n      BitFieldModel<uint32_t, 18, 1> dmeif2;\n\
    \      /**\n       * @brief FEIF2 field\n       *\n       * Stream x FIFO error\
    \ interrupt flag\n       *               (x=3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> feif2;\n      /**\n       * @brief TCIF1 field\n       *\n       * Stream\
    \ x transfer complete interrupt\n       *               flag (x = 3..0)\n    \
    \   */\n      BitFieldModel<uint32_t, 11, 1> tcif1;\n      /**\n       * @brief\
    \ HTIF1 field\n       *\n       * Stream x half transfer interrupt flag\n    \
    \   *               (x=3..0)\n       */\n      BitFieldModel<uint32_t, 10, 1>\
    \ htif1;\n      /**\n       * @brief TEIF1 field\n       *\n       * Stream x\
    \ transfer error interrupt flag\n       *               (x=3..0)\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> teif1;\n      /**\n       * @brief DMEIF1\
    \ field\n       *\n       * Stream x direct mode error interrupt\n       *   \
    \            flag (x=3..0)\n       */\n      BitFieldModel<uint32_t, 8, 1> dmeif1;\n\
    \      /**\n       * @brief FEIF1 field\n       *\n       * Stream x FIFO error\
    \ interrupt flag\n       *               (x=3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> feif1;\n      /**\n       * @brief TCIF0 field\n       *\n       * Stream\
    \ x transfer complete interrupt\n       *               flag (x = 3..0)\n    \
    \   */\n      BitFieldModel<uint32_t, 5, 1> tcif0;\n      /**\n       * @brief\
    \ HTIF0 field\n       *\n       * Stream x half transfer interrupt flag\n    \
    \   *               (x=3..0)\n       */\n      BitFieldModel<uint32_t, 4, 1> htif0;\n\
    \      /**\n       * @brief TEIF0 field\n       *\n       * Stream x transfer\
    \ error interrupt flag\n       *               (x=3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> teif0;\n      /**\n       * @brief DMEIF0 field\n       *\n       * Stream\
    \ x direct mode error interrupt\n       *               flag (x=3..0)\n      \
    \ */\n      BitFieldModel<uint32_t, 2, 1> dmeif0;\n      /**\n       * @brief\
    \ FEIF0 field\n       *\n       * Stream x FIFO error interrupt flag\n       *\
    \               (x=3..0)\n       */\n      BitFieldModel<uint32_t, 0, 1> feif0;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief LISR register\n   *\n   * low interrupt\
    \ status register\n   */\n  using lisr = LisrReg<BaseAddress + 0x0000>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class HisrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief TCIF7 field\n     *\n     *\
    \ Stream x transfer complete interrupt\n     *               flag (x=7..4)\n \
    \    */\n    using tcif7 = FieldModel<uint32_t, address, 27, 1>;\n    /**\n  \
    \   * @brief HTIF7 field\n     *\n     * Stream x half transfer interrupt flag\n\
    \     *               (x=7..4)\n     */\n    using htif7 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    /**\n     * @brief TEIF7 field\n     *\n     * Stream\
    \ x transfer error interrupt flag\n     *               (x=7..4)\n     */\n  \
    \  using teif7 = FieldModel<uint32_t, address, 25, 1>;\n    /**\n     * @brief\
    \ DMEIF7 field\n     *\n     * Stream x direct mode error interrupt\n     *  \
    \             flag (x=7..4)\n     */\n    using dmeif7 = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    /**\n     * @brief FEIF7 field\n     *\n     * Stream\
    \ x FIFO error interrupt flag\n     *               (x=7..4)\n     */\n    using\
    \ feif7 = FieldModel<uint32_t, address, 22, 1>;\n    /**\n     * @brief TCIF6\
    \ field\n     *\n     * Stream x transfer complete interrupt\n     *         \
    \      flag (x=7..4)\n     */\n    using tcif6 = FieldModel<uint32_t, address,\
    \ 21, 1>;\n    /**\n     * @brief HTIF6 field\n     *\n     * Stream x half transfer\
    \ interrupt flag\n     *               (x=7..4)\n     */\n    using htif6 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief TEIF6 field\n     *\n     * Stream\
    \ x transfer error interrupt flag\n     *               (x=7..4)\n     */\n  \
    \  using teif6 = FieldModel<uint32_t, address, 19, 1>;\n    /**\n     * @brief\
    \ DMEIF6 field\n     *\n     * Stream x direct mode error interrupt\n     *  \
    \             flag (x=7..4)\n     */\n    using dmeif6 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    /**\n     * @brief FEIF6 field\n     *\n     * Stream\
    \ x FIFO error interrupt flag\n     *               (x=7..4)\n     */\n    using\
    \ feif6 = FieldModel<uint32_t, address, 16, 1>;\n    /**\n     * @brief TCIF5\
    \ field\n     *\n     * Stream x transfer complete interrupt\n     *         \
    \      flag (x=7..4)\n     */\n    using tcif5 = FieldModel<uint32_t, address,\
    \ 11, 1>;\n    /**\n     * @brief HTIF5 field\n     *\n     * Stream x half transfer\
    \ interrupt flag\n     *               (x=7..4)\n     */\n    using htif5 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief TEIF5 field\n     *\n     * Stream\
    \ x transfer error interrupt flag\n     *               (x=7..4)\n     */\n  \
    \  using teif5 = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief\
    \ DMEIF5 field\n     *\n     * Stream x direct mode error interrupt\n     *  \
    \             flag (x=7..4)\n     */\n    using dmeif5 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief FEIF5 field\n     *\n     * Stream x\
    \ FIFO error interrupt flag\n     *               (x=7..4)\n     */\n    using\
    \ feif5 = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief TCIF4 field\n\
    \     *\n     * Stream x transfer complete interrupt\n     *               flag\
    \ (x=7..4)\n     */\n    using tcif4 = FieldModel<uint32_t, address, 5, 1>;\n\
    \    /**\n     * @brief HTIF4 field\n     *\n     * Stream x half transfer interrupt\
    \ flag\n     *               (x=7..4)\n     */\n    using htif4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief TEIF4 field\n     *\n     * Stream x\
    \ transfer error interrupt flag\n     *               (x=7..4)\n     */\n    using\
    \ teif4 = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief DMEIF4\
    \ field\n     *\n     * Stream x direct mode error interrupt\n     *         \
    \      flag (x=7..4)\n     */\n    using dmeif4 = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief FEIF4 field\n     *\n     * Stream x FIFO error\
    \ interrupt flag\n     *               (x=7..4)\n     */\n    using feif4 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief TCIF7 field\n       *\n\
    \       * Stream x transfer complete interrupt\n       *               flag (x=7..4)\n\
    \       */\n      BitFieldModel<uint32_t, 27, 1> tcif7;\n      /**\n       * @brief\
    \ HTIF7 field\n       *\n       * Stream x half transfer interrupt flag\n    \
    \   *               (x=7..4)\n       */\n      BitFieldModel<uint32_t, 26, 1>\
    \ htif7;\n      /**\n       * @brief TEIF7 field\n       *\n       * Stream x\
    \ transfer error interrupt flag\n       *               (x=7..4)\n       */\n\
    \      BitFieldModel<uint32_t, 25, 1> teif7;\n      /**\n       * @brief DMEIF7\
    \ field\n       *\n       * Stream x direct mode error interrupt\n       *   \
    \            flag (x=7..4)\n       */\n      BitFieldModel<uint32_t, 24, 1> dmeif7;\n\
    \      /**\n       * @brief FEIF7 field\n       *\n       * Stream x FIFO error\
    \ interrupt flag\n       *               (x=7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> feif7;\n      /**\n       * @brief TCIF6 field\n       *\n       * Stream\
    \ x transfer complete interrupt\n       *               flag (x=7..4)\n      \
    \ */\n      BitFieldModel<uint32_t, 21, 1> tcif6;\n      /**\n       * @brief\
    \ HTIF6 field\n       *\n       * Stream x half transfer interrupt flag\n    \
    \   *               (x=7..4)\n       */\n      BitFieldModel<uint32_t, 20, 1>\
    \ htif6;\n      /**\n       * @brief TEIF6 field\n       *\n       * Stream x\
    \ transfer error interrupt flag\n       *               (x=7..4)\n       */\n\
    \      BitFieldModel<uint32_t, 19, 1> teif6;\n      /**\n       * @brief DMEIF6\
    \ field\n       *\n       * Stream x direct mode error interrupt\n       *   \
    \            flag (x=7..4)\n       */\n      BitFieldModel<uint32_t, 18, 1> dmeif6;\n\
    \      /**\n       * @brief FEIF6 field\n       *\n       * Stream x FIFO error\
    \ interrupt flag\n       *               (x=7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> feif6;\n      /**\n       * @brief TCIF5 field\n       *\n       * Stream\
    \ x transfer complete interrupt\n       *               flag (x=7..4)\n      \
    \ */\n      BitFieldModel<uint32_t, 11, 1> tcif5;\n      /**\n       * @brief\
    \ HTIF5 field\n       *\n       * Stream x half transfer interrupt flag\n    \
    \   *               (x=7..4)\n       */\n      BitFieldModel<uint32_t, 10, 1>\
    \ htif5;\n      /**\n       * @brief TEIF5 field\n       *\n       * Stream x\
    \ transfer error interrupt flag\n       *               (x=7..4)\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> teif5;\n      /**\n       * @brief DMEIF5\
    \ field\n       *\n       * Stream x direct mode error interrupt\n       *   \
    \            flag (x=7..4)\n       */\n      BitFieldModel<uint32_t, 8, 1> dmeif5;\n\
    \      /**\n       * @brief FEIF5 field\n       *\n       * Stream x FIFO error\
    \ interrupt flag\n       *               (x=7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> feif5;\n      /**\n       * @brief TCIF4 field\n       *\n       * Stream\
    \ x transfer complete interrupt\n       *               flag (x=7..4)\n      \
    \ */\n      BitFieldModel<uint32_t, 5, 1> tcif4;\n      /**\n       * @brief HTIF4\
    \ field\n       *\n       * Stream x half transfer interrupt flag\n       *  \
    \             (x=7..4)\n       */\n      BitFieldModel<uint32_t, 4, 1> htif4;\n\
    \      /**\n       * @brief TEIF4 field\n       *\n       * Stream x transfer\
    \ error interrupt flag\n       *               (x=7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> teif4;\n      /**\n       * @brief DMEIF4 field\n       *\n       * Stream\
    \ x direct mode error interrupt\n       *               flag (x=7..4)\n      \
    \ */\n      BitFieldModel<uint32_t, 2, 1> dmeif4;\n      /**\n       * @brief\
    \ FEIF4 field\n       *\n       * Stream x FIFO error interrupt flag\n       *\
    \               (x=7..4)\n       */\n      BitFieldModel<uint32_t, 0, 1> feif4;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief HISR register\n   *\n   * high interrupt\
    \ status register\n   */\n  using hisr = HisrReg<BaseAddress + 0x0004>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class LifcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CTCIF3 field\n     *\n    \
    \ * Stream x clear transfer complete\n     *               interrupt flag (x =\
    \ 3..0)\n     */\n    using ctcif3 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   /**\n     * @brief CHTIF3 field\n     *\n     * Stream x clear half transfer\
    \ interrupt\n     *               flag (x = 3..0)\n     */\n    using chtif3 =\
    \ FieldModel<uint32_t, address, 26, 1>;\n    /**\n     * @brief CTEIF3 field\n\
    \     *\n     * Stream x clear transfer error interrupt\n     *              \
    \ flag (x = 3..0)\n     */\n    using cteif3 = FieldModel<uint32_t, address, 25,\
    \ 1>;\n    /**\n     * @brief CDMEIF3 field\n     *\n     * Stream x clear direct\
    \ mode error\n     *               interrupt flag (x = 3..0)\n     */\n    using\
    \ cdmeif3 = FieldModel<uint32_t, address, 24, 1>;\n    /**\n     * @brief CFEIF3\
    \ field\n     *\n     * Stream x clear FIFO error interrupt flag\n     *     \
    \          (x = 3..0)\n     */\n    using cfeif3 = FieldModel<uint32_t, address,\
    \ 22, 1>;\n    /**\n     * @brief CTCIF2 field\n     *\n     * Stream x clear\
    \ transfer complete\n     *               interrupt flag (x = 3..0)\n     */\n\
    \    using ctcif2 = FieldModel<uint32_t, address, 21, 1>;\n    /**\n     * @brief\
    \ CHTIF2 field\n     *\n     * Stream x clear half transfer interrupt\n     *\
    \               flag (x = 3..0)\n     */\n    using chtif2 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief CTEIF2 field\n     *\n     * Stream\
    \ x clear transfer error interrupt\n     *               flag (x = 3..0)\n   \
    \  */\n    using cteif2 = FieldModel<uint32_t, address, 19, 1>;\n    /**\n   \
    \  * @brief CDMEIF2 field\n     *\n     * Stream x clear direct mode error\n \
    \    *               interrupt flag (x = 3..0)\n     */\n    using cdmeif2 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    /**\n     * @brief CFEIF2 field\n     *\n     * Stream\
    \ x clear FIFO error interrupt flag\n     *               (x = 3..0)\n     */\n\
    \    using cfeif2 = FieldModel<uint32_t, address, 16, 1>;\n    /**\n     * @brief\
    \ CTCIF1 field\n     *\n     * Stream x clear transfer complete\n     *      \
    \         interrupt flag (x = 3..0)\n     */\n    using ctcif1 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief CHTIF1 field\n     *\n     * Stream\
    \ x clear half transfer interrupt\n     *               flag (x = 3..0)\n    \
    \ */\n    using chtif1 = FieldModel<uint32_t, address, 10, 1>;\n    /**\n    \
    \ * @brief CTEIF1 field\n     *\n     * Stream x clear transfer error interrupt\n\
    \     *               flag (x = 3..0)\n     */\n    using cteif1 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief CDMEIF1 field\n     *\n     * Stream\
    \ x clear direct mode error\n     *               interrupt flag (x = 3..0)\n\
    \     */\n    using cdmeif1 = FieldModel<uint32_t, address, 8, 1>;\n    /**\n\
    \     * @brief CFEIF1 field\n     *\n     * Stream x clear FIFO error interrupt\
    \ flag\n     *               (x = 3..0)\n     */\n    using cfeif1 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief CTCIF0 field\n     *\n     * Stream\
    \ x clear transfer complete\n     *               interrupt flag (x = 3..0)\n\
    \     */\n    using ctcif0 = FieldModel<uint32_t, address, 5, 1>;\n    /**\n \
    \    * @brief CHTIF0 field\n     *\n     * Stream x clear half transfer interrupt\n\
    \     *               flag (x = 3..0)\n     */\n    using chtif0 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief CTEIF0 field\n     *\n     * Stream\
    \ x clear transfer error interrupt\n     *               flag (x = 3..0)\n   \
    \  */\n    using cteif0 = FieldModel<uint32_t, address, 3, 1>;\n    /**\n    \
    \ * @brief CDMEIF0 field\n     *\n     * Stream x clear direct mode error\n  \
    \   *               interrupt flag (x = 3..0)\n     */\n    using cdmeif0 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CFEIF0 field\n     *\n     * Stream\
    \ x clear FIFO error interrupt flag\n     *               (x = 3..0)\n     */\n\
    \    using cfeif0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CTCIF3 field\n       *\n       * Stream x clear transfer complete\n       *\
    \               interrupt flag (x = 3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 27, 1> ctcif3;\n      /**\n       * @brief CHTIF3 field\n       *\n       *\
    \ Stream x clear half transfer interrupt\n       *               flag (x = 3..0)\n\
    \       */\n      BitFieldModel<uint32_t, 26, 1> chtif3;\n      /**\n       *\
    \ @brief CTEIF3 field\n       *\n       * Stream x clear transfer error interrupt\n\
    \       *               flag (x = 3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 1> cteif3;\n      /**\n       * @brief CDMEIF3 field\n       *\n       *\
    \ Stream x clear direct mode error\n       *               interrupt flag (x =\
    \ 3..0)\n       */\n      BitFieldModel<uint32_t, 24, 1> cdmeif3;\n      /**\n\
    \       * @brief CFEIF3 field\n       *\n       * Stream x clear FIFO error interrupt\
    \ flag\n       *               (x = 3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> cfeif3;\n      /**\n       * @brief CTCIF2 field\n       *\n       *\
    \ Stream x clear transfer complete\n       *               interrupt flag (x =\
    \ 3..0)\n       */\n      BitFieldModel<uint32_t, 21, 1> ctcif2;\n      /**\n\
    \       * @brief CHTIF2 field\n       *\n       * Stream x clear half transfer\
    \ interrupt\n       *               flag (x = 3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 1> chtif2;\n      /**\n       * @brief CTEIF2 field\n       *\n       *\
    \ Stream x clear transfer error interrupt\n       *               flag (x = 3..0)\n\
    \       */\n      BitFieldModel<uint32_t, 19, 1> cteif2;\n      /**\n       *\
    \ @brief CDMEIF2 field\n       *\n       * Stream x clear direct mode error\n\
    \       *               interrupt flag (x = 3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 1> cdmeif2;\n      /**\n       * @brief CFEIF2 field\n       *\n       *\
    \ Stream x clear FIFO error interrupt flag\n       *               (x = 3..0)\n\
    \       */\n      BitFieldModel<uint32_t, 16, 1> cfeif2;\n      /**\n       *\
    \ @brief CTCIF1 field\n       *\n       * Stream x clear transfer complete\n \
    \      *               interrupt flag (x = 3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> ctcif1;\n      /**\n       * @brief CHTIF1 field\n       *\n       *\
    \ Stream x clear half transfer interrupt\n       *               flag (x = 3..0)\n\
    \       */\n      BitFieldModel<uint32_t, 10, 1> chtif1;\n      /**\n       *\
    \ @brief CTEIF1 field\n       *\n       * Stream x clear transfer error interrupt\n\
    \       *               flag (x = 3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cteif1;\n      /**\n       * @brief CDMEIF1 field\n       *\n       *\
    \ Stream x clear direct mode error\n       *               interrupt flag (x =\
    \ 3..0)\n       */\n      BitFieldModel<uint32_t, 8, 1> cdmeif1;\n      /**\n\
    \       * @brief CFEIF1 field\n       *\n       * Stream x clear FIFO error interrupt\
    \ flag\n       *               (x = 3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> cfeif1;\n      /**\n       * @brief CTCIF0 field\n       *\n       * Stream\
    \ x clear transfer complete\n       *               interrupt flag (x = 3..0)\n\
    \       */\n      BitFieldModel<uint32_t, 5, 1> ctcif0;\n      /**\n       * @brief\
    \ CHTIF0 field\n       *\n       * Stream x clear half transfer interrupt\n  \
    \     *               flag (x = 3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> chtif0;\n      /**\n       * @brief CTEIF0 field\n       *\n       * Stream\
    \ x clear transfer error interrupt\n       *               flag (x = 3..0)\n \
    \      */\n      BitFieldModel<uint32_t, 3, 1> cteif0;\n      /**\n       * @brief\
    \ CDMEIF0 field\n       *\n       * Stream x clear direct mode error\n       *\
    \               interrupt flag (x = 3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cdmeif0;\n      /**\n       * @brief CFEIF0 field\n       *\n       *\
    \ Stream x clear FIFO error interrupt flag\n       *               (x = 3..0)\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> cfeif0;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief LIFCR register\n   *\n   * low interrupt flag clear\n   *\
    \           register\n   */\n  using lifcr = LifcrReg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class HifcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CTCIF7 field\n     *\n    \
    \ * Stream x clear transfer complete\n     *               interrupt flag (x =\
    \ 7..4)\n     */\n    using ctcif7 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   /**\n     * @brief CHTIF7 field\n     *\n     * Stream x clear half transfer\
    \ interrupt\n     *               flag (x = 7..4)\n     */\n    using chtif7 =\
    \ FieldModel<uint32_t, address, 26, 1>;\n    /**\n     * @brief CTEIF7 field\n\
    \     *\n     * Stream x clear transfer error interrupt\n     *              \
    \ flag (x = 7..4)\n     */\n    using cteif7 = FieldModel<uint32_t, address, 25,\
    \ 1>;\n    /**\n     * @brief CDMEIF7 field\n     *\n     * Stream x clear direct\
    \ mode error\n     *               interrupt flag (x = 7..4)\n     */\n    using\
    \ cdmeif7 = FieldModel<uint32_t, address, 24, 1>;\n    /**\n     * @brief CFEIF7\
    \ field\n     *\n     * Stream x clear FIFO error interrupt flag\n     *     \
    \          (x = 7..4)\n     */\n    using cfeif7 = FieldModel<uint32_t, address,\
    \ 22, 1>;\n    /**\n     * @brief CTCIF6 field\n     *\n     * Stream x clear\
    \ transfer complete\n     *               interrupt flag (x = 7..4)\n     */\n\
    \    using ctcif6 = FieldModel<uint32_t, address, 21, 1>;\n    /**\n     * @brief\
    \ CHTIF6 field\n     *\n     * Stream x clear half transfer interrupt\n     *\
    \               flag (x = 7..4)\n     */\n    using chtif6 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief CTEIF6 field\n     *\n     * Stream\
    \ x clear transfer error interrupt\n     *               flag (x = 7..4)\n   \
    \  */\n    using cteif6 = FieldModel<uint32_t, address, 19, 1>;\n    /**\n   \
    \  * @brief CDMEIF6 field\n     *\n     * Stream x clear direct mode error\n \
    \    *               interrupt flag (x = 7..4)\n     */\n    using cdmeif6 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    /**\n     * @brief CFEIF6 field\n     *\n     * Stream\
    \ x clear FIFO error interrupt flag\n     *               (x = 7..4)\n     */\n\
    \    using cfeif6 = FieldModel<uint32_t, address, 16, 1>;\n    /**\n     * @brief\
    \ CTCIF5 field\n     *\n     * Stream x clear transfer complete\n     *      \
    \         interrupt flag (x = 7..4)\n     */\n    using ctcif5 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief CHTIF5 field\n     *\n     * Stream\
    \ x clear half transfer interrupt\n     *               flag (x = 7..4)\n    \
    \ */\n    using chtif5 = FieldModel<uint32_t, address, 10, 1>;\n    /**\n    \
    \ * @brief CTEIF5 field\n     *\n     * Stream x clear transfer error interrupt\n\
    \     *               flag (x = 7..4)\n     */\n    using cteif5 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief CDMEIF5 field\n     *\n     * Stream\
    \ x clear direct mode error\n     *               interrupt flag (x = 7..4)\n\
    \     */\n    using cdmeif5 = FieldModel<uint32_t, address, 8, 1>;\n    /**\n\
    \     * @brief CFEIF5 field\n     *\n     * Stream x clear FIFO error interrupt\
    \ flag\n     *               (x = 7..4)\n     */\n    using cfeif5 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief CTCIF4 field\n     *\n     * Stream\
    \ x clear transfer complete\n     *               interrupt flag (x = 7..4)\n\
    \     */\n    using ctcif4 = FieldModel<uint32_t, address, 5, 1>;\n    /**\n \
    \    * @brief CHTIF4 field\n     *\n     * Stream x clear half transfer interrupt\n\
    \     *               flag (x = 7..4)\n     */\n    using chtif4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief CTEIF4 field\n     *\n     * Stream\
    \ x clear transfer error interrupt\n     *               flag (x = 7..4)\n   \
    \  */\n    using cteif4 = FieldModel<uint32_t, address, 3, 1>;\n    /**\n    \
    \ * @brief CDMEIF4 field\n     *\n     * Stream x clear direct mode error\n  \
    \   *               interrupt flag (x = 7..4)\n     */\n    using cdmeif4 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CFEIF4 field\n     *\n     * Stream\
    \ x clear FIFO error interrupt flag\n     *               (x = 7..4)\n     */\n\
    \    using cfeif4 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CTCIF7 field\n       *\n       * Stream x clear transfer complete\n       *\
    \               interrupt flag (x = 7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 27, 1> ctcif7;\n      /**\n       * @brief CHTIF7 field\n       *\n       *\
    \ Stream x clear half transfer interrupt\n       *               flag (x = 7..4)\n\
    \       */\n      BitFieldModel<uint32_t, 26, 1> chtif7;\n      /**\n       *\
    \ @brief CTEIF7 field\n       *\n       * Stream x clear transfer error interrupt\n\
    \       *               flag (x = 7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 1> cteif7;\n      /**\n       * @brief CDMEIF7 field\n       *\n       *\
    \ Stream x clear direct mode error\n       *               interrupt flag (x =\
    \ 7..4)\n       */\n      BitFieldModel<uint32_t, 24, 1> cdmeif7;\n      /**\n\
    \       * @brief CFEIF7 field\n       *\n       * Stream x clear FIFO error interrupt\
    \ flag\n       *               (x = 7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> cfeif7;\n      /**\n       * @brief CTCIF6 field\n       *\n       *\
    \ Stream x clear transfer complete\n       *               interrupt flag (x =\
    \ 7..4)\n       */\n      BitFieldModel<uint32_t, 21, 1> ctcif6;\n      /**\n\
    \       * @brief CHTIF6 field\n       *\n       * Stream x clear half transfer\
    \ interrupt\n       *               flag (x = 7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 1> chtif6;\n      /**\n       * @brief CTEIF6 field\n       *\n       *\
    \ Stream x clear transfer error interrupt\n       *               flag (x = 7..4)\n\
    \       */\n      BitFieldModel<uint32_t, 19, 1> cteif6;\n      /**\n       *\
    \ @brief CDMEIF6 field\n       *\n       * Stream x clear direct mode error\n\
    \       *               interrupt flag (x = 7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 1> cdmeif6;\n      /**\n       * @brief CFEIF6 field\n       *\n       *\
    \ Stream x clear FIFO error interrupt flag\n       *               (x = 7..4)\n\
    \       */\n      BitFieldModel<uint32_t, 16, 1> cfeif6;\n      /**\n       *\
    \ @brief CTCIF5 field\n       *\n       * Stream x clear transfer complete\n \
    \      *               interrupt flag (x = 7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> ctcif5;\n      /**\n       * @brief CHTIF5 field\n       *\n       *\
    \ Stream x clear half transfer interrupt\n       *               flag (x = 7..4)\n\
    \       */\n      BitFieldModel<uint32_t, 10, 1> chtif5;\n      /**\n       *\
    \ @brief CTEIF5 field\n       *\n       * Stream x clear transfer error interrupt\n\
    \       *               flag (x = 7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cteif5;\n      /**\n       * @brief CDMEIF5 field\n       *\n       *\
    \ Stream x clear direct mode error\n       *               interrupt flag (x =\
    \ 7..4)\n       */\n      BitFieldModel<uint32_t, 8, 1> cdmeif5;\n      /**\n\
    \       * @brief CFEIF5 field\n       *\n       * Stream x clear FIFO error interrupt\
    \ flag\n       *               (x = 7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> cfeif5;\n      /**\n       * @brief CTCIF4 field\n       *\n       * Stream\
    \ x clear transfer complete\n       *               interrupt flag (x = 7..4)\n\
    \       */\n      BitFieldModel<uint32_t, 5, 1> ctcif4;\n      /**\n       * @brief\
    \ CHTIF4 field\n       *\n       * Stream x clear half transfer interrupt\n  \
    \     *               flag (x = 7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> chtif4;\n      /**\n       * @brief CTEIF4 field\n       *\n       * Stream\
    \ x clear transfer error interrupt\n       *               flag (x = 7..4)\n \
    \      */\n      BitFieldModel<uint32_t, 3, 1> cteif4;\n      /**\n       * @brief\
    \ CDMEIF4 field\n       *\n       * Stream x clear direct mode error\n       *\
    \               interrupt flag (x = 7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cdmeif4;\n      /**\n       * @brief CFEIF4 field\n       *\n       *\
    \ Stream x clear FIFO error interrupt flag\n       *               (x = 7..4)\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> cfeif4;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief HIFCR register\n   *\n   * high interrupt flag clear\n   *\
    \           register\n   */\n  using hifcr = HifcrReg<BaseAddress + 0x000C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S0crReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CHSEL field\n     *\n     *\
    \ Channel selection\n     */\n    using chsel = FieldModel<uint32_t, address,\
    \ 25, 3>;\n    /**\n     * @brief MBURST field\n     *\n     * Memory burst transfer\n\
    \     *               configuration\n     */\n    using mburst = FieldModel<uint32_t,\
    \ address, 23, 2>;\n    /**\n     * @brief PBURST field\n     *\n     * Peripheral\
    \ burst transfer\n     *               configuration\n     */\n    using pburst\
    \ = FieldModel<uint32_t, address, 21, 2>;\n    /**\n     * @brief CT field\n \
    \    *\n     * Current target (only in double buffer\n     *               mode)\n\
    \     */\n    using ct = FieldModel<uint32_t, address, 19, 1>;\n    /**\n    \
    \ * @brief DBM field\n     *\n     * Double buffer mode\n     */\n    using dbm\
    \ = FieldModel<uint32_t, address, 18, 1>;\n    /**\n     * @brief PL field\n \
    \    *\n     * Priority level\n     */\n    using pl = FieldModel<uint32_t, address,\
    \ 16, 2>;\n    /**\n     * @brief PINCOS field\n     *\n     * Peripheral increment\
    \ offset\n     *               size\n     */\n    using pincos = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief MSIZE field\n     *\n     * Memory\
    \ data size\n     */\n    using msize = FieldModel<uint32_t, address, 13, 2>;\n\
    \    /**\n     * @brief PSIZE field\n     *\n     * Peripheral data size\n   \
    \  */\n    using psize = FieldModel<uint32_t, address, 11, 2>;\n    /**\n    \
    \ * @brief MINC field\n     *\n     * Memory increment mode\n     */\n    using\
    \ minc = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief PINC field\n\
    \     *\n     * Peripheral increment mode\n     */\n    using pinc = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief CIRC field\n     *\n     * Circular\
    \ mode\n     */\n    using circ = FieldModel<uint32_t, address, 8, 1>;\n    /**\n\
    \     * @brief DIR field\n     *\n     * Data transfer direction\n     */\n  \
    \  using dir = FieldModel<uint32_t, address, 6, 2>;\n    /**\n     * @brief PFCTRL\
    \ field\n     *\n     * Peripheral flow controller\n     */\n    using pfctrl\
    \ = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief TCIE field\n\
    \     *\n     * Transfer complete interrupt\n     *               enable\n   \
    \  */\n    using tcie = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     *\
    \ @brief HTIE field\n     *\n     * Half transfer interrupt\n     *          \
    \     enable\n     */\n    using htie = FieldModel<uint32_t, address, 3, 1>;\n\
    \    /**\n     * @brief TEIE field\n     *\n     * Transfer error interrupt\n\
    \     *               enable\n     */\n    using teie = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief DMEIE field\n     *\n     * Direct mode error\
    \ interrupt\n     *               enable\n     */\n    using dmeie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief EN field\n     *\n     * Stream enable\
    \ / flag stream ready when\n     *               read low\n     */\n    using\
    \ en = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CHSEL field\n       *\n       * Channel selection\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 3> chsel;\n      /**\n       * @brief MBURST field\n       *\n       * Memory\
    \ burst transfer\n       *               configuration\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 2> mburst;\n      /**\n       * @brief PBURST field\n       *\n       *\
    \ Peripheral burst transfer\n       *               configuration\n       */\n\
    \      BitFieldModel<uint32_t, 21, 2> pburst;\n      /**\n       * @brief CT field\n\
    \       *\n       * Current target (only in double buffer\n       *          \
    \     mode)\n       */\n      BitFieldModel<uint32_t, 19, 1> ct;\n      /**\n\
    \       * @brief DBM field\n       *\n       * Double buffer mode\n       */\n\
    \      BitFieldModel<uint32_t, 18, 1> dbm;\n      /**\n       * @brief PL field\n\
    \       *\n       * Priority level\n       */\n      BitFieldModel<uint32_t, 16,\
    \ 2> pl;\n      /**\n       * @brief PINCOS field\n       *\n       * Peripheral\
    \ increment offset\n       *               size\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> pincos;\n      /**\n       * @brief MSIZE field\n       *\n       * Memory\
    \ data size\n       */\n      BitFieldModel<uint32_t, 13, 2> msize;\n      /**\n\
    \       * @brief PSIZE field\n       *\n       * Peripheral data size\n      \
    \ */\n      BitFieldModel<uint32_t, 11, 2> psize;\n      /**\n       * @brief\
    \ MINC field\n       *\n       * Memory increment mode\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> minc;\n      /**\n       * @brief PINC field\n       *\n       * Peripheral\
    \ increment mode\n       */\n      BitFieldModel<uint32_t, 9, 1> pinc;\n     \
    \ /**\n       * @brief CIRC field\n       *\n       * Circular mode\n       */\n\
    \      BitFieldModel<uint32_t, 8, 1> circ;\n      /**\n       * @brief DIR field\n\
    \       *\n       * Data transfer direction\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 2> dir;\n      /**\n       * @brief PFCTRL field\n       *\n       * Peripheral\
    \ flow controller\n       */\n      BitFieldModel<uint32_t, 5, 1> pfctrl;\n  \
    \    /**\n       * @brief TCIE field\n       *\n       * Transfer complete interrupt\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 4, 1>\
    \ tcie;\n      /**\n       * @brief HTIE field\n       *\n       * Half transfer\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      /**\n       * @brief TEIE field\n       *\n       * Transfer\
    \ error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      /**\n       * @brief DMEIE field\n       *\n       * Direct\
    \ mode error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      /**\n       * @brief EN field\n       *\n       * Stream\
    \ enable / flag stream ready when\n       *               read low\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief S0CR register\n   *\n   * stream x configuration\n   *           register\n\
    \   */\n  using s0cr = S0crReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S0ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief NDT field\n     *\n     * Number of data\
    \ items to\n     *               transfer\n     */\n    using ndt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief NDT field\n       *\n \
    \      * Number of data items to\n       *               transfer\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ndt;\n    };\n  };\n\npublic:\n  /**\n \
    \  * @brief S0NDTR register\n   *\n   * stream x number of data\n   *        \
    \   register\n   */\n  using s0ndtr = S0ndtrReg<BaseAddress + 0x0014>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class S0parReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief PA field\n     *\n     * Peripheral\
    \ address\n     */\n    using pa = FieldModel<uint32_t, address, 0, 32>;\n\n \
    \ public:\n    /**\n     * @brief Register union\n     *\n     * Can be used to\
    \ create a local register variable for easy bit manipulation.\n     * Useful for\
    \ read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief PA field\n       *\n       * Peripheral address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S0PAR register\n   *\n   * stream x peripheral address\n \
    \  *           register\n   */\n  using s0par = S0parReg<BaseAddress + 0x0018>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S0m0arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M0A field\n     *\n     * Memory\
    \ 0 address\n     */\n    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief M0A field\n       *\n       * Memory 0 address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> m0a;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S0M0AR register\n   *\n   * stream x memory 0 address\n  \
    \ *           register\n   */\n  using s0m0ar = S0m0arReg<BaseAddress + 0x001C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S0m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M1A field\n     *\n     * Memory\
    \ 1 address (used in case of Double\n     *               buffer mode)\n     */\n\
    \    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ M1A field\n       *\n       * Memory 1 address (used in case of Double\n   \
    \    *               buffer mode)\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 32> m1a;\n    };\n  };\n\npublic:\n  /**\n   * @brief S0M1AR register\n   *\n\
    \   * stream x memory 1 address\n   *           register\n   */\n  using s0m1ar\
    \ = S0m1arReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S0fcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief FEIE field\n     *\n     * FIFO error interrupt\n    \
    \ *               enable\n     */\n    using feie = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    /**\n     * @brief FS field\n     *\n     * FIFO status\n     */\n\
    \    using fs = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     * @brief DMDIS\
    \ field\n     *\n     * Direct mode disable\n     */\n    using dmdis = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief FTH field\n     *\n     * FIFO threshold\
    \ selection\n     */\n    using fth = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief FEIE field\n       *\n       * FIFO error\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> feie;\n      /**\n       * @brief FS field\n       *\n       * FIFO status\n\
    \       */\n      BitFieldModel<uint32_t, 3, 3> fs;\n      /**\n       * @brief\
    \ DMDIS field\n       *\n       * Direct mode disable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmdis;\n      /**\n       * @brief FTH field\n       *\n       * FIFO\
    \ threshold selection\n       */\n      BitFieldModel<uint32_t, 0, 2> fth;\n \
    \   };\n  };\n\npublic:\n  /**\n   * @brief S0FCR register\n   *\n   * stream\
    \ x FIFO control register\n   */\n  using s0fcr = S0fcrReg<BaseAddress + 0x0024>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S1crReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CHSEL field\n     *\n     *\
    \ Channel selection\n     */\n    using chsel = FieldModel<uint32_t, address,\
    \ 25, 3>;\n    /**\n     * @brief MBURST field\n     *\n     * Memory burst transfer\n\
    \     *               configuration\n     */\n    using mburst = FieldModel<uint32_t,\
    \ address, 23, 2>;\n    /**\n     * @brief PBURST field\n     *\n     * Peripheral\
    \ burst transfer\n     *               configuration\n     */\n    using pburst\
    \ = FieldModel<uint32_t, address, 21, 2>;\n    /**\n     * @brief ACK field\n\
    \     *\n     * ACK\n     */\n    using ack = FieldModel<uint32_t, address, 20,\
    \ 1>;\n    /**\n     * @brief CT field\n     *\n     * Current target (only in\
    \ double buffer\n     *               mode)\n     */\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief DBM field\n     *\n     * Double buffer\
    \ mode\n     */\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n    /**\n\
    \     * @brief PL field\n     *\n     * Priority level\n     */\n    using pl\
    \ = FieldModel<uint32_t, address, 16, 2>;\n    /**\n     * @brief PINCOS field\n\
    \     *\n     * Peripheral increment offset\n     *               size\n     */\n\
    \    using pincos = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief\
    \ MSIZE field\n     *\n     * Memory data size\n     */\n    using msize = FieldModel<uint32_t,\
    \ address, 13, 2>;\n    /**\n     * @brief PSIZE field\n     *\n     * Peripheral\
    \ data size\n     */\n    using psize = FieldModel<uint32_t, address, 11, 2>;\n\
    \    /**\n     * @brief MINC field\n     *\n     * Memory increment mode\n   \
    \  */\n    using minc = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     *\
    \ @brief PINC field\n     *\n     * Peripheral increment mode\n     */\n    using\
    \ pinc = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief CIRC field\n\
    \     *\n     * Circular mode\n     */\n    using circ = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief DIR field\n     *\n     * Data transfer\
    \ direction\n     */\n    using dir = FieldModel<uint32_t, address, 6, 2>;\n \
    \   /**\n     * @brief PFCTRL field\n     *\n     * Peripheral flow controller\n\
    \     */\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n    /**\n \
    \    * @brief TCIE field\n     *\n     * Transfer complete interrupt\n     * \
    \              enable\n     */\n    using tcie = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief HTIE field\n     *\n     * Half transfer interrupt\n\
    \     *               enable\n     */\n    using htie = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief TEIE field\n     *\n     * Transfer error interrupt\n\
    \     *               enable\n     */\n    using teie = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief DMEIE field\n     *\n     * Direct mode error\
    \ interrupt\n     *               enable\n     */\n    using dmeie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief EN field\n     *\n     * Stream enable\
    \ / flag stream ready when\n     *               read low\n     */\n    using\
    \ en = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CHSEL field\n       *\n       * Channel selection\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 3> chsel;\n      /**\n       * @brief MBURST field\n       *\n       * Memory\
    \ burst transfer\n       *               configuration\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 2> mburst;\n      /**\n       * @brief PBURST field\n       *\n       *\
    \ Peripheral burst transfer\n       *               configuration\n       */\n\
    \      BitFieldModel<uint32_t, 21, 2> pburst;\n      /**\n       * @brief ACK\
    \ field\n       *\n       * ACK\n       */\n      BitFieldModel<uint32_t, 20,\
    \ 1> ack;\n      /**\n       * @brief CT field\n       *\n       * Current target\
    \ (only in double buffer\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      /**\n       * @brief DBM field\n       *\n       * Double\
    \ buffer mode\n       */\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      /**\n\
    \       * @brief PL field\n       *\n       * Priority level\n       */\n    \
    \  BitFieldModel<uint32_t, 16, 2> pl;\n      /**\n       * @brief PINCOS field\n\
    \       *\n       * Peripheral increment offset\n       *               size\n\
    \       */\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      /**\n       *\
    \ @brief MSIZE field\n       *\n       * Memory data size\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      /**\n       * @brief PSIZE field\n       *\n       * Peripheral\
    \ data size\n       */\n      BitFieldModel<uint32_t, 11, 2> psize;\n      /**\n\
    \       * @brief MINC field\n       *\n       * Memory increment mode\n      \
    \ */\n      BitFieldModel<uint32_t, 10, 1> minc;\n      /**\n       * @brief PINC\
    \ field\n       *\n       * Peripheral increment mode\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> pinc;\n      /**\n       * @brief CIRC field\n       *\n       * Circular\
    \ mode\n       */\n      BitFieldModel<uint32_t, 8, 1> circ;\n      /**\n    \
    \   * @brief DIR field\n       *\n       * Data transfer direction\n       */\n\
    \      BitFieldModel<uint32_t, 6, 2> dir;\n      /**\n       * @brief PFCTRL field\n\
    \       *\n       * Peripheral flow controller\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      /**\n       * @brief TCIE field\n       *\n       * Transfer\
    \ complete interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> tcie;\n      /**\n       * @brief HTIE field\n       *\n       * Half\
    \ transfer interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      /**\n       * @brief TEIE field\n       *\n       * Transfer\
    \ error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      /**\n       * @brief DMEIE field\n       *\n       * Direct\
    \ mode error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      /**\n       * @brief EN field\n       *\n       * Stream\
    \ enable / flag stream ready when\n       *               read low\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief S1CR register\n   *\n   * stream x configuration\n   *           register\n\
    \   */\n  using s1cr = S1crReg<BaseAddress + 0x0028>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S1ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief NDT field\n     *\n     * Number of data\
    \ items to\n     *               transfer\n     */\n    using ndt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief NDT field\n       *\n \
    \      * Number of data items to\n       *               transfer\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ndt;\n    };\n  };\n\npublic:\n  /**\n \
    \  * @brief S1NDTR register\n   *\n   * stream x number of data\n   *        \
    \   register\n   */\n  using s1ndtr = S1ndtrReg<BaseAddress + 0x002C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class S1parReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief PA field\n     *\n     * Peripheral\
    \ address\n     */\n    using pa = FieldModel<uint32_t, address, 0, 32>;\n\n \
    \ public:\n    /**\n     * @brief Register union\n     *\n     * Can be used to\
    \ create a local register variable for easy bit manipulation.\n     * Useful for\
    \ read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief PA field\n       *\n       * Peripheral address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S1PAR register\n   *\n   * stream x peripheral address\n \
    \  *           register\n   */\n  using s1par = S1parReg<BaseAddress + 0x0030>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S1m0arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M0A field\n     *\n     * Memory\
    \ 0 address\n     */\n    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief M0A field\n       *\n       * Memory 0 address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> m0a;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S1M0AR register\n   *\n   * stream x memory 0 address\n  \
    \ *           register\n   */\n  using s1m0ar = S1m0arReg<BaseAddress + 0x0034>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S1m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M1A field\n     *\n     * Memory\
    \ 1 address (used in case of Double\n     *               buffer mode)\n     */\n\
    \    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ M1A field\n       *\n       * Memory 1 address (used in case of Double\n   \
    \    *               buffer mode)\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 32> m1a;\n    };\n  };\n\npublic:\n  /**\n   * @brief S1M1AR register\n   *\n\
    \   * stream x memory 1 address\n   *           register\n   */\n  using s1m1ar\
    \ = S1m1arReg<BaseAddress + 0x0038>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S1fcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief FEIE field\n     *\n     * FIFO error interrupt\n    \
    \ *               enable\n     */\n    using feie = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    /**\n     * @brief FS field\n     *\n     * FIFO status\n     */\n\
    \    using fs = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     * @brief DMDIS\
    \ field\n     *\n     * Direct mode disable\n     */\n    using dmdis = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief FTH field\n     *\n     * FIFO threshold\
    \ selection\n     */\n    using fth = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief FEIE field\n       *\n       * FIFO error\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> feie;\n      /**\n       * @brief FS field\n       *\n       * FIFO status\n\
    \       */\n      BitFieldModel<uint32_t, 3, 3> fs;\n      /**\n       * @brief\
    \ DMDIS field\n       *\n       * Direct mode disable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmdis;\n      /**\n       * @brief FTH field\n       *\n       * FIFO\
    \ threshold selection\n       */\n      BitFieldModel<uint32_t, 0, 2> fth;\n \
    \   };\n  };\n\npublic:\n  /**\n   * @brief S1FCR register\n   *\n   * stream\
    \ x FIFO control register\n   */\n  using s1fcr = S1fcrReg<BaseAddress + 0x003C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S2crReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CHSEL field\n     *\n     *\
    \ Channel selection\n     */\n    using chsel = FieldModel<uint32_t, address,\
    \ 25, 3>;\n    /**\n     * @brief MBURST field\n     *\n     * Memory burst transfer\n\
    \     *               configuration\n     */\n    using mburst = FieldModel<uint32_t,\
    \ address, 23, 2>;\n    /**\n     * @brief PBURST field\n     *\n     * Peripheral\
    \ burst transfer\n     *               configuration\n     */\n    using pburst\
    \ = FieldModel<uint32_t, address, 21, 2>;\n    /**\n     * @brief ACK field\n\
    \     *\n     * ACK\n     */\n    using ack = FieldModel<uint32_t, address, 20,\
    \ 1>;\n    /**\n     * @brief CT field\n     *\n     * Current target (only in\
    \ double buffer\n     *               mode)\n     */\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief DBM field\n     *\n     * Double buffer\
    \ mode\n     */\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n    /**\n\
    \     * @brief PL field\n     *\n     * Priority level\n     */\n    using pl\
    \ = FieldModel<uint32_t, address, 16, 2>;\n    /**\n     * @brief PINCOS field\n\
    \     *\n     * Peripheral increment offset\n     *               size\n     */\n\
    \    using pincos = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief\
    \ MSIZE field\n     *\n     * Memory data size\n     */\n    using msize = FieldModel<uint32_t,\
    \ address, 13, 2>;\n    /**\n     * @brief PSIZE field\n     *\n     * Peripheral\
    \ data size\n     */\n    using psize = FieldModel<uint32_t, address, 11, 2>;\n\
    \    /**\n     * @brief MINC field\n     *\n     * Memory increment mode\n   \
    \  */\n    using minc = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     *\
    \ @brief PINC field\n     *\n     * Peripheral increment mode\n     */\n    using\
    \ pinc = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief CIRC field\n\
    \     *\n     * Circular mode\n     */\n    using circ = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief DIR field\n     *\n     * Data transfer\
    \ direction\n     */\n    using dir = FieldModel<uint32_t, address, 6, 2>;\n \
    \   /**\n     * @brief PFCTRL field\n     *\n     * Peripheral flow controller\n\
    \     */\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n    /**\n \
    \    * @brief TCIE field\n     *\n     * Transfer complete interrupt\n     * \
    \              enable\n     */\n    using tcie = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief HTIE field\n     *\n     * Half transfer interrupt\n\
    \     *               enable\n     */\n    using htie = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief TEIE field\n     *\n     * Transfer error interrupt\n\
    \     *               enable\n     */\n    using teie = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief DMEIE field\n     *\n     * Direct mode error\
    \ interrupt\n     *               enable\n     */\n    using dmeie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief EN field\n     *\n     * Stream enable\
    \ / flag stream ready when\n     *               read low\n     */\n    using\
    \ en = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CHSEL field\n       *\n       * Channel selection\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 3> chsel;\n      /**\n       * @brief MBURST field\n       *\n       * Memory\
    \ burst transfer\n       *               configuration\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 2> mburst;\n      /**\n       * @brief PBURST field\n       *\n       *\
    \ Peripheral burst transfer\n       *               configuration\n       */\n\
    \      BitFieldModel<uint32_t, 21, 2> pburst;\n      /**\n       * @brief ACK\
    \ field\n       *\n       * ACK\n       */\n      BitFieldModel<uint32_t, 20,\
    \ 1> ack;\n      /**\n       * @brief CT field\n       *\n       * Current target\
    \ (only in double buffer\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      /**\n       * @brief DBM field\n       *\n       * Double\
    \ buffer mode\n       */\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      /**\n\
    \       * @brief PL field\n       *\n       * Priority level\n       */\n    \
    \  BitFieldModel<uint32_t, 16, 2> pl;\n      /**\n       * @brief PINCOS field\n\
    \       *\n       * Peripheral increment offset\n       *               size\n\
    \       */\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      /**\n       *\
    \ @brief MSIZE field\n       *\n       * Memory data size\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      /**\n       * @brief PSIZE field\n       *\n       * Peripheral\
    \ data size\n       */\n      BitFieldModel<uint32_t, 11, 2> psize;\n      /**\n\
    \       * @brief MINC field\n       *\n       * Memory increment mode\n      \
    \ */\n      BitFieldModel<uint32_t, 10, 1> minc;\n      /**\n       * @brief PINC\
    \ field\n       *\n       * Peripheral increment mode\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> pinc;\n      /**\n       * @brief CIRC field\n       *\n       * Circular\
    \ mode\n       */\n      BitFieldModel<uint32_t, 8, 1> circ;\n      /**\n    \
    \   * @brief DIR field\n       *\n       * Data transfer direction\n       */\n\
    \      BitFieldModel<uint32_t, 6, 2> dir;\n      /**\n       * @brief PFCTRL field\n\
    \       *\n       * Peripheral flow controller\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      /**\n       * @brief TCIE field\n       *\n       * Transfer\
    \ complete interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> tcie;\n      /**\n       * @brief HTIE field\n       *\n       * Half\
    \ transfer interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      /**\n       * @brief TEIE field\n       *\n       * Transfer\
    \ error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      /**\n       * @brief DMEIE field\n       *\n       * Direct\
    \ mode error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      /**\n       * @brief EN field\n       *\n       * Stream\
    \ enable / flag stream ready when\n       *               read low\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief S2CR register\n   *\n   * stream x configuration\n   *           register\n\
    \   */\n  using s2cr = S2crReg<BaseAddress + 0x0040>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S2ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief NDT field\n     *\n     * Number of data\
    \ items to\n     *               transfer\n     */\n    using ndt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief NDT field\n       *\n \
    \      * Number of data items to\n       *               transfer\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ndt;\n    };\n  };\n\npublic:\n  /**\n \
    \  * @brief S2NDTR register\n   *\n   * stream x number of data\n   *        \
    \   register\n   */\n  using s2ndtr = S2ndtrReg<BaseAddress + 0x0044>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class S2parReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief PA field\n     *\n     * Peripheral\
    \ address\n     */\n    using pa = FieldModel<uint32_t, address, 0, 32>;\n\n \
    \ public:\n    /**\n     * @brief Register union\n     *\n     * Can be used to\
    \ create a local register variable for easy bit manipulation.\n     * Useful for\
    \ read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief PA field\n       *\n       * Peripheral address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S2PAR register\n   *\n   * stream x peripheral address\n \
    \  *           register\n   */\n  using s2par = S2parReg<BaseAddress + 0x0048>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S2m0arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M0A field\n     *\n     * Memory\
    \ 0 address\n     */\n    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief M0A field\n       *\n       * Memory 0 address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> m0a;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S2M0AR register\n   *\n   * stream x memory 0 address\n  \
    \ *           register\n   */\n  using s2m0ar = S2m0arReg<BaseAddress + 0x004C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S2m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M1A field\n     *\n     * Memory\
    \ 1 address (used in case of Double\n     *               buffer mode)\n     */\n\
    \    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ M1A field\n       *\n       * Memory 1 address (used in case of Double\n   \
    \    *               buffer mode)\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 32> m1a;\n    };\n  };\n\npublic:\n  /**\n   * @brief S2M1AR register\n   *\n\
    \   * stream x memory 1 address\n   *           register\n   */\n  using s2m1ar\
    \ = S2m1arReg<BaseAddress + 0x0050>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S2fcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief FEIE field\n     *\n     * FIFO error interrupt\n    \
    \ *               enable\n     */\n    using feie = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    /**\n     * @brief FS field\n     *\n     * FIFO status\n     */\n\
    \    using fs = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     * @brief DMDIS\
    \ field\n     *\n     * Direct mode disable\n     */\n    using dmdis = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief FTH field\n     *\n     * FIFO threshold\
    \ selection\n     */\n    using fth = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief FEIE field\n       *\n       * FIFO error\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> feie;\n      /**\n       * @brief FS field\n       *\n       * FIFO status\n\
    \       */\n      BitFieldModel<uint32_t, 3, 3> fs;\n      /**\n       * @brief\
    \ DMDIS field\n       *\n       * Direct mode disable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmdis;\n      /**\n       * @brief FTH field\n       *\n       * FIFO\
    \ threshold selection\n       */\n      BitFieldModel<uint32_t, 0, 2> fth;\n \
    \   };\n  };\n\npublic:\n  /**\n   * @brief S2FCR register\n   *\n   * stream\
    \ x FIFO control register\n   */\n  using s2fcr = S2fcrReg<BaseAddress + 0x0054>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S3crReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CHSEL field\n     *\n     *\
    \ Channel selection\n     */\n    using chsel = FieldModel<uint32_t, address,\
    \ 25, 3>;\n    /**\n     * @brief MBURST field\n     *\n     * Memory burst transfer\n\
    \     *               configuration\n     */\n    using mburst = FieldModel<uint32_t,\
    \ address, 23, 2>;\n    /**\n     * @brief PBURST field\n     *\n     * Peripheral\
    \ burst transfer\n     *               configuration\n     */\n    using pburst\
    \ = FieldModel<uint32_t, address, 21, 2>;\n    /**\n     * @brief ACK field\n\
    \     *\n     * ACK\n     */\n    using ack = FieldModel<uint32_t, address, 20,\
    \ 1>;\n    /**\n     * @brief CT field\n     *\n     * Current target (only in\
    \ double buffer\n     *               mode)\n     */\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief DBM field\n     *\n     * Double buffer\
    \ mode\n     */\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n    /**\n\
    \     * @brief PL field\n     *\n     * Priority level\n     */\n    using pl\
    \ = FieldModel<uint32_t, address, 16, 2>;\n    /**\n     * @brief PINCOS field\n\
    \     *\n     * Peripheral increment offset\n     *               size\n     */\n\
    \    using pincos = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief\
    \ MSIZE field\n     *\n     * Memory data size\n     */\n    using msize = FieldModel<uint32_t,\
    \ address, 13, 2>;\n    /**\n     * @brief PSIZE field\n     *\n     * Peripheral\
    \ data size\n     */\n    using psize = FieldModel<uint32_t, address, 11, 2>;\n\
    \    /**\n     * @brief MINC field\n     *\n     * Memory increment mode\n   \
    \  */\n    using minc = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     *\
    \ @brief PINC field\n     *\n     * Peripheral increment mode\n     */\n    using\
    \ pinc = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief CIRC field\n\
    \     *\n     * Circular mode\n     */\n    using circ = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief DIR field\n     *\n     * Data transfer\
    \ direction\n     */\n    using dir = FieldModel<uint32_t, address, 6, 2>;\n \
    \   /**\n     * @brief PFCTRL field\n     *\n     * Peripheral flow controller\n\
    \     */\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n    /**\n \
    \    * @brief TCIE field\n     *\n     * Transfer complete interrupt\n     * \
    \              enable\n     */\n    using tcie = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief HTIE field\n     *\n     * Half transfer interrupt\n\
    \     *               enable\n     */\n    using htie = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief TEIE field\n     *\n     * Transfer error interrupt\n\
    \     *               enable\n     */\n    using teie = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief DMEIE field\n     *\n     * Direct mode error\
    \ interrupt\n     *               enable\n     */\n    using dmeie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief EN field\n     *\n     * Stream enable\
    \ / flag stream ready when\n     *               read low\n     */\n    using\
    \ en = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CHSEL field\n       *\n       * Channel selection\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 3> chsel;\n      /**\n       * @brief MBURST field\n       *\n       * Memory\
    \ burst transfer\n       *               configuration\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 2> mburst;\n      /**\n       * @brief PBURST field\n       *\n       *\
    \ Peripheral burst transfer\n       *               configuration\n       */\n\
    \      BitFieldModel<uint32_t, 21, 2> pburst;\n      /**\n       * @brief ACK\
    \ field\n       *\n       * ACK\n       */\n      BitFieldModel<uint32_t, 20,\
    \ 1> ack;\n      /**\n       * @brief CT field\n       *\n       * Current target\
    \ (only in double buffer\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      /**\n       * @brief DBM field\n       *\n       * Double\
    \ buffer mode\n       */\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      /**\n\
    \       * @brief PL field\n       *\n       * Priority level\n       */\n    \
    \  BitFieldModel<uint32_t, 16, 2> pl;\n      /**\n       * @brief PINCOS field\n\
    \       *\n       * Peripheral increment offset\n       *               size\n\
    \       */\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      /**\n       *\
    \ @brief MSIZE field\n       *\n       * Memory data size\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      /**\n       * @brief PSIZE field\n       *\n       * Peripheral\
    \ data size\n       */\n      BitFieldModel<uint32_t, 11, 2> psize;\n      /**\n\
    \       * @brief MINC field\n       *\n       * Memory increment mode\n      \
    \ */\n      BitFieldModel<uint32_t, 10, 1> minc;\n      /**\n       * @brief PINC\
    \ field\n       *\n       * Peripheral increment mode\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> pinc;\n      /**\n       * @brief CIRC field\n       *\n       * Circular\
    \ mode\n       */\n      BitFieldModel<uint32_t, 8, 1> circ;\n      /**\n    \
    \   * @brief DIR field\n       *\n       * Data transfer direction\n       */\n\
    \      BitFieldModel<uint32_t, 6, 2> dir;\n      /**\n       * @brief PFCTRL field\n\
    \       *\n       * Peripheral flow controller\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      /**\n       * @brief TCIE field\n       *\n       * Transfer\
    \ complete interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> tcie;\n      /**\n       * @brief HTIE field\n       *\n       * Half\
    \ transfer interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      /**\n       * @brief TEIE field\n       *\n       * Transfer\
    \ error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      /**\n       * @brief DMEIE field\n       *\n       * Direct\
    \ mode error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      /**\n       * @brief EN field\n       *\n       * Stream\
    \ enable / flag stream ready when\n       *               read low\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief S3CR register\n   *\n   * stream x configuration\n   *           register\n\
    \   */\n  using s3cr = S3crReg<BaseAddress + 0x0058>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S3ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief NDT field\n     *\n     * Number of data\
    \ items to\n     *               transfer\n     */\n    using ndt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief NDT field\n       *\n \
    \      * Number of data items to\n       *               transfer\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ndt;\n    };\n  };\n\npublic:\n  /**\n \
    \  * @brief S3NDTR register\n   *\n   * stream x number of data\n   *        \
    \   register\n   */\n  using s3ndtr = S3ndtrReg<BaseAddress + 0x005C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class S3parReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief PA field\n     *\n     * Peripheral\
    \ address\n     */\n    using pa = FieldModel<uint32_t, address, 0, 32>;\n\n \
    \ public:\n    /**\n     * @brief Register union\n     *\n     * Can be used to\
    \ create a local register variable for easy bit manipulation.\n     * Useful for\
    \ read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief PA field\n       *\n       * Peripheral address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S3PAR register\n   *\n   * stream x peripheral address\n \
    \  *           register\n   */\n  using s3par = S3parReg<BaseAddress + 0x0060>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S3m0arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M0A field\n     *\n     * Memory\
    \ 0 address\n     */\n    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief M0A field\n       *\n       * Memory 0 address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> m0a;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S3M0AR register\n   *\n   * stream x memory 0 address\n  \
    \ *           register\n   */\n  using s3m0ar = S3m0arReg<BaseAddress + 0x0064>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S3m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M1A field\n     *\n     * Memory\
    \ 1 address (used in case of Double\n     *               buffer mode)\n     */\n\
    \    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ M1A field\n       *\n       * Memory 1 address (used in case of Double\n   \
    \    *               buffer mode)\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 32> m1a;\n    };\n  };\n\npublic:\n  /**\n   * @brief S3M1AR register\n   *\n\
    \   * stream x memory 1 address\n   *           register\n   */\n  using s3m1ar\
    \ = S3m1arReg<BaseAddress + 0x0068>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S3fcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief FEIE field\n     *\n     * FIFO error interrupt\n    \
    \ *               enable\n     */\n    using feie = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    /**\n     * @brief FS field\n     *\n     * FIFO status\n     */\n\
    \    using fs = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     * @brief DMDIS\
    \ field\n     *\n     * Direct mode disable\n     */\n    using dmdis = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief FTH field\n     *\n     * FIFO threshold\
    \ selection\n     */\n    using fth = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief FEIE field\n       *\n       * FIFO error\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> feie;\n      /**\n       * @brief FS field\n       *\n       * FIFO status\n\
    \       */\n      BitFieldModel<uint32_t, 3, 3> fs;\n      /**\n       * @brief\
    \ DMDIS field\n       *\n       * Direct mode disable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmdis;\n      /**\n       * @brief FTH field\n       *\n       * FIFO\
    \ threshold selection\n       */\n      BitFieldModel<uint32_t, 0, 2> fth;\n \
    \   };\n  };\n\npublic:\n  /**\n   * @brief S3FCR register\n   *\n   * stream\
    \ x FIFO control register\n   */\n  using s3fcr = S3fcrReg<BaseAddress + 0x006C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S4crReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CHSEL field\n     *\n     *\
    \ Channel selection\n     */\n    using chsel = FieldModel<uint32_t, address,\
    \ 25, 3>;\n    /**\n     * @brief MBURST field\n     *\n     * Memory burst transfer\n\
    \     *               configuration\n     */\n    using mburst = FieldModel<uint32_t,\
    \ address, 23, 2>;\n    /**\n     * @brief PBURST field\n     *\n     * Peripheral\
    \ burst transfer\n     *               configuration\n     */\n    using pburst\
    \ = FieldModel<uint32_t, address, 21, 2>;\n    /**\n     * @brief ACK field\n\
    \     *\n     * ACK\n     */\n    using ack = FieldModel<uint32_t, address, 20,\
    \ 1>;\n    /**\n     * @brief CT field\n     *\n     * Current target (only in\
    \ double buffer\n     *               mode)\n     */\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief DBM field\n     *\n     * Double buffer\
    \ mode\n     */\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n    /**\n\
    \     * @brief PL field\n     *\n     * Priority level\n     */\n    using pl\
    \ = FieldModel<uint32_t, address, 16, 2>;\n    /**\n     * @brief PINCOS field\n\
    \     *\n     * Peripheral increment offset\n     *               size\n     */\n\
    \    using pincos = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief\
    \ MSIZE field\n     *\n     * Memory data size\n     */\n    using msize = FieldModel<uint32_t,\
    \ address, 13, 2>;\n    /**\n     * @brief PSIZE field\n     *\n     * Peripheral\
    \ data size\n     */\n    using psize = FieldModel<uint32_t, address, 11, 2>;\n\
    \    /**\n     * @brief MINC field\n     *\n     * Memory increment mode\n   \
    \  */\n    using minc = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     *\
    \ @brief PINC field\n     *\n     * Peripheral increment mode\n     */\n    using\
    \ pinc = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief CIRC field\n\
    \     *\n     * Circular mode\n     */\n    using circ = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief DIR field\n     *\n     * Data transfer\
    \ direction\n     */\n    using dir = FieldModel<uint32_t, address, 6, 2>;\n \
    \   /**\n     * @brief PFCTRL field\n     *\n     * Peripheral flow controller\n\
    \     */\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n    /**\n \
    \    * @brief TCIE field\n     *\n     * Transfer complete interrupt\n     * \
    \              enable\n     */\n    using tcie = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief HTIE field\n     *\n     * Half transfer interrupt\n\
    \     *               enable\n     */\n    using htie = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief TEIE field\n     *\n     * Transfer error interrupt\n\
    \     *               enable\n     */\n    using teie = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief DMEIE field\n     *\n     * Direct mode error\
    \ interrupt\n     *               enable\n     */\n    using dmeie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief EN field\n     *\n     * Stream enable\
    \ / flag stream ready when\n     *               read low\n     */\n    using\
    \ en = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CHSEL field\n       *\n       * Channel selection\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 3> chsel;\n      /**\n       * @brief MBURST field\n       *\n       * Memory\
    \ burst transfer\n       *               configuration\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 2> mburst;\n      /**\n       * @brief PBURST field\n       *\n       *\
    \ Peripheral burst transfer\n       *               configuration\n       */\n\
    \      BitFieldModel<uint32_t, 21, 2> pburst;\n      /**\n       * @brief ACK\
    \ field\n       *\n       * ACK\n       */\n      BitFieldModel<uint32_t, 20,\
    \ 1> ack;\n      /**\n       * @brief CT field\n       *\n       * Current target\
    \ (only in double buffer\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      /**\n       * @brief DBM field\n       *\n       * Double\
    \ buffer mode\n       */\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      /**\n\
    \       * @brief PL field\n       *\n       * Priority level\n       */\n    \
    \  BitFieldModel<uint32_t, 16, 2> pl;\n      /**\n       * @brief PINCOS field\n\
    \       *\n       * Peripheral increment offset\n       *               size\n\
    \       */\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      /**\n       *\
    \ @brief MSIZE field\n       *\n       * Memory data size\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      /**\n       * @brief PSIZE field\n       *\n       * Peripheral\
    \ data size\n       */\n      BitFieldModel<uint32_t, 11, 2> psize;\n      /**\n\
    \       * @brief MINC field\n       *\n       * Memory increment mode\n      \
    \ */\n      BitFieldModel<uint32_t, 10, 1> minc;\n      /**\n       * @brief PINC\
    \ field\n       *\n       * Peripheral increment mode\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> pinc;\n      /**\n       * @brief CIRC field\n       *\n       * Circular\
    \ mode\n       */\n      BitFieldModel<uint32_t, 8, 1> circ;\n      /**\n    \
    \   * @brief DIR field\n       *\n       * Data transfer direction\n       */\n\
    \      BitFieldModel<uint32_t, 6, 2> dir;\n      /**\n       * @brief PFCTRL field\n\
    \       *\n       * Peripheral flow controller\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      /**\n       * @brief TCIE field\n       *\n       * Transfer\
    \ complete interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> tcie;\n      /**\n       * @brief HTIE field\n       *\n       * Half\
    \ transfer interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      /**\n       * @brief TEIE field\n       *\n       * Transfer\
    \ error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      /**\n       * @brief DMEIE field\n       *\n       * Direct\
    \ mode error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      /**\n       * @brief EN field\n       *\n       * Stream\
    \ enable / flag stream ready when\n       *               read low\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief S4CR register\n   *\n   * stream x configuration\n   *           register\n\
    \   */\n  using s4cr = S4crReg<BaseAddress + 0x0070>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S4ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief NDT field\n     *\n     * Number of data\
    \ items to\n     *               transfer\n     */\n    using ndt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief NDT field\n       *\n \
    \      * Number of data items to\n       *               transfer\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ndt;\n    };\n  };\n\npublic:\n  /**\n \
    \  * @brief S4NDTR register\n   *\n   * stream x number of data\n   *        \
    \   register\n   */\n  using s4ndtr = S4ndtrReg<BaseAddress + 0x0074>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class S4parReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief PA field\n     *\n     * Peripheral\
    \ address\n     */\n    using pa = FieldModel<uint32_t, address, 0, 32>;\n\n \
    \ public:\n    /**\n     * @brief Register union\n     *\n     * Can be used to\
    \ create a local register variable for easy bit manipulation.\n     * Useful for\
    \ read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief PA field\n       *\n       * Peripheral address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S4PAR register\n   *\n   * stream x peripheral address\n \
    \  *           register\n   */\n  using s4par = S4parReg<BaseAddress + 0x0078>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S4m0arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M0A field\n     *\n     * Memory\
    \ 0 address\n     */\n    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief M0A field\n       *\n       * Memory 0 address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> m0a;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S4M0AR register\n   *\n   * stream x memory 0 address\n  \
    \ *           register\n   */\n  using s4m0ar = S4m0arReg<BaseAddress + 0x007C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S4m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M1A field\n     *\n     * Memory\
    \ 1 address (used in case of Double\n     *               buffer mode)\n     */\n\
    \    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ M1A field\n       *\n       * Memory 1 address (used in case of Double\n   \
    \    *               buffer mode)\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 32> m1a;\n    };\n  };\n\npublic:\n  /**\n   * @brief S4M1AR register\n   *\n\
    \   * stream x memory 1 address\n   *           register\n   */\n  using s4m1ar\
    \ = S4m1arReg<BaseAddress + 0x0080>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S4fcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief FEIE field\n     *\n     * FIFO error interrupt\n    \
    \ *               enable\n     */\n    using feie = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    /**\n     * @brief FS field\n     *\n     * FIFO status\n     */\n\
    \    using fs = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     * @brief DMDIS\
    \ field\n     *\n     * Direct mode disable\n     */\n    using dmdis = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief FTH field\n     *\n     * FIFO threshold\
    \ selection\n     */\n    using fth = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief FEIE field\n       *\n       * FIFO error\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> feie;\n      /**\n       * @brief FS field\n       *\n       * FIFO status\n\
    \       */\n      BitFieldModel<uint32_t, 3, 3> fs;\n      /**\n       * @brief\
    \ DMDIS field\n       *\n       * Direct mode disable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmdis;\n      /**\n       * @brief FTH field\n       *\n       * FIFO\
    \ threshold selection\n       */\n      BitFieldModel<uint32_t, 0, 2> fth;\n \
    \   };\n  };\n\npublic:\n  /**\n   * @brief S4FCR register\n   *\n   * stream\
    \ x FIFO control register\n   */\n  using s4fcr = S4fcrReg<BaseAddress + 0x0084>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S5crReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CHSEL field\n     *\n     *\
    \ Channel selection\n     */\n    using chsel = FieldModel<uint32_t, address,\
    \ 25, 3>;\n    /**\n     * @brief MBURST field\n     *\n     * Memory burst transfer\n\
    \     *               configuration\n     */\n    using mburst = FieldModel<uint32_t,\
    \ address, 23, 2>;\n    /**\n     * @brief PBURST field\n     *\n     * Peripheral\
    \ burst transfer\n     *               configuration\n     */\n    using pburst\
    \ = FieldModel<uint32_t, address, 21, 2>;\n    /**\n     * @brief ACK field\n\
    \     *\n     * ACK\n     */\n    using ack = FieldModel<uint32_t, address, 20,\
    \ 1>;\n    /**\n     * @brief CT field\n     *\n     * Current target (only in\
    \ double buffer\n     *               mode)\n     */\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief DBM field\n     *\n     * Double buffer\
    \ mode\n     */\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n    /**\n\
    \     * @brief PL field\n     *\n     * Priority level\n     */\n    using pl\
    \ = FieldModel<uint32_t, address, 16, 2>;\n    /**\n     * @brief PINCOS field\n\
    \     *\n     * Peripheral increment offset\n     *               size\n     */\n\
    \    using pincos = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief\
    \ MSIZE field\n     *\n     * Memory data size\n     */\n    using msize = FieldModel<uint32_t,\
    \ address, 13, 2>;\n    /**\n     * @brief PSIZE field\n     *\n     * Peripheral\
    \ data size\n     */\n    using psize = FieldModel<uint32_t, address, 11, 2>;\n\
    \    /**\n     * @brief MINC field\n     *\n     * Memory increment mode\n   \
    \  */\n    using minc = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     *\
    \ @brief PINC field\n     *\n     * Peripheral increment mode\n     */\n    using\
    \ pinc = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief CIRC field\n\
    \     *\n     * Circular mode\n     */\n    using circ = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief DIR field\n     *\n     * Data transfer\
    \ direction\n     */\n    using dir = FieldModel<uint32_t, address, 6, 2>;\n \
    \   /**\n     * @brief PFCTRL field\n     *\n     * Peripheral flow controller\n\
    \     */\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n    /**\n \
    \    * @brief TCIE field\n     *\n     * Transfer complete interrupt\n     * \
    \              enable\n     */\n    using tcie = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief HTIE field\n     *\n     * Half transfer interrupt\n\
    \     *               enable\n     */\n    using htie = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief TEIE field\n     *\n     * Transfer error interrupt\n\
    \     *               enable\n     */\n    using teie = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief DMEIE field\n     *\n     * Direct mode error\
    \ interrupt\n     *               enable\n     */\n    using dmeie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief EN field\n     *\n     * Stream enable\
    \ / flag stream ready when\n     *               read low\n     */\n    using\
    \ en = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CHSEL field\n       *\n       * Channel selection\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 3> chsel;\n      /**\n       * @brief MBURST field\n       *\n       * Memory\
    \ burst transfer\n       *               configuration\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 2> mburst;\n      /**\n       * @brief PBURST field\n       *\n       *\
    \ Peripheral burst transfer\n       *               configuration\n       */\n\
    \      BitFieldModel<uint32_t, 21, 2> pburst;\n      /**\n       * @brief ACK\
    \ field\n       *\n       * ACK\n       */\n      BitFieldModel<uint32_t, 20,\
    \ 1> ack;\n      /**\n       * @brief CT field\n       *\n       * Current target\
    \ (only in double buffer\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      /**\n       * @brief DBM field\n       *\n       * Double\
    \ buffer mode\n       */\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      /**\n\
    \       * @brief PL field\n       *\n       * Priority level\n       */\n    \
    \  BitFieldModel<uint32_t, 16, 2> pl;\n      /**\n       * @brief PINCOS field\n\
    \       *\n       * Peripheral increment offset\n       *               size\n\
    \       */\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      /**\n       *\
    \ @brief MSIZE field\n       *\n       * Memory data size\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      /**\n       * @brief PSIZE field\n       *\n       * Peripheral\
    \ data size\n       */\n      BitFieldModel<uint32_t, 11, 2> psize;\n      /**\n\
    \       * @brief MINC field\n       *\n       * Memory increment mode\n      \
    \ */\n      BitFieldModel<uint32_t, 10, 1> minc;\n      /**\n       * @brief PINC\
    \ field\n       *\n       * Peripheral increment mode\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> pinc;\n      /**\n       * @brief CIRC field\n       *\n       * Circular\
    \ mode\n       */\n      BitFieldModel<uint32_t, 8, 1> circ;\n      /**\n    \
    \   * @brief DIR field\n       *\n       * Data transfer direction\n       */\n\
    \      BitFieldModel<uint32_t, 6, 2> dir;\n      /**\n       * @brief PFCTRL field\n\
    \       *\n       * Peripheral flow controller\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      /**\n       * @brief TCIE field\n       *\n       * Transfer\
    \ complete interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> tcie;\n      /**\n       * @brief HTIE field\n       *\n       * Half\
    \ transfer interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      /**\n       * @brief TEIE field\n       *\n       * Transfer\
    \ error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      /**\n       * @brief DMEIE field\n       *\n       * Direct\
    \ mode error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      /**\n       * @brief EN field\n       *\n       * Stream\
    \ enable / flag stream ready when\n       *               read low\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief S5CR register\n   *\n   * stream x configuration\n   *           register\n\
    \   */\n  using s5cr = S5crReg<BaseAddress + 0x0088>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S5ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief NDT field\n     *\n     * Number of data\
    \ items to\n     *               transfer\n     */\n    using ndt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief NDT field\n       *\n \
    \      * Number of data items to\n       *               transfer\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ndt;\n    };\n  };\n\npublic:\n  /**\n \
    \  * @brief S5NDTR register\n   *\n   * stream x number of data\n   *        \
    \   register\n   */\n  using s5ndtr = S5ndtrReg<BaseAddress + 0x008C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class S5parReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief PA field\n     *\n     * Peripheral\
    \ address\n     */\n    using pa = FieldModel<uint32_t, address, 0, 32>;\n\n \
    \ public:\n    /**\n     * @brief Register union\n     *\n     * Can be used to\
    \ create a local register variable for easy bit manipulation.\n     * Useful for\
    \ read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief PA field\n       *\n       * Peripheral address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S5PAR register\n   *\n   * stream x peripheral address\n \
    \  *           register\n   */\n  using s5par = S5parReg<BaseAddress + 0x0090>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S5m0arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M0A field\n     *\n     * Memory\
    \ 0 address\n     */\n    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief M0A field\n       *\n       * Memory 0 address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> m0a;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S5M0AR register\n   *\n   * stream x memory 0 address\n  \
    \ *           register\n   */\n  using s5m0ar = S5m0arReg<BaseAddress + 0x0094>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S5m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M1A field\n     *\n     * Memory\
    \ 1 address (used in case of Double\n     *               buffer mode)\n     */\n\
    \    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ M1A field\n       *\n       * Memory 1 address (used in case of Double\n   \
    \    *               buffer mode)\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 32> m1a;\n    };\n  };\n\npublic:\n  /**\n   * @brief S5M1AR register\n   *\n\
    \   * stream x memory 1 address\n   *           register\n   */\n  using s5m1ar\
    \ = S5m1arReg<BaseAddress + 0x0098>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S5fcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief FEIE field\n     *\n     * FIFO error interrupt\n    \
    \ *               enable\n     */\n    using feie = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    /**\n     * @brief FS field\n     *\n     * FIFO status\n     */\n\
    \    using fs = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     * @brief DMDIS\
    \ field\n     *\n     * Direct mode disable\n     */\n    using dmdis = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief FTH field\n     *\n     * FIFO threshold\
    \ selection\n     */\n    using fth = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief FEIE field\n       *\n       * FIFO error\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> feie;\n      /**\n       * @brief FS field\n       *\n       * FIFO status\n\
    \       */\n      BitFieldModel<uint32_t, 3, 3> fs;\n      /**\n       * @brief\
    \ DMDIS field\n       *\n       * Direct mode disable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmdis;\n      /**\n       * @brief FTH field\n       *\n       * FIFO\
    \ threshold selection\n       */\n      BitFieldModel<uint32_t, 0, 2> fth;\n \
    \   };\n  };\n\npublic:\n  /**\n   * @brief S5FCR register\n   *\n   * stream\
    \ x FIFO control register\n   */\n  using s5fcr = S5fcrReg<BaseAddress + 0x009C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S6crReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CHSEL field\n     *\n     *\
    \ Channel selection\n     */\n    using chsel = FieldModel<uint32_t, address,\
    \ 25, 3>;\n    /**\n     * @brief MBURST field\n     *\n     * Memory burst transfer\n\
    \     *               configuration\n     */\n    using mburst = FieldModel<uint32_t,\
    \ address, 23, 2>;\n    /**\n     * @brief PBURST field\n     *\n     * Peripheral\
    \ burst transfer\n     *               configuration\n     */\n    using pburst\
    \ = FieldModel<uint32_t, address, 21, 2>;\n    /**\n     * @brief ACK field\n\
    \     *\n     * ACK\n     */\n    using ack = FieldModel<uint32_t, address, 20,\
    \ 1>;\n    /**\n     * @brief CT field\n     *\n     * Current target (only in\
    \ double buffer\n     *               mode)\n     */\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief DBM field\n     *\n     * Double buffer\
    \ mode\n     */\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n    /**\n\
    \     * @brief PL field\n     *\n     * Priority level\n     */\n    using pl\
    \ = FieldModel<uint32_t, address, 16, 2>;\n    /**\n     * @brief PINCOS field\n\
    \     *\n     * Peripheral increment offset\n     *               size\n     */\n\
    \    using pincos = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief\
    \ MSIZE field\n     *\n     * Memory data size\n     */\n    using msize = FieldModel<uint32_t,\
    \ address, 13, 2>;\n    /**\n     * @brief PSIZE field\n     *\n     * Peripheral\
    \ data size\n     */\n    using psize = FieldModel<uint32_t, address, 11, 2>;\n\
    \    /**\n     * @brief MINC field\n     *\n     * Memory increment mode\n   \
    \  */\n    using minc = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     *\
    \ @brief PINC field\n     *\n     * Peripheral increment mode\n     */\n    using\
    \ pinc = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief CIRC field\n\
    \     *\n     * Circular mode\n     */\n    using circ = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief DIR field\n     *\n     * Data transfer\
    \ direction\n     */\n    using dir = FieldModel<uint32_t, address, 6, 2>;\n \
    \   /**\n     * @brief PFCTRL field\n     *\n     * Peripheral flow controller\n\
    \     */\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n    /**\n \
    \    * @brief TCIE field\n     *\n     * Transfer complete interrupt\n     * \
    \              enable\n     */\n    using tcie = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief HTIE field\n     *\n     * Half transfer interrupt\n\
    \     *               enable\n     */\n    using htie = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief TEIE field\n     *\n     * Transfer error interrupt\n\
    \     *               enable\n     */\n    using teie = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief DMEIE field\n     *\n     * Direct mode error\
    \ interrupt\n     *               enable\n     */\n    using dmeie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief EN field\n     *\n     * Stream enable\
    \ / flag stream ready when\n     *               read low\n     */\n    using\
    \ en = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CHSEL field\n       *\n       * Channel selection\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 3> chsel;\n      /**\n       * @brief MBURST field\n       *\n       * Memory\
    \ burst transfer\n       *               configuration\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 2> mburst;\n      /**\n       * @brief PBURST field\n       *\n       *\
    \ Peripheral burst transfer\n       *               configuration\n       */\n\
    \      BitFieldModel<uint32_t, 21, 2> pburst;\n      /**\n       * @brief ACK\
    \ field\n       *\n       * ACK\n       */\n      BitFieldModel<uint32_t, 20,\
    \ 1> ack;\n      /**\n       * @brief CT field\n       *\n       * Current target\
    \ (only in double buffer\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      /**\n       * @brief DBM field\n       *\n       * Double\
    \ buffer mode\n       */\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      /**\n\
    \       * @brief PL field\n       *\n       * Priority level\n       */\n    \
    \  BitFieldModel<uint32_t, 16, 2> pl;\n      /**\n       * @brief PINCOS field\n\
    \       *\n       * Peripheral increment offset\n       *               size\n\
    \       */\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      /**\n       *\
    \ @brief MSIZE field\n       *\n       * Memory data size\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      /**\n       * @brief PSIZE field\n       *\n       * Peripheral\
    \ data size\n       */\n      BitFieldModel<uint32_t, 11, 2> psize;\n      /**\n\
    \       * @brief MINC field\n       *\n       * Memory increment mode\n      \
    \ */\n      BitFieldModel<uint32_t, 10, 1> minc;\n      /**\n       * @brief PINC\
    \ field\n       *\n       * Peripheral increment mode\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> pinc;\n      /**\n       * @brief CIRC field\n       *\n       * Circular\
    \ mode\n       */\n      BitFieldModel<uint32_t, 8, 1> circ;\n      /**\n    \
    \   * @brief DIR field\n       *\n       * Data transfer direction\n       */\n\
    \      BitFieldModel<uint32_t, 6, 2> dir;\n      /**\n       * @brief PFCTRL field\n\
    \       *\n       * Peripheral flow controller\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      /**\n       * @brief TCIE field\n       *\n       * Transfer\
    \ complete interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> tcie;\n      /**\n       * @brief HTIE field\n       *\n       * Half\
    \ transfer interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      /**\n       * @brief TEIE field\n       *\n       * Transfer\
    \ error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      /**\n       * @brief DMEIE field\n       *\n       * Direct\
    \ mode error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      /**\n       * @brief EN field\n       *\n       * Stream\
    \ enable / flag stream ready when\n       *               read low\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief S6CR register\n   *\n   * stream x configuration\n   *           register\n\
    \   */\n  using s6cr = S6crReg<BaseAddress + 0x00A0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S6ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief NDT field\n     *\n     * Number of data\
    \ items to\n     *               transfer\n     */\n    using ndt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief NDT field\n       *\n \
    \      * Number of data items to\n       *               transfer\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ndt;\n    };\n  };\n\npublic:\n  /**\n \
    \  * @brief S6NDTR register\n   *\n   * stream x number of data\n   *        \
    \   register\n   */\n  using s6ndtr = S6ndtrReg<BaseAddress + 0x00A4>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class S6parReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief PA field\n     *\n     * Peripheral\
    \ address\n     */\n    using pa = FieldModel<uint32_t, address, 0, 32>;\n\n \
    \ public:\n    /**\n     * @brief Register union\n     *\n     * Can be used to\
    \ create a local register variable for easy bit manipulation.\n     * Useful for\
    \ read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief PA field\n       *\n       * Peripheral address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S6PAR register\n   *\n   * stream x peripheral address\n \
    \  *           register\n   */\n  using s6par = S6parReg<BaseAddress + 0x00A8>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S6m0arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M0A field\n     *\n     * Memory\
    \ 0 address\n     */\n    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief M0A field\n       *\n       * Memory 0 address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> m0a;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S6M0AR register\n   *\n   * stream x memory 0 address\n  \
    \ *           register\n   */\n  using s6m0ar = S6m0arReg<BaseAddress + 0x00AC>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S6m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M1A field\n     *\n     * Memory\
    \ 1 address (used in case of Double\n     *               buffer mode)\n     */\n\
    \    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ M1A field\n       *\n       * Memory 1 address (used in case of Double\n   \
    \    *               buffer mode)\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 32> m1a;\n    };\n  };\n\npublic:\n  /**\n   * @brief S6M1AR register\n   *\n\
    \   * stream x memory 1 address\n   *           register\n   */\n  using s6m1ar\
    \ = S6m1arReg<BaseAddress + 0x00B0>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S6fcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief FEIE field\n     *\n     * FIFO error interrupt\n    \
    \ *               enable\n     */\n    using feie = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    /**\n     * @brief FS field\n     *\n     * FIFO status\n     */\n\
    \    using fs = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     * @brief DMDIS\
    \ field\n     *\n     * Direct mode disable\n     */\n    using dmdis = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief FTH field\n     *\n     * FIFO threshold\
    \ selection\n     */\n    using fth = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief FEIE field\n       *\n       * FIFO error\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> feie;\n      /**\n       * @brief FS field\n       *\n       * FIFO status\n\
    \       */\n      BitFieldModel<uint32_t, 3, 3> fs;\n      /**\n       * @brief\
    \ DMDIS field\n       *\n       * Direct mode disable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmdis;\n      /**\n       * @brief FTH field\n       *\n       * FIFO\
    \ threshold selection\n       */\n      BitFieldModel<uint32_t, 0, 2> fth;\n \
    \   };\n  };\n\npublic:\n  /**\n   * @brief S6FCR register\n   *\n   * stream\
    \ x FIFO control register\n   */\n  using s6fcr = S6fcrReg<BaseAddress + 0x00B4>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S7crReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CHSEL field\n     *\n     *\
    \ Channel selection\n     */\n    using chsel = FieldModel<uint32_t, address,\
    \ 25, 3>;\n    /**\n     * @brief MBURST field\n     *\n     * Memory burst transfer\n\
    \     *               configuration\n     */\n    using mburst = FieldModel<uint32_t,\
    \ address, 23, 2>;\n    /**\n     * @brief PBURST field\n     *\n     * Peripheral\
    \ burst transfer\n     *               configuration\n     */\n    using pburst\
    \ = FieldModel<uint32_t, address, 21, 2>;\n    /**\n     * @brief ACK field\n\
    \     *\n     * ACK\n     */\n    using ack = FieldModel<uint32_t, address, 20,\
    \ 1>;\n    /**\n     * @brief CT field\n     *\n     * Current target (only in\
    \ double buffer\n     *               mode)\n     */\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief DBM field\n     *\n     * Double buffer\
    \ mode\n     */\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n    /**\n\
    \     * @brief PL field\n     *\n     * Priority level\n     */\n    using pl\
    \ = FieldModel<uint32_t, address, 16, 2>;\n    /**\n     * @brief PINCOS field\n\
    \     *\n     * Peripheral increment offset\n     *               size\n     */\n\
    \    using pincos = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief\
    \ MSIZE field\n     *\n     * Memory data size\n     */\n    using msize = FieldModel<uint32_t,\
    \ address, 13, 2>;\n    /**\n     * @brief PSIZE field\n     *\n     * Peripheral\
    \ data size\n     */\n    using psize = FieldModel<uint32_t, address, 11, 2>;\n\
    \    /**\n     * @brief MINC field\n     *\n     * Memory increment mode\n   \
    \  */\n    using minc = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     *\
    \ @brief PINC field\n     *\n     * Peripheral increment mode\n     */\n    using\
    \ pinc = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief CIRC field\n\
    \     *\n     * Circular mode\n     */\n    using circ = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief DIR field\n     *\n     * Data transfer\
    \ direction\n     */\n    using dir = FieldModel<uint32_t, address, 6, 2>;\n \
    \   /**\n     * @brief PFCTRL field\n     *\n     * Peripheral flow controller\n\
    \     */\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n    /**\n \
    \    * @brief TCIE field\n     *\n     * Transfer complete interrupt\n     * \
    \              enable\n     */\n    using tcie = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief HTIE field\n     *\n     * Half transfer interrupt\n\
    \     *               enable\n     */\n    using htie = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief TEIE field\n     *\n     * Transfer error interrupt\n\
    \     *               enable\n     */\n    using teie = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief DMEIE field\n     *\n     * Direct mode error\
    \ interrupt\n     *               enable\n     */\n    using dmeie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief EN field\n     *\n     * Stream enable\
    \ / flag stream ready when\n     *               read low\n     */\n    using\
    \ en = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CHSEL field\n       *\n       * Channel selection\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 3> chsel;\n      /**\n       * @brief MBURST field\n       *\n       * Memory\
    \ burst transfer\n       *               configuration\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 2> mburst;\n      /**\n       * @brief PBURST field\n       *\n       *\
    \ Peripheral burst transfer\n       *               configuration\n       */\n\
    \      BitFieldModel<uint32_t, 21, 2> pburst;\n      /**\n       * @brief ACK\
    \ field\n       *\n       * ACK\n       */\n      BitFieldModel<uint32_t, 20,\
    \ 1> ack;\n      /**\n       * @brief CT field\n       *\n       * Current target\
    \ (only in double buffer\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      /**\n       * @brief DBM field\n       *\n       * Double\
    \ buffer mode\n       */\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      /**\n\
    \       * @brief PL field\n       *\n       * Priority level\n       */\n    \
    \  BitFieldModel<uint32_t, 16, 2> pl;\n      /**\n       * @brief PINCOS field\n\
    \       *\n       * Peripheral increment offset\n       *               size\n\
    \       */\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      /**\n       *\
    \ @brief MSIZE field\n       *\n       * Memory data size\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      /**\n       * @brief PSIZE field\n       *\n       * Peripheral\
    \ data size\n       */\n      BitFieldModel<uint32_t, 11, 2> psize;\n      /**\n\
    \       * @brief MINC field\n       *\n       * Memory increment mode\n      \
    \ */\n      BitFieldModel<uint32_t, 10, 1> minc;\n      /**\n       * @brief PINC\
    \ field\n       *\n       * Peripheral increment mode\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> pinc;\n      /**\n       * @brief CIRC field\n       *\n       * Circular\
    \ mode\n       */\n      BitFieldModel<uint32_t, 8, 1> circ;\n      /**\n    \
    \   * @brief DIR field\n       *\n       * Data transfer direction\n       */\n\
    \      BitFieldModel<uint32_t, 6, 2> dir;\n      /**\n       * @brief PFCTRL field\n\
    \       *\n       * Peripheral flow controller\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      /**\n       * @brief TCIE field\n       *\n       * Transfer\
    \ complete interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> tcie;\n      /**\n       * @brief HTIE field\n       *\n       * Half\
    \ transfer interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      /**\n       * @brief TEIE field\n       *\n       * Transfer\
    \ error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      /**\n       * @brief DMEIE field\n       *\n       * Direct\
    \ mode error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      /**\n       * @brief EN field\n       *\n       * Stream\
    \ enable / flag stream ready when\n       *               read low\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief S7CR register\n   *\n   * stream x configuration\n   *           register\n\
    \   */\n  using s7cr = S7crReg<BaseAddress + 0x00B8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S7ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief NDT field\n     *\n     * Number of data\
    \ items to\n     *               transfer\n     */\n    using ndt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief NDT field\n       *\n \
    \      * Number of data items to\n       *               transfer\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ndt;\n    };\n  };\n\npublic:\n  /**\n \
    \  * @brief S7NDTR register\n   *\n   * stream x number of data\n   *        \
    \   register\n   */\n  using s7ndtr = S7ndtrReg<BaseAddress + 0x00BC>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class S7parReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief PA field\n     *\n     * Peripheral\
    \ address\n     */\n    using pa = FieldModel<uint32_t, address, 0, 32>;\n\n \
    \ public:\n    /**\n     * @brief Register union\n     *\n     * Can be used to\
    \ create a local register variable for easy bit manipulation.\n     * Useful for\
    \ read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief PA field\n       *\n       * Peripheral address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S7PAR register\n   *\n   * stream x peripheral address\n \
    \  *           register\n   */\n  using s7par = S7parReg<BaseAddress + 0x00C0>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S7m0arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M0A field\n     *\n     * Memory\
    \ 0 address\n     */\n    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief M0A field\n       *\n       * Memory 0 address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> m0a;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S7M0AR register\n   *\n   * stream x memory 0 address\n  \
    \ *           register\n   */\n  using s7m0ar = S7m0arReg<BaseAddress + 0x00C4>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S7m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M1A field\n     *\n     * Memory\
    \ 1 address (used in case of Double\n     *               buffer mode)\n     */\n\
    \    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ M1A field\n       *\n       * Memory 1 address (used in case of Double\n   \
    \    *               buffer mode)\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 32> m1a;\n    };\n  };\n\npublic:\n  /**\n   * @brief S7M1AR register\n   *\n\
    \   * stream x memory 1 address\n   *           register\n   */\n  using s7m1ar\
    \ = S7m1arReg<BaseAddress + 0x00C8>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S7fcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief FEIE field\n     *\n     * FIFO error interrupt\n    \
    \ *               enable\n     */\n    using feie = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    /**\n     * @brief FS field\n     *\n     * FIFO status\n     */\n\
    \    using fs = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     * @brief DMDIS\
    \ field\n     *\n     * Direct mode disable\n     */\n    using dmdis = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief FTH field\n     *\n     * FIFO threshold\
    \ selection\n     */\n    using fth = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief FEIE field\n       *\n       * FIFO error\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> feie;\n      /**\n       * @brief FS field\n       *\n       * FIFO status\n\
    \       */\n      BitFieldModel<uint32_t, 3, 3> fs;\n      /**\n       * @brief\
    \ DMDIS field\n       *\n       * Direct mode disable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmdis;\n      /**\n       * @brief FTH field\n       *\n       * FIFO\
    \ threshold selection\n       */\n      BitFieldModel<uint32_t, 0, 2> fth;\n \
    \   };\n  };\n\npublic:\n  /**\n   * @brief S7FCR register\n   *\n   * stream\
    \ x FIFO control register\n   */\n  using s7fcr = S7fcrReg<BaseAddress + 0x00CC>;\n\
    \nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n  class\
    \ SxndtrBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n\
    \  public:\n    /**\n     * @brief NDT field\n     *\n     * Number of data items\
    \ to\n     *               transfer\n     */\n    using ndt = FieldModel<uint32_t,\
    \ address, 0, 16, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief NDT field\n       *\n       * Number of data\
    \ items to\n       *               transfer\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> ndt;\n    };\n  };\n\npublic:\n  /**\n   * @brief SXNDTR register bank\n\
    \   *\n   * stream x number of data\n   *           register\n   */\n  using sxndtr\
    \ = SxndtrBankReg<BaseAddress + 0x0014, 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class SxparBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    /**\n     * @brief PA field\n    \
    \ *\n     * Peripheral address\n     */\n    using pa = FieldModel<uint32_t, address,\
    \ 0, 32, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      /**\n       * @brief PA field\n       *\n       * Peripheral address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief SXPAR register bank\n   *\n   * stream x peripheral address\n\
    \   *           register\n   */\n  using sxpar = SxparBankReg<BaseAddress + 0x0018,\
    \ 0x0018>;\n\nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n\
    \  class Sxm0arBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n\
    \  {\n  public:\n    /**\n     * @brief M0A field\n     *\n     * Memory 0 address\n\
    \     */\n    using m0a = FieldModel<uint32_t, address, 0, 32, bankOffset>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ M0A field\n       *\n       * Memory 0 address\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> m0a;\n    };\n  };\n\npublic:\n  /**\n   * @brief SXM0AR register bank\n\
    \   *\n   * stream x memory 0 address\n   *           register\n   */\n  using\
    \ sxm0ar = Sxm0arBankReg<BaseAddress + 0x001C, 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class Sxm1arBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    /**\n     * @brief M1A field\n   \
    \  *\n     * Memory 1 address (used in case of Double\n     *               buffer\
    \ mode)\n     */\n    using m1a = FieldModel<uint32_t, address, 0, 32, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      /**\n       *\
    \ @brief M1A field\n       *\n       * Memory 1 address (used in case of Double\n\
    \       *               buffer mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> m1a;\n    };\n  };\n\npublic:\n  /**\n   * @brief SXM1AR register bank\n\
    \   *\n   * stream x memory 1 address\n   *           register\n   */\n  using\
    \ sxm1ar = Sxm1arBankReg<BaseAddress + 0x0020, 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class SxfcrBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    /**\n     * @brief FEIE field\n  \
    \   *\n     * FIFO error interrupt\n     *               enable\n     */\n   \
    \ using feie = FieldModel<uint32_t, address, 7, 1, bankOffset>;\n    /**\n   \
    \  * @brief FS field\n     *\n     * FIFO status\n     */\n    using fs = FieldModel<uint32_t,\
    \ address, 3, 3, bankOffset>;\n    /**\n     * @brief DMDIS field\n     *\n  \
    \   * Direct mode disable\n     */\n    using dmdis = FieldModel<uint32_t, address,\
    \ 2, 1, bankOffset>;\n    /**\n     * @brief FTH field\n     *\n     * FIFO threshold\
    \ selection\n     */\n    using fth = FieldModel<uint32_t, address, 0, 2, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      /**\n       *\
    \ @brief FEIE field\n       *\n       * FIFO error interrupt\n       *       \
    \        enable\n       */\n      BitFieldModel<uint32_t, 7, 1> feie;\n      /**\n\
    \       * @brief FS field\n       *\n       * FIFO status\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 3> fs;\n      /**\n       * @brief DMDIS field\n       *\n       * Direct\
    \ mode disable\n       */\n      BitFieldModel<uint32_t, 2, 1> dmdis;\n      /**\n\
    \       * @brief FTH field\n       *\n       * FIFO threshold selection\n    \
    \   */\n      BitFieldModel<uint32_t, 0, 2> fth;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief SXFCR register bank\n   *\n   * stream x FIFO control register\n\
    \   */\n  using sxfcr = SxfcrBankReg<BaseAddress + 0x0024, 0x0018>;\n\nprivate:\n\
    \  template<unsigned int address, unsigned int bankOffset>\n  class SxcrBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    /**\n     * @brief CHSEL field\n     *\n     * Channel selection\n     */\n\
    \    using chsel = FieldModel<uint32_t, address, 25, 3, bankOffset>;\n    /**\n\
    \     * @brief MBURST field\n     *\n     * Memory burst transfer\n     *    \
    \           configuration\n     */\n    using mburst = FieldModel<uint32_t, address,\
    \ 23, 2, bankOffset>;\n    /**\n     * @brief PBURST field\n     *\n     * Peripheral\
    \ burst transfer\n     *               configuration\n     */\n    using pburst\
    \ = FieldModel<uint32_t, address, 21, 2, bankOffset>;\n    /**\n     * @brief\
    \ ACK field\n     *\n     * ACK\n     */\n    using ack = FieldModel<uint32_t,\
    \ address, 20, 1, bankOffset>;\n    /**\n     * @brief CT field\n     *\n    \
    \ * Current target (only in double buffer\n     *               mode)\n     */\n\
    \    using ct = FieldModel<uint32_t, address, 19, 1, bankOffset>;\n    /**\n \
    \    * @brief DBM field\n     *\n     * Double buffer mode\n     */\n    using\
    \ dbm = FieldModel<uint32_t, address, 18, 1, bankOffset>;\n    /**\n     * @brief\
    \ PL field\n     *\n     * Priority level\n     */\n    using pl = FieldModel<uint32_t,\
    \ address, 16, 2, bankOffset>;\n    /**\n     * @brief PINCOS field\n     *\n\
    \     * Peripheral increment offset\n     *               size\n     */\n    using\
    \ pincos = FieldModel<uint32_t, address, 15, 1, bankOffset>;\n    /**\n     *\
    \ @brief MSIZE field\n     *\n     * Memory data size\n     */\n    using msize\
    \ = FieldModel<uint32_t, address, 13, 2, bankOffset>;\n    /**\n     * @brief\
    \ PSIZE field\n     *\n     * Peripheral data size\n     */\n    using psize =\
    \ FieldModel<uint32_t, address, 11, 2, bankOffset>;\n    /**\n     * @brief MINC\
    \ field\n     *\n     * Memory increment mode\n     */\n    using minc = FieldModel<uint32_t,\
    \ address, 10, 1, bankOffset>;\n    /**\n     * @brief PINC field\n     *\n  \
    \   * Peripheral increment mode\n     */\n    using pinc = FieldModel<uint32_t,\
    \ address, 9, 1, bankOffset>;\n    /**\n     * @brief CIRC field\n     *\n   \
    \  * Circular mode\n     */\n    using circ = FieldModel<uint32_t, address, 8,\
    \ 1, bankOffset>;\n    /**\n     * @brief DIR field\n     *\n     * Data transfer\
    \ direction\n     */\n    using dir = FieldModel<uint32_t, address, 6, 2, bankOffset>;\n\
    \    /**\n     * @brief PFCTRL field\n     *\n     * Peripheral flow controller\n\
    \     */\n    using pfctrl = FieldModel<uint32_t, address, 5, 1, bankOffset>;\n\
    \    /**\n     * @brief TCIE field\n     *\n     * Transfer complete interrupt\n\
    \     *               enable\n     */\n    using tcie = FieldModel<uint32_t, address,\
    \ 4, 1, bankOffset>;\n    /**\n     * @brief HTIE field\n     *\n     * Half transfer\
    \ interrupt\n     *               enable\n     */\n    using htie = FieldModel<uint32_t,\
    \ address, 3, 1, bankOffset>;\n    /**\n     * @brief TEIE field\n     *\n   \
    \  * Transfer error interrupt\n     *               enable\n     */\n    using\
    \ teie = FieldModel<uint32_t, address, 2, 1, bankOffset>;\n    /**\n     * @brief\
    \ DMEIE field\n     *\n     * Direct mode error interrupt\n     *            \
    \   enable\n     */\n    using dmeie = FieldModel<uint32_t, address, 1, 1, bankOffset>;\n\
    \    /**\n     * @brief EN field\n     *\n     * Stream enable / flag stream ready\
    \ when\n     *               read low\n     */\n    using en = FieldModel<uint32_t,\
    \ address, 0, 1, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief CHSEL field\n       *\n       * Channel selection\n\
    \       */\n      BitFieldModel<uint32_t, 25, 3> chsel;\n      /**\n       * @brief\
    \ MBURST field\n       *\n       * Memory burst transfer\n       *           \
    \    configuration\n       */\n      BitFieldModel<uint32_t, 23, 2> mburst;\n\
    \      /**\n       * @brief PBURST field\n       *\n       * Peripheral burst\
    \ transfer\n       *               configuration\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 2> pburst;\n      /**\n       * @brief ACK field\n       *\n       * ACK\n\
    \       */\n      BitFieldModel<uint32_t, 20, 1> ack;\n      /**\n       * @brief\
    \ CT field\n       *\n       * Current target (only in double buffer\n       *\
    \               mode)\n       */\n      BitFieldModel<uint32_t, 19, 1> ct;\n \
    \     /**\n       * @brief DBM field\n       *\n       * Double buffer mode\n\
    \       */\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      /**\n       * @brief\
    \ PL field\n       *\n       * Priority level\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 2> pl;\n      /**\n       * @brief PINCOS field\n       *\n       * Peripheral\
    \ increment offset\n       *               size\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> pincos;\n      /**\n       * @brief MSIZE field\n       *\n       * Memory\
    \ data size\n       */\n      BitFieldModel<uint32_t, 13, 2> msize;\n      /**\n\
    \       * @brief PSIZE field\n       *\n       * Peripheral data size\n      \
    \ */\n      BitFieldModel<uint32_t, 11, 2> psize;\n      /**\n       * @brief\
    \ MINC field\n       *\n       * Memory increment mode\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> minc;\n      /**\n       * @brief PINC field\n       *\n       * Peripheral\
    \ increment mode\n       */\n      BitFieldModel<uint32_t, 9, 1> pinc;\n     \
    \ /**\n       * @brief CIRC field\n       *\n       * Circular mode\n       */\n\
    \      BitFieldModel<uint32_t, 8, 1> circ;\n      /**\n       * @brief DIR field\n\
    \       *\n       * Data transfer direction\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 2> dir;\n      /**\n       * @brief PFCTRL field\n       *\n       * Peripheral\
    \ flow controller\n       */\n      BitFieldModel<uint32_t, 5, 1> pfctrl;\n  \
    \    /**\n       * @brief TCIE field\n       *\n       * Transfer complete interrupt\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 4, 1>\
    \ tcie;\n      /**\n       * @brief HTIE field\n       *\n       * Half transfer\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      /**\n       * @brief TEIE field\n       *\n       * Transfer\
    \ error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      /**\n       * @brief DMEIE field\n       *\n       * Direct\
    \ mode error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      /**\n       * @brief EN field\n       *\n       * Stream\
    \ enable / flag stream ready when\n       *               read low\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief SXCR register bank\n   *\n   * stream x configuration\n   *         \
    \  register\n   */\n  using sxcr = SxcrBankReg<BaseAddress + 0x0028, 0x0018>;\n\
    \n};\n\n}\n\n#endif /* DRAL_STM32F411_DMA2_H */"
  name: DMA2
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_DMA1_H\n#define DRAL_STM32F411_DMA1_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ DMA1 peripheral\n *\n * DMA controller\n */\nclass dma1\n{\npublic:\n  static\
    \ constexpr unsigned int BaseAddress = 0x40026000; /**< Peripheral base address\
    \ */\n\nprivate:\n  template<unsigned int address>\n  class LisrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief TCIF3 field\n     *\n     *\
    \ Stream x transfer complete interrupt\n     *               flag (x = 3..0)\n\
    \     */\n    using tcif3 = FieldModel<uint32_t, address, 27, 1>;\n    /**\n \
    \    * @brief HTIF3 field\n     *\n     * Stream x half transfer interrupt flag\n\
    \     *               (x=3..0)\n     */\n    using htif3 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    /**\n     * @brief TEIF3 field\n     *\n     * Stream\
    \ x transfer error interrupt flag\n     *               (x=3..0)\n     */\n  \
    \  using teif3 = FieldModel<uint32_t, address, 25, 1>;\n    /**\n     * @brief\
    \ DMEIF3 field\n     *\n     * Stream x direct mode error interrupt\n     *  \
    \             flag (x=3..0)\n     */\n    using dmeif3 = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    /**\n     * @brief FEIF3 field\n     *\n     * Stream\
    \ x FIFO error interrupt flag\n     *               (x=3..0)\n     */\n    using\
    \ feif3 = FieldModel<uint32_t, address, 22, 1>;\n    /**\n     * @brief TCIF2\
    \ field\n     *\n     * Stream x transfer complete interrupt\n     *         \
    \      flag (x = 3..0)\n     */\n    using tcif2 = FieldModel<uint32_t, address,\
    \ 21, 1>;\n    /**\n     * @brief HTIF2 field\n     *\n     * Stream x half transfer\
    \ interrupt flag\n     *               (x=3..0)\n     */\n    using htif2 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief TEIF2 field\n     *\n     * Stream\
    \ x transfer error interrupt flag\n     *               (x=3..0)\n     */\n  \
    \  using teif2 = FieldModel<uint32_t, address, 19, 1>;\n    /**\n     * @brief\
    \ DMEIF2 field\n     *\n     * Stream x direct mode error interrupt\n     *  \
    \             flag (x=3..0)\n     */\n    using dmeif2 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    /**\n     * @brief FEIF2 field\n     *\n     * Stream\
    \ x FIFO error interrupt flag\n     *               (x=3..0)\n     */\n    using\
    \ feif2 = FieldModel<uint32_t, address, 16, 1>;\n    /**\n     * @brief TCIF1\
    \ field\n     *\n     * Stream x transfer complete interrupt\n     *         \
    \      flag (x = 3..0)\n     */\n    using tcif1 = FieldModel<uint32_t, address,\
    \ 11, 1>;\n    /**\n     * @brief HTIF1 field\n     *\n     * Stream x half transfer\
    \ interrupt flag\n     *               (x=3..0)\n     */\n    using htif1 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief TEIF1 field\n     *\n     * Stream\
    \ x transfer error interrupt flag\n     *               (x=3..0)\n     */\n  \
    \  using teif1 = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief\
    \ DMEIF1 field\n     *\n     * Stream x direct mode error interrupt\n     *  \
    \             flag (x=3..0)\n     */\n    using dmeif1 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief FEIF1 field\n     *\n     * Stream x\
    \ FIFO error interrupt flag\n     *               (x=3..0)\n     */\n    using\
    \ feif1 = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief TCIF0 field\n\
    \     *\n     * Stream x transfer complete interrupt\n     *               flag\
    \ (x = 3..0)\n     */\n    using tcif0 = FieldModel<uint32_t, address, 5, 1>;\n\
    \    /**\n     * @brief HTIF0 field\n     *\n     * Stream x half transfer interrupt\
    \ flag\n     *               (x=3..0)\n     */\n    using htif0 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief TEIF0 field\n     *\n     * Stream x\
    \ transfer error interrupt flag\n     *               (x=3..0)\n     */\n    using\
    \ teif0 = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief DMEIF0\
    \ field\n     *\n     * Stream x direct mode error interrupt\n     *         \
    \      flag (x=3..0)\n     */\n    using dmeif0 = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief FEIF0 field\n     *\n     * Stream x FIFO error\
    \ interrupt flag\n     *               (x=3..0)\n     */\n    using feif0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief TCIF3 field\n       *\n\
    \       * Stream x transfer complete interrupt\n       *               flag (x\
    \ = 3..0)\n       */\n      BitFieldModel<uint32_t, 27, 1> tcif3;\n      /**\n\
    \       * @brief HTIF3 field\n       *\n       * Stream x half transfer interrupt\
    \ flag\n       *               (x=3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 26, 1> htif3;\n      /**\n       * @brief TEIF3 field\n       *\n       * Stream\
    \ x transfer error interrupt flag\n       *               (x=3..0)\n       */\n\
    \      BitFieldModel<uint32_t, 25, 1> teif3;\n      /**\n       * @brief DMEIF3\
    \ field\n       *\n       * Stream x direct mode error interrupt\n       *   \
    \            flag (x=3..0)\n       */\n      BitFieldModel<uint32_t, 24, 1> dmeif3;\n\
    \      /**\n       * @brief FEIF3 field\n       *\n       * Stream x FIFO error\
    \ interrupt flag\n       *               (x=3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> feif3;\n      /**\n       * @brief TCIF2 field\n       *\n       * Stream\
    \ x transfer complete interrupt\n       *               flag (x = 3..0)\n    \
    \   */\n      BitFieldModel<uint32_t, 21, 1> tcif2;\n      /**\n       * @brief\
    \ HTIF2 field\n       *\n       * Stream x half transfer interrupt flag\n    \
    \   *               (x=3..0)\n       */\n      BitFieldModel<uint32_t, 20, 1>\
    \ htif2;\n      /**\n       * @brief TEIF2 field\n       *\n       * Stream x\
    \ transfer error interrupt flag\n       *               (x=3..0)\n       */\n\
    \      BitFieldModel<uint32_t, 19, 1> teif2;\n      /**\n       * @brief DMEIF2\
    \ field\n       *\n       * Stream x direct mode error interrupt\n       *   \
    \            flag (x=3..0)\n       */\n      BitFieldModel<uint32_t, 18, 1> dmeif2;\n\
    \      /**\n       * @brief FEIF2 field\n       *\n       * Stream x FIFO error\
    \ interrupt flag\n       *               (x=3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> feif2;\n      /**\n       * @brief TCIF1 field\n       *\n       * Stream\
    \ x transfer complete interrupt\n       *               flag (x = 3..0)\n    \
    \   */\n      BitFieldModel<uint32_t, 11, 1> tcif1;\n      /**\n       * @brief\
    \ HTIF1 field\n       *\n       * Stream x half transfer interrupt flag\n    \
    \   *               (x=3..0)\n       */\n      BitFieldModel<uint32_t, 10, 1>\
    \ htif1;\n      /**\n       * @brief TEIF1 field\n       *\n       * Stream x\
    \ transfer error interrupt flag\n       *               (x=3..0)\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> teif1;\n      /**\n       * @brief DMEIF1\
    \ field\n       *\n       * Stream x direct mode error interrupt\n       *   \
    \            flag (x=3..0)\n       */\n      BitFieldModel<uint32_t, 8, 1> dmeif1;\n\
    \      /**\n       * @brief FEIF1 field\n       *\n       * Stream x FIFO error\
    \ interrupt flag\n       *               (x=3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> feif1;\n      /**\n       * @brief TCIF0 field\n       *\n       * Stream\
    \ x transfer complete interrupt\n       *               flag (x = 3..0)\n    \
    \   */\n      BitFieldModel<uint32_t, 5, 1> tcif0;\n      /**\n       * @brief\
    \ HTIF0 field\n       *\n       * Stream x half transfer interrupt flag\n    \
    \   *               (x=3..0)\n       */\n      BitFieldModel<uint32_t, 4, 1> htif0;\n\
    \      /**\n       * @brief TEIF0 field\n       *\n       * Stream x transfer\
    \ error interrupt flag\n       *               (x=3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> teif0;\n      /**\n       * @brief DMEIF0 field\n       *\n       * Stream\
    \ x direct mode error interrupt\n       *               flag (x=3..0)\n      \
    \ */\n      BitFieldModel<uint32_t, 2, 1> dmeif0;\n      /**\n       * @brief\
    \ FEIF0 field\n       *\n       * Stream x FIFO error interrupt flag\n       *\
    \               (x=3..0)\n       */\n      BitFieldModel<uint32_t, 0, 1> feif0;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief LISR register\n   *\n   * low interrupt\
    \ status register\n   */\n  using lisr = LisrReg<BaseAddress + 0x0000>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class HisrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief TCIF7 field\n     *\n     *\
    \ Stream x transfer complete interrupt\n     *               flag (x=7..4)\n \
    \    */\n    using tcif7 = FieldModel<uint32_t, address, 27, 1>;\n    /**\n  \
    \   * @brief HTIF7 field\n     *\n     * Stream x half transfer interrupt flag\n\
    \     *               (x=7..4)\n     */\n    using htif7 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    /**\n     * @brief TEIF7 field\n     *\n     * Stream\
    \ x transfer error interrupt flag\n     *               (x=7..4)\n     */\n  \
    \  using teif7 = FieldModel<uint32_t, address, 25, 1>;\n    /**\n     * @brief\
    \ DMEIF7 field\n     *\n     * Stream x direct mode error interrupt\n     *  \
    \             flag (x=7..4)\n     */\n    using dmeif7 = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    /**\n     * @brief FEIF7 field\n     *\n     * Stream\
    \ x FIFO error interrupt flag\n     *               (x=7..4)\n     */\n    using\
    \ feif7 = FieldModel<uint32_t, address, 22, 1>;\n    /**\n     * @brief TCIF6\
    \ field\n     *\n     * Stream x transfer complete interrupt\n     *         \
    \      flag (x=7..4)\n     */\n    using tcif6 = FieldModel<uint32_t, address,\
    \ 21, 1>;\n    /**\n     * @brief HTIF6 field\n     *\n     * Stream x half transfer\
    \ interrupt flag\n     *               (x=7..4)\n     */\n    using htif6 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief TEIF6 field\n     *\n     * Stream\
    \ x transfer error interrupt flag\n     *               (x=7..4)\n     */\n  \
    \  using teif6 = FieldModel<uint32_t, address, 19, 1>;\n    /**\n     * @brief\
    \ DMEIF6 field\n     *\n     * Stream x direct mode error interrupt\n     *  \
    \             flag (x=7..4)\n     */\n    using dmeif6 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    /**\n     * @brief FEIF6 field\n     *\n     * Stream\
    \ x FIFO error interrupt flag\n     *               (x=7..4)\n     */\n    using\
    \ feif6 = FieldModel<uint32_t, address, 16, 1>;\n    /**\n     * @brief TCIF5\
    \ field\n     *\n     * Stream x transfer complete interrupt\n     *         \
    \      flag (x=7..4)\n     */\n    using tcif5 = FieldModel<uint32_t, address,\
    \ 11, 1>;\n    /**\n     * @brief HTIF5 field\n     *\n     * Stream x half transfer\
    \ interrupt flag\n     *               (x=7..4)\n     */\n    using htif5 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief TEIF5 field\n     *\n     * Stream\
    \ x transfer error interrupt flag\n     *               (x=7..4)\n     */\n  \
    \  using teif5 = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief\
    \ DMEIF5 field\n     *\n     * Stream x direct mode error interrupt\n     *  \
    \             flag (x=7..4)\n     */\n    using dmeif5 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief FEIF5 field\n     *\n     * Stream x\
    \ FIFO error interrupt flag\n     *               (x=7..4)\n     */\n    using\
    \ feif5 = FieldModel<uint32_t, address, 6, 1>;\n    /**\n     * @brief TCIF4 field\n\
    \     *\n     * Stream x transfer complete interrupt\n     *               flag\
    \ (x=7..4)\n     */\n    using tcif4 = FieldModel<uint32_t, address, 5, 1>;\n\
    \    /**\n     * @brief HTIF4 field\n     *\n     * Stream x half transfer interrupt\
    \ flag\n     *               (x=7..4)\n     */\n    using htif4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief TEIF4 field\n     *\n     * Stream x\
    \ transfer error interrupt flag\n     *               (x=7..4)\n     */\n    using\
    \ teif4 = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief DMEIF4\
    \ field\n     *\n     * Stream x direct mode error interrupt\n     *         \
    \      flag (x=7..4)\n     */\n    using dmeif4 = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief FEIF4 field\n     *\n     * Stream x FIFO error\
    \ interrupt flag\n     *               (x=7..4)\n     */\n    using feif4 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief TCIF7 field\n       *\n\
    \       * Stream x transfer complete interrupt\n       *               flag (x=7..4)\n\
    \       */\n      BitFieldModel<uint32_t, 27, 1> tcif7;\n      /**\n       * @brief\
    \ HTIF7 field\n       *\n       * Stream x half transfer interrupt flag\n    \
    \   *               (x=7..4)\n       */\n      BitFieldModel<uint32_t, 26, 1>\
    \ htif7;\n      /**\n       * @brief TEIF7 field\n       *\n       * Stream x\
    \ transfer error interrupt flag\n       *               (x=7..4)\n       */\n\
    \      BitFieldModel<uint32_t, 25, 1> teif7;\n      /**\n       * @brief DMEIF7\
    \ field\n       *\n       * Stream x direct mode error interrupt\n       *   \
    \            flag (x=7..4)\n       */\n      BitFieldModel<uint32_t, 24, 1> dmeif7;\n\
    \      /**\n       * @brief FEIF7 field\n       *\n       * Stream x FIFO error\
    \ interrupt flag\n       *               (x=7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> feif7;\n      /**\n       * @brief TCIF6 field\n       *\n       * Stream\
    \ x transfer complete interrupt\n       *               flag (x=7..4)\n      \
    \ */\n      BitFieldModel<uint32_t, 21, 1> tcif6;\n      /**\n       * @brief\
    \ HTIF6 field\n       *\n       * Stream x half transfer interrupt flag\n    \
    \   *               (x=7..4)\n       */\n      BitFieldModel<uint32_t, 20, 1>\
    \ htif6;\n      /**\n       * @brief TEIF6 field\n       *\n       * Stream x\
    \ transfer error interrupt flag\n       *               (x=7..4)\n       */\n\
    \      BitFieldModel<uint32_t, 19, 1> teif6;\n      /**\n       * @brief DMEIF6\
    \ field\n       *\n       * Stream x direct mode error interrupt\n       *   \
    \            flag (x=7..4)\n       */\n      BitFieldModel<uint32_t, 18, 1> dmeif6;\n\
    \      /**\n       * @brief FEIF6 field\n       *\n       * Stream x FIFO error\
    \ interrupt flag\n       *               (x=7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> feif6;\n      /**\n       * @brief TCIF5 field\n       *\n       * Stream\
    \ x transfer complete interrupt\n       *               flag (x=7..4)\n      \
    \ */\n      BitFieldModel<uint32_t, 11, 1> tcif5;\n      /**\n       * @brief\
    \ HTIF5 field\n       *\n       * Stream x half transfer interrupt flag\n    \
    \   *               (x=7..4)\n       */\n      BitFieldModel<uint32_t, 10, 1>\
    \ htif5;\n      /**\n       * @brief TEIF5 field\n       *\n       * Stream x\
    \ transfer error interrupt flag\n       *               (x=7..4)\n       */\n\
    \      BitFieldModel<uint32_t, 9, 1> teif5;\n      /**\n       * @brief DMEIF5\
    \ field\n       *\n       * Stream x direct mode error interrupt\n       *   \
    \            flag (x=7..4)\n       */\n      BitFieldModel<uint32_t, 8, 1> dmeif5;\n\
    \      /**\n       * @brief FEIF5 field\n       *\n       * Stream x FIFO error\
    \ interrupt flag\n       *               (x=7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> feif5;\n      /**\n       * @brief TCIF4 field\n       *\n       * Stream\
    \ x transfer complete interrupt\n       *               flag (x=7..4)\n      \
    \ */\n      BitFieldModel<uint32_t, 5, 1> tcif4;\n      /**\n       * @brief HTIF4\
    \ field\n       *\n       * Stream x half transfer interrupt flag\n       *  \
    \             (x=7..4)\n       */\n      BitFieldModel<uint32_t, 4, 1> htif4;\n\
    \      /**\n       * @brief TEIF4 field\n       *\n       * Stream x transfer\
    \ error interrupt flag\n       *               (x=7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> teif4;\n      /**\n       * @brief DMEIF4 field\n       *\n       * Stream\
    \ x direct mode error interrupt\n       *               flag (x=7..4)\n      \
    \ */\n      BitFieldModel<uint32_t, 2, 1> dmeif4;\n      /**\n       * @brief\
    \ FEIF4 field\n       *\n       * Stream x FIFO error interrupt flag\n       *\
    \               (x=7..4)\n       */\n      BitFieldModel<uint32_t, 0, 1> feif4;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief HISR register\n   *\n   * high interrupt\
    \ status register\n   */\n  using hisr = HisrReg<BaseAddress + 0x0004>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class LifcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CTCIF3 field\n     *\n    \
    \ * Stream x clear transfer complete\n     *               interrupt flag (x =\
    \ 3..0)\n     */\n    using ctcif3 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   /**\n     * @brief CHTIF3 field\n     *\n     * Stream x clear half transfer\
    \ interrupt\n     *               flag (x = 3..0)\n     */\n    using chtif3 =\
    \ FieldModel<uint32_t, address, 26, 1>;\n    /**\n     * @brief CTEIF3 field\n\
    \     *\n     * Stream x clear transfer error interrupt\n     *              \
    \ flag (x = 3..0)\n     */\n    using cteif3 = FieldModel<uint32_t, address, 25,\
    \ 1>;\n    /**\n     * @brief CDMEIF3 field\n     *\n     * Stream x clear direct\
    \ mode error\n     *               interrupt flag (x = 3..0)\n     */\n    using\
    \ cdmeif3 = FieldModel<uint32_t, address, 24, 1>;\n    /**\n     * @brief CFEIF3\
    \ field\n     *\n     * Stream x clear FIFO error interrupt flag\n     *     \
    \          (x = 3..0)\n     */\n    using cfeif3 = FieldModel<uint32_t, address,\
    \ 22, 1>;\n    /**\n     * @brief CTCIF2 field\n     *\n     * Stream x clear\
    \ transfer complete\n     *               interrupt flag (x = 3..0)\n     */\n\
    \    using ctcif2 = FieldModel<uint32_t, address, 21, 1>;\n    /**\n     * @brief\
    \ CHTIF2 field\n     *\n     * Stream x clear half transfer interrupt\n     *\
    \               flag (x = 3..0)\n     */\n    using chtif2 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief CTEIF2 field\n     *\n     * Stream\
    \ x clear transfer error interrupt\n     *               flag (x = 3..0)\n   \
    \  */\n    using cteif2 = FieldModel<uint32_t, address, 19, 1>;\n    /**\n   \
    \  * @brief CDMEIF2 field\n     *\n     * Stream x clear direct mode error\n \
    \    *               interrupt flag (x = 3..0)\n     */\n    using cdmeif2 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    /**\n     * @brief CFEIF2 field\n     *\n     * Stream\
    \ x clear FIFO error interrupt flag\n     *               (x = 3..0)\n     */\n\
    \    using cfeif2 = FieldModel<uint32_t, address, 16, 1>;\n    /**\n     * @brief\
    \ CTCIF1 field\n     *\n     * Stream x clear transfer complete\n     *      \
    \         interrupt flag (x = 3..0)\n     */\n    using ctcif1 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief CHTIF1 field\n     *\n     * Stream\
    \ x clear half transfer interrupt\n     *               flag (x = 3..0)\n    \
    \ */\n    using chtif1 = FieldModel<uint32_t, address, 10, 1>;\n    /**\n    \
    \ * @brief CTEIF1 field\n     *\n     * Stream x clear transfer error interrupt\n\
    \     *               flag (x = 3..0)\n     */\n    using cteif1 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief CDMEIF1 field\n     *\n     * Stream\
    \ x clear direct mode error\n     *               interrupt flag (x = 3..0)\n\
    \     */\n    using cdmeif1 = FieldModel<uint32_t, address, 8, 1>;\n    /**\n\
    \     * @brief CFEIF1 field\n     *\n     * Stream x clear FIFO error interrupt\
    \ flag\n     *               (x = 3..0)\n     */\n    using cfeif1 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief CTCIF0 field\n     *\n     * Stream\
    \ x clear transfer complete\n     *               interrupt flag (x = 3..0)\n\
    \     */\n    using ctcif0 = FieldModel<uint32_t, address, 5, 1>;\n    /**\n \
    \    * @brief CHTIF0 field\n     *\n     * Stream x clear half transfer interrupt\n\
    \     *               flag (x = 3..0)\n     */\n    using chtif0 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief CTEIF0 field\n     *\n     * Stream\
    \ x clear transfer error interrupt\n     *               flag (x = 3..0)\n   \
    \  */\n    using cteif0 = FieldModel<uint32_t, address, 3, 1>;\n    /**\n    \
    \ * @brief CDMEIF0 field\n     *\n     * Stream x clear direct mode error\n  \
    \   *               interrupt flag (x = 3..0)\n     */\n    using cdmeif0 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CFEIF0 field\n     *\n     * Stream\
    \ x clear FIFO error interrupt flag\n     *               (x = 3..0)\n     */\n\
    \    using cfeif0 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CTCIF3 field\n       *\n       * Stream x clear transfer complete\n       *\
    \               interrupt flag (x = 3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 27, 1> ctcif3;\n      /**\n       * @brief CHTIF3 field\n       *\n       *\
    \ Stream x clear half transfer interrupt\n       *               flag (x = 3..0)\n\
    \       */\n      BitFieldModel<uint32_t, 26, 1> chtif3;\n      /**\n       *\
    \ @brief CTEIF3 field\n       *\n       * Stream x clear transfer error interrupt\n\
    \       *               flag (x = 3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 1> cteif3;\n      /**\n       * @brief CDMEIF3 field\n       *\n       *\
    \ Stream x clear direct mode error\n       *               interrupt flag (x =\
    \ 3..0)\n       */\n      BitFieldModel<uint32_t, 24, 1> cdmeif3;\n      /**\n\
    \       * @brief CFEIF3 field\n       *\n       * Stream x clear FIFO error interrupt\
    \ flag\n       *               (x = 3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> cfeif3;\n      /**\n       * @brief CTCIF2 field\n       *\n       *\
    \ Stream x clear transfer complete\n       *               interrupt flag (x =\
    \ 3..0)\n       */\n      BitFieldModel<uint32_t, 21, 1> ctcif2;\n      /**\n\
    \       * @brief CHTIF2 field\n       *\n       * Stream x clear half transfer\
    \ interrupt\n       *               flag (x = 3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 1> chtif2;\n      /**\n       * @brief CTEIF2 field\n       *\n       *\
    \ Stream x clear transfer error interrupt\n       *               flag (x = 3..0)\n\
    \       */\n      BitFieldModel<uint32_t, 19, 1> cteif2;\n      /**\n       *\
    \ @brief CDMEIF2 field\n       *\n       * Stream x clear direct mode error\n\
    \       *               interrupt flag (x = 3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 1> cdmeif2;\n      /**\n       * @brief CFEIF2 field\n       *\n       *\
    \ Stream x clear FIFO error interrupt flag\n       *               (x = 3..0)\n\
    \       */\n      BitFieldModel<uint32_t, 16, 1> cfeif2;\n      /**\n       *\
    \ @brief CTCIF1 field\n       *\n       * Stream x clear transfer complete\n \
    \      *               interrupt flag (x = 3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> ctcif1;\n      /**\n       * @brief CHTIF1 field\n       *\n       *\
    \ Stream x clear half transfer interrupt\n       *               flag (x = 3..0)\n\
    \       */\n      BitFieldModel<uint32_t, 10, 1> chtif1;\n      /**\n       *\
    \ @brief CTEIF1 field\n       *\n       * Stream x clear transfer error interrupt\n\
    \       *               flag (x = 3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cteif1;\n      /**\n       * @brief CDMEIF1 field\n       *\n       *\
    \ Stream x clear direct mode error\n       *               interrupt flag (x =\
    \ 3..0)\n       */\n      BitFieldModel<uint32_t, 8, 1> cdmeif1;\n      /**\n\
    \       * @brief CFEIF1 field\n       *\n       * Stream x clear FIFO error interrupt\
    \ flag\n       *               (x = 3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> cfeif1;\n      /**\n       * @brief CTCIF0 field\n       *\n       * Stream\
    \ x clear transfer complete\n       *               interrupt flag (x = 3..0)\n\
    \       */\n      BitFieldModel<uint32_t, 5, 1> ctcif0;\n      /**\n       * @brief\
    \ CHTIF0 field\n       *\n       * Stream x clear half transfer interrupt\n  \
    \     *               flag (x = 3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> chtif0;\n      /**\n       * @brief CTEIF0 field\n       *\n       * Stream\
    \ x clear transfer error interrupt\n       *               flag (x = 3..0)\n \
    \      */\n      BitFieldModel<uint32_t, 3, 1> cteif0;\n      /**\n       * @brief\
    \ CDMEIF0 field\n       *\n       * Stream x clear direct mode error\n       *\
    \               interrupt flag (x = 3..0)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cdmeif0;\n      /**\n       * @brief CFEIF0 field\n       *\n       *\
    \ Stream x clear FIFO error interrupt flag\n       *               (x = 3..0)\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> cfeif0;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief LIFCR register\n   *\n   * low interrupt flag clear\n   *\
    \           register\n   */\n  using lifcr = LifcrReg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class HifcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CTCIF7 field\n     *\n    \
    \ * Stream x clear transfer complete\n     *               interrupt flag (x =\
    \ 7..4)\n     */\n    using ctcif7 = FieldModel<uint32_t, address, 27, 1>;\n \
    \   /**\n     * @brief CHTIF7 field\n     *\n     * Stream x clear half transfer\
    \ interrupt\n     *               flag (x = 7..4)\n     */\n    using chtif7 =\
    \ FieldModel<uint32_t, address, 26, 1>;\n    /**\n     * @brief CTEIF7 field\n\
    \     *\n     * Stream x clear transfer error interrupt\n     *              \
    \ flag (x = 7..4)\n     */\n    using cteif7 = FieldModel<uint32_t, address, 25,\
    \ 1>;\n    /**\n     * @brief CDMEIF7 field\n     *\n     * Stream x clear direct\
    \ mode error\n     *               interrupt flag (x = 7..4)\n     */\n    using\
    \ cdmeif7 = FieldModel<uint32_t, address, 24, 1>;\n    /**\n     * @brief CFEIF7\
    \ field\n     *\n     * Stream x clear FIFO error interrupt flag\n     *     \
    \          (x = 7..4)\n     */\n    using cfeif7 = FieldModel<uint32_t, address,\
    \ 22, 1>;\n    /**\n     * @brief CTCIF6 field\n     *\n     * Stream x clear\
    \ transfer complete\n     *               interrupt flag (x = 7..4)\n     */\n\
    \    using ctcif6 = FieldModel<uint32_t, address, 21, 1>;\n    /**\n     * @brief\
    \ CHTIF6 field\n     *\n     * Stream x clear half transfer interrupt\n     *\
    \               flag (x = 7..4)\n     */\n    using chtif6 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief CTEIF6 field\n     *\n     * Stream\
    \ x clear transfer error interrupt\n     *               flag (x = 7..4)\n   \
    \  */\n    using cteif6 = FieldModel<uint32_t, address, 19, 1>;\n    /**\n   \
    \  * @brief CDMEIF6 field\n     *\n     * Stream x clear direct mode error\n \
    \    *               interrupt flag (x = 7..4)\n     */\n    using cdmeif6 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    /**\n     * @brief CFEIF6 field\n     *\n     * Stream\
    \ x clear FIFO error interrupt flag\n     *               (x = 7..4)\n     */\n\
    \    using cfeif6 = FieldModel<uint32_t, address, 16, 1>;\n    /**\n     * @brief\
    \ CTCIF5 field\n     *\n     * Stream x clear transfer complete\n     *      \
    \         interrupt flag (x = 7..4)\n     */\n    using ctcif5 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief CHTIF5 field\n     *\n     * Stream\
    \ x clear half transfer interrupt\n     *               flag (x = 7..4)\n    \
    \ */\n    using chtif5 = FieldModel<uint32_t, address, 10, 1>;\n    /**\n    \
    \ * @brief CTEIF5 field\n     *\n     * Stream x clear transfer error interrupt\n\
    \     *               flag (x = 7..4)\n     */\n    using cteif5 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief CDMEIF5 field\n     *\n     * Stream\
    \ x clear direct mode error\n     *               interrupt flag (x = 7..4)\n\
    \     */\n    using cdmeif5 = FieldModel<uint32_t, address, 8, 1>;\n    /**\n\
    \     * @brief CFEIF5 field\n     *\n     * Stream x clear FIFO error interrupt\
    \ flag\n     *               (x = 7..4)\n     */\n    using cfeif5 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief CTCIF4 field\n     *\n     * Stream\
    \ x clear transfer complete\n     *               interrupt flag (x = 7..4)\n\
    \     */\n    using ctcif4 = FieldModel<uint32_t, address, 5, 1>;\n    /**\n \
    \    * @brief CHTIF4 field\n     *\n     * Stream x clear half transfer interrupt\n\
    \     *               flag (x = 7..4)\n     */\n    using chtif4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief CTEIF4 field\n     *\n     * Stream\
    \ x clear transfer error interrupt\n     *               flag (x = 7..4)\n   \
    \  */\n    using cteif4 = FieldModel<uint32_t, address, 3, 1>;\n    /**\n    \
    \ * @brief CDMEIF4 field\n     *\n     * Stream x clear direct mode error\n  \
    \   *               interrupt flag (x = 7..4)\n     */\n    using cdmeif4 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief CFEIF4 field\n     *\n     * Stream\
    \ x clear FIFO error interrupt flag\n     *               (x = 7..4)\n     */\n\
    \    using cfeif4 = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CTCIF7 field\n       *\n       * Stream x clear transfer complete\n       *\
    \               interrupt flag (x = 7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 27, 1> ctcif7;\n      /**\n       * @brief CHTIF7 field\n       *\n       *\
    \ Stream x clear half transfer interrupt\n       *               flag (x = 7..4)\n\
    \       */\n      BitFieldModel<uint32_t, 26, 1> chtif7;\n      /**\n       *\
    \ @brief CTEIF7 field\n       *\n       * Stream x clear transfer error interrupt\n\
    \       *               flag (x = 7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 1> cteif7;\n      /**\n       * @brief CDMEIF7 field\n       *\n       *\
    \ Stream x clear direct mode error\n       *               interrupt flag (x =\
    \ 7..4)\n       */\n      BitFieldModel<uint32_t, 24, 1> cdmeif7;\n      /**\n\
    \       * @brief CFEIF7 field\n       *\n       * Stream x clear FIFO error interrupt\
    \ flag\n       *               (x = 7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> cfeif7;\n      /**\n       * @brief CTCIF6 field\n       *\n       *\
    \ Stream x clear transfer complete\n       *               interrupt flag (x =\
    \ 7..4)\n       */\n      BitFieldModel<uint32_t, 21, 1> ctcif6;\n      /**\n\
    \       * @brief CHTIF6 field\n       *\n       * Stream x clear half transfer\
    \ interrupt\n       *               flag (x = 7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 1> chtif6;\n      /**\n       * @brief CTEIF6 field\n       *\n       *\
    \ Stream x clear transfer error interrupt\n       *               flag (x = 7..4)\n\
    \       */\n      BitFieldModel<uint32_t, 19, 1> cteif6;\n      /**\n       *\
    \ @brief CDMEIF6 field\n       *\n       * Stream x clear direct mode error\n\
    \       *               interrupt flag (x = 7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 1> cdmeif6;\n      /**\n       * @brief CFEIF6 field\n       *\n       *\
    \ Stream x clear FIFO error interrupt flag\n       *               (x = 7..4)\n\
    \       */\n      BitFieldModel<uint32_t, 16, 1> cfeif6;\n      /**\n       *\
    \ @brief CTCIF5 field\n       *\n       * Stream x clear transfer complete\n \
    \      *               interrupt flag (x = 7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> ctcif5;\n      /**\n       * @brief CHTIF5 field\n       *\n       *\
    \ Stream x clear half transfer interrupt\n       *               flag (x = 7..4)\n\
    \       */\n      BitFieldModel<uint32_t, 10, 1> chtif5;\n      /**\n       *\
    \ @brief CTEIF5 field\n       *\n       * Stream x clear transfer error interrupt\n\
    \       *               flag (x = 7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> cteif5;\n      /**\n       * @brief CDMEIF5 field\n       *\n       *\
    \ Stream x clear direct mode error\n       *               interrupt flag (x =\
    \ 7..4)\n       */\n      BitFieldModel<uint32_t, 8, 1> cdmeif5;\n      /**\n\
    \       * @brief CFEIF5 field\n       *\n       * Stream x clear FIFO error interrupt\
    \ flag\n       *               (x = 7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> cfeif5;\n      /**\n       * @brief CTCIF4 field\n       *\n       * Stream\
    \ x clear transfer complete\n       *               interrupt flag (x = 7..4)\n\
    \       */\n      BitFieldModel<uint32_t, 5, 1> ctcif4;\n      /**\n       * @brief\
    \ CHTIF4 field\n       *\n       * Stream x clear half transfer interrupt\n  \
    \     *               flag (x = 7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> chtif4;\n      /**\n       * @brief CTEIF4 field\n       *\n       * Stream\
    \ x clear transfer error interrupt\n       *               flag (x = 7..4)\n \
    \      */\n      BitFieldModel<uint32_t, 3, 1> cteif4;\n      /**\n       * @brief\
    \ CDMEIF4 field\n       *\n       * Stream x clear direct mode error\n       *\
    \               interrupt flag (x = 7..4)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> cdmeif4;\n      /**\n       * @brief CFEIF4 field\n       *\n       *\
    \ Stream x clear FIFO error interrupt flag\n       *               (x = 7..4)\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> cfeif4;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief HIFCR register\n   *\n   * high interrupt flag clear\n   *\
    \           register\n   */\n  using hifcr = HifcrReg<BaseAddress + 0x000C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S0crReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CHSEL field\n     *\n     *\
    \ Channel selection\n     */\n    using chsel = FieldModel<uint32_t, address,\
    \ 25, 3>;\n    /**\n     * @brief MBURST field\n     *\n     * Memory burst transfer\n\
    \     *               configuration\n     */\n    using mburst = FieldModel<uint32_t,\
    \ address, 23, 2>;\n    /**\n     * @brief PBURST field\n     *\n     * Peripheral\
    \ burst transfer\n     *               configuration\n     */\n    using pburst\
    \ = FieldModel<uint32_t, address, 21, 2>;\n    /**\n     * @brief CT field\n \
    \    *\n     * Current target (only in double buffer\n     *               mode)\n\
    \     */\n    using ct = FieldModel<uint32_t, address, 19, 1>;\n    /**\n    \
    \ * @brief DBM field\n     *\n     * Double buffer mode\n     */\n    using dbm\
    \ = FieldModel<uint32_t, address, 18, 1>;\n    /**\n     * @brief PL field\n \
    \    *\n     * Priority level\n     */\n    using pl = FieldModel<uint32_t, address,\
    \ 16, 2>;\n    /**\n     * @brief PINCOS field\n     *\n     * Peripheral increment\
    \ offset\n     *               size\n     */\n    using pincos = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief MSIZE field\n     *\n     * Memory\
    \ data size\n     */\n    using msize = FieldModel<uint32_t, address, 13, 2>;\n\
    \    /**\n     * @brief PSIZE field\n     *\n     * Peripheral data size\n   \
    \  */\n    using psize = FieldModel<uint32_t, address, 11, 2>;\n    /**\n    \
    \ * @brief MINC field\n     *\n     * Memory increment mode\n     */\n    using\
    \ minc = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief PINC field\n\
    \     *\n     * Peripheral increment mode\n     */\n    using pinc = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief CIRC field\n     *\n     * Circular\
    \ mode\n     */\n    using circ = FieldModel<uint32_t, address, 8, 1>;\n    /**\n\
    \     * @brief DIR field\n     *\n     * Data transfer direction\n     */\n  \
    \  using dir = FieldModel<uint32_t, address, 6, 2>;\n    /**\n     * @brief PFCTRL\
    \ field\n     *\n     * Peripheral flow controller\n     */\n    using pfctrl\
    \ = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief TCIE field\n\
    \     *\n     * Transfer complete interrupt\n     *               enable\n   \
    \  */\n    using tcie = FieldModel<uint32_t, address, 4, 1>;\n    /**\n     *\
    \ @brief HTIE field\n     *\n     * Half transfer interrupt\n     *          \
    \     enable\n     */\n    using htie = FieldModel<uint32_t, address, 3, 1>;\n\
    \    /**\n     * @brief TEIE field\n     *\n     * Transfer error interrupt\n\
    \     *               enable\n     */\n    using teie = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief DMEIE field\n     *\n     * Direct mode error\
    \ interrupt\n     *               enable\n     */\n    using dmeie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief EN field\n     *\n     * Stream enable\
    \ / flag stream ready when\n     *               read low\n     */\n    using\
    \ en = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CHSEL field\n       *\n       * Channel selection\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 3> chsel;\n      /**\n       * @brief MBURST field\n       *\n       * Memory\
    \ burst transfer\n       *               configuration\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 2> mburst;\n      /**\n       * @brief PBURST field\n       *\n       *\
    \ Peripheral burst transfer\n       *               configuration\n       */\n\
    \      BitFieldModel<uint32_t, 21, 2> pburst;\n      /**\n       * @brief CT field\n\
    \       *\n       * Current target (only in double buffer\n       *          \
    \     mode)\n       */\n      BitFieldModel<uint32_t, 19, 1> ct;\n      /**\n\
    \       * @brief DBM field\n       *\n       * Double buffer mode\n       */\n\
    \      BitFieldModel<uint32_t, 18, 1> dbm;\n      /**\n       * @brief PL field\n\
    \       *\n       * Priority level\n       */\n      BitFieldModel<uint32_t, 16,\
    \ 2> pl;\n      /**\n       * @brief PINCOS field\n       *\n       * Peripheral\
    \ increment offset\n       *               size\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> pincos;\n      /**\n       * @brief MSIZE field\n       *\n       * Memory\
    \ data size\n       */\n      BitFieldModel<uint32_t, 13, 2> msize;\n      /**\n\
    \       * @brief PSIZE field\n       *\n       * Peripheral data size\n      \
    \ */\n      BitFieldModel<uint32_t, 11, 2> psize;\n      /**\n       * @brief\
    \ MINC field\n       *\n       * Memory increment mode\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> minc;\n      /**\n       * @brief PINC field\n       *\n       * Peripheral\
    \ increment mode\n       */\n      BitFieldModel<uint32_t, 9, 1> pinc;\n     \
    \ /**\n       * @brief CIRC field\n       *\n       * Circular mode\n       */\n\
    \      BitFieldModel<uint32_t, 8, 1> circ;\n      /**\n       * @brief DIR field\n\
    \       *\n       * Data transfer direction\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 2> dir;\n      /**\n       * @brief PFCTRL field\n       *\n       * Peripheral\
    \ flow controller\n       */\n      BitFieldModel<uint32_t, 5, 1> pfctrl;\n  \
    \    /**\n       * @brief TCIE field\n       *\n       * Transfer complete interrupt\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 4, 1>\
    \ tcie;\n      /**\n       * @brief HTIE field\n       *\n       * Half transfer\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      /**\n       * @brief TEIE field\n       *\n       * Transfer\
    \ error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      /**\n       * @brief DMEIE field\n       *\n       * Direct\
    \ mode error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      /**\n       * @brief EN field\n       *\n       * Stream\
    \ enable / flag stream ready when\n       *               read low\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief S0CR register\n   *\n   * stream x configuration\n   *           register\n\
    \   */\n  using s0cr = S0crReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S0ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief NDT field\n     *\n     * Number of data\
    \ items to\n     *               transfer\n     */\n    using ndt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief NDT field\n       *\n \
    \      * Number of data items to\n       *               transfer\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ndt;\n    };\n  };\n\npublic:\n  /**\n \
    \  * @brief S0NDTR register\n   *\n   * stream x number of data\n   *        \
    \   register\n   */\n  using s0ndtr = S0ndtrReg<BaseAddress + 0x0014>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class S0parReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief PA field\n     *\n     * Peripheral\
    \ address\n     */\n    using pa = FieldModel<uint32_t, address, 0, 32>;\n\n \
    \ public:\n    /**\n     * @brief Register union\n     *\n     * Can be used to\
    \ create a local register variable for easy bit manipulation.\n     * Useful for\
    \ read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief PA field\n       *\n       * Peripheral address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S0PAR register\n   *\n   * stream x peripheral address\n \
    \  *           register\n   */\n  using s0par = S0parReg<BaseAddress + 0x0018>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S0m0arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M0A field\n     *\n     * Memory\
    \ 0 address\n     */\n    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief M0A field\n       *\n       * Memory 0 address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> m0a;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S0M0AR register\n   *\n   * stream x memory 0 address\n  \
    \ *           register\n   */\n  using s0m0ar = S0m0arReg<BaseAddress + 0x001C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S0m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M1A field\n     *\n     * Memory\
    \ 1 address (used in case of Double\n     *               buffer mode)\n     */\n\
    \    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ M1A field\n       *\n       * Memory 1 address (used in case of Double\n   \
    \    *               buffer mode)\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 32> m1a;\n    };\n  };\n\npublic:\n  /**\n   * @brief S0M1AR register\n   *\n\
    \   * stream x memory 1 address\n   *           register\n   */\n  using s0m1ar\
    \ = S0m1arReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S0fcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief FEIE field\n     *\n     * FIFO error interrupt\n    \
    \ *               enable\n     */\n    using feie = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    /**\n     * @brief FS field\n     *\n     * FIFO status\n     */\n\
    \    using fs = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     * @brief DMDIS\
    \ field\n     *\n     * Direct mode disable\n     */\n    using dmdis = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief FTH field\n     *\n     * FIFO threshold\
    \ selection\n     */\n    using fth = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief FEIE field\n       *\n       * FIFO error\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> feie;\n      /**\n       * @brief FS field\n       *\n       * FIFO status\n\
    \       */\n      BitFieldModel<uint32_t, 3, 3> fs;\n      /**\n       * @brief\
    \ DMDIS field\n       *\n       * Direct mode disable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmdis;\n      /**\n       * @brief FTH field\n       *\n       * FIFO\
    \ threshold selection\n       */\n      BitFieldModel<uint32_t, 0, 2> fth;\n \
    \   };\n  };\n\npublic:\n  /**\n   * @brief S0FCR register\n   *\n   * stream\
    \ x FIFO control register\n   */\n  using s0fcr = S0fcrReg<BaseAddress + 0x0024>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S1crReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CHSEL field\n     *\n     *\
    \ Channel selection\n     */\n    using chsel = FieldModel<uint32_t, address,\
    \ 25, 3>;\n    /**\n     * @brief MBURST field\n     *\n     * Memory burst transfer\n\
    \     *               configuration\n     */\n    using mburst = FieldModel<uint32_t,\
    \ address, 23, 2>;\n    /**\n     * @brief PBURST field\n     *\n     * Peripheral\
    \ burst transfer\n     *               configuration\n     */\n    using pburst\
    \ = FieldModel<uint32_t, address, 21, 2>;\n    /**\n     * @brief ACK field\n\
    \     *\n     * ACK\n     */\n    using ack = FieldModel<uint32_t, address, 20,\
    \ 1>;\n    /**\n     * @brief CT field\n     *\n     * Current target (only in\
    \ double buffer\n     *               mode)\n     */\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief DBM field\n     *\n     * Double buffer\
    \ mode\n     */\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n    /**\n\
    \     * @brief PL field\n     *\n     * Priority level\n     */\n    using pl\
    \ = FieldModel<uint32_t, address, 16, 2>;\n    /**\n     * @brief PINCOS field\n\
    \     *\n     * Peripheral increment offset\n     *               size\n     */\n\
    \    using pincos = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief\
    \ MSIZE field\n     *\n     * Memory data size\n     */\n    using msize = FieldModel<uint32_t,\
    \ address, 13, 2>;\n    /**\n     * @brief PSIZE field\n     *\n     * Peripheral\
    \ data size\n     */\n    using psize = FieldModel<uint32_t, address, 11, 2>;\n\
    \    /**\n     * @brief MINC field\n     *\n     * Memory increment mode\n   \
    \  */\n    using minc = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     *\
    \ @brief PINC field\n     *\n     * Peripheral increment mode\n     */\n    using\
    \ pinc = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief CIRC field\n\
    \     *\n     * Circular mode\n     */\n    using circ = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief DIR field\n     *\n     * Data transfer\
    \ direction\n     */\n    using dir = FieldModel<uint32_t, address, 6, 2>;\n \
    \   /**\n     * @brief PFCTRL field\n     *\n     * Peripheral flow controller\n\
    \     */\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n    /**\n \
    \    * @brief TCIE field\n     *\n     * Transfer complete interrupt\n     * \
    \              enable\n     */\n    using tcie = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief HTIE field\n     *\n     * Half transfer interrupt\n\
    \     *               enable\n     */\n    using htie = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief TEIE field\n     *\n     * Transfer error interrupt\n\
    \     *               enable\n     */\n    using teie = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief DMEIE field\n     *\n     * Direct mode error\
    \ interrupt\n     *               enable\n     */\n    using dmeie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief EN field\n     *\n     * Stream enable\
    \ / flag stream ready when\n     *               read low\n     */\n    using\
    \ en = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CHSEL field\n       *\n       * Channel selection\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 3> chsel;\n      /**\n       * @brief MBURST field\n       *\n       * Memory\
    \ burst transfer\n       *               configuration\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 2> mburst;\n      /**\n       * @brief PBURST field\n       *\n       *\
    \ Peripheral burst transfer\n       *               configuration\n       */\n\
    \      BitFieldModel<uint32_t, 21, 2> pburst;\n      /**\n       * @brief ACK\
    \ field\n       *\n       * ACK\n       */\n      BitFieldModel<uint32_t, 20,\
    \ 1> ack;\n      /**\n       * @brief CT field\n       *\n       * Current target\
    \ (only in double buffer\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      /**\n       * @brief DBM field\n       *\n       * Double\
    \ buffer mode\n       */\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      /**\n\
    \       * @brief PL field\n       *\n       * Priority level\n       */\n    \
    \  BitFieldModel<uint32_t, 16, 2> pl;\n      /**\n       * @brief PINCOS field\n\
    \       *\n       * Peripheral increment offset\n       *               size\n\
    \       */\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      /**\n       *\
    \ @brief MSIZE field\n       *\n       * Memory data size\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      /**\n       * @brief PSIZE field\n       *\n       * Peripheral\
    \ data size\n       */\n      BitFieldModel<uint32_t, 11, 2> psize;\n      /**\n\
    \       * @brief MINC field\n       *\n       * Memory increment mode\n      \
    \ */\n      BitFieldModel<uint32_t, 10, 1> minc;\n      /**\n       * @brief PINC\
    \ field\n       *\n       * Peripheral increment mode\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> pinc;\n      /**\n       * @brief CIRC field\n       *\n       * Circular\
    \ mode\n       */\n      BitFieldModel<uint32_t, 8, 1> circ;\n      /**\n    \
    \   * @brief DIR field\n       *\n       * Data transfer direction\n       */\n\
    \      BitFieldModel<uint32_t, 6, 2> dir;\n      /**\n       * @brief PFCTRL field\n\
    \       *\n       * Peripheral flow controller\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      /**\n       * @brief TCIE field\n       *\n       * Transfer\
    \ complete interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> tcie;\n      /**\n       * @brief HTIE field\n       *\n       * Half\
    \ transfer interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      /**\n       * @brief TEIE field\n       *\n       * Transfer\
    \ error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      /**\n       * @brief DMEIE field\n       *\n       * Direct\
    \ mode error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      /**\n       * @brief EN field\n       *\n       * Stream\
    \ enable / flag stream ready when\n       *               read low\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief S1CR register\n   *\n   * stream x configuration\n   *           register\n\
    \   */\n  using s1cr = S1crReg<BaseAddress + 0x0028>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S1ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief NDT field\n     *\n     * Number of data\
    \ items to\n     *               transfer\n     */\n    using ndt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief NDT field\n       *\n \
    \      * Number of data items to\n       *               transfer\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ndt;\n    };\n  };\n\npublic:\n  /**\n \
    \  * @brief S1NDTR register\n   *\n   * stream x number of data\n   *        \
    \   register\n   */\n  using s1ndtr = S1ndtrReg<BaseAddress + 0x002C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class S1parReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief PA field\n     *\n     * Peripheral\
    \ address\n     */\n    using pa = FieldModel<uint32_t, address, 0, 32>;\n\n \
    \ public:\n    /**\n     * @brief Register union\n     *\n     * Can be used to\
    \ create a local register variable for easy bit manipulation.\n     * Useful for\
    \ read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief PA field\n       *\n       * Peripheral address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S1PAR register\n   *\n   * stream x peripheral address\n \
    \  *           register\n   */\n  using s1par = S1parReg<BaseAddress + 0x0030>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S1m0arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M0A field\n     *\n     * Memory\
    \ 0 address\n     */\n    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief M0A field\n       *\n       * Memory 0 address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> m0a;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S1M0AR register\n   *\n   * stream x memory 0 address\n  \
    \ *           register\n   */\n  using s1m0ar = S1m0arReg<BaseAddress + 0x0034>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S1m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M1A field\n     *\n     * Memory\
    \ 1 address (used in case of Double\n     *               buffer mode)\n     */\n\
    \    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ M1A field\n       *\n       * Memory 1 address (used in case of Double\n   \
    \    *               buffer mode)\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 32> m1a;\n    };\n  };\n\npublic:\n  /**\n   * @brief S1M1AR register\n   *\n\
    \   * stream x memory 1 address\n   *           register\n   */\n  using s1m1ar\
    \ = S1m1arReg<BaseAddress + 0x0038>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S1fcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief FEIE field\n     *\n     * FIFO error interrupt\n    \
    \ *               enable\n     */\n    using feie = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    /**\n     * @brief FS field\n     *\n     * FIFO status\n     */\n\
    \    using fs = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     * @brief DMDIS\
    \ field\n     *\n     * Direct mode disable\n     */\n    using dmdis = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief FTH field\n     *\n     * FIFO threshold\
    \ selection\n     */\n    using fth = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief FEIE field\n       *\n       * FIFO error\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> feie;\n      /**\n       * @brief FS field\n       *\n       * FIFO status\n\
    \       */\n      BitFieldModel<uint32_t, 3, 3> fs;\n      /**\n       * @brief\
    \ DMDIS field\n       *\n       * Direct mode disable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmdis;\n      /**\n       * @brief FTH field\n       *\n       * FIFO\
    \ threshold selection\n       */\n      BitFieldModel<uint32_t, 0, 2> fth;\n \
    \   };\n  };\n\npublic:\n  /**\n   * @brief S1FCR register\n   *\n   * stream\
    \ x FIFO control register\n   */\n  using s1fcr = S1fcrReg<BaseAddress + 0x003C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S2crReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CHSEL field\n     *\n     *\
    \ Channel selection\n     */\n    using chsel = FieldModel<uint32_t, address,\
    \ 25, 3>;\n    /**\n     * @brief MBURST field\n     *\n     * Memory burst transfer\n\
    \     *               configuration\n     */\n    using mburst = FieldModel<uint32_t,\
    \ address, 23, 2>;\n    /**\n     * @brief PBURST field\n     *\n     * Peripheral\
    \ burst transfer\n     *               configuration\n     */\n    using pburst\
    \ = FieldModel<uint32_t, address, 21, 2>;\n    /**\n     * @brief ACK field\n\
    \     *\n     * ACK\n     */\n    using ack = FieldModel<uint32_t, address, 20,\
    \ 1>;\n    /**\n     * @brief CT field\n     *\n     * Current target (only in\
    \ double buffer\n     *               mode)\n     */\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief DBM field\n     *\n     * Double buffer\
    \ mode\n     */\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n    /**\n\
    \     * @brief PL field\n     *\n     * Priority level\n     */\n    using pl\
    \ = FieldModel<uint32_t, address, 16, 2>;\n    /**\n     * @brief PINCOS field\n\
    \     *\n     * Peripheral increment offset\n     *               size\n     */\n\
    \    using pincos = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief\
    \ MSIZE field\n     *\n     * Memory data size\n     */\n    using msize = FieldModel<uint32_t,\
    \ address, 13, 2>;\n    /**\n     * @brief PSIZE field\n     *\n     * Peripheral\
    \ data size\n     */\n    using psize = FieldModel<uint32_t, address, 11, 2>;\n\
    \    /**\n     * @brief MINC field\n     *\n     * Memory increment mode\n   \
    \  */\n    using minc = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     *\
    \ @brief PINC field\n     *\n     * Peripheral increment mode\n     */\n    using\
    \ pinc = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief CIRC field\n\
    \     *\n     * Circular mode\n     */\n    using circ = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief DIR field\n     *\n     * Data transfer\
    \ direction\n     */\n    using dir = FieldModel<uint32_t, address, 6, 2>;\n \
    \   /**\n     * @brief PFCTRL field\n     *\n     * Peripheral flow controller\n\
    \     */\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n    /**\n \
    \    * @brief TCIE field\n     *\n     * Transfer complete interrupt\n     * \
    \              enable\n     */\n    using tcie = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief HTIE field\n     *\n     * Half transfer interrupt\n\
    \     *               enable\n     */\n    using htie = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief TEIE field\n     *\n     * Transfer error interrupt\n\
    \     *               enable\n     */\n    using teie = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief DMEIE field\n     *\n     * Direct mode error\
    \ interrupt\n     *               enable\n     */\n    using dmeie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief EN field\n     *\n     * Stream enable\
    \ / flag stream ready when\n     *               read low\n     */\n    using\
    \ en = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CHSEL field\n       *\n       * Channel selection\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 3> chsel;\n      /**\n       * @brief MBURST field\n       *\n       * Memory\
    \ burst transfer\n       *               configuration\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 2> mburst;\n      /**\n       * @brief PBURST field\n       *\n       *\
    \ Peripheral burst transfer\n       *               configuration\n       */\n\
    \      BitFieldModel<uint32_t, 21, 2> pburst;\n      /**\n       * @brief ACK\
    \ field\n       *\n       * ACK\n       */\n      BitFieldModel<uint32_t, 20,\
    \ 1> ack;\n      /**\n       * @brief CT field\n       *\n       * Current target\
    \ (only in double buffer\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      /**\n       * @brief DBM field\n       *\n       * Double\
    \ buffer mode\n       */\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      /**\n\
    \       * @brief PL field\n       *\n       * Priority level\n       */\n    \
    \  BitFieldModel<uint32_t, 16, 2> pl;\n      /**\n       * @brief PINCOS field\n\
    \       *\n       * Peripheral increment offset\n       *               size\n\
    \       */\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      /**\n       *\
    \ @brief MSIZE field\n       *\n       * Memory data size\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      /**\n       * @brief PSIZE field\n       *\n       * Peripheral\
    \ data size\n       */\n      BitFieldModel<uint32_t, 11, 2> psize;\n      /**\n\
    \       * @brief MINC field\n       *\n       * Memory increment mode\n      \
    \ */\n      BitFieldModel<uint32_t, 10, 1> minc;\n      /**\n       * @brief PINC\
    \ field\n       *\n       * Peripheral increment mode\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> pinc;\n      /**\n       * @brief CIRC field\n       *\n       * Circular\
    \ mode\n       */\n      BitFieldModel<uint32_t, 8, 1> circ;\n      /**\n    \
    \   * @brief DIR field\n       *\n       * Data transfer direction\n       */\n\
    \      BitFieldModel<uint32_t, 6, 2> dir;\n      /**\n       * @brief PFCTRL field\n\
    \       *\n       * Peripheral flow controller\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      /**\n       * @brief TCIE field\n       *\n       * Transfer\
    \ complete interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> tcie;\n      /**\n       * @brief HTIE field\n       *\n       * Half\
    \ transfer interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      /**\n       * @brief TEIE field\n       *\n       * Transfer\
    \ error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      /**\n       * @brief DMEIE field\n       *\n       * Direct\
    \ mode error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      /**\n       * @brief EN field\n       *\n       * Stream\
    \ enable / flag stream ready when\n       *               read low\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief S2CR register\n   *\n   * stream x configuration\n   *           register\n\
    \   */\n  using s2cr = S2crReg<BaseAddress + 0x0040>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S2ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief NDT field\n     *\n     * Number of data\
    \ items to\n     *               transfer\n     */\n    using ndt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief NDT field\n       *\n \
    \      * Number of data items to\n       *               transfer\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ndt;\n    };\n  };\n\npublic:\n  /**\n \
    \  * @brief S2NDTR register\n   *\n   * stream x number of data\n   *        \
    \   register\n   */\n  using s2ndtr = S2ndtrReg<BaseAddress + 0x0044>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class S2parReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief PA field\n     *\n     * Peripheral\
    \ address\n     */\n    using pa = FieldModel<uint32_t, address, 0, 32>;\n\n \
    \ public:\n    /**\n     * @brief Register union\n     *\n     * Can be used to\
    \ create a local register variable for easy bit manipulation.\n     * Useful for\
    \ read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief PA field\n       *\n       * Peripheral address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S2PAR register\n   *\n   * stream x peripheral address\n \
    \  *           register\n   */\n  using s2par = S2parReg<BaseAddress + 0x0048>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S2m0arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M0A field\n     *\n     * Memory\
    \ 0 address\n     */\n    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief M0A field\n       *\n       * Memory 0 address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> m0a;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S2M0AR register\n   *\n   * stream x memory 0 address\n  \
    \ *           register\n   */\n  using s2m0ar = S2m0arReg<BaseAddress + 0x004C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S2m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M1A field\n     *\n     * Memory\
    \ 1 address (used in case of Double\n     *               buffer mode)\n     */\n\
    \    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ M1A field\n       *\n       * Memory 1 address (used in case of Double\n   \
    \    *               buffer mode)\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 32> m1a;\n    };\n  };\n\npublic:\n  /**\n   * @brief S2M1AR register\n   *\n\
    \   * stream x memory 1 address\n   *           register\n   */\n  using s2m1ar\
    \ = S2m1arReg<BaseAddress + 0x0050>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S2fcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief FEIE field\n     *\n     * FIFO error interrupt\n    \
    \ *               enable\n     */\n    using feie = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    /**\n     * @brief FS field\n     *\n     * FIFO status\n     */\n\
    \    using fs = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     * @brief DMDIS\
    \ field\n     *\n     * Direct mode disable\n     */\n    using dmdis = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief FTH field\n     *\n     * FIFO threshold\
    \ selection\n     */\n    using fth = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief FEIE field\n       *\n       * FIFO error\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> feie;\n      /**\n       * @brief FS field\n       *\n       * FIFO status\n\
    \       */\n      BitFieldModel<uint32_t, 3, 3> fs;\n      /**\n       * @brief\
    \ DMDIS field\n       *\n       * Direct mode disable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmdis;\n      /**\n       * @brief FTH field\n       *\n       * FIFO\
    \ threshold selection\n       */\n      BitFieldModel<uint32_t, 0, 2> fth;\n \
    \   };\n  };\n\npublic:\n  /**\n   * @brief S2FCR register\n   *\n   * stream\
    \ x FIFO control register\n   */\n  using s2fcr = S2fcrReg<BaseAddress + 0x0054>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S3crReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CHSEL field\n     *\n     *\
    \ Channel selection\n     */\n    using chsel = FieldModel<uint32_t, address,\
    \ 25, 3>;\n    /**\n     * @brief MBURST field\n     *\n     * Memory burst transfer\n\
    \     *               configuration\n     */\n    using mburst = FieldModel<uint32_t,\
    \ address, 23, 2>;\n    /**\n     * @brief PBURST field\n     *\n     * Peripheral\
    \ burst transfer\n     *               configuration\n     */\n    using pburst\
    \ = FieldModel<uint32_t, address, 21, 2>;\n    /**\n     * @brief ACK field\n\
    \     *\n     * ACK\n     */\n    using ack = FieldModel<uint32_t, address, 20,\
    \ 1>;\n    /**\n     * @brief CT field\n     *\n     * Current target (only in\
    \ double buffer\n     *               mode)\n     */\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief DBM field\n     *\n     * Double buffer\
    \ mode\n     */\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n    /**\n\
    \     * @brief PL field\n     *\n     * Priority level\n     */\n    using pl\
    \ = FieldModel<uint32_t, address, 16, 2>;\n    /**\n     * @brief PINCOS field\n\
    \     *\n     * Peripheral increment offset\n     *               size\n     */\n\
    \    using pincos = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief\
    \ MSIZE field\n     *\n     * Memory data size\n     */\n    using msize = FieldModel<uint32_t,\
    \ address, 13, 2>;\n    /**\n     * @brief PSIZE field\n     *\n     * Peripheral\
    \ data size\n     */\n    using psize = FieldModel<uint32_t, address, 11, 2>;\n\
    \    /**\n     * @brief MINC field\n     *\n     * Memory increment mode\n   \
    \  */\n    using minc = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     *\
    \ @brief PINC field\n     *\n     * Peripheral increment mode\n     */\n    using\
    \ pinc = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief CIRC field\n\
    \     *\n     * Circular mode\n     */\n    using circ = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief DIR field\n     *\n     * Data transfer\
    \ direction\n     */\n    using dir = FieldModel<uint32_t, address, 6, 2>;\n \
    \   /**\n     * @brief PFCTRL field\n     *\n     * Peripheral flow controller\n\
    \     */\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n    /**\n \
    \    * @brief TCIE field\n     *\n     * Transfer complete interrupt\n     * \
    \              enable\n     */\n    using tcie = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief HTIE field\n     *\n     * Half transfer interrupt\n\
    \     *               enable\n     */\n    using htie = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief TEIE field\n     *\n     * Transfer error interrupt\n\
    \     *               enable\n     */\n    using teie = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief DMEIE field\n     *\n     * Direct mode error\
    \ interrupt\n     *               enable\n     */\n    using dmeie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief EN field\n     *\n     * Stream enable\
    \ / flag stream ready when\n     *               read low\n     */\n    using\
    \ en = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CHSEL field\n       *\n       * Channel selection\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 3> chsel;\n      /**\n       * @brief MBURST field\n       *\n       * Memory\
    \ burst transfer\n       *               configuration\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 2> mburst;\n      /**\n       * @brief PBURST field\n       *\n       *\
    \ Peripheral burst transfer\n       *               configuration\n       */\n\
    \      BitFieldModel<uint32_t, 21, 2> pburst;\n      /**\n       * @brief ACK\
    \ field\n       *\n       * ACK\n       */\n      BitFieldModel<uint32_t, 20,\
    \ 1> ack;\n      /**\n       * @brief CT field\n       *\n       * Current target\
    \ (only in double buffer\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      /**\n       * @brief DBM field\n       *\n       * Double\
    \ buffer mode\n       */\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      /**\n\
    \       * @brief PL field\n       *\n       * Priority level\n       */\n    \
    \  BitFieldModel<uint32_t, 16, 2> pl;\n      /**\n       * @brief PINCOS field\n\
    \       *\n       * Peripheral increment offset\n       *               size\n\
    \       */\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      /**\n       *\
    \ @brief MSIZE field\n       *\n       * Memory data size\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      /**\n       * @brief PSIZE field\n       *\n       * Peripheral\
    \ data size\n       */\n      BitFieldModel<uint32_t, 11, 2> psize;\n      /**\n\
    \       * @brief MINC field\n       *\n       * Memory increment mode\n      \
    \ */\n      BitFieldModel<uint32_t, 10, 1> minc;\n      /**\n       * @brief PINC\
    \ field\n       *\n       * Peripheral increment mode\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> pinc;\n      /**\n       * @brief CIRC field\n       *\n       * Circular\
    \ mode\n       */\n      BitFieldModel<uint32_t, 8, 1> circ;\n      /**\n    \
    \   * @brief DIR field\n       *\n       * Data transfer direction\n       */\n\
    \      BitFieldModel<uint32_t, 6, 2> dir;\n      /**\n       * @brief PFCTRL field\n\
    \       *\n       * Peripheral flow controller\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      /**\n       * @brief TCIE field\n       *\n       * Transfer\
    \ complete interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> tcie;\n      /**\n       * @brief HTIE field\n       *\n       * Half\
    \ transfer interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      /**\n       * @brief TEIE field\n       *\n       * Transfer\
    \ error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      /**\n       * @brief DMEIE field\n       *\n       * Direct\
    \ mode error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      /**\n       * @brief EN field\n       *\n       * Stream\
    \ enable / flag stream ready when\n       *               read low\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief S3CR register\n   *\n   * stream x configuration\n   *           register\n\
    \   */\n  using s3cr = S3crReg<BaseAddress + 0x0058>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S3ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief NDT field\n     *\n     * Number of data\
    \ items to\n     *               transfer\n     */\n    using ndt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief NDT field\n       *\n \
    \      * Number of data items to\n       *               transfer\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ndt;\n    };\n  };\n\npublic:\n  /**\n \
    \  * @brief S3NDTR register\n   *\n   * stream x number of data\n   *        \
    \   register\n   */\n  using s3ndtr = S3ndtrReg<BaseAddress + 0x005C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class S3parReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief PA field\n     *\n     * Peripheral\
    \ address\n     */\n    using pa = FieldModel<uint32_t, address, 0, 32>;\n\n \
    \ public:\n    /**\n     * @brief Register union\n     *\n     * Can be used to\
    \ create a local register variable for easy bit manipulation.\n     * Useful for\
    \ read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief PA field\n       *\n       * Peripheral address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S3PAR register\n   *\n   * stream x peripheral address\n \
    \  *           register\n   */\n  using s3par = S3parReg<BaseAddress + 0x0060>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S3m0arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M0A field\n     *\n     * Memory\
    \ 0 address\n     */\n    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief M0A field\n       *\n       * Memory 0 address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> m0a;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S3M0AR register\n   *\n   * stream x memory 0 address\n  \
    \ *           register\n   */\n  using s3m0ar = S3m0arReg<BaseAddress + 0x0064>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S3m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M1A field\n     *\n     * Memory\
    \ 1 address (used in case of Double\n     *               buffer mode)\n     */\n\
    \    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ M1A field\n       *\n       * Memory 1 address (used in case of Double\n   \
    \    *               buffer mode)\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 32> m1a;\n    };\n  };\n\npublic:\n  /**\n   * @brief S3M1AR register\n   *\n\
    \   * stream x memory 1 address\n   *           register\n   */\n  using s3m1ar\
    \ = S3m1arReg<BaseAddress + 0x0068>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S3fcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief FEIE field\n     *\n     * FIFO error interrupt\n    \
    \ *               enable\n     */\n    using feie = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    /**\n     * @brief FS field\n     *\n     * FIFO status\n     */\n\
    \    using fs = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     * @brief DMDIS\
    \ field\n     *\n     * Direct mode disable\n     */\n    using dmdis = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief FTH field\n     *\n     * FIFO threshold\
    \ selection\n     */\n    using fth = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief FEIE field\n       *\n       * FIFO error\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> feie;\n      /**\n       * @brief FS field\n       *\n       * FIFO status\n\
    \       */\n      BitFieldModel<uint32_t, 3, 3> fs;\n      /**\n       * @brief\
    \ DMDIS field\n       *\n       * Direct mode disable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmdis;\n      /**\n       * @brief FTH field\n       *\n       * FIFO\
    \ threshold selection\n       */\n      BitFieldModel<uint32_t, 0, 2> fth;\n \
    \   };\n  };\n\npublic:\n  /**\n   * @brief S3FCR register\n   *\n   * stream\
    \ x FIFO control register\n   */\n  using s3fcr = S3fcrReg<BaseAddress + 0x006C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S4crReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CHSEL field\n     *\n     *\
    \ Channel selection\n     */\n    using chsel = FieldModel<uint32_t, address,\
    \ 25, 3>;\n    /**\n     * @brief MBURST field\n     *\n     * Memory burst transfer\n\
    \     *               configuration\n     */\n    using mburst = FieldModel<uint32_t,\
    \ address, 23, 2>;\n    /**\n     * @brief PBURST field\n     *\n     * Peripheral\
    \ burst transfer\n     *               configuration\n     */\n    using pburst\
    \ = FieldModel<uint32_t, address, 21, 2>;\n    /**\n     * @brief ACK field\n\
    \     *\n     * ACK\n     */\n    using ack = FieldModel<uint32_t, address, 20,\
    \ 1>;\n    /**\n     * @brief CT field\n     *\n     * Current target (only in\
    \ double buffer\n     *               mode)\n     */\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief DBM field\n     *\n     * Double buffer\
    \ mode\n     */\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n    /**\n\
    \     * @brief PL field\n     *\n     * Priority level\n     */\n    using pl\
    \ = FieldModel<uint32_t, address, 16, 2>;\n    /**\n     * @brief PINCOS field\n\
    \     *\n     * Peripheral increment offset\n     *               size\n     */\n\
    \    using pincos = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief\
    \ MSIZE field\n     *\n     * Memory data size\n     */\n    using msize = FieldModel<uint32_t,\
    \ address, 13, 2>;\n    /**\n     * @brief PSIZE field\n     *\n     * Peripheral\
    \ data size\n     */\n    using psize = FieldModel<uint32_t, address, 11, 2>;\n\
    \    /**\n     * @brief MINC field\n     *\n     * Memory increment mode\n   \
    \  */\n    using minc = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     *\
    \ @brief PINC field\n     *\n     * Peripheral increment mode\n     */\n    using\
    \ pinc = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief CIRC field\n\
    \     *\n     * Circular mode\n     */\n    using circ = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief DIR field\n     *\n     * Data transfer\
    \ direction\n     */\n    using dir = FieldModel<uint32_t, address, 6, 2>;\n \
    \   /**\n     * @brief PFCTRL field\n     *\n     * Peripheral flow controller\n\
    \     */\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n    /**\n \
    \    * @brief TCIE field\n     *\n     * Transfer complete interrupt\n     * \
    \              enable\n     */\n    using tcie = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief HTIE field\n     *\n     * Half transfer interrupt\n\
    \     *               enable\n     */\n    using htie = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief TEIE field\n     *\n     * Transfer error interrupt\n\
    \     *               enable\n     */\n    using teie = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief DMEIE field\n     *\n     * Direct mode error\
    \ interrupt\n     *               enable\n     */\n    using dmeie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief EN field\n     *\n     * Stream enable\
    \ / flag stream ready when\n     *               read low\n     */\n    using\
    \ en = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CHSEL field\n       *\n       * Channel selection\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 3> chsel;\n      /**\n       * @brief MBURST field\n       *\n       * Memory\
    \ burst transfer\n       *               configuration\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 2> mburst;\n      /**\n       * @brief PBURST field\n       *\n       *\
    \ Peripheral burst transfer\n       *               configuration\n       */\n\
    \      BitFieldModel<uint32_t, 21, 2> pburst;\n      /**\n       * @brief ACK\
    \ field\n       *\n       * ACK\n       */\n      BitFieldModel<uint32_t, 20,\
    \ 1> ack;\n      /**\n       * @brief CT field\n       *\n       * Current target\
    \ (only in double buffer\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      /**\n       * @brief DBM field\n       *\n       * Double\
    \ buffer mode\n       */\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      /**\n\
    \       * @brief PL field\n       *\n       * Priority level\n       */\n    \
    \  BitFieldModel<uint32_t, 16, 2> pl;\n      /**\n       * @brief PINCOS field\n\
    \       *\n       * Peripheral increment offset\n       *               size\n\
    \       */\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      /**\n       *\
    \ @brief MSIZE field\n       *\n       * Memory data size\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      /**\n       * @brief PSIZE field\n       *\n       * Peripheral\
    \ data size\n       */\n      BitFieldModel<uint32_t, 11, 2> psize;\n      /**\n\
    \       * @brief MINC field\n       *\n       * Memory increment mode\n      \
    \ */\n      BitFieldModel<uint32_t, 10, 1> minc;\n      /**\n       * @brief PINC\
    \ field\n       *\n       * Peripheral increment mode\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> pinc;\n      /**\n       * @brief CIRC field\n       *\n       * Circular\
    \ mode\n       */\n      BitFieldModel<uint32_t, 8, 1> circ;\n      /**\n    \
    \   * @brief DIR field\n       *\n       * Data transfer direction\n       */\n\
    \      BitFieldModel<uint32_t, 6, 2> dir;\n      /**\n       * @brief PFCTRL field\n\
    \       *\n       * Peripheral flow controller\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      /**\n       * @brief TCIE field\n       *\n       * Transfer\
    \ complete interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> tcie;\n      /**\n       * @brief HTIE field\n       *\n       * Half\
    \ transfer interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      /**\n       * @brief TEIE field\n       *\n       * Transfer\
    \ error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      /**\n       * @brief DMEIE field\n       *\n       * Direct\
    \ mode error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      /**\n       * @brief EN field\n       *\n       * Stream\
    \ enable / flag stream ready when\n       *               read low\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief S4CR register\n   *\n   * stream x configuration\n   *           register\n\
    \   */\n  using s4cr = S4crReg<BaseAddress + 0x0070>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S4ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief NDT field\n     *\n     * Number of data\
    \ items to\n     *               transfer\n     */\n    using ndt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief NDT field\n       *\n \
    \      * Number of data items to\n       *               transfer\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ndt;\n    };\n  };\n\npublic:\n  /**\n \
    \  * @brief S4NDTR register\n   *\n   * stream x number of data\n   *        \
    \   register\n   */\n  using s4ndtr = S4ndtrReg<BaseAddress + 0x0074>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class S4parReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief PA field\n     *\n     * Peripheral\
    \ address\n     */\n    using pa = FieldModel<uint32_t, address, 0, 32>;\n\n \
    \ public:\n    /**\n     * @brief Register union\n     *\n     * Can be used to\
    \ create a local register variable for easy bit manipulation.\n     * Useful for\
    \ read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief PA field\n       *\n       * Peripheral address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S4PAR register\n   *\n   * stream x peripheral address\n \
    \  *           register\n   */\n  using s4par = S4parReg<BaseAddress + 0x0078>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S4m0arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M0A field\n     *\n     * Memory\
    \ 0 address\n     */\n    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief M0A field\n       *\n       * Memory 0 address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> m0a;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S4M0AR register\n   *\n   * stream x memory 0 address\n  \
    \ *           register\n   */\n  using s4m0ar = S4m0arReg<BaseAddress + 0x007C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S4m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M1A field\n     *\n     * Memory\
    \ 1 address (used in case of Double\n     *               buffer mode)\n     */\n\
    \    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ M1A field\n       *\n       * Memory 1 address (used in case of Double\n   \
    \    *               buffer mode)\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 32> m1a;\n    };\n  };\n\npublic:\n  /**\n   * @brief S4M1AR register\n   *\n\
    \   * stream x memory 1 address\n   *           register\n   */\n  using s4m1ar\
    \ = S4m1arReg<BaseAddress + 0x0080>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S4fcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief FEIE field\n     *\n     * FIFO error interrupt\n    \
    \ *               enable\n     */\n    using feie = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    /**\n     * @brief FS field\n     *\n     * FIFO status\n     */\n\
    \    using fs = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     * @brief DMDIS\
    \ field\n     *\n     * Direct mode disable\n     */\n    using dmdis = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief FTH field\n     *\n     * FIFO threshold\
    \ selection\n     */\n    using fth = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief FEIE field\n       *\n       * FIFO error\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> feie;\n      /**\n       * @brief FS field\n       *\n       * FIFO status\n\
    \       */\n      BitFieldModel<uint32_t, 3, 3> fs;\n      /**\n       * @brief\
    \ DMDIS field\n       *\n       * Direct mode disable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmdis;\n      /**\n       * @brief FTH field\n       *\n       * FIFO\
    \ threshold selection\n       */\n      BitFieldModel<uint32_t, 0, 2> fth;\n \
    \   };\n  };\n\npublic:\n  /**\n   * @brief S4FCR register\n   *\n   * stream\
    \ x FIFO control register\n   */\n  using s4fcr = S4fcrReg<BaseAddress + 0x0084>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S5crReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CHSEL field\n     *\n     *\
    \ Channel selection\n     */\n    using chsel = FieldModel<uint32_t, address,\
    \ 25, 3>;\n    /**\n     * @brief MBURST field\n     *\n     * Memory burst transfer\n\
    \     *               configuration\n     */\n    using mburst = FieldModel<uint32_t,\
    \ address, 23, 2>;\n    /**\n     * @brief PBURST field\n     *\n     * Peripheral\
    \ burst transfer\n     *               configuration\n     */\n    using pburst\
    \ = FieldModel<uint32_t, address, 21, 2>;\n    /**\n     * @brief ACK field\n\
    \     *\n     * ACK\n     */\n    using ack = FieldModel<uint32_t, address, 20,\
    \ 1>;\n    /**\n     * @brief CT field\n     *\n     * Current target (only in\
    \ double buffer\n     *               mode)\n     */\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief DBM field\n     *\n     * Double buffer\
    \ mode\n     */\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n    /**\n\
    \     * @brief PL field\n     *\n     * Priority level\n     */\n    using pl\
    \ = FieldModel<uint32_t, address, 16, 2>;\n    /**\n     * @brief PINCOS field\n\
    \     *\n     * Peripheral increment offset\n     *               size\n     */\n\
    \    using pincos = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief\
    \ MSIZE field\n     *\n     * Memory data size\n     */\n    using msize = FieldModel<uint32_t,\
    \ address, 13, 2>;\n    /**\n     * @brief PSIZE field\n     *\n     * Peripheral\
    \ data size\n     */\n    using psize = FieldModel<uint32_t, address, 11, 2>;\n\
    \    /**\n     * @brief MINC field\n     *\n     * Memory increment mode\n   \
    \  */\n    using minc = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     *\
    \ @brief PINC field\n     *\n     * Peripheral increment mode\n     */\n    using\
    \ pinc = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief CIRC field\n\
    \     *\n     * Circular mode\n     */\n    using circ = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief DIR field\n     *\n     * Data transfer\
    \ direction\n     */\n    using dir = FieldModel<uint32_t, address, 6, 2>;\n \
    \   /**\n     * @brief PFCTRL field\n     *\n     * Peripheral flow controller\n\
    \     */\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n    /**\n \
    \    * @brief TCIE field\n     *\n     * Transfer complete interrupt\n     * \
    \              enable\n     */\n    using tcie = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief HTIE field\n     *\n     * Half transfer interrupt\n\
    \     *               enable\n     */\n    using htie = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief TEIE field\n     *\n     * Transfer error interrupt\n\
    \     *               enable\n     */\n    using teie = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief DMEIE field\n     *\n     * Direct mode error\
    \ interrupt\n     *               enable\n     */\n    using dmeie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief EN field\n     *\n     * Stream enable\
    \ / flag stream ready when\n     *               read low\n     */\n    using\
    \ en = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CHSEL field\n       *\n       * Channel selection\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 3> chsel;\n      /**\n       * @brief MBURST field\n       *\n       * Memory\
    \ burst transfer\n       *               configuration\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 2> mburst;\n      /**\n       * @brief PBURST field\n       *\n       *\
    \ Peripheral burst transfer\n       *               configuration\n       */\n\
    \      BitFieldModel<uint32_t, 21, 2> pburst;\n      /**\n       * @brief ACK\
    \ field\n       *\n       * ACK\n       */\n      BitFieldModel<uint32_t, 20,\
    \ 1> ack;\n      /**\n       * @brief CT field\n       *\n       * Current target\
    \ (only in double buffer\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      /**\n       * @brief DBM field\n       *\n       * Double\
    \ buffer mode\n       */\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      /**\n\
    \       * @brief PL field\n       *\n       * Priority level\n       */\n    \
    \  BitFieldModel<uint32_t, 16, 2> pl;\n      /**\n       * @brief PINCOS field\n\
    \       *\n       * Peripheral increment offset\n       *               size\n\
    \       */\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      /**\n       *\
    \ @brief MSIZE field\n       *\n       * Memory data size\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      /**\n       * @brief PSIZE field\n       *\n       * Peripheral\
    \ data size\n       */\n      BitFieldModel<uint32_t, 11, 2> psize;\n      /**\n\
    \       * @brief MINC field\n       *\n       * Memory increment mode\n      \
    \ */\n      BitFieldModel<uint32_t, 10, 1> minc;\n      /**\n       * @brief PINC\
    \ field\n       *\n       * Peripheral increment mode\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> pinc;\n      /**\n       * @brief CIRC field\n       *\n       * Circular\
    \ mode\n       */\n      BitFieldModel<uint32_t, 8, 1> circ;\n      /**\n    \
    \   * @brief DIR field\n       *\n       * Data transfer direction\n       */\n\
    \      BitFieldModel<uint32_t, 6, 2> dir;\n      /**\n       * @brief PFCTRL field\n\
    \       *\n       * Peripheral flow controller\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      /**\n       * @brief TCIE field\n       *\n       * Transfer\
    \ complete interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> tcie;\n      /**\n       * @brief HTIE field\n       *\n       * Half\
    \ transfer interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      /**\n       * @brief TEIE field\n       *\n       * Transfer\
    \ error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      /**\n       * @brief DMEIE field\n       *\n       * Direct\
    \ mode error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      /**\n       * @brief EN field\n       *\n       * Stream\
    \ enable / flag stream ready when\n       *               read low\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief S5CR register\n   *\n   * stream x configuration\n   *           register\n\
    \   */\n  using s5cr = S5crReg<BaseAddress + 0x0088>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S5ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief NDT field\n     *\n     * Number of data\
    \ items to\n     *               transfer\n     */\n    using ndt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief NDT field\n       *\n \
    \      * Number of data items to\n       *               transfer\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ndt;\n    };\n  };\n\npublic:\n  /**\n \
    \  * @brief S5NDTR register\n   *\n   * stream x number of data\n   *        \
    \   register\n   */\n  using s5ndtr = S5ndtrReg<BaseAddress + 0x008C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class S5parReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief PA field\n     *\n     * Peripheral\
    \ address\n     */\n    using pa = FieldModel<uint32_t, address, 0, 32>;\n\n \
    \ public:\n    /**\n     * @brief Register union\n     *\n     * Can be used to\
    \ create a local register variable for easy bit manipulation.\n     * Useful for\
    \ read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief PA field\n       *\n       * Peripheral address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S5PAR register\n   *\n   * stream x peripheral address\n \
    \  *           register\n   */\n  using s5par = S5parReg<BaseAddress + 0x0090>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S5m0arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M0A field\n     *\n     * Memory\
    \ 0 address\n     */\n    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief M0A field\n       *\n       * Memory 0 address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> m0a;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S5M0AR register\n   *\n   * stream x memory 0 address\n  \
    \ *           register\n   */\n  using s5m0ar = S5m0arReg<BaseAddress + 0x0094>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S5m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M1A field\n     *\n     * Memory\
    \ 1 address (used in case of Double\n     *               buffer mode)\n     */\n\
    \    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ M1A field\n       *\n       * Memory 1 address (used in case of Double\n   \
    \    *               buffer mode)\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 32> m1a;\n    };\n  };\n\npublic:\n  /**\n   * @brief S5M1AR register\n   *\n\
    \   * stream x memory 1 address\n   *           register\n   */\n  using s5m1ar\
    \ = S5m1arReg<BaseAddress + 0x0098>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S5fcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief FEIE field\n     *\n     * FIFO error interrupt\n    \
    \ *               enable\n     */\n    using feie = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    /**\n     * @brief FS field\n     *\n     * FIFO status\n     */\n\
    \    using fs = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     * @brief DMDIS\
    \ field\n     *\n     * Direct mode disable\n     */\n    using dmdis = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief FTH field\n     *\n     * FIFO threshold\
    \ selection\n     */\n    using fth = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief FEIE field\n       *\n       * FIFO error\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> feie;\n      /**\n       * @brief FS field\n       *\n       * FIFO status\n\
    \       */\n      BitFieldModel<uint32_t, 3, 3> fs;\n      /**\n       * @brief\
    \ DMDIS field\n       *\n       * Direct mode disable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmdis;\n      /**\n       * @brief FTH field\n       *\n       * FIFO\
    \ threshold selection\n       */\n      BitFieldModel<uint32_t, 0, 2> fth;\n \
    \   };\n  };\n\npublic:\n  /**\n   * @brief S5FCR register\n   *\n   * stream\
    \ x FIFO control register\n   */\n  using s5fcr = S5fcrReg<BaseAddress + 0x009C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S6crReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CHSEL field\n     *\n     *\
    \ Channel selection\n     */\n    using chsel = FieldModel<uint32_t, address,\
    \ 25, 3>;\n    /**\n     * @brief MBURST field\n     *\n     * Memory burst transfer\n\
    \     *               configuration\n     */\n    using mburst = FieldModel<uint32_t,\
    \ address, 23, 2>;\n    /**\n     * @brief PBURST field\n     *\n     * Peripheral\
    \ burst transfer\n     *               configuration\n     */\n    using pburst\
    \ = FieldModel<uint32_t, address, 21, 2>;\n    /**\n     * @brief ACK field\n\
    \     *\n     * ACK\n     */\n    using ack = FieldModel<uint32_t, address, 20,\
    \ 1>;\n    /**\n     * @brief CT field\n     *\n     * Current target (only in\
    \ double buffer\n     *               mode)\n     */\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief DBM field\n     *\n     * Double buffer\
    \ mode\n     */\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n    /**\n\
    \     * @brief PL field\n     *\n     * Priority level\n     */\n    using pl\
    \ = FieldModel<uint32_t, address, 16, 2>;\n    /**\n     * @brief PINCOS field\n\
    \     *\n     * Peripheral increment offset\n     *               size\n     */\n\
    \    using pincos = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief\
    \ MSIZE field\n     *\n     * Memory data size\n     */\n    using msize = FieldModel<uint32_t,\
    \ address, 13, 2>;\n    /**\n     * @brief PSIZE field\n     *\n     * Peripheral\
    \ data size\n     */\n    using psize = FieldModel<uint32_t, address, 11, 2>;\n\
    \    /**\n     * @brief MINC field\n     *\n     * Memory increment mode\n   \
    \  */\n    using minc = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     *\
    \ @brief PINC field\n     *\n     * Peripheral increment mode\n     */\n    using\
    \ pinc = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief CIRC field\n\
    \     *\n     * Circular mode\n     */\n    using circ = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief DIR field\n     *\n     * Data transfer\
    \ direction\n     */\n    using dir = FieldModel<uint32_t, address, 6, 2>;\n \
    \   /**\n     * @brief PFCTRL field\n     *\n     * Peripheral flow controller\n\
    \     */\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n    /**\n \
    \    * @brief TCIE field\n     *\n     * Transfer complete interrupt\n     * \
    \              enable\n     */\n    using tcie = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief HTIE field\n     *\n     * Half transfer interrupt\n\
    \     *               enable\n     */\n    using htie = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief TEIE field\n     *\n     * Transfer error interrupt\n\
    \     *               enable\n     */\n    using teie = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief DMEIE field\n     *\n     * Direct mode error\
    \ interrupt\n     *               enable\n     */\n    using dmeie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief EN field\n     *\n     * Stream enable\
    \ / flag stream ready when\n     *               read low\n     */\n    using\
    \ en = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CHSEL field\n       *\n       * Channel selection\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 3> chsel;\n      /**\n       * @brief MBURST field\n       *\n       * Memory\
    \ burst transfer\n       *               configuration\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 2> mburst;\n      /**\n       * @brief PBURST field\n       *\n       *\
    \ Peripheral burst transfer\n       *               configuration\n       */\n\
    \      BitFieldModel<uint32_t, 21, 2> pburst;\n      /**\n       * @brief ACK\
    \ field\n       *\n       * ACK\n       */\n      BitFieldModel<uint32_t, 20,\
    \ 1> ack;\n      /**\n       * @brief CT field\n       *\n       * Current target\
    \ (only in double buffer\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      /**\n       * @brief DBM field\n       *\n       * Double\
    \ buffer mode\n       */\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      /**\n\
    \       * @brief PL field\n       *\n       * Priority level\n       */\n    \
    \  BitFieldModel<uint32_t, 16, 2> pl;\n      /**\n       * @brief PINCOS field\n\
    \       *\n       * Peripheral increment offset\n       *               size\n\
    \       */\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      /**\n       *\
    \ @brief MSIZE field\n       *\n       * Memory data size\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      /**\n       * @brief PSIZE field\n       *\n       * Peripheral\
    \ data size\n       */\n      BitFieldModel<uint32_t, 11, 2> psize;\n      /**\n\
    \       * @brief MINC field\n       *\n       * Memory increment mode\n      \
    \ */\n      BitFieldModel<uint32_t, 10, 1> minc;\n      /**\n       * @brief PINC\
    \ field\n       *\n       * Peripheral increment mode\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> pinc;\n      /**\n       * @brief CIRC field\n       *\n       * Circular\
    \ mode\n       */\n      BitFieldModel<uint32_t, 8, 1> circ;\n      /**\n    \
    \   * @brief DIR field\n       *\n       * Data transfer direction\n       */\n\
    \      BitFieldModel<uint32_t, 6, 2> dir;\n      /**\n       * @brief PFCTRL field\n\
    \       *\n       * Peripheral flow controller\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      /**\n       * @brief TCIE field\n       *\n       * Transfer\
    \ complete interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> tcie;\n      /**\n       * @brief HTIE field\n       *\n       * Half\
    \ transfer interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      /**\n       * @brief TEIE field\n       *\n       * Transfer\
    \ error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      /**\n       * @brief DMEIE field\n       *\n       * Direct\
    \ mode error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      /**\n       * @brief EN field\n       *\n       * Stream\
    \ enable / flag stream ready when\n       *               read low\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief S6CR register\n   *\n   * stream x configuration\n   *           register\n\
    \   */\n  using s6cr = S6crReg<BaseAddress + 0x00A0>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S6ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief NDT field\n     *\n     * Number of data\
    \ items to\n     *               transfer\n     */\n    using ndt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief NDT field\n       *\n \
    \      * Number of data items to\n       *               transfer\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ndt;\n    };\n  };\n\npublic:\n  /**\n \
    \  * @brief S6NDTR register\n   *\n   * stream x number of data\n   *        \
    \   register\n   */\n  using s6ndtr = S6ndtrReg<BaseAddress + 0x00A4>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class S6parReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief PA field\n     *\n     * Peripheral\
    \ address\n     */\n    using pa = FieldModel<uint32_t, address, 0, 32>;\n\n \
    \ public:\n    /**\n     * @brief Register union\n     *\n     * Can be used to\
    \ create a local register variable for easy bit manipulation.\n     * Useful for\
    \ read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief PA field\n       *\n       * Peripheral address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S6PAR register\n   *\n   * stream x peripheral address\n \
    \  *           register\n   */\n  using s6par = S6parReg<BaseAddress + 0x00A8>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S6m0arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M0A field\n     *\n     * Memory\
    \ 0 address\n     */\n    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief M0A field\n       *\n       * Memory 0 address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> m0a;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S6M0AR register\n   *\n   * stream x memory 0 address\n  \
    \ *           register\n   */\n  using s6m0ar = S6m0arReg<BaseAddress + 0x00AC>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S6m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M1A field\n     *\n     * Memory\
    \ 1 address (used in case of Double\n     *               buffer mode)\n     */\n\
    \    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ M1A field\n       *\n       * Memory 1 address (used in case of Double\n   \
    \    *               buffer mode)\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 32> m1a;\n    };\n  };\n\npublic:\n  /**\n   * @brief S6M1AR register\n   *\n\
    \   * stream x memory 1 address\n   *           register\n   */\n  using s6m1ar\
    \ = S6m1arReg<BaseAddress + 0x00B0>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S6fcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief FEIE field\n     *\n     * FIFO error interrupt\n    \
    \ *               enable\n     */\n    using feie = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    /**\n     * @brief FS field\n     *\n     * FIFO status\n     */\n\
    \    using fs = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     * @brief DMDIS\
    \ field\n     *\n     * Direct mode disable\n     */\n    using dmdis = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief FTH field\n     *\n     * FIFO threshold\
    \ selection\n     */\n    using fth = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief FEIE field\n       *\n       * FIFO error\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> feie;\n      /**\n       * @brief FS field\n       *\n       * FIFO status\n\
    \       */\n      BitFieldModel<uint32_t, 3, 3> fs;\n      /**\n       * @brief\
    \ DMDIS field\n       *\n       * Direct mode disable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmdis;\n      /**\n       * @brief FTH field\n       *\n       * FIFO\
    \ threshold selection\n       */\n      BitFieldModel<uint32_t, 0, 2> fth;\n \
    \   };\n  };\n\npublic:\n  /**\n   * @brief S6FCR register\n   *\n   * stream\
    \ x FIFO control register\n   */\n  using s6fcr = S6fcrReg<BaseAddress + 0x00B4>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S7crReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CHSEL field\n     *\n     *\
    \ Channel selection\n     */\n    using chsel = FieldModel<uint32_t, address,\
    \ 25, 3>;\n    /**\n     * @brief MBURST field\n     *\n     * Memory burst transfer\n\
    \     *               configuration\n     */\n    using mburst = FieldModel<uint32_t,\
    \ address, 23, 2>;\n    /**\n     * @brief PBURST field\n     *\n     * Peripheral\
    \ burst transfer\n     *               configuration\n     */\n    using pburst\
    \ = FieldModel<uint32_t, address, 21, 2>;\n    /**\n     * @brief ACK field\n\
    \     *\n     * ACK\n     */\n    using ack = FieldModel<uint32_t, address, 20,\
    \ 1>;\n    /**\n     * @brief CT field\n     *\n     * Current target (only in\
    \ double buffer\n     *               mode)\n     */\n    using ct = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief DBM field\n     *\n     * Double buffer\
    \ mode\n     */\n    using dbm = FieldModel<uint32_t, address, 18, 1>;\n    /**\n\
    \     * @brief PL field\n     *\n     * Priority level\n     */\n    using pl\
    \ = FieldModel<uint32_t, address, 16, 2>;\n    /**\n     * @brief PINCOS field\n\
    \     *\n     * Peripheral increment offset\n     *               size\n     */\n\
    \    using pincos = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief\
    \ MSIZE field\n     *\n     * Memory data size\n     */\n    using msize = FieldModel<uint32_t,\
    \ address, 13, 2>;\n    /**\n     * @brief PSIZE field\n     *\n     * Peripheral\
    \ data size\n     */\n    using psize = FieldModel<uint32_t, address, 11, 2>;\n\
    \    /**\n     * @brief MINC field\n     *\n     * Memory increment mode\n   \
    \  */\n    using minc = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     *\
    \ @brief PINC field\n     *\n     * Peripheral increment mode\n     */\n    using\
    \ pinc = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief CIRC field\n\
    \     *\n     * Circular mode\n     */\n    using circ = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief DIR field\n     *\n     * Data transfer\
    \ direction\n     */\n    using dir = FieldModel<uint32_t, address, 6, 2>;\n \
    \   /**\n     * @brief PFCTRL field\n     *\n     * Peripheral flow controller\n\
    \     */\n    using pfctrl = FieldModel<uint32_t, address, 5, 1>;\n    /**\n \
    \    * @brief TCIE field\n     *\n     * Transfer complete interrupt\n     * \
    \              enable\n     */\n    using tcie = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief HTIE field\n     *\n     * Half transfer interrupt\n\
    \     *               enable\n     */\n    using htie = FieldModel<uint32_t, address,\
    \ 3, 1>;\n    /**\n     * @brief TEIE field\n     *\n     * Transfer error interrupt\n\
    \     *               enable\n     */\n    using teie = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief DMEIE field\n     *\n     * Direct mode error\
    \ interrupt\n     *               enable\n     */\n    using dmeie = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief EN field\n     *\n     * Stream enable\
    \ / flag stream ready when\n     *               read low\n     */\n    using\
    \ en = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ CHSEL field\n       *\n       * Channel selection\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 3> chsel;\n      /**\n       * @brief MBURST field\n       *\n       * Memory\
    \ burst transfer\n       *               configuration\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 2> mburst;\n      /**\n       * @brief PBURST field\n       *\n       *\
    \ Peripheral burst transfer\n       *               configuration\n       */\n\
    \      BitFieldModel<uint32_t, 21, 2> pburst;\n      /**\n       * @brief ACK\
    \ field\n       *\n       * ACK\n       */\n      BitFieldModel<uint32_t, 20,\
    \ 1> ack;\n      /**\n       * @brief CT field\n       *\n       * Current target\
    \ (only in double buffer\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> ct;\n      /**\n       * @brief DBM field\n       *\n       * Double\
    \ buffer mode\n       */\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      /**\n\
    \       * @brief PL field\n       *\n       * Priority level\n       */\n    \
    \  BitFieldModel<uint32_t, 16, 2> pl;\n      /**\n       * @brief PINCOS field\n\
    \       *\n       * Peripheral increment offset\n       *               size\n\
    \       */\n      BitFieldModel<uint32_t, 15, 1> pincos;\n      /**\n       *\
    \ @brief MSIZE field\n       *\n       * Memory data size\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 2> msize;\n      /**\n       * @brief PSIZE field\n       *\n       * Peripheral\
    \ data size\n       */\n      BitFieldModel<uint32_t, 11, 2> psize;\n      /**\n\
    \       * @brief MINC field\n       *\n       * Memory increment mode\n      \
    \ */\n      BitFieldModel<uint32_t, 10, 1> minc;\n      /**\n       * @brief PINC\
    \ field\n       *\n       * Peripheral increment mode\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> pinc;\n      /**\n       * @brief CIRC field\n       *\n       * Circular\
    \ mode\n       */\n      BitFieldModel<uint32_t, 8, 1> circ;\n      /**\n    \
    \   * @brief DIR field\n       *\n       * Data transfer direction\n       */\n\
    \      BitFieldModel<uint32_t, 6, 2> dir;\n      /**\n       * @brief PFCTRL field\n\
    \       *\n       * Peripheral flow controller\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> pfctrl;\n      /**\n       * @brief TCIE field\n       *\n       * Transfer\
    \ complete interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> tcie;\n      /**\n       * @brief HTIE field\n       *\n       * Half\
    \ transfer interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      /**\n       * @brief TEIE field\n       *\n       * Transfer\
    \ error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      /**\n       * @brief DMEIE field\n       *\n       * Direct\
    \ mode error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      /**\n       * @brief EN field\n       *\n       * Stream\
    \ enable / flag stream ready when\n       *               read low\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief S7CR register\n   *\n   * stream x configuration\n   *           register\n\
    \   */\n  using s7cr = S7crReg<BaseAddress + 0x00B8>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class S7ndtrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief NDT field\n     *\n     * Number of data\
    \ items to\n     *               transfer\n     */\n    using ndt = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief NDT field\n       *\n \
    \      * Number of data items to\n       *               transfer\n       */\n\
    \      BitFieldModel<uint32_t, 0, 16> ndt;\n    };\n  };\n\npublic:\n  /**\n \
    \  * @brief S7NDTR register\n   *\n   * stream x number of data\n   *        \
    \   register\n   */\n  using s7ndtr = S7ndtrReg<BaseAddress + 0x00BC>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class S7parReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief PA field\n     *\n     * Peripheral\
    \ address\n     */\n    using pa = FieldModel<uint32_t, address, 0, 32>;\n\n \
    \ public:\n    /**\n     * @brief Register union\n     *\n     * Can be used to\
    \ create a local register variable for easy bit manipulation.\n     * Useful for\
    \ read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief PA field\n       *\n       * Peripheral address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S7PAR register\n   *\n   * stream x peripheral address\n \
    \  *           register\n   */\n  using s7par = S7parReg<BaseAddress + 0x00C0>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S7m0arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M0A field\n     *\n     * Memory\
    \ 0 address\n     */\n    using m0a = FieldModel<uint32_t, address, 0, 32>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief M0A field\n       *\n       * Memory 0 address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> m0a;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief S7M0AR register\n   *\n   * stream x memory 0 address\n  \
    \ *           register\n   */\n  using s7m0ar = S7m0arReg<BaseAddress + 0x00C4>;\n\
    \nprivate:\n  template<unsigned int address>\n  class S7m1arReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief M1A field\n     *\n     * Memory\
    \ 1 address (used in case of Double\n     *               buffer mode)\n     */\n\
    \    using m1a = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ M1A field\n       *\n       * Memory 1 address (used in case of Double\n   \
    \    *               buffer mode)\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 32> m1a;\n    };\n  };\n\npublic:\n  /**\n   * @brief S7M1AR register\n   *\n\
    \   * stream x memory 1 address\n   *           register\n   */\n  using s7m1ar\
    \ = S7m1arReg<BaseAddress + 0x00C8>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class S7fcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief FEIE field\n     *\n     * FIFO error interrupt\n    \
    \ *               enable\n     */\n    using feie = FieldModel<uint32_t, address,\
    \ 7, 1>;\n    /**\n     * @brief FS field\n     *\n     * FIFO status\n     */\n\
    \    using fs = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     * @brief DMDIS\
    \ field\n     *\n     * Direct mode disable\n     */\n    using dmdis = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief FTH field\n     *\n     * FIFO threshold\
    \ selection\n     */\n    using fth = FieldModel<uint32_t, address, 0, 2>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief FEIE field\n       *\n       * FIFO error\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> feie;\n      /**\n       * @brief FS field\n       *\n       * FIFO status\n\
    \       */\n      BitFieldModel<uint32_t, 3, 3> fs;\n      /**\n       * @brief\
    \ DMDIS field\n       *\n       * Direct mode disable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> dmdis;\n      /**\n       * @brief FTH field\n       *\n       * FIFO\
    \ threshold selection\n       */\n      BitFieldModel<uint32_t, 0, 2> fth;\n \
    \   };\n  };\n\npublic:\n  /**\n   * @brief S7FCR register\n   *\n   * stream\
    \ x FIFO control register\n   */\n  using s7fcr = S7fcrReg<BaseAddress + 0x00CC>;\n\
    \nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n  class\
    \ SxndtrBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n\
    \  public:\n    /**\n     * @brief NDT field\n     *\n     * Number of data items\
    \ to\n     *               transfer\n     */\n    using ndt = FieldModel<uint32_t,\
    \ address, 0, 16, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief NDT field\n       *\n       * Number of data\
    \ items to\n       *               transfer\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> ndt;\n    };\n  };\n\npublic:\n  /**\n   * @brief SXNDTR register bank\n\
    \   *\n   * stream x number of data\n   *           register\n   */\n  using sxndtr\
    \ = SxndtrBankReg<BaseAddress + 0x0014, 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class SxparBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    /**\n     * @brief PA field\n    \
    \ *\n     * Peripheral address\n     */\n    using pa = FieldModel<uint32_t, address,\
    \ 0, 32, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      /**\n       * @brief PA field\n       *\n       * Peripheral address\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> pa;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief SXPAR register bank\n   *\n   * stream x peripheral address\n\
    \   *           register\n   */\n  using sxpar = SxparBankReg<BaseAddress + 0x0018,\
    \ 0x0018>;\n\nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n\
    \  class Sxm0arBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n\
    \  {\n  public:\n    /**\n     * @brief M0A field\n     *\n     * Memory 0 address\n\
    \     */\n    using m0a = FieldModel<uint32_t, address, 0, 32, bankOffset>;\n\n\
    \  public:\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ M0A field\n       *\n       * Memory 0 address\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> m0a;\n    };\n  };\n\npublic:\n  /**\n   * @brief SXM0AR register bank\n\
    \   *\n   * stream x memory 0 address\n   *           register\n   */\n  using\
    \ sxm0ar = Sxm0arBankReg<BaseAddress + 0x001C, 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class Sxm1arBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    /**\n     * @brief M1A field\n   \
    \  *\n     * Memory 1 address (used in case of Double\n     *               buffer\
    \ mode)\n     */\n    using m1a = FieldModel<uint32_t, address, 0, 32, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      /**\n       *\
    \ @brief M1A field\n       *\n       * Memory 1 address (used in case of Double\n\
    \       *               buffer mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> m1a;\n    };\n  };\n\npublic:\n  /**\n   * @brief SXM1AR register bank\n\
    \   *\n   * stream x memory 1 address\n   *           register\n   */\n  using\
    \ sxm1ar = Sxm1arBankReg<BaseAddress + 0x0020, 0x0018>;\n\nprivate:\n  template<unsigned\
    \ int address, unsigned int bankOffset>\n  class SxfcrBankReg : public RegisterBankModel<uint32_t,\
    \ address, bankOffset>\n  {\n  public:\n    /**\n     * @brief FEIE field\n  \
    \   *\n     * FIFO error interrupt\n     *               enable\n     */\n   \
    \ using feie = FieldModel<uint32_t, address, 7, 1, bankOffset>;\n    /**\n   \
    \  * @brief FS field\n     *\n     * FIFO status\n     */\n    using fs = FieldModel<uint32_t,\
    \ address, 3, 3, bankOffset>;\n    /**\n     * @brief DMDIS field\n     *\n  \
    \   * Direct mode disable\n     */\n    using dmdis = FieldModel<uint32_t, address,\
    \ 2, 1, bankOffset>;\n    /**\n     * @brief FTH field\n     *\n     * FIFO threshold\
    \ selection\n     */\n    using fth = FieldModel<uint32_t, address, 0, 2, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      /**\n       *\
    \ @brief FEIE field\n       *\n       * FIFO error interrupt\n       *       \
    \        enable\n       */\n      BitFieldModel<uint32_t, 7, 1> feie;\n      /**\n\
    \       * @brief FS field\n       *\n       * FIFO status\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 3> fs;\n      /**\n       * @brief DMDIS field\n       *\n       * Direct\
    \ mode disable\n       */\n      BitFieldModel<uint32_t, 2, 1> dmdis;\n      /**\n\
    \       * @brief FTH field\n       *\n       * FIFO threshold selection\n    \
    \   */\n      BitFieldModel<uint32_t, 0, 2> fth;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief SXFCR register bank\n   *\n   * stream x FIFO control register\n\
    \   */\n  using sxfcr = SxfcrBankReg<BaseAddress + 0x0024, 0x0018>;\n\nprivate:\n\
    \  template<unsigned int address, unsigned int bankOffset>\n  class SxcrBankReg\
    \ : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n  public:\n\
    \    /**\n     * @brief CHSEL field\n     *\n     * Channel selection\n     */\n\
    \    using chsel = FieldModel<uint32_t, address, 25, 3, bankOffset>;\n    /**\n\
    \     * @brief MBURST field\n     *\n     * Memory burst transfer\n     *    \
    \           configuration\n     */\n    using mburst = FieldModel<uint32_t, address,\
    \ 23, 2, bankOffset>;\n    /**\n     * @brief PBURST field\n     *\n     * Peripheral\
    \ burst transfer\n     *               configuration\n     */\n    using pburst\
    \ = FieldModel<uint32_t, address, 21, 2, bankOffset>;\n    /**\n     * @brief\
    \ ACK field\n     *\n     * ACK\n     */\n    using ack = FieldModel<uint32_t,\
    \ address, 20, 1, bankOffset>;\n    /**\n     * @brief CT field\n     *\n    \
    \ * Current target (only in double buffer\n     *               mode)\n     */\n\
    \    using ct = FieldModel<uint32_t, address, 19, 1, bankOffset>;\n    /**\n \
    \    * @brief DBM field\n     *\n     * Double buffer mode\n     */\n    using\
    \ dbm = FieldModel<uint32_t, address, 18, 1, bankOffset>;\n    /**\n     * @brief\
    \ PL field\n     *\n     * Priority level\n     */\n    using pl = FieldModel<uint32_t,\
    \ address, 16, 2, bankOffset>;\n    /**\n     * @brief PINCOS field\n     *\n\
    \     * Peripheral increment offset\n     *               size\n     */\n    using\
    \ pincos = FieldModel<uint32_t, address, 15, 1, bankOffset>;\n    /**\n     *\
    \ @brief MSIZE field\n     *\n     * Memory data size\n     */\n    using msize\
    \ = FieldModel<uint32_t, address, 13, 2, bankOffset>;\n    /**\n     * @brief\
    \ PSIZE field\n     *\n     * Peripheral data size\n     */\n    using psize =\
    \ FieldModel<uint32_t, address, 11, 2, bankOffset>;\n    /**\n     * @brief MINC\
    \ field\n     *\n     * Memory increment mode\n     */\n    using minc = FieldModel<uint32_t,\
    \ address, 10, 1, bankOffset>;\n    /**\n     * @brief PINC field\n     *\n  \
    \   * Peripheral increment mode\n     */\n    using pinc = FieldModel<uint32_t,\
    \ address, 9, 1, bankOffset>;\n    /**\n     * @brief CIRC field\n     *\n   \
    \  * Circular mode\n     */\n    using circ = FieldModel<uint32_t, address, 8,\
    \ 1, bankOffset>;\n    /**\n     * @brief DIR field\n     *\n     * Data transfer\
    \ direction\n     */\n    using dir = FieldModel<uint32_t, address, 6, 2, bankOffset>;\n\
    \    /**\n     * @brief PFCTRL field\n     *\n     * Peripheral flow controller\n\
    \     */\n    using pfctrl = FieldModel<uint32_t, address, 5, 1, bankOffset>;\n\
    \    /**\n     * @brief TCIE field\n     *\n     * Transfer complete interrupt\n\
    \     *               enable\n     */\n    using tcie = FieldModel<uint32_t, address,\
    \ 4, 1, bankOffset>;\n    /**\n     * @brief HTIE field\n     *\n     * Half transfer\
    \ interrupt\n     *               enable\n     */\n    using htie = FieldModel<uint32_t,\
    \ address, 3, 1, bankOffset>;\n    /**\n     * @brief TEIE field\n     *\n   \
    \  * Transfer error interrupt\n     *               enable\n     */\n    using\
    \ teie = FieldModel<uint32_t, address, 2, 1, bankOffset>;\n    /**\n     * @brief\
    \ DMEIE field\n     *\n     * Direct mode error interrupt\n     *            \
    \   enable\n     */\n    using dmeie = FieldModel<uint32_t, address, 1, 1, bankOffset>;\n\
    \    /**\n     * @brief EN field\n     *\n     * Stream enable / flag stream ready\
    \ when\n     *               read low\n     */\n    using en = FieldModel<uint32_t,\
    \ address, 0, 1, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief CHSEL field\n       *\n       * Channel selection\n\
    \       */\n      BitFieldModel<uint32_t, 25, 3> chsel;\n      /**\n       * @brief\
    \ MBURST field\n       *\n       * Memory burst transfer\n       *           \
    \    configuration\n       */\n      BitFieldModel<uint32_t, 23, 2> mburst;\n\
    \      /**\n       * @brief PBURST field\n       *\n       * Peripheral burst\
    \ transfer\n       *               configuration\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 2> pburst;\n      /**\n       * @brief ACK field\n       *\n       * ACK\n\
    \       */\n      BitFieldModel<uint32_t, 20, 1> ack;\n      /**\n       * @brief\
    \ CT field\n       *\n       * Current target (only in double buffer\n       *\
    \               mode)\n       */\n      BitFieldModel<uint32_t, 19, 1> ct;\n \
    \     /**\n       * @brief DBM field\n       *\n       * Double buffer mode\n\
    \       */\n      BitFieldModel<uint32_t, 18, 1> dbm;\n      /**\n       * @brief\
    \ PL field\n       *\n       * Priority level\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 2> pl;\n      /**\n       * @brief PINCOS field\n       *\n       * Peripheral\
    \ increment offset\n       *               size\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> pincos;\n      /**\n       * @brief MSIZE field\n       *\n       * Memory\
    \ data size\n       */\n      BitFieldModel<uint32_t, 13, 2> msize;\n      /**\n\
    \       * @brief PSIZE field\n       *\n       * Peripheral data size\n      \
    \ */\n      BitFieldModel<uint32_t, 11, 2> psize;\n      /**\n       * @brief\
    \ MINC field\n       *\n       * Memory increment mode\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> minc;\n      /**\n       * @brief PINC field\n       *\n       * Peripheral\
    \ increment mode\n       */\n      BitFieldModel<uint32_t, 9, 1> pinc;\n     \
    \ /**\n       * @brief CIRC field\n       *\n       * Circular mode\n       */\n\
    \      BitFieldModel<uint32_t, 8, 1> circ;\n      /**\n       * @brief DIR field\n\
    \       *\n       * Data transfer direction\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 2> dir;\n      /**\n       * @brief PFCTRL field\n       *\n       * Peripheral\
    \ flow controller\n       */\n      BitFieldModel<uint32_t, 5, 1> pfctrl;\n  \
    \    /**\n       * @brief TCIE field\n       *\n       * Transfer complete interrupt\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 4, 1>\
    \ tcie;\n      /**\n       * @brief HTIE field\n       *\n       * Half transfer\
    \ interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> htie;\n      /**\n       * @brief TEIE field\n       *\n       * Transfer\
    \ error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> teie;\n      /**\n       * @brief DMEIE field\n       *\n       * Direct\
    \ mode error interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dmeie;\n      /**\n       * @brief EN field\n       *\n       * Stream\
    \ enable / flag stream ready when\n       *               read low\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> en;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief SXCR register bank\n   *\n   * stream x configuration\n   *         \
    \  register\n   */\n  using sxcr = SxcrBankReg<BaseAddress + 0x0028, 0x0018>;\n\
    \n};\n\n}\n\n#endif /* DRAL_STM32F411_DMA1_H */"
  name: DMA1
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_GPIOH_H\n#define DRAL_STM32F411_GPIOH_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ GPIOH peripheral\n *\n * General-purpose I/Os\n */\nclass gpioh\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40021C00; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class ModerReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ MODER15 field\n     *\n     * Port x configuration bits (y =\n     *       \
    \        0..15)\n     */\n    using moder15 = FieldModel<uint32_t, address, 30,\
    \ 2>;\n    /**\n     * @brief MODER14 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using moder14 = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    /**\n     * @brief MODER13 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using moder13\
    \ = FieldModel<uint32_t, address, 26, 2>;\n    /**\n     * @brief MODER12 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder12 = FieldModel<uint32_t, address, 24, 2>;\n    /**\n\
    \     * @brief MODER11 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using moder11 = FieldModel<uint32_t,\
    \ address, 22, 2>;\n    /**\n     * @brief MODER10 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using moder10\
    \ = FieldModel<uint32_t, address, 20, 2>;\n    /**\n     * @brief MODER9 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder9 = FieldModel<uint32_t, address, 18, 2>;\n    /**\n\
    \     * @brief MODER8 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using moder8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    /**\n     * @brief MODER7 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using moder7\
    \ = FieldModel<uint32_t, address, 14, 2>;\n    /**\n     * @brief MODER6 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder6 = FieldModel<uint32_t, address, 12, 2>;\n    /**\n\
    \     * @brief MODER5 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using moder5 = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    /**\n     * @brief MODER4 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using moder4\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief MODER3 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder3 = FieldModel<uint32_t, address, 6, 2>;\n    /**\n \
    \    * @brief MODER2 field\n     *\n     * Port x configuration bits (y =\n  \
    \   *               0..15)\n     */\n    using moder2 = FieldModel<uint32_t, address,\
    \ 4, 2>;\n    /**\n     * @brief MODER1 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using moder1 = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    /**\n     * @brief MODER0 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using moder0\
    \ = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ MODER15 field\n       *\n       * Port x configuration bits (y =\n       * \
    \              0..15)\n       */\n      BitFieldModel<uint32_t, 30, 2> moder15;\n\
    \      /**\n       * @brief MODER14 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 28, 2> moder14;\n      /**\n       * @brief MODER13 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 26, 2> moder13;\n      /**\n       * @brief MODER12\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 24, 2> moder12;\n    \
    \  /**\n       * @brief MODER11 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 2> moder11;\n      /**\n       * @brief MODER10 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 20, 2> moder10;\n      /**\n       * @brief MODER9\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 18, 2> moder9;\n     \
    \ /**\n       * @brief MODER8 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 2> moder8;\n      /**\n       * @brief MODER7 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 14, 2> moder7;\n      /**\n       * @brief MODER6\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 12, 2> moder6;\n     \
    \ /**\n       * @brief MODER5 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 2> moder5;\n      /**\n       * @brief MODER4 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 8, 2> moder4;\n      /**\n       * @brief MODER3\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 6, 2> moder3;\n      /**\n\
    \       * @brief MODER2 field\n       *\n       * Port x configuration bits (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 2> moder2;\n      /**\n       * @brief MODER1 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 2> moder1;\n      /**\n       * @brief MODER0 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> moder0;\n    };\n  };\n\npublic:\n  /**\n   * @brief MODER register\n\
    \   *\n   * GPIO port mode register\n   */\n  using moder = ModerReg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class OtyperReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ OT15 field\n     *\n     * Port x configuration bits (y =\n     *          \
    \     0..15)\n     */\n    using ot15 = FieldModel<uint32_t, address, 15, 1>;\n\
    \    /**\n     * @brief OT14 field\n     *\n     * Port x configuration bits (y\
    \ =\n     *               0..15)\n     */\n    using ot14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief OT13 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief OT12 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief OT11 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief OT10 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief OT9 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief OT8 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief OT7 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief OT6 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief OT5 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief OT4 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief OT3 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief OT2 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief OT1 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief OT0 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OT15 field\n       *\n\
    \       * Port x configuration bits (y =\n       *               0..15)\n    \
    \   */\n      BitFieldModel<uint32_t, 15, 1> ot15;\n      /**\n       * @brief\
    \ OT14 field\n       *\n       * Port x configuration bits (y =\n       *    \
    \           0..15)\n       */\n      BitFieldModel<uint32_t, 14, 1> ot14;\n  \
    \    /**\n       * @brief OT13 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> ot13;\n      /**\n       * @brief OT12 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> ot12;\n      /**\n       * @brief OT11 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> ot11;\n      /**\n       * @brief OT10 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> ot10;\n      /**\n       * @brief OT9 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> ot9;\n      /**\n       * @brief OT8 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> ot8;\n      /**\n       * @brief OT7 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> ot7;\n      /**\n       * @brief OT6 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> ot6;\n      /**\n       * @brief OT5 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> ot5;\n      /**\n       * @brief OT4 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> ot4;\n      /**\n       * @brief OT3 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> ot3;\n      /**\n       * @brief OT2 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> ot2;\n      /**\n       * @brief OT1 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> ot1;\n      /**\n       * @brief OT0 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> ot0;\n    };\n  };\n\npublic:\n  /**\n   * @brief OTYPER register\n  \
    \ *\n   * GPIO port output type register\n   */\n  using otyper = OtyperReg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class OspeedrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ OSPEEDR15 field\n     *\n     * Port x configuration bits (y =\n     *     \
    \          0..15)\n     */\n    using ospeedr15 = FieldModel<uint32_t, address,\
    \ 30, 2>;\n    /**\n     * @brief OSPEEDR14 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ospeedr14 = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    /**\n     * @brief OSPEEDR13 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr13\
    \ = FieldModel<uint32_t, address, 26, 2>;\n    /**\n     * @brief OSPEEDR12 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr12 = FieldModel<uint32_t, address, 24, 2>;\n    /**\n\
    \     * @brief OSPEEDR11 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr11 = FieldModel<uint32_t,\
    \ address, 22, 2>;\n    /**\n     * @brief OSPEEDR10 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr10\
    \ = FieldModel<uint32_t, address, 20, 2>;\n    /**\n     * @brief OSPEEDR9 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr9 = FieldModel<uint32_t, address, 18, 2>;\n    /**\n\
    \     * @brief OSPEEDR8 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    /**\n     * @brief OSPEEDR7 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr7\
    \ = FieldModel<uint32_t, address, 14, 2>;\n    /**\n     * @brief OSPEEDR6 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr6 = FieldModel<uint32_t, address, 12, 2>;\n    /**\n\
    \     * @brief OSPEEDR5 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr5 = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    /**\n     * @brief OSPEEDR4 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr4\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief OSPEEDR3 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr3 = FieldModel<uint32_t, address, 6, 2>;\n    /**\n\
    \     * @brief OSPEEDR2 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr2 = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    /**\n     * @brief OSPEEDR1 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr1\
    \ = FieldModel<uint32_t, address, 2, 2>;\n    /**\n     * @brief OSPEEDR0 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr0 = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief OSPEEDR15 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 30, 2> ospeedr15;\n      /**\n       * @brief OSPEEDR14 field\n       *\n  \
    \     * Port x configuration bits (y =\n       *               0..15)\n      \
    \ */\n      BitFieldModel<uint32_t, 28, 2> ospeedr14;\n      /**\n       * @brief\
    \ OSPEEDR13 field\n       *\n       * Port x configuration bits (y =\n       *\
    \               0..15)\n       */\n      BitFieldModel<uint32_t, 26, 2> ospeedr13;\n\
    \      /**\n       * @brief OSPEEDR12 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 2> ospeedr12;\n      /**\n       * @brief OSPEEDR11 field\n       *\n  \
    \     * Port x configuration bits (y =\n       *               0..15)\n      \
    \ */\n      BitFieldModel<uint32_t, 22, 2> ospeedr11;\n      /**\n       * @brief\
    \ OSPEEDR10 field\n       *\n       * Port x configuration bits (y =\n       *\
    \               0..15)\n       */\n      BitFieldModel<uint32_t, 20, 2> ospeedr10;\n\
    \      /**\n       * @brief OSPEEDR9 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 2> ospeedr9;\n      /**\n       * @brief OSPEEDR8 field\n       *\n    \
    \   * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 16, 2> ospeedr8;\n      /**\n       * @brief OSPEEDR7\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 14, 2> ospeedr7;\n   \
    \   /**\n       * @brief OSPEEDR6 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 2> ospeedr6;\n      /**\n       * @brief OSPEEDR5 field\n       *\n    \
    \   * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 10, 2> ospeedr5;\n      /**\n       * @brief OSPEEDR4\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 8, 2> ospeedr4;\n    \
    \  /**\n       * @brief OSPEEDR3 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 2> ospeedr3;\n      /**\n       * @brief OSPEEDR2 field\n       *\n     \
    \  * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 4, 2> ospeedr2;\n      /**\n       * @brief OSPEEDR1\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 2, 2> ospeedr1;\n    \
    \  /**\n       * @brief OSPEEDR0 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> ospeedr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief OSPEEDR register\n\
    \   *\n   * GPIO port output speed\n   *           register\n   */\n  using ospeedr\
    \ = OspeedrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class PupdrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief PUPDR15 field\n     *\n     * Port x configuration bits\
    \ (y =\n     *               0..15)\n     */\n    using pupdr15 = FieldModel<uint32_t,\
    \ address, 30, 2>;\n    /**\n     * @brief PUPDR14 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using pupdr14\
    \ = FieldModel<uint32_t, address, 28, 2>;\n    /**\n     * @brief PUPDR13 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr13 = FieldModel<uint32_t, address, 26, 2>;\n    /**\n\
    \     * @brief PUPDR12 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using pupdr12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    /**\n     * @brief PUPDR11 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using pupdr11\
    \ = FieldModel<uint32_t, address, 22, 2>;\n    /**\n     * @brief PUPDR10 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr10 = FieldModel<uint32_t, address, 20, 2>;\n    /**\n\
    \     * @brief PUPDR9 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using pupdr9 = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    /**\n     * @brief PUPDR8 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using pupdr8\
    \ = FieldModel<uint32_t, address, 16, 2>;\n    /**\n     * @brief PUPDR7 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr7 = FieldModel<uint32_t, address, 14, 2>;\n    /**\n\
    \     * @brief PUPDR6 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using pupdr6 = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    /**\n     * @brief PUPDR5 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using pupdr5\
    \ = FieldModel<uint32_t, address, 10, 2>;\n    /**\n     * @brief PUPDR4 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr4 = FieldModel<uint32_t, address, 8, 2>;\n    /**\n \
    \    * @brief PUPDR3 field\n     *\n     * Port x configuration bits (y =\n  \
    \   *               0..15)\n     */\n    using pupdr3 = FieldModel<uint32_t, address,\
    \ 6, 2>;\n    /**\n     * @brief PUPDR2 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using pupdr2 = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    /**\n     * @brief PUPDR1 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using pupdr1\
    \ = FieldModel<uint32_t, address, 2, 2>;\n    /**\n     * @brief PUPDR0 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr0 = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief PUPDR15 field\n       *\n       * Port x configuration bits (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 30,\
    \ 2> pupdr15;\n      /**\n       * @brief PUPDR14 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 28, 2> pupdr14;\n      /**\n       * @brief PUPDR13 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 26, 2> pupdr13;\n      /**\n       * @brief PUPDR12\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 24, 2> pupdr12;\n    \
    \  /**\n       * @brief PUPDR11 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 2> pupdr11;\n      /**\n       * @brief PUPDR10 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 20, 2> pupdr10;\n      /**\n       * @brief PUPDR9\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 18, 2> pupdr9;\n     \
    \ /**\n       * @brief PUPDR8 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 2> pupdr8;\n      /**\n       * @brief PUPDR7 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 14, 2> pupdr7;\n      /**\n       * @brief PUPDR6\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 12, 2> pupdr6;\n     \
    \ /**\n       * @brief PUPDR5 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 2> pupdr5;\n      /**\n       * @brief PUPDR4 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 8, 2> pupdr4;\n      /**\n       * @brief PUPDR3\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 6, 2> pupdr3;\n      /**\n\
    \       * @brief PUPDR2 field\n       *\n       * Port x configuration bits (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 2> pupdr2;\n      /**\n       * @brief PUPDR1 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 2> pupdr1;\n      /**\n       * @brief PUPDR0 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> pupdr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief PUPDR register\n\
    \   *\n   * GPIO port pull-up/pull-down\n   *           register\n   */\n  using\
    \ pupdr = PupdrReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class IdrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief IDR15 field\n     *\n     * Port input data (y =\n   \
    \  *               0..15)\n     */\n    using idr15 = FieldModel<uint32_t, address,\
    \ 15, 1>;\n    /**\n     * @brief IDR14 field\n     *\n     * Port input data\
    \ (y =\n     *               0..15)\n     */\n    using idr14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief IDR13 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief IDR12 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief IDR11 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief IDR10 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief IDR9 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief IDR8 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief IDR7 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief IDR6 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief IDR5 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief IDR4 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief IDR3 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief IDR2 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief IDR1 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief IDR0 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief IDR15 field\n       *\n\
    \       * Port input data (y =\n       *               0..15)\n       */\n   \
    \   BitFieldModel<uint32_t, 15, 1> idr15;\n      /**\n       * @brief IDR14 field\n\
    \       *\n       * Port input data (y =\n       *               0..15)\n    \
    \   */\n      BitFieldModel<uint32_t, 14, 1> idr14;\n      /**\n       * @brief\
    \ IDR13 field\n       *\n       * Port input data (y =\n       *             \
    \  0..15)\n       */\n      BitFieldModel<uint32_t, 13, 1> idr13;\n      /**\n\
    \       * @brief IDR12 field\n       *\n       * Port input data (y =\n      \
    \ *               0..15)\n       */\n      BitFieldModel<uint32_t, 12, 1> idr12;\n\
    \      /**\n       * @brief IDR11 field\n       *\n       * Port input data (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 11,\
    \ 1> idr11;\n      /**\n       * @brief IDR10 field\n       *\n       * Port input\
    \ data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> idr10;\n      /**\n       * @brief IDR9 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> idr9;\n      /**\n       * @brief IDR8 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> idr8;\n      /**\n       * @brief IDR7 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> idr7;\n      /**\n       * @brief IDR6 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> idr6;\n      /**\n       * @brief IDR5 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> idr5;\n      /**\n       * @brief IDR4 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> idr4;\n      /**\n       * @brief IDR3 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> idr3;\n      /**\n       * @brief IDR2 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> idr2;\n      /**\n       * @brief IDR1 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> idr1;\n      /**\n       * @brief IDR0 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> idr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief IDR register\n   *\n\
    \   * GPIO port input data register\n   */\n  using idr = IdrReg<BaseAddress +\
    \ 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class OdrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief ODR15\
    \ field\n     *\n     * Port output data (y =\n     *               0..15)\n \
    \    */\n    using odr15 = FieldModel<uint32_t, address, 15, 1>;\n    /**\n  \
    \   * @brief ODR14 field\n     *\n     * Port output data (y =\n     *       \
    \        0..15)\n     */\n    using odr14 = FieldModel<uint32_t, address, 14,\
    \ 1>;\n    /**\n     * @brief ODR13 field\n     *\n     * Port output data (y\
    \ =\n     *               0..15)\n     */\n    using odr13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief ODR12 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief ODR11 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief ODR10 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief ODR9 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief ODR8 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief ODR7 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief ODR6 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief ODR5 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief ODR4 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ODR3 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief ODR2 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief ODR1 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief ODR0 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief ODR15 field\n       *\n\
    \       * Port output data (y =\n       *               0..15)\n       */\n  \
    \    BitFieldModel<uint32_t, 15, 1> odr15;\n      /**\n       * @brief ODR14 field\n\
    \       *\n       * Port output data (y =\n       *               0..15)\n   \
    \    */\n      BitFieldModel<uint32_t, 14, 1> odr14;\n      /**\n       * @brief\
    \ ODR13 field\n       *\n       * Port output data (y =\n       *            \
    \   0..15)\n       */\n      BitFieldModel<uint32_t, 13, 1> odr13;\n      /**\n\
    \       * @brief ODR12 field\n       *\n       * Port output data (y =\n     \
    \  *               0..15)\n       */\n      BitFieldModel<uint32_t, 12, 1> odr12;\n\
    \      /**\n       * @brief ODR11 field\n       *\n       * Port output data (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 11,\
    \ 1> odr11;\n      /**\n       * @brief ODR10 field\n       *\n       * Port output\
    \ data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> odr10;\n      /**\n       * @brief ODR9 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> odr9;\n      /**\n       * @brief ODR8 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> odr8;\n      /**\n       * @brief ODR7 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> odr7;\n      /**\n       * @brief ODR6 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> odr6;\n      /**\n       * @brief ODR5 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> odr5;\n      /**\n       * @brief ODR4 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> odr4;\n      /**\n       * @brief ODR3 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> odr3;\n      /**\n       * @brief ODR2 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> odr2;\n      /**\n       * @brief ODR1 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> odr1;\n      /**\n       * @brief ODR0 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> odr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief ODR register\n   *\n\
    \   * GPIO port output data register\n   */\n  using odr = OdrReg<BaseAddress\
    \ + 0x0014>;\n\nprivate:\n  template<unsigned int address>\n  class BsrrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ BR15 field\n     *\n     * Port x reset bit y (y =\n     *               0..15)\n\
    \     */\n    using br15 = FieldModel<uint32_t, address, 31, 1>;\n    /**\n  \
    \   * @brief BR14 field\n     *\n     * Port x reset bit y (y =\n     *      \
    \         0..15)\n     */\n    using br14 = FieldModel<uint32_t, address, 30,\
    \ 1>;\n    /**\n     * @brief BR13 field\n     *\n     * Port x reset bit y (y\
    \ =\n     *               0..15)\n     */\n    using br13 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    /**\n     * @brief BR12 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br12 = FieldModel<uint32_t,\
    \ address, 28, 1>;\n    /**\n     * @brief BR11 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br11 = FieldModel<uint32_t,\
    \ address, 27, 1>;\n    /**\n     * @brief BR10 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br10 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    /**\n     * @brief BR9 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br9 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    /**\n     * @brief BR8 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br8 = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    /**\n     * @brief BR7 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br7 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    /**\n     * @brief BR6 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br6 = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    /**\n     * @brief BR5 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br5 = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    /**\n     * @brief BR4 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br4 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief BR3 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br3 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief BR2 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br2 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    /**\n     * @brief BR1 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br1 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    /**\n     * @brief BR0 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using br0 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    /**\n     * @brief BS15 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief BS14 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief BS13 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief BS12 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief BS11 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief BS10 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief BS9 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief BS8 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief BS7 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief BS6 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief BS5 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief BS4 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief BS3 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief BS2 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief BS1 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief BS0 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief BR15 field\n       *\n\
    \       * Port x reset bit y (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 31, 1> br15;\n      /**\n       * @brief BR14 field\n\
    \       *\n       * Port x reset bit y (y =\n       *               0..15)\n \
    \      */\n      BitFieldModel<uint32_t, 30, 1> br14;\n      /**\n       * @brief\
    \ BR13 field\n       *\n       * Port x reset bit y (y =\n       *           \
    \    0..15)\n       */\n      BitFieldModel<uint32_t, 29, 1> br13;\n      /**\n\
    \       * @brief BR12 field\n       *\n       * Port x reset bit y (y =\n    \
    \   *               0..15)\n       */\n      BitFieldModel<uint32_t, 28, 1> br12;\n\
    \      /**\n       * @brief BR11 field\n       *\n       * Port x reset bit y\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 27, 1> br11;\n      /**\n       * @brief BR10 field\n       *\n       * Port\
    \ x reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 26, 1> br10;\n      /**\n       * @brief BR9 field\n       *\n       * Port\
    \ x reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 1> br9;\n      /**\n       * @brief BR8 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 1> br8;\n      /**\n       * @brief BR7 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 1> br7;\n      /**\n       * @brief BR6 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> br6;\n      /**\n       * @brief BR5 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 1> br5;\n      /**\n       * @brief BR4 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 1> br4;\n      /**\n       * @brief BR3 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> br3;\n      /**\n       * @brief BR2 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 1> br2;\n      /**\n       * @brief BR1 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> br1;\n      /**\n       * @brief BR0 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> br0;\n      /**\n       * @brief BS15 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> bs15;\n      /**\n       * @brief BS14 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> bs14;\n      /**\n       * @brief BS13 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> bs13;\n      /**\n       * @brief BS12 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> bs12;\n      /**\n       * @brief BS11 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> bs11;\n      /**\n       * @brief BS10 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> bs10;\n      /**\n       * @brief BS9 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> bs9;\n      /**\n       * @brief BS8 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> bs8;\n      /**\n       * @brief BS7 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> bs7;\n      /**\n       * @brief BS6 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> bs6;\n      /**\n       * @brief BS5 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> bs5;\n      /**\n       * @brief BS4 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> bs4;\n      /**\n       * @brief BS3 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> bs3;\n      /**\n       * @brief BS2 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> bs2;\n      /**\n       * @brief BS1 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> bs1;\n      /**\n       * @brief BS0 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> bs0;\n    };\n  };\n\npublic:\n  /**\n   * @brief BSRR register\n   *\n\
    \   * GPIO port bit set/reset\n   *           register\n   */\n  using bsrr =\
    \ BsrrReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class LckrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief LCKK field\n     *\n     * Port x lock bit y (y=\n    \
    \ *               0..15)\n     */\n    using lckk = FieldModel<uint32_t, address,\
    \ 16, 1>;\n    /**\n     * @brief LCK15 field\n     *\n     * Port x lock bit\
    \ y (y=\n     *               0..15)\n     */\n    using lck15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief LCK14 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief LCK13 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief LCK12 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief LCK11 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief LCK10 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief LCK9 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief LCK8 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief LCK7 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief LCK6 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief LCK5 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief LCK4 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief LCK3 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief LCK2 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief LCK1 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief LCK0 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief LCKK field\n       *\n\
    \       * Port x lock bit y (y=\n       *               0..15)\n       */\n  \
    \    BitFieldModel<uint32_t, 16, 1> lckk;\n      /**\n       * @brief LCK15 field\n\
    \       *\n       * Port x lock bit y (y=\n       *               0..15)\n   \
    \    */\n      BitFieldModel<uint32_t, 15, 1> lck15;\n      /**\n       * @brief\
    \ LCK14 field\n       *\n       * Port x lock bit y (y=\n       *            \
    \   0..15)\n       */\n      BitFieldModel<uint32_t, 14, 1> lck14;\n      /**\n\
    \       * @brief LCK13 field\n       *\n       * Port x lock bit y (y=\n     \
    \  *               0..15)\n       */\n      BitFieldModel<uint32_t, 13, 1> lck13;\n\
    \      /**\n       * @brief LCK12 field\n       *\n       * Port x lock bit y\
    \ (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> lck12;\n      /**\n       * @brief LCK11 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> lck11;\n      /**\n       * @brief LCK10 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> lck10;\n      /**\n       * @brief LCK9 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> lck9;\n      /**\n       * @brief LCK8 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> lck8;\n      /**\n       * @brief LCK7 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> lck7;\n      /**\n       * @brief LCK6 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> lck6;\n      /**\n       * @brief LCK5 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> lck5;\n      /**\n       * @brief LCK4 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> lck4;\n      /**\n       * @brief LCK3 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> lck3;\n      /**\n       * @brief LCK2 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> lck2;\n      /**\n       * @brief LCK1 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> lck1;\n      /**\n       * @brief LCK0 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> lck0;\n    };\n  };\n\npublic:\n  /**\n   * @brief LCKR register\n   *\n\
    \   * GPIO port configuration lock\n   *           register\n   */\n  using lckr\
    \ = LckrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class AfrlReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief AFRL7 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl7\
    \ = FieldModel<uint32_t, address, 28, 4>;\n    /**\n     * @brief AFRL6 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl6 = FieldModel<uint32_t, address, 24,\
    \ 4>;\n    /**\n     * @brief AFRL5 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl5\
    \ = FieldModel<uint32_t, address, 20, 4>;\n    /**\n     * @brief AFRL4 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl4 = FieldModel<uint32_t, address, 16,\
    \ 4>;\n    /**\n     * @brief AFRL3 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl3\
    \ = FieldModel<uint32_t, address, 12, 4>;\n    /**\n     * @brief AFRL2 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl2 = FieldModel<uint32_t, address, 8,\
    \ 4>;\n    /**\n     * @brief AFRL1 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl1\
    \ = FieldModel<uint32_t, address, 4, 4>;\n    /**\n     * @brief AFRL0 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl0 = FieldModel<uint32_t, address, 0,\
    \ 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief AFRL7 field\n       *\n   \
    \    * Alternate function selection for port x\n       *               bit y (y\
    \ = 0..7)\n       */\n      BitFieldModel<uint32_t, 28, 4> afrl7;\n      /**\n\
    \       * @brief AFRL6 field\n       *\n       * Alternate function selection\
    \ for port x\n       *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 4> afrl6;\n      /**\n       * @brief AFRL5 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 0..7)\n   \
    \    */\n      BitFieldModel<uint32_t, 20, 4> afrl5;\n      /**\n       * @brief\
    \ AFRL4 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 4> afrl4;\n      /**\n       * @brief AFRL3 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 0..7)\n   \
    \    */\n      BitFieldModel<uint32_t, 12, 4> afrl3;\n      /**\n       * @brief\
    \ AFRL2 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 4> afrl2;\n      /**\n       * @brief AFRL1 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 0..7)\n   \
    \    */\n      BitFieldModel<uint32_t, 4, 4> afrl1;\n      /**\n       * @brief\
    \ AFRL0 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> afrl0;\n    };\n  };\n\npublic:\n  /**\n   * @brief AFRL register\n  \
    \ *\n   * GPIO alternate function low\n   *           register\n   */\n  using\
    \ afrl = AfrlReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class AfrhReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief AFRH15 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 8..15)\n     */\n    using afrh15\
    \ = FieldModel<uint32_t, address, 28, 4>;\n    /**\n     * @brief AFRH14 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 8..15)\n     */\n    using afrh14 = FieldModel<uint32_t, address,\
    \ 24, 4>;\n    /**\n     * @brief AFRH13 field\n     *\n     * Alternate function\
    \ selection for port x\n     *               bit y (y = 8..15)\n     */\n    using\
    \ afrh13 = FieldModel<uint32_t, address, 20, 4>;\n    /**\n     * @brief AFRH12\
    \ field\n     *\n     * Alternate function selection for port x\n     *      \
    \         bit y (y = 8..15)\n     */\n    using afrh12 = FieldModel<uint32_t,\
    \ address, 16, 4>;\n    /**\n     * @brief AFRH11 field\n     *\n     * Alternate\
    \ function selection for port x\n     *               bit y (y = 8..15)\n    \
    \ */\n    using afrh11 = FieldModel<uint32_t, address, 12, 4>;\n    /**\n    \
    \ * @brief AFRH10 field\n     *\n     * Alternate function selection for port\
    \ x\n     *               bit y (y = 8..15)\n     */\n    using afrh10 = FieldModel<uint32_t,\
    \ address, 8, 4>;\n    /**\n     * @brief AFRH9 field\n     *\n     * Alternate\
    \ function selection for port x\n     *               bit y (y = 8..15)\n    \
    \ */\n    using afrh9 = FieldModel<uint32_t, address, 4, 4>;\n    /**\n     *\
    \ @brief AFRH8 field\n     *\n     * Alternate function selection for port x\n\
    \     *               bit y (y = 8..15)\n     */\n    using afrh8 = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief AFRH15 field\n       *\n\
    \       * Alternate function selection for port x\n       *               bit\
    \ y (y = 8..15)\n       */\n      BitFieldModel<uint32_t, 28, 4> afrh15;\n   \
    \   /**\n       * @brief AFRH14 field\n       *\n       * Alternate function selection\
    \ for port x\n       *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 4> afrh14;\n      /**\n       * @brief AFRH13 field\n       *\n       *\
    \ Alternate function selection for port x\n       *               bit y (y = 8..15)\n\
    \       */\n      BitFieldModel<uint32_t, 20, 4> afrh13;\n      /**\n       *\
    \ @brief AFRH12 field\n       *\n       * Alternate function selection for port\
    \ x\n       *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 4> afrh12;\n      /**\n       * @brief AFRH11 field\n       *\n       *\
    \ Alternate function selection for port x\n       *               bit y (y = 8..15)\n\
    \       */\n      BitFieldModel<uint32_t, 12, 4> afrh11;\n      /**\n       *\
    \ @brief AFRH10 field\n       *\n       * Alternate function selection for port\
    \ x\n       *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 4> afrh10;\n      /**\n       * @brief AFRH9 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 8..15)\n  \
    \     */\n      BitFieldModel<uint32_t, 4, 4> afrh9;\n      /**\n       * @brief\
    \ AFRH8 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> afrh8;\n    };\n  };\n\npublic:\n  /**\n   * @brief AFRH register\n  \
    \ *\n   * GPIO alternate function high\n   *           register\n   */\n  using\
    \ afrh = AfrhReg<BaseAddress + 0x0024>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_GPIOH_H\
    \ */"
  name: GPIOH
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_GPIOE_H\n#define DRAL_STM32F411_GPIOE_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ GPIOE peripheral\n *\n * General-purpose I/Os\n */\nclass gpioe\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40021000; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class ModerReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ MODER15 field\n     *\n     * Port x configuration bits (y =\n     *       \
    \        0..15)\n     */\n    using moder15 = FieldModel<uint32_t, address, 30,\
    \ 2>;\n    /**\n     * @brief MODER14 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using moder14 = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    /**\n     * @brief MODER13 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using moder13\
    \ = FieldModel<uint32_t, address, 26, 2>;\n    /**\n     * @brief MODER12 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder12 = FieldModel<uint32_t, address, 24, 2>;\n    /**\n\
    \     * @brief MODER11 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using moder11 = FieldModel<uint32_t,\
    \ address, 22, 2>;\n    /**\n     * @brief MODER10 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using moder10\
    \ = FieldModel<uint32_t, address, 20, 2>;\n    /**\n     * @brief MODER9 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder9 = FieldModel<uint32_t, address, 18, 2>;\n    /**\n\
    \     * @brief MODER8 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using moder8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    /**\n     * @brief MODER7 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using moder7\
    \ = FieldModel<uint32_t, address, 14, 2>;\n    /**\n     * @brief MODER6 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder6 = FieldModel<uint32_t, address, 12, 2>;\n    /**\n\
    \     * @brief MODER5 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using moder5 = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    /**\n     * @brief MODER4 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using moder4\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief MODER3 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder3 = FieldModel<uint32_t, address, 6, 2>;\n    /**\n \
    \    * @brief MODER2 field\n     *\n     * Port x configuration bits (y =\n  \
    \   *               0..15)\n     */\n    using moder2 = FieldModel<uint32_t, address,\
    \ 4, 2>;\n    /**\n     * @brief MODER1 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using moder1 = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    /**\n     * @brief MODER0 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using moder0\
    \ = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ MODER15 field\n       *\n       * Port x configuration bits (y =\n       * \
    \              0..15)\n       */\n      BitFieldModel<uint32_t, 30, 2> moder15;\n\
    \      /**\n       * @brief MODER14 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 28, 2> moder14;\n      /**\n       * @brief MODER13 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 26, 2> moder13;\n      /**\n       * @brief MODER12\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 24, 2> moder12;\n    \
    \  /**\n       * @brief MODER11 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 2> moder11;\n      /**\n       * @brief MODER10 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 20, 2> moder10;\n      /**\n       * @brief MODER9\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 18, 2> moder9;\n     \
    \ /**\n       * @brief MODER8 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 2> moder8;\n      /**\n       * @brief MODER7 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 14, 2> moder7;\n      /**\n       * @brief MODER6\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 12, 2> moder6;\n     \
    \ /**\n       * @brief MODER5 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 2> moder5;\n      /**\n       * @brief MODER4 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 8, 2> moder4;\n      /**\n       * @brief MODER3\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 6, 2> moder3;\n      /**\n\
    \       * @brief MODER2 field\n       *\n       * Port x configuration bits (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 2> moder2;\n      /**\n       * @brief MODER1 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 2> moder1;\n      /**\n       * @brief MODER0 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> moder0;\n    };\n  };\n\npublic:\n  /**\n   * @brief MODER register\n\
    \   *\n   * GPIO port mode register\n   */\n  using moder = ModerReg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class OtyperReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ OT15 field\n     *\n     * Port x configuration bits (y =\n     *          \
    \     0..15)\n     */\n    using ot15 = FieldModel<uint32_t, address, 15, 1>;\n\
    \    /**\n     * @brief OT14 field\n     *\n     * Port x configuration bits (y\
    \ =\n     *               0..15)\n     */\n    using ot14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief OT13 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief OT12 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief OT11 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief OT10 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief OT9 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief OT8 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief OT7 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief OT6 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief OT5 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief OT4 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief OT3 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief OT2 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief OT1 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief OT0 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OT15 field\n       *\n\
    \       * Port x configuration bits (y =\n       *               0..15)\n    \
    \   */\n      BitFieldModel<uint32_t, 15, 1> ot15;\n      /**\n       * @brief\
    \ OT14 field\n       *\n       * Port x configuration bits (y =\n       *    \
    \           0..15)\n       */\n      BitFieldModel<uint32_t, 14, 1> ot14;\n  \
    \    /**\n       * @brief OT13 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> ot13;\n      /**\n       * @brief OT12 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> ot12;\n      /**\n       * @brief OT11 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> ot11;\n      /**\n       * @brief OT10 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> ot10;\n      /**\n       * @brief OT9 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> ot9;\n      /**\n       * @brief OT8 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> ot8;\n      /**\n       * @brief OT7 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> ot7;\n      /**\n       * @brief OT6 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> ot6;\n      /**\n       * @brief OT5 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> ot5;\n      /**\n       * @brief OT4 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> ot4;\n      /**\n       * @brief OT3 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> ot3;\n      /**\n       * @brief OT2 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> ot2;\n      /**\n       * @brief OT1 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> ot1;\n      /**\n       * @brief OT0 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> ot0;\n    };\n  };\n\npublic:\n  /**\n   * @brief OTYPER register\n  \
    \ *\n   * GPIO port output type register\n   */\n  using otyper = OtyperReg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class OspeedrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ OSPEEDR15 field\n     *\n     * Port x configuration bits (y =\n     *     \
    \          0..15)\n     */\n    using ospeedr15 = FieldModel<uint32_t, address,\
    \ 30, 2>;\n    /**\n     * @brief OSPEEDR14 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ospeedr14 = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    /**\n     * @brief OSPEEDR13 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr13\
    \ = FieldModel<uint32_t, address, 26, 2>;\n    /**\n     * @brief OSPEEDR12 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr12 = FieldModel<uint32_t, address, 24, 2>;\n    /**\n\
    \     * @brief OSPEEDR11 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr11 = FieldModel<uint32_t,\
    \ address, 22, 2>;\n    /**\n     * @brief OSPEEDR10 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr10\
    \ = FieldModel<uint32_t, address, 20, 2>;\n    /**\n     * @brief OSPEEDR9 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr9 = FieldModel<uint32_t, address, 18, 2>;\n    /**\n\
    \     * @brief OSPEEDR8 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    /**\n     * @brief OSPEEDR7 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr7\
    \ = FieldModel<uint32_t, address, 14, 2>;\n    /**\n     * @brief OSPEEDR6 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr6 = FieldModel<uint32_t, address, 12, 2>;\n    /**\n\
    \     * @brief OSPEEDR5 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr5 = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    /**\n     * @brief OSPEEDR4 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr4\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief OSPEEDR3 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr3 = FieldModel<uint32_t, address, 6, 2>;\n    /**\n\
    \     * @brief OSPEEDR2 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr2 = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    /**\n     * @brief OSPEEDR1 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr1\
    \ = FieldModel<uint32_t, address, 2, 2>;\n    /**\n     * @brief OSPEEDR0 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr0 = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief OSPEEDR15 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 30, 2> ospeedr15;\n      /**\n       * @brief OSPEEDR14 field\n       *\n  \
    \     * Port x configuration bits (y =\n       *               0..15)\n      \
    \ */\n      BitFieldModel<uint32_t, 28, 2> ospeedr14;\n      /**\n       * @brief\
    \ OSPEEDR13 field\n       *\n       * Port x configuration bits (y =\n       *\
    \               0..15)\n       */\n      BitFieldModel<uint32_t, 26, 2> ospeedr13;\n\
    \      /**\n       * @brief OSPEEDR12 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 2> ospeedr12;\n      /**\n       * @brief OSPEEDR11 field\n       *\n  \
    \     * Port x configuration bits (y =\n       *               0..15)\n      \
    \ */\n      BitFieldModel<uint32_t, 22, 2> ospeedr11;\n      /**\n       * @brief\
    \ OSPEEDR10 field\n       *\n       * Port x configuration bits (y =\n       *\
    \               0..15)\n       */\n      BitFieldModel<uint32_t, 20, 2> ospeedr10;\n\
    \      /**\n       * @brief OSPEEDR9 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 2> ospeedr9;\n      /**\n       * @brief OSPEEDR8 field\n       *\n    \
    \   * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 16, 2> ospeedr8;\n      /**\n       * @brief OSPEEDR7\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 14, 2> ospeedr7;\n   \
    \   /**\n       * @brief OSPEEDR6 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 2> ospeedr6;\n      /**\n       * @brief OSPEEDR5 field\n       *\n    \
    \   * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 10, 2> ospeedr5;\n      /**\n       * @brief OSPEEDR4\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 8, 2> ospeedr4;\n    \
    \  /**\n       * @brief OSPEEDR3 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 2> ospeedr3;\n      /**\n       * @brief OSPEEDR2 field\n       *\n     \
    \  * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 4, 2> ospeedr2;\n      /**\n       * @brief OSPEEDR1\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 2, 2> ospeedr1;\n    \
    \  /**\n       * @brief OSPEEDR0 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> ospeedr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief OSPEEDR register\n\
    \   *\n   * GPIO port output speed\n   *           register\n   */\n  using ospeedr\
    \ = OspeedrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class PupdrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief PUPDR15 field\n     *\n     * Port x configuration bits\
    \ (y =\n     *               0..15)\n     */\n    using pupdr15 = FieldModel<uint32_t,\
    \ address, 30, 2>;\n    /**\n     * @brief PUPDR14 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using pupdr14\
    \ = FieldModel<uint32_t, address, 28, 2>;\n    /**\n     * @brief PUPDR13 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr13 = FieldModel<uint32_t, address, 26, 2>;\n    /**\n\
    \     * @brief PUPDR12 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using pupdr12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    /**\n     * @brief PUPDR11 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using pupdr11\
    \ = FieldModel<uint32_t, address, 22, 2>;\n    /**\n     * @brief PUPDR10 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr10 = FieldModel<uint32_t, address, 20, 2>;\n    /**\n\
    \     * @brief PUPDR9 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using pupdr9 = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    /**\n     * @brief PUPDR8 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using pupdr8\
    \ = FieldModel<uint32_t, address, 16, 2>;\n    /**\n     * @brief PUPDR7 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr7 = FieldModel<uint32_t, address, 14, 2>;\n    /**\n\
    \     * @brief PUPDR6 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using pupdr6 = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    /**\n     * @brief PUPDR5 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using pupdr5\
    \ = FieldModel<uint32_t, address, 10, 2>;\n    /**\n     * @brief PUPDR4 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr4 = FieldModel<uint32_t, address, 8, 2>;\n    /**\n \
    \    * @brief PUPDR3 field\n     *\n     * Port x configuration bits (y =\n  \
    \   *               0..15)\n     */\n    using pupdr3 = FieldModel<uint32_t, address,\
    \ 6, 2>;\n    /**\n     * @brief PUPDR2 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using pupdr2 = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    /**\n     * @brief PUPDR1 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using pupdr1\
    \ = FieldModel<uint32_t, address, 2, 2>;\n    /**\n     * @brief PUPDR0 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr0 = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief PUPDR15 field\n       *\n       * Port x configuration bits (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 30,\
    \ 2> pupdr15;\n      /**\n       * @brief PUPDR14 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 28, 2> pupdr14;\n      /**\n       * @brief PUPDR13 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 26, 2> pupdr13;\n      /**\n       * @brief PUPDR12\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 24, 2> pupdr12;\n    \
    \  /**\n       * @brief PUPDR11 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 2> pupdr11;\n      /**\n       * @brief PUPDR10 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 20, 2> pupdr10;\n      /**\n       * @brief PUPDR9\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 18, 2> pupdr9;\n     \
    \ /**\n       * @brief PUPDR8 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 2> pupdr8;\n      /**\n       * @brief PUPDR7 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 14, 2> pupdr7;\n      /**\n       * @brief PUPDR6\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 12, 2> pupdr6;\n     \
    \ /**\n       * @brief PUPDR5 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 2> pupdr5;\n      /**\n       * @brief PUPDR4 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 8, 2> pupdr4;\n      /**\n       * @brief PUPDR3\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 6, 2> pupdr3;\n      /**\n\
    \       * @brief PUPDR2 field\n       *\n       * Port x configuration bits (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 2> pupdr2;\n      /**\n       * @brief PUPDR1 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 2> pupdr1;\n      /**\n       * @brief PUPDR0 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> pupdr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief PUPDR register\n\
    \   *\n   * GPIO port pull-up/pull-down\n   *           register\n   */\n  using\
    \ pupdr = PupdrReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class IdrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief IDR15 field\n     *\n     * Port input data (y =\n   \
    \  *               0..15)\n     */\n    using idr15 = FieldModel<uint32_t, address,\
    \ 15, 1>;\n    /**\n     * @brief IDR14 field\n     *\n     * Port input data\
    \ (y =\n     *               0..15)\n     */\n    using idr14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief IDR13 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief IDR12 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief IDR11 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief IDR10 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief IDR9 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief IDR8 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief IDR7 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief IDR6 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief IDR5 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief IDR4 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief IDR3 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief IDR2 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief IDR1 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief IDR0 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief IDR15 field\n       *\n\
    \       * Port input data (y =\n       *               0..15)\n       */\n   \
    \   BitFieldModel<uint32_t, 15, 1> idr15;\n      /**\n       * @brief IDR14 field\n\
    \       *\n       * Port input data (y =\n       *               0..15)\n    \
    \   */\n      BitFieldModel<uint32_t, 14, 1> idr14;\n      /**\n       * @brief\
    \ IDR13 field\n       *\n       * Port input data (y =\n       *             \
    \  0..15)\n       */\n      BitFieldModel<uint32_t, 13, 1> idr13;\n      /**\n\
    \       * @brief IDR12 field\n       *\n       * Port input data (y =\n      \
    \ *               0..15)\n       */\n      BitFieldModel<uint32_t, 12, 1> idr12;\n\
    \      /**\n       * @brief IDR11 field\n       *\n       * Port input data (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 11,\
    \ 1> idr11;\n      /**\n       * @brief IDR10 field\n       *\n       * Port input\
    \ data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> idr10;\n      /**\n       * @brief IDR9 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> idr9;\n      /**\n       * @brief IDR8 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> idr8;\n      /**\n       * @brief IDR7 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> idr7;\n      /**\n       * @brief IDR6 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> idr6;\n      /**\n       * @brief IDR5 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> idr5;\n      /**\n       * @brief IDR4 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> idr4;\n      /**\n       * @brief IDR3 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> idr3;\n      /**\n       * @brief IDR2 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> idr2;\n      /**\n       * @brief IDR1 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> idr1;\n      /**\n       * @brief IDR0 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> idr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief IDR register\n   *\n\
    \   * GPIO port input data register\n   */\n  using idr = IdrReg<BaseAddress +\
    \ 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class OdrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief ODR15\
    \ field\n     *\n     * Port output data (y =\n     *               0..15)\n \
    \    */\n    using odr15 = FieldModel<uint32_t, address, 15, 1>;\n    /**\n  \
    \   * @brief ODR14 field\n     *\n     * Port output data (y =\n     *       \
    \        0..15)\n     */\n    using odr14 = FieldModel<uint32_t, address, 14,\
    \ 1>;\n    /**\n     * @brief ODR13 field\n     *\n     * Port output data (y\
    \ =\n     *               0..15)\n     */\n    using odr13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief ODR12 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief ODR11 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief ODR10 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief ODR9 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief ODR8 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief ODR7 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief ODR6 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief ODR5 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief ODR4 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ODR3 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief ODR2 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief ODR1 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief ODR0 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief ODR15 field\n       *\n\
    \       * Port output data (y =\n       *               0..15)\n       */\n  \
    \    BitFieldModel<uint32_t, 15, 1> odr15;\n      /**\n       * @brief ODR14 field\n\
    \       *\n       * Port output data (y =\n       *               0..15)\n   \
    \    */\n      BitFieldModel<uint32_t, 14, 1> odr14;\n      /**\n       * @brief\
    \ ODR13 field\n       *\n       * Port output data (y =\n       *            \
    \   0..15)\n       */\n      BitFieldModel<uint32_t, 13, 1> odr13;\n      /**\n\
    \       * @brief ODR12 field\n       *\n       * Port output data (y =\n     \
    \  *               0..15)\n       */\n      BitFieldModel<uint32_t, 12, 1> odr12;\n\
    \      /**\n       * @brief ODR11 field\n       *\n       * Port output data (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 11,\
    \ 1> odr11;\n      /**\n       * @brief ODR10 field\n       *\n       * Port output\
    \ data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> odr10;\n      /**\n       * @brief ODR9 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> odr9;\n      /**\n       * @brief ODR8 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> odr8;\n      /**\n       * @brief ODR7 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> odr7;\n      /**\n       * @brief ODR6 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> odr6;\n      /**\n       * @brief ODR5 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> odr5;\n      /**\n       * @brief ODR4 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> odr4;\n      /**\n       * @brief ODR3 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> odr3;\n      /**\n       * @brief ODR2 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> odr2;\n      /**\n       * @brief ODR1 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> odr1;\n      /**\n       * @brief ODR0 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> odr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief ODR register\n   *\n\
    \   * GPIO port output data register\n   */\n  using odr = OdrReg<BaseAddress\
    \ + 0x0014>;\n\nprivate:\n  template<unsigned int address>\n  class BsrrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ BR15 field\n     *\n     * Port x reset bit y (y =\n     *               0..15)\n\
    \     */\n    using br15 = FieldModel<uint32_t, address, 31, 1>;\n    /**\n  \
    \   * @brief BR14 field\n     *\n     * Port x reset bit y (y =\n     *      \
    \         0..15)\n     */\n    using br14 = FieldModel<uint32_t, address, 30,\
    \ 1>;\n    /**\n     * @brief BR13 field\n     *\n     * Port x reset bit y (y\
    \ =\n     *               0..15)\n     */\n    using br13 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    /**\n     * @brief BR12 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br12 = FieldModel<uint32_t,\
    \ address, 28, 1>;\n    /**\n     * @brief BR11 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br11 = FieldModel<uint32_t,\
    \ address, 27, 1>;\n    /**\n     * @brief BR10 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br10 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    /**\n     * @brief BR9 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br9 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    /**\n     * @brief BR8 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br8 = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    /**\n     * @brief BR7 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br7 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    /**\n     * @brief BR6 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br6 = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    /**\n     * @brief BR5 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br5 = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    /**\n     * @brief BR4 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br4 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief BR3 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br3 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief BR2 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br2 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    /**\n     * @brief BR1 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br1 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    /**\n     * @brief BR0 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using br0 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    /**\n     * @brief BS15 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief BS14 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief BS13 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief BS12 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief BS11 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief BS10 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief BS9 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief BS8 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief BS7 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief BS6 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief BS5 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief BS4 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief BS3 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief BS2 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief BS1 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief BS0 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief BR15 field\n       *\n\
    \       * Port x reset bit y (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 31, 1> br15;\n      /**\n       * @brief BR14 field\n\
    \       *\n       * Port x reset bit y (y =\n       *               0..15)\n \
    \      */\n      BitFieldModel<uint32_t, 30, 1> br14;\n      /**\n       * @brief\
    \ BR13 field\n       *\n       * Port x reset bit y (y =\n       *           \
    \    0..15)\n       */\n      BitFieldModel<uint32_t, 29, 1> br13;\n      /**\n\
    \       * @brief BR12 field\n       *\n       * Port x reset bit y (y =\n    \
    \   *               0..15)\n       */\n      BitFieldModel<uint32_t, 28, 1> br12;\n\
    \      /**\n       * @brief BR11 field\n       *\n       * Port x reset bit y\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 27, 1> br11;\n      /**\n       * @brief BR10 field\n       *\n       * Port\
    \ x reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 26, 1> br10;\n      /**\n       * @brief BR9 field\n       *\n       * Port\
    \ x reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 1> br9;\n      /**\n       * @brief BR8 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 1> br8;\n      /**\n       * @brief BR7 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 1> br7;\n      /**\n       * @brief BR6 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> br6;\n      /**\n       * @brief BR5 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 1> br5;\n      /**\n       * @brief BR4 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 1> br4;\n      /**\n       * @brief BR3 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> br3;\n      /**\n       * @brief BR2 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 1> br2;\n      /**\n       * @brief BR1 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> br1;\n      /**\n       * @brief BR0 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> br0;\n      /**\n       * @brief BS15 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> bs15;\n      /**\n       * @brief BS14 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> bs14;\n      /**\n       * @brief BS13 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> bs13;\n      /**\n       * @brief BS12 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> bs12;\n      /**\n       * @brief BS11 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> bs11;\n      /**\n       * @brief BS10 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> bs10;\n      /**\n       * @brief BS9 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> bs9;\n      /**\n       * @brief BS8 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> bs8;\n      /**\n       * @brief BS7 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> bs7;\n      /**\n       * @brief BS6 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> bs6;\n      /**\n       * @brief BS5 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> bs5;\n      /**\n       * @brief BS4 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> bs4;\n      /**\n       * @brief BS3 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> bs3;\n      /**\n       * @brief BS2 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> bs2;\n      /**\n       * @brief BS1 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> bs1;\n      /**\n       * @brief BS0 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> bs0;\n    };\n  };\n\npublic:\n  /**\n   * @brief BSRR register\n   *\n\
    \   * GPIO port bit set/reset\n   *           register\n   */\n  using bsrr =\
    \ BsrrReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class LckrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief LCKK field\n     *\n     * Port x lock bit y (y=\n    \
    \ *               0..15)\n     */\n    using lckk = FieldModel<uint32_t, address,\
    \ 16, 1>;\n    /**\n     * @brief LCK15 field\n     *\n     * Port x lock bit\
    \ y (y=\n     *               0..15)\n     */\n    using lck15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief LCK14 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief LCK13 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief LCK12 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief LCK11 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief LCK10 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief LCK9 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief LCK8 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief LCK7 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief LCK6 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief LCK5 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief LCK4 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief LCK3 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief LCK2 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief LCK1 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief LCK0 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief LCKK field\n       *\n\
    \       * Port x lock bit y (y=\n       *               0..15)\n       */\n  \
    \    BitFieldModel<uint32_t, 16, 1> lckk;\n      /**\n       * @brief LCK15 field\n\
    \       *\n       * Port x lock bit y (y=\n       *               0..15)\n   \
    \    */\n      BitFieldModel<uint32_t, 15, 1> lck15;\n      /**\n       * @brief\
    \ LCK14 field\n       *\n       * Port x lock bit y (y=\n       *            \
    \   0..15)\n       */\n      BitFieldModel<uint32_t, 14, 1> lck14;\n      /**\n\
    \       * @brief LCK13 field\n       *\n       * Port x lock bit y (y=\n     \
    \  *               0..15)\n       */\n      BitFieldModel<uint32_t, 13, 1> lck13;\n\
    \      /**\n       * @brief LCK12 field\n       *\n       * Port x lock bit y\
    \ (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> lck12;\n      /**\n       * @brief LCK11 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> lck11;\n      /**\n       * @brief LCK10 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> lck10;\n      /**\n       * @brief LCK9 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> lck9;\n      /**\n       * @brief LCK8 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> lck8;\n      /**\n       * @brief LCK7 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> lck7;\n      /**\n       * @brief LCK6 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> lck6;\n      /**\n       * @brief LCK5 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> lck5;\n      /**\n       * @brief LCK4 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> lck4;\n      /**\n       * @brief LCK3 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> lck3;\n      /**\n       * @brief LCK2 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> lck2;\n      /**\n       * @brief LCK1 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> lck1;\n      /**\n       * @brief LCK0 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> lck0;\n    };\n  };\n\npublic:\n  /**\n   * @brief LCKR register\n   *\n\
    \   * GPIO port configuration lock\n   *           register\n   */\n  using lckr\
    \ = LckrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class AfrlReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief AFRL7 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl7\
    \ = FieldModel<uint32_t, address, 28, 4>;\n    /**\n     * @brief AFRL6 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl6 = FieldModel<uint32_t, address, 24,\
    \ 4>;\n    /**\n     * @brief AFRL5 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl5\
    \ = FieldModel<uint32_t, address, 20, 4>;\n    /**\n     * @brief AFRL4 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl4 = FieldModel<uint32_t, address, 16,\
    \ 4>;\n    /**\n     * @brief AFRL3 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl3\
    \ = FieldModel<uint32_t, address, 12, 4>;\n    /**\n     * @brief AFRL2 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl2 = FieldModel<uint32_t, address, 8,\
    \ 4>;\n    /**\n     * @brief AFRL1 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl1\
    \ = FieldModel<uint32_t, address, 4, 4>;\n    /**\n     * @brief AFRL0 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl0 = FieldModel<uint32_t, address, 0,\
    \ 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief AFRL7 field\n       *\n   \
    \    * Alternate function selection for port x\n       *               bit y (y\
    \ = 0..7)\n       */\n      BitFieldModel<uint32_t, 28, 4> afrl7;\n      /**\n\
    \       * @brief AFRL6 field\n       *\n       * Alternate function selection\
    \ for port x\n       *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 4> afrl6;\n      /**\n       * @brief AFRL5 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 0..7)\n   \
    \    */\n      BitFieldModel<uint32_t, 20, 4> afrl5;\n      /**\n       * @brief\
    \ AFRL4 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 4> afrl4;\n      /**\n       * @brief AFRL3 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 0..7)\n   \
    \    */\n      BitFieldModel<uint32_t, 12, 4> afrl3;\n      /**\n       * @brief\
    \ AFRL2 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 4> afrl2;\n      /**\n       * @brief AFRL1 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 0..7)\n   \
    \    */\n      BitFieldModel<uint32_t, 4, 4> afrl1;\n      /**\n       * @brief\
    \ AFRL0 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> afrl0;\n    };\n  };\n\npublic:\n  /**\n   * @brief AFRL register\n  \
    \ *\n   * GPIO alternate function low\n   *           register\n   */\n  using\
    \ afrl = AfrlReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class AfrhReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief AFRH15 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 8..15)\n     */\n    using afrh15\
    \ = FieldModel<uint32_t, address, 28, 4>;\n    /**\n     * @brief AFRH14 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 8..15)\n     */\n    using afrh14 = FieldModel<uint32_t, address,\
    \ 24, 4>;\n    /**\n     * @brief AFRH13 field\n     *\n     * Alternate function\
    \ selection for port x\n     *               bit y (y = 8..15)\n     */\n    using\
    \ afrh13 = FieldModel<uint32_t, address, 20, 4>;\n    /**\n     * @brief AFRH12\
    \ field\n     *\n     * Alternate function selection for port x\n     *      \
    \         bit y (y = 8..15)\n     */\n    using afrh12 = FieldModel<uint32_t,\
    \ address, 16, 4>;\n    /**\n     * @brief AFRH11 field\n     *\n     * Alternate\
    \ function selection for port x\n     *               bit y (y = 8..15)\n    \
    \ */\n    using afrh11 = FieldModel<uint32_t, address, 12, 4>;\n    /**\n    \
    \ * @brief AFRH10 field\n     *\n     * Alternate function selection for port\
    \ x\n     *               bit y (y = 8..15)\n     */\n    using afrh10 = FieldModel<uint32_t,\
    \ address, 8, 4>;\n    /**\n     * @brief AFRH9 field\n     *\n     * Alternate\
    \ function selection for port x\n     *               bit y (y = 8..15)\n    \
    \ */\n    using afrh9 = FieldModel<uint32_t, address, 4, 4>;\n    /**\n     *\
    \ @brief AFRH8 field\n     *\n     * Alternate function selection for port x\n\
    \     *               bit y (y = 8..15)\n     */\n    using afrh8 = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief AFRH15 field\n       *\n\
    \       * Alternate function selection for port x\n       *               bit\
    \ y (y = 8..15)\n       */\n      BitFieldModel<uint32_t, 28, 4> afrh15;\n   \
    \   /**\n       * @brief AFRH14 field\n       *\n       * Alternate function selection\
    \ for port x\n       *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 4> afrh14;\n      /**\n       * @brief AFRH13 field\n       *\n       *\
    \ Alternate function selection for port x\n       *               bit y (y = 8..15)\n\
    \       */\n      BitFieldModel<uint32_t, 20, 4> afrh13;\n      /**\n       *\
    \ @brief AFRH12 field\n       *\n       * Alternate function selection for port\
    \ x\n       *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 4> afrh12;\n      /**\n       * @brief AFRH11 field\n       *\n       *\
    \ Alternate function selection for port x\n       *               bit y (y = 8..15)\n\
    \       */\n      BitFieldModel<uint32_t, 12, 4> afrh11;\n      /**\n       *\
    \ @brief AFRH10 field\n       *\n       * Alternate function selection for port\
    \ x\n       *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 4> afrh10;\n      /**\n       * @brief AFRH9 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 8..15)\n  \
    \     */\n      BitFieldModel<uint32_t, 4, 4> afrh9;\n      /**\n       * @brief\
    \ AFRH8 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> afrh8;\n    };\n  };\n\npublic:\n  /**\n   * @brief AFRH register\n  \
    \ *\n   * GPIO alternate function high\n   *           register\n   */\n  using\
    \ afrh = AfrhReg<BaseAddress + 0x0024>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_GPIOE_H\
    \ */"
  name: GPIOE
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_GPIOD_H\n#define DRAL_STM32F411_GPIOD_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ GPIOD peripheral\n *\n * General-purpose I/Os\n */\nclass gpiod\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40020C00; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class ModerReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ MODER15 field\n     *\n     * Port x configuration bits (y =\n     *       \
    \        0..15)\n     */\n    using moder15 = FieldModel<uint32_t, address, 30,\
    \ 2>;\n    /**\n     * @brief MODER14 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using moder14 = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    /**\n     * @brief MODER13 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using moder13\
    \ = FieldModel<uint32_t, address, 26, 2>;\n    /**\n     * @brief MODER12 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder12 = FieldModel<uint32_t, address, 24, 2>;\n    /**\n\
    \     * @brief MODER11 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using moder11 = FieldModel<uint32_t,\
    \ address, 22, 2>;\n    /**\n     * @brief MODER10 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using moder10\
    \ = FieldModel<uint32_t, address, 20, 2>;\n    /**\n     * @brief MODER9 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder9 = FieldModel<uint32_t, address, 18, 2>;\n    /**\n\
    \     * @brief MODER8 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using moder8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    /**\n     * @brief MODER7 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using moder7\
    \ = FieldModel<uint32_t, address, 14, 2>;\n    /**\n     * @brief MODER6 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder6 = FieldModel<uint32_t, address, 12, 2>;\n    /**\n\
    \     * @brief MODER5 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using moder5 = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    /**\n     * @brief MODER4 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using moder4\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief MODER3 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder3 = FieldModel<uint32_t, address, 6, 2>;\n    /**\n \
    \    * @brief MODER2 field\n     *\n     * Port x configuration bits (y =\n  \
    \   *               0..15)\n     */\n    using moder2 = FieldModel<uint32_t, address,\
    \ 4, 2>;\n    /**\n     * @brief MODER1 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using moder1 = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    /**\n     * @brief MODER0 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using moder0\
    \ = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ MODER15 field\n       *\n       * Port x configuration bits (y =\n       * \
    \              0..15)\n       */\n      BitFieldModel<uint32_t, 30, 2> moder15;\n\
    \      /**\n       * @brief MODER14 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 28, 2> moder14;\n      /**\n       * @brief MODER13 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 26, 2> moder13;\n      /**\n       * @brief MODER12\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 24, 2> moder12;\n    \
    \  /**\n       * @brief MODER11 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 2> moder11;\n      /**\n       * @brief MODER10 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 20, 2> moder10;\n      /**\n       * @brief MODER9\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 18, 2> moder9;\n     \
    \ /**\n       * @brief MODER8 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 2> moder8;\n      /**\n       * @brief MODER7 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 14, 2> moder7;\n      /**\n       * @brief MODER6\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 12, 2> moder6;\n     \
    \ /**\n       * @brief MODER5 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 2> moder5;\n      /**\n       * @brief MODER4 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 8, 2> moder4;\n      /**\n       * @brief MODER3\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 6, 2> moder3;\n      /**\n\
    \       * @brief MODER2 field\n       *\n       * Port x configuration bits (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 2> moder2;\n      /**\n       * @brief MODER1 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 2> moder1;\n      /**\n       * @brief MODER0 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> moder0;\n    };\n  };\n\npublic:\n  /**\n   * @brief MODER register\n\
    \   *\n   * GPIO port mode register\n   */\n  using moder = ModerReg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class OtyperReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ OT15 field\n     *\n     * Port x configuration bits (y =\n     *          \
    \     0..15)\n     */\n    using ot15 = FieldModel<uint32_t, address, 15, 1>;\n\
    \    /**\n     * @brief OT14 field\n     *\n     * Port x configuration bits (y\
    \ =\n     *               0..15)\n     */\n    using ot14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief OT13 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief OT12 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief OT11 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief OT10 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief OT9 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief OT8 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief OT7 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief OT6 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief OT5 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief OT4 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief OT3 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief OT2 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief OT1 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief OT0 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OT15 field\n       *\n\
    \       * Port x configuration bits (y =\n       *               0..15)\n    \
    \   */\n      BitFieldModel<uint32_t, 15, 1> ot15;\n      /**\n       * @brief\
    \ OT14 field\n       *\n       * Port x configuration bits (y =\n       *    \
    \           0..15)\n       */\n      BitFieldModel<uint32_t, 14, 1> ot14;\n  \
    \    /**\n       * @brief OT13 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> ot13;\n      /**\n       * @brief OT12 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> ot12;\n      /**\n       * @brief OT11 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> ot11;\n      /**\n       * @brief OT10 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> ot10;\n      /**\n       * @brief OT9 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> ot9;\n      /**\n       * @brief OT8 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> ot8;\n      /**\n       * @brief OT7 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> ot7;\n      /**\n       * @brief OT6 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> ot6;\n      /**\n       * @brief OT5 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> ot5;\n      /**\n       * @brief OT4 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> ot4;\n      /**\n       * @brief OT3 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> ot3;\n      /**\n       * @brief OT2 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> ot2;\n      /**\n       * @brief OT1 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> ot1;\n      /**\n       * @brief OT0 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> ot0;\n    };\n  };\n\npublic:\n  /**\n   * @brief OTYPER register\n  \
    \ *\n   * GPIO port output type register\n   */\n  using otyper = OtyperReg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class OspeedrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ OSPEEDR15 field\n     *\n     * Port x configuration bits (y =\n     *     \
    \          0..15)\n     */\n    using ospeedr15 = FieldModel<uint32_t, address,\
    \ 30, 2>;\n    /**\n     * @brief OSPEEDR14 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ospeedr14 = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    /**\n     * @brief OSPEEDR13 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr13\
    \ = FieldModel<uint32_t, address, 26, 2>;\n    /**\n     * @brief OSPEEDR12 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr12 = FieldModel<uint32_t, address, 24, 2>;\n    /**\n\
    \     * @brief OSPEEDR11 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr11 = FieldModel<uint32_t,\
    \ address, 22, 2>;\n    /**\n     * @brief OSPEEDR10 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr10\
    \ = FieldModel<uint32_t, address, 20, 2>;\n    /**\n     * @brief OSPEEDR9 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr9 = FieldModel<uint32_t, address, 18, 2>;\n    /**\n\
    \     * @brief OSPEEDR8 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    /**\n     * @brief OSPEEDR7 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr7\
    \ = FieldModel<uint32_t, address, 14, 2>;\n    /**\n     * @brief OSPEEDR6 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr6 = FieldModel<uint32_t, address, 12, 2>;\n    /**\n\
    \     * @brief OSPEEDR5 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr5 = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    /**\n     * @brief OSPEEDR4 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr4\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief OSPEEDR3 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr3 = FieldModel<uint32_t, address, 6, 2>;\n    /**\n\
    \     * @brief OSPEEDR2 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr2 = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    /**\n     * @brief OSPEEDR1 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr1\
    \ = FieldModel<uint32_t, address, 2, 2>;\n    /**\n     * @brief OSPEEDR0 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr0 = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief OSPEEDR15 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 30, 2> ospeedr15;\n      /**\n       * @brief OSPEEDR14 field\n       *\n  \
    \     * Port x configuration bits (y =\n       *               0..15)\n      \
    \ */\n      BitFieldModel<uint32_t, 28, 2> ospeedr14;\n      /**\n       * @brief\
    \ OSPEEDR13 field\n       *\n       * Port x configuration bits (y =\n       *\
    \               0..15)\n       */\n      BitFieldModel<uint32_t, 26, 2> ospeedr13;\n\
    \      /**\n       * @brief OSPEEDR12 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 2> ospeedr12;\n      /**\n       * @brief OSPEEDR11 field\n       *\n  \
    \     * Port x configuration bits (y =\n       *               0..15)\n      \
    \ */\n      BitFieldModel<uint32_t, 22, 2> ospeedr11;\n      /**\n       * @brief\
    \ OSPEEDR10 field\n       *\n       * Port x configuration bits (y =\n       *\
    \               0..15)\n       */\n      BitFieldModel<uint32_t, 20, 2> ospeedr10;\n\
    \      /**\n       * @brief OSPEEDR9 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 2> ospeedr9;\n      /**\n       * @brief OSPEEDR8 field\n       *\n    \
    \   * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 16, 2> ospeedr8;\n      /**\n       * @brief OSPEEDR7\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 14, 2> ospeedr7;\n   \
    \   /**\n       * @brief OSPEEDR6 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 2> ospeedr6;\n      /**\n       * @brief OSPEEDR5 field\n       *\n    \
    \   * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 10, 2> ospeedr5;\n      /**\n       * @brief OSPEEDR4\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 8, 2> ospeedr4;\n    \
    \  /**\n       * @brief OSPEEDR3 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 2> ospeedr3;\n      /**\n       * @brief OSPEEDR2 field\n       *\n     \
    \  * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 4, 2> ospeedr2;\n      /**\n       * @brief OSPEEDR1\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 2, 2> ospeedr1;\n    \
    \  /**\n       * @brief OSPEEDR0 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> ospeedr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief OSPEEDR register\n\
    \   *\n   * GPIO port output speed\n   *           register\n   */\n  using ospeedr\
    \ = OspeedrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class PupdrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief PUPDR15 field\n     *\n     * Port x configuration bits\
    \ (y =\n     *               0..15)\n     */\n    using pupdr15 = FieldModel<uint32_t,\
    \ address, 30, 2>;\n    /**\n     * @brief PUPDR14 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using pupdr14\
    \ = FieldModel<uint32_t, address, 28, 2>;\n    /**\n     * @brief PUPDR13 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr13 = FieldModel<uint32_t, address, 26, 2>;\n    /**\n\
    \     * @brief PUPDR12 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using pupdr12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    /**\n     * @brief PUPDR11 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using pupdr11\
    \ = FieldModel<uint32_t, address, 22, 2>;\n    /**\n     * @brief PUPDR10 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr10 = FieldModel<uint32_t, address, 20, 2>;\n    /**\n\
    \     * @brief PUPDR9 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using pupdr9 = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    /**\n     * @brief PUPDR8 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using pupdr8\
    \ = FieldModel<uint32_t, address, 16, 2>;\n    /**\n     * @brief PUPDR7 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr7 = FieldModel<uint32_t, address, 14, 2>;\n    /**\n\
    \     * @brief PUPDR6 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using pupdr6 = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    /**\n     * @brief PUPDR5 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using pupdr5\
    \ = FieldModel<uint32_t, address, 10, 2>;\n    /**\n     * @brief PUPDR4 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr4 = FieldModel<uint32_t, address, 8, 2>;\n    /**\n \
    \    * @brief PUPDR3 field\n     *\n     * Port x configuration bits (y =\n  \
    \   *               0..15)\n     */\n    using pupdr3 = FieldModel<uint32_t, address,\
    \ 6, 2>;\n    /**\n     * @brief PUPDR2 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using pupdr2 = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    /**\n     * @brief PUPDR1 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using pupdr1\
    \ = FieldModel<uint32_t, address, 2, 2>;\n    /**\n     * @brief PUPDR0 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr0 = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief PUPDR15 field\n       *\n       * Port x configuration bits (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 30,\
    \ 2> pupdr15;\n      /**\n       * @brief PUPDR14 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 28, 2> pupdr14;\n      /**\n       * @brief PUPDR13 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 26, 2> pupdr13;\n      /**\n       * @brief PUPDR12\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 24, 2> pupdr12;\n    \
    \  /**\n       * @brief PUPDR11 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 2> pupdr11;\n      /**\n       * @brief PUPDR10 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 20, 2> pupdr10;\n      /**\n       * @brief PUPDR9\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 18, 2> pupdr9;\n     \
    \ /**\n       * @brief PUPDR8 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 2> pupdr8;\n      /**\n       * @brief PUPDR7 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 14, 2> pupdr7;\n      /**\n       * @brief PUPDR6\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 12, 2> pupdr6;\n     \
    \ /**\n       * @brief PUPDR5 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 2> pupdr5;\n      /**\n       * @brief PUPDR4 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 8, 2> pupdr4;\n      /**\n       * @brief PUPDR3\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 6, 2> pupdr3;\n      /**\n\
    \       * @brief PUPDR2 field\n       *\n       * Port x configuration bits (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 2> pupdr2;\n      /**\n       * @brief PUPDR1 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 2> pupdr1;\n      /**\n       * @brief PUPDR0 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> pupdr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief PUPDR register\n\
    \   *\n   * GPIO port pull-up/pull-down\n   *           register\n   */\n  using\
    \ pupdr = PupdrReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class IdrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief IDR15 field\n     *\n     * Port input data (y =\n   \
    \  *               0..15)\n     */\n    using idr15 = FieldModel<uint32_t, address,\
    \ 15, 1>;\n    /**\n     * @brief IDR14 field\n     *\n     * Port input data\
    \ (y =\n     *               0..15)\n     */\n    using idr14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief IDR13 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief IDR12 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief IDR11 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief IDR10 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief IDR9 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief IDR8 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief IDR7 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief IDR6 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief IDR5 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief IDR4 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief IDR3 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief IDR2 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief IDR1 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief IDR0 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief IDR15 field\n       *\n\
    \       * Port input data (y =\n       *               0..15)\n       */\n   \
    \   BitFieldModel<uint32_t, 15, 1> idr15;\n      /**\n       * @brief IDR14 field\n\
    \       *\n       * Port input data (y =\n       *               0..15)\n    \
    \   */\n      BitFieldModel<uint32_t, 14, 1> idr14;\n      /**\n       * @brief\
    \ IDR13 field\n       *\n       * Port input data (y =\n       *             \
    \  0..15)\n       */\n      BitFieldModel<uint32_t, 13, 1> idr13;\n      /**\n\
    \       * @brief IDR12 field\n       *\n       * Port input data (y =\n      \
    \ *               0..15)\n       */\n      BitFieldModel<uint32_t, 12, 1> idr12;\n\
    \      /**\n       * @brief IDR11 field\n       *\n       * Port input data (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 11,\
    \ 1> idr11;\n      /**\n       * @brief IDR10 field\n       *\n       * Port input\
    \ data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> idr10;\n      /**\n       * @brief IDR9 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> idr9;\n      /**\n       * @brief IDR8 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> idr8;\n      /**\n       * @brief IDR7 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> idr7;\n      /**\n       * @brief IDR6 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> idr6;\n      /**\n       * @brief IDR5 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> idr5;\n      /**\n       * @brief IDR4 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> idr4;\n      /**\n       * @brief IDR3 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> idr3;\n      /**\n       * @brief IDR2 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> idr2;\n      /**\n       * @brief IDR1 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> idr1;\n      /**\n       * @brief IDR0 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> idr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief IDR register\n   *\n\
    \   * GPIO port input data register\n   */\n  using idr = IdrReg<BaseAddress +\
    \ 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class OdrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief ODR15\
    \ field\n     *\n     * Port output data (y =\n     *               0..15)\n \
    \    */\n    using odr15 = FieldModel<uint32_t, address, 15, 1>;\n    /**\n  \
    \   * @brief ODR14 field\n     *\n     * Port output data (y =\n     *       \
    \        0..15)\n     */\n    using odr14 = FieldModel<uint32_t, address, 14,\
    \ 1>;\n    /**\n     * @brief ODR13 field\n     *\n     * Port output data (y\
    \ =\n     *               0..15)\n     */\n    using odr13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief ODR12 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief ODR11 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief ODR10 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief ODR9 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief ODR8 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief ODR7 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief ODR6 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief ODR5 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief ODR4 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ODR3 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief ODR2 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief ODR1 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief ODR0 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief ODR15 field\n       *\n\
    \       * Port output data (y =\n       *               0..15)\n       */\n  \
    \    BitFieldModel<uint32_t, 15, 1> odr15;\n      /**\n       * @brief ODR14 field\n\
    \       *\n       * Port output data (y =\n       *               0..15)\n   \
    \    */\n      BitFieldModel<uint32_t, 14, 1> odr14;\n      /**\n       * @brief\
    \ ODR13 field\n       *\n       * Port output data (y =\n       *            \
    \   0..15)\n       */\n      BitFieldModel<uint32_t, 13, 1> odr13;\n      /**\n\
    \       * @brief ODR12 field\n       *\n       * Port output data (y =\n     \
    \  *               0..15)\n       */\n      BitFieldModel<uint32_t, 12, 1> odr12;\n\
    \      /**\n       * @brief ODR11 field\n       *\n       * Port output data (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 11,\
    \ 1> odr11;\n      /**\n       * @brief ODR10 field\n       *\n       * Port output\
    \ data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> odr10;\n      /**\n       * @brief ODR9 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> odr9;\n      /**\n       * @brief ODR8 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> odr8;\n      /**\n       * @brief ODR7 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> odr7;\n      /**\n       * @brief ODR6 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> odr6;\n      /**\n       * @brief ODR5 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> odr5;\n      /**\n       * @brief ODR4 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> odr4;\n      /**\n       * @brief ODR3 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> odr3;\n      /**\n       * @brief ODR2 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> odr2;\n      /**\n       * @brief ODR1 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> odr1;\n      /**\n       * @brief ODR0 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> odr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief ODR register\n   *\n\
    \   * GPIO port output data register\n   */\n  using odr = OdrReg<BaseAddress\
    \ + 0x0014>;\n\nprivate:\n  template<unsigned int address>\n  class BsrrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ BR15 field\n     *\n     * Port x reset bit y (y =\n     *               0..15)\n\
    \     */\n    using br15 = FieldModel<uint32_t, address, 31, 1>;\n    /**\n  \
    \   * @brief BR14 field\n     *\n     * Port x reset bit y (y =\n     *      \
    \         0..15)\n     */\n    using br14 = FieldModel<uint32_t, address, 30,\
    \ 1>;\n    /**\n     * @brief BR13 field\n     *\n     * Port x reset bit y (y\
    \ =\n     *               0..15)\n     */\n    using br13 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    /**\n     * @brief BR12 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br12 = FieldModel<uint32_t,\
    \ address, 28, 1>;\n    /**\n     * @brief BR11 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br11 = FieldModel<uint32_t,\
    \ address, 27, 1>;\n    /**\n     * @brief BR10 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br10 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    /**\n     * @brief BR9 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br9 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    /**\n     * @brief BR8 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br8 = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    /**\n     * @brief BR7 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br7 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    /**\n     * @brief BR6 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br6 = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    /**\n     * @brief BR5 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br5 = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    /**\n     * @brief BR4 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br4 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief BR3 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br3 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief BR2 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br2 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    /**\n     * @brief BR1 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br1 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    /**\n     * @brief BR0 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using br0 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    /**\n     * @brief BS15 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief BS14 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief BS13 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief BS12 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief BS11 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief BS10 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief BS9 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief BS8 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief BS7 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief BS6 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief BS5 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief BS4 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief BS3 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief BS2 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief BS1 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief BS0 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief BR15 field\n       *\n\
    \       * Port x reset bit y (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 31, 1> br15;\n      /**\n       * @brief BR14 field\n\
    \       *\n       * Port x reset bit y (y =\n       *               0..15)\n \
    \      */\n      BitFieldModel<uint32_t, 30, 1> br14;\n      /**\n       * @brief\
    \ BR13 field\n       *\n       * Port x reset bit y (y =\n       *           \
    \    0..15)\n       */\n      BitFieldModel<uint32_t, 29, 1> br13;\n      /**\n\
    \       * @brief BR12 field\n       *\n       * Port x reset bit y (y =\n    \
    \   *               0..15)\n       */\n      BitFieldModel<uint32_t, 28, 1> br12;\n\
    \      /**\n       * @brief BR11 field\n       *\n       * Port x reset bit y\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 27, 1> br11;\n      /**\n       * @brief BR10 field\n       *\n       * Port\
    \ x reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 26, 1> br10;\n      /**\n       * @brief BR9 field\n       *\n       * Port\
    \ x reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 1> br9;\n      /**\n       * @brief BR8 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 1> br8;\n      /**\n       * @brief BR7 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 1> br7;\n      /**\n       * @brief BR6 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> br6;\n      /**\n       * @brief BR5 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 1> br5;\n      /**\n       * @brief BR4 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 1> br4;\n      /**\n       * @brief BR3 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> br3;\n      /**\n       * @brief BR2 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 1> br2;\n      /**\n       * @brief BR1 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> br1;\n      /**\n       * @brief BR0 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> br0;\n      /**\n       * @brief BS15 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> bs15;\n      /**\n       * @brief BS14 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> bs14;\n      /**\n       * @brief BS13 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> bs13;\n      /**\n       * @brief BS12 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> bs12;\n      /**\n       * @brief BS11 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> bs11;\n      /**\n       * @brief BS10 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> bs10;\n      /**\n       * @brief BS9 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> bs9;\n      /**\n       * @brief BS8 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> bs8;\n      /**\n       * @brief BS7 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> bs7;\n      /**\n       * @brief BS6 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> bs6;\n      /**\n       * @brief BS5 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> bs5;\n      /**\n       * @brief BS4 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> bs4;\n      /**\n       * @brief BS3 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> bs3;\n      /**\n       * @brief BS2 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> bs2;\n      /**\n       * @brief BS1 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> bs1;\n      /**\n       * @brief BS0 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> bs0;\n    };\n  };\n\npublic:\n  /**\n   * @brief BSRR register\n   *\n\
    \   * GPIO port bit set/reset\n   *           register\n   */\n  using bsrr =\
    \ BsrrReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class LckrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief LCKK field\n     *\n     * Port x lock bit y (y=\n    \
    \ *               0..15)\n     */\n    using lckk = FieldModel<uint32_t, address,\
    \ 16, 1>;\n    /**\n     * @brief LCK15 field\n     *\n     * Port x lock bit\
    \ y (y=\n     *               0..15)\n     */\n    using lck15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief LCK14 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief LCK13 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief LCK12 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief LCK11 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief LCK10 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief LCK9 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief LCK8 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief LCK7 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief LCK6 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief LCK5 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief LCK4 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief LCK3 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief LCK2 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief LCK1 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief LCK0 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief LCKK field\n       *\n\
    \       * Port x lock bit y (y=\n       *               0..15)\n       */\n  \
    \    BitFieldModel<uint32_t, 16, 1> lckk;\n      /**\n       * @brief LCK15 field\n\
    \       *\n       * Port x lock bit y (y=\n       *               0..15)\n   \
    \    */\n      BitFieldModel<uint32_t, 15, 1> lck15;\n      /**\n       * @brief\
    \ LCK14 field\n       *\n       * Port x lock bit y (y=\n       *            \
    \   0..15)\n       */\n      BitFieldModel<uint32_t, 14, 1> lck14;\n      /**\n\
    \       * @brief LCK13 field\n       *\n       * Port x lock bit y (y=\n     \
    \  *               0..15)\n       */\n      BitFieldModel<uint32_t, 13, 1> lck13;\n\
    \      /**\n       * @brief LCK12 field\n       *\n       * Port x lock bit y\
    \ (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> lck12;\n      /**\n       * @brief LCK11 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> lck11;\n      /**\n       * @brief LCK10 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> lck10;\n      /**\n       * @brief LCK9 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> lck9;\n      /**\n       * @brief LCK8 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> lck8;\n      /**\n       * @brief LCK7 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> lck7;\n      /**\n       * @brief LCK6 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> lck6;\n      /**\n       * @brief LCK5 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> lck5;\n      /**\n       * @brief LCK4 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> lck4;\n      /**\n       * @brief LCK3 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> lck3;\n      /**\n       * @brief LCK2 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> lck2;\n      /**\n       * @brief LCK1 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> lck1;\n      /**\n       * @brief LCK0 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> lck0;\n    };\n  };\n\npublic:\n  /**\n   * @brief LCKR register\n   *\n\
    \   * GPIO port configuration lock\n   *           register\n   */\n  using lckr\
    \ = LckrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class AfrlReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief AFRL7 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl7\
    \ = FieldModel<uint32_t, address, 28, 4>;\n    /**\n     * @brief AFRL6 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl6 = FieldModel<uint32_t, address, 24,\
    \ 4>;\n    /**\n     * @brief AFRL5 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl5\
    \ = FieldModel<uint32_t, address, 20, 4>;\n    /**\n     * @brief AFRL4 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl4 = FieldModel<uint32_t, address, 16,\
    \ 4>;\n    /**\n     * @brief AFRL3 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl3\
    \ = FieldModel<uint32_t, address, 12, 4>;\n    /**\n     * @brief AFRL2 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl2 = FieldModel<uint32_t, address, 8,\
    \ 4>;\n    /**\n     * @brief AFRL1 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl1\
    \ = FieldModel<uint32_t, address, 4, 4>;\n    /**\n     * @brief AFRL0 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl0 = FieldModel<uint32_t, address, 0,\
    \ 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief AFRL7 field\n       *\n   \
    \    * Alternate function selection for port x\n       *               bit y (y\
    \ = 0..7)\n       */\n      BitFieldModel<uint32_t, 28, 4> afrl7;\n      /**\n\
    \       * @brief AFRL6 field\n       *\n       * Alternate function selection\
    \ for port x\n       *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 4> afrl6;\n      /**\n       * @brief AFRL5 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 0..7)\n   \
    \    */\n      BitFieldModel<uint32_t, 20, 4> afrl5;\n      /**\n       * @brief\
    \ AFRL4 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 4> afrl4;\n      /**\n       * @brief AFRL3 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 0..7)\n   \
    \    */\n      BitFieldModel<uint32_t, 12, 4> afrl3;\n      /**\n       * @brief\
    \ AFRL2 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 4> afrl2;\n      /**\n       * @brief AFRL1 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 0..7)\n   \
    \    */\n      BitFieldModel<uint32_t, 4, 4> afrl1;\n      /**\n       * @brief\
    \ AFRL0 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> afrl0;\n    };\n  };\n\npublic:\n  /**\n   * @brief AFRL register\n  \
    \ *\n   * GPIO alternate function low\n   *           register\n   */\n  using\
    \ afrl = AfrlReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class AfrhReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief AFRH15 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 8..15)\n     */\n    using afrh15\
    \ = FieldModel<uint32_t, address, 28, 4>;\n    /**\n     * @brief AFRH14 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 8..15)\n     */\n    using afrh14 = FieldModel<uint32_t, address,\
    \ 24, 4>;\n    /**\n     * @brief AFRH13 field\n     *\n     * Alternate function\
    \ selection for port x\n     *               bit y (y = 8..15)\n     */\n    using\
    \ afrh13 = FieldModel<uint32_t, address, 20, 4>;\n    /**\n     * @brief AFRH12\
    \ field\n     *\n     * Alternate function selection for port x\n     *      \
    \         bit y (y = 8..15)\n     */\n    using afrh12 = FieldModel<uint32_t,\
    \ address, 16, 4>;\n    /**\n     * @brief AFRH11 field\n     *\n     * Alternate\
    \ function selection for port x\n     *               bit y (y = 8..15)\n    \
    \ */\n    using afrh11 = FieldModel<uint32_t, address, 12, 4>;\n    /**\n    \
    \ * @brief AFRH10 field\n     *\n     * Alternate function selection for port\
    \ x\n     *               bit y (y = 8..15)\n     */\n    using afrh10 = FieldModel<uint32_t,\
    \ address, 8, 4>;\n    /**\n     * @brief AFRH9 field\n     *\n     * Alternate\
    \ function selection for port x\n     *               bit y (y = 8..15)\n    \
    \ */\n    using afrh9 = FieldModel<uint32_t, address, 4, 4>;\n    /**\n     *\
    \ @brief AFRH8 field\n     *\n     * Alternate function selection for port x\n\
    \     *               bit y (y = 8..15)\n     */\n    using afrh8 = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief AFRH15 field\n       *\n\
    \       * Alternate function selection for port x\n       *               bit\
    \ y (y = 8..15)\n       */\n      BitFieldModel<uint32_t, 28, 4> afrh15;\n   \
    \   /**\n       * @brief AFRH14 field\n       *\n       * Alternate function selection\
    \ for port x\n       *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 4> afrh14;\n      /**\n       * @brief AFRH13 field\n       *\n       *\
    \ Alternate function selection for port x\n       *               bit y (y = 8..15)\n\
    \       */\n      BitFieldModel<uint32_t, 20, 4> afrh13;\n      /**\n       *\
    \ @brief AFRH12 field\n       *\n       * Alternate function selection for port\
    \ x\n       *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 4> afrh12;\n      /**\n       * @brief AFRH11 field\n       *\n       *\
    \ Alternate function selection for port x\n       *               bit y (y = 8..15)\n\
    \       */\n      BitFieldModel<uint32_t, 12, 4> afrh11;\n      /**\n       *\
    \ @brief AFRH10 field\n       *\n       * Alternate function selection for port\
    \ x\n       *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 4> afrh10;\n      /**\n       * @brief AFRH9 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 8..15)\n  \
    \     */\n      BitFieldModel<uint32_t, 4, 4> afrh9;\n      /**\n       * @brief\
    \ AFRH8 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> afrh8;\n    };\n  };\n\npublic:\n  /**\n   * @brief AFRH register\n  \
    \ *\n   * GPIO alternate function high\n   *           register\n   */\n  using\
    \ afrh = AfrhReg<BaseAddress + 0x0024>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_GPIOD_H\
    \ */"
  name: GPIOD
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_GPIOC_H\n#define DRAL_STM32F411_GPIOC_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ GPIOC peripheral\n *\n * General-purpose I/Os\n */\nclass gpioc\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40020800; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class ModerReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ MODER15 field\n     *\n     * Port x configuration bits (y =\n     *       \
    \        0..15)\n     */\n    using moder15 = FieldModel<uint32_t, address, 30,\
    \ 2>;\n    /**\n     * @brief MODER14 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using moder14 = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    /**\n     * @brief MODER13 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using moder13\
    \ = FieldModel<uint32_t, address, 26, 2>;\n    /**\n     * @brief MODER12 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder12 = FieldModel<uint32_t, address, 24, 2>;\n    /**\n\
    \     * @brief MODER11 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using moder11 = FieldModel<uint32_t,\
    \ address, 22, 2>;\n    /**\n     * @brief MODER10 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using moder10\
    \ = FieldModel<uint32_t, address, 20, 2>;\n    /**\n     * @brief MODER9 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder9 = FieldModel<uint32_t, address, 18, 2>;\n    /**\n\
    \     * @brief MODER8 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using moder8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    /**\n     * @brief MODER7 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using moder7\
    \ = FieldModel<uint32_t, address, 14, 2>;\n    /**\n     * @brief MODER6 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder6 = FieldModel<uint32_t, address, 12, 2>;\n    /**\n\
    \     * @brief MODER5 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using moder5 = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    /**\n     * @brief MODER4 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using moder4\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief MODER3 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder3 = FieldModel<uint32_t, address, 6, 2>;\n    /**\n \
    \    * @brief MODER2 field\n     *\n     * Port x configuration bits (y =\n  \
    \   *               0..15)\n     */\n    using moder2 = FieldModel<uint32_t, address,\
    \ 4, 2>;\n    /**\n     * @brief MODER1 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using moder1 = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    /**\n     * @brief MODER0 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using moder0\
    \ = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ MODER15 field\n       *\n       * Port x configuration bits (y =\n       * \
    \              0..15)\n       */\n      BitFieldModel<uint32_t, 30, 2> moder15;\n\
    \      /**\n       * @brief MODER14 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 28, 2> moder14;\n      /**\n       * @brief MODER13 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 26, 2> moder13;\n      /**\n       * @brief MODER12\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 24, 2> moder12;\n    \
    \  /**\n       * @brief MODER11 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 2> moder11;\n      /**\n       * @brief MODER10 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 20, 2> moder10;\n      /**\n       * @brief MODER9\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 18, 2> moder9;\n     \
    \ /**\n       * @brief MODER8 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 2> moder8;\n      /**\n       * @brief MODER7 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 14, 2> moder7;\n      /**\n       * @brief MODER6\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 12, 2> moder6;\n     \
    \ /**\n       * @brief MODER5 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 2> moder5;\n      /**\n       * @brief MODER4 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 8, 2> moder4;\n      /**\n       * @brief MODER3\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 6, 2> moder3;\n      /**\n\
    \       * @brief MODER2 field\n       *\n       * Port x configuration bits (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 2> moder2;\n      /**\n       * @brief MODER1 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 2> moder1;\n      /**\n       * @brief MODER0 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> moder0;\n    };\n  };\n\npublic:\n  /**\n   * @brief MODER register\n\
    \   *\n   * GPIO port mode register\n   */\n  using moder = ModerReg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class OtyperReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ OT15 field\n     *\n     * Port x configuration bits (y =\n     *          \
    \     0..15)\n     */\n    using ot15 = FieldModel<uint32_t, address, 15, 1>;\n\
    \    /**\n     * @brief OT14 field\n     *\n     * Port x configuration bits (y\
    \ =\n     *               0..15)\n     */\n    using ot14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief OT13 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief OT12 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief OT11 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief OT10 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief OT9 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief OT8 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief OT7 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief OT6 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief OT5 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief OT4 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief OT3 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief OT2 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief OT1 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief OT0 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OT15 field\n       *\n\
    \       * Port x configuration bits (y =\n       *               0..15)\n    \
    \   */\n      BitFieldModel<uint32_t, 15, 1> ot15;\n      /**\n       * @brief\
    \ OT14 field\n       *\n       * Port x configuration bits (y =\n       *    \
    \           0..15)\n       */\n      BitFieldModel<uint32_t, 14, 1> ot14;\n  \
    \    /**\n       * @brief OT13 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> ot13;\n      /**\n       * @brief OT12 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> ot12;\n      /**\n       * @brief OT11 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> ot11;\n      /**\n       * @brief OT10 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> ot10;\n      /**\n       * @brief OT9 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> ot9;\n      /**\n       * @brief OT8 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> ot8;\n      /**\n       * @brief OT7 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> ot7;\n      /**\n       * @brief OT6 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> ot6;\n      /**\n       * @brief OT5 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> ot5;\n      /**\n       * @brief OT4 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> ot4;\n      /**\n       * @brief OT3 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> ot3;\n      /**\n       * @brief OT2 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> ot2;\n      /**\n       * @brief OT1 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> ot1;\n      /**\n       * @brief OT0 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> ot0;\n    };\n  };\n\npublic:\n  /**\n   * @brief OTYPER register\n  \
    \ *\n   * GPIO port output type register\n   */\n  using otyper = OtyperReg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class OspeedrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ OSPEEDR15 field\n     *\n     * Port x configuration bits (y =\n     *     \
    \          0..15)\n     */\n    using ospeedr15 = FieldModel<uint32_t, address,\
    \ 30, 2>;\n    /**\n     * @brief OSPEEDR14 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ospeedr14 = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    /**\n     * @brief OSPEEDR13 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr13\
    \ = FieldModel<uint32_t, address, 26, 2>;\n    /**\n     * @brief OSPEEDR12 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr12 = FieldModel<uint32_t, address, 24, 2>;\n    /**\n\
    \     * @brief OSPEEDR11 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr11 = FieldModel<uint32_t,\
    \ address, 22, 2>;\n    /**\n     * @brief OSPEEDR10 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr10\
    \ = FieldModel<uint32_t, address, 20, 2>;\n    /**\n     * @brief OSPEEDR9 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr9 = FieldModel<uint32_t, address, 18, 2>;\n    /**\n\
    \     * @brief OSPEEDR8 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    /**\n     * @brief OSPEEDR7 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr7\
    \ = FieldModel<uint32_t, address, 14, 2>;\n    /**\n     * @brief OSPEEDR6 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr6 = FieldModel<uint32_t, address, 12, 2>;\n    /**\n\
    \     * @brief OSPEEDR5 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr5 = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    /**\n     * @brief OSPEEDR4 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr4\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief OSPEEDR3 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr3 = FieldModel<uint32_t, address, 6, 2>;\n    /**\n\
    \     * @brief OSPEEDR2 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr2 = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    /**\n     * @brief OSPEEDR1 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr1\
    \ = FieldModel<uint32_t, address, 2, 2>;\n    /**\n     * @brief OSPEEDR0 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr0 = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief OSPEEDR15 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 30, 2> ospeedr15;\n      /**\n       * @brief OSPEEDR14 field\n       *\n  \
    \     * Port x configuration bits (y =\n       *               0..15)\n      \
    \ */\n      BitFieldModel<uint32_t, 28, 2> ospeedr14;\n      /**\n       * @brief\
    \ OSPEEDR13 field\n       *\n       * Port x configuration bits (y =\n       *\
    \               0..15)\n       */\n      BitFieldModel<uint32_t, 26, 2> ospeedr13;\n\
    \      /**\n       * @brief OSPEEDR12 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 2> ospeedr12;\n      /**\n       * @brief OSPEEDR11 field\n       *\n  \
    \     * Port x configuration bits (y =\n       *               0..15)\n      \
    \ */\n      BitFieldModel<uint32_t, 22, 2> ospeedr11;\n      /**\n       * @brief\
    \ OSPEEDR10 field\n       *\n       * Port x configuration bits (y =\n       *\
    \               0..15)\n       */\n      BitFieldModel<uint32_t, 20, 2> ospeedr10;\n\
    \      /**\n       * @brief OSPEEDR9 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 2> ospeedr9;\n      /**\n       * @brief OSPEEDR8 field\n       *\n    \
    \   * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 16, 2> ospeedr8;\n      /**\n       * @brief OSPEEDR7\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 14, 2> ospeedr7;\n   \
    \   /**\n       * @brief OSPEEDR6 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 2> ospeedr6;\n      /**\n       * @brief OSPEEDR5 field\n       *\n    \
    \   * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 10, 2> ospeedr5;\n      /**\n       * @brief OSPEEDR4\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 8, 2> ospeedr4;\n    \
    \  /**\n       * @brief OSPEEDR3 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 2> ospeedr3;\n      /**\n       * @brief OSPEEDR2 field\n       *\n     \
    \  * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 4, 2> ospeedr2;\n      /**\n       * @brief OSPEEDR1\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 2, 2> ospeedr1;\n    \
    \  /**\n       * @brief OSPEEDR0 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> ospeedr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief OSPEEDR register\n\
    \   *\n   * GPIO port output speed\n   *           register\n   */\n  using ospeedr\
    \ = OspeedrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class PupdrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief PUPDR15 field\n     *\n     * Port x configuration bits\
    \ (y =\n     *               0..15)\n     */\n    using pupdr15 = FieldModel<uint32_t,\
    \ address, 30, 2>;\n    /**\n     * @brief PUPDR14 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using pupdr14\
    \ = FieldModel<uint32_t, address, 28, 2>;\n    /**\n     * @brief PUPDR13 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr13 = FieldModel<uint32_t, address, 26, 2>;\n    /**\n\
    \     * @brief PUPDR12 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using pupdr12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    /**\n     * @brief PUPDR11 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using pupdr11\
    \ = FieldModel<uint32_t, address, 22, 2>;\n    /**\n     * @brief PUPDR10 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr10 = FieldModel<uint32_t, address, 20, 2>;\n    /**\n\
    \     * @brief PUPDR9 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using pupdr9 = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    /**\n     * @brief PUPDR8 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using pupdr8\
    \ = FieldModel<uint32_t, address, 16, 2>;\n    /**\n     * @brief PUPDR7 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr7 = FieldModel<uint32_t, address, 14, 2>;\n    /**\n\
    \     * @brief PUPDR6 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using pupdr6 = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    /**\n     * @brief PUPDR5 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using pupdr5\
    \ = FieldModel<uint32_t, address, 10, 2>;\n    /**\n     * @brief PUPDR4 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr4 = FieldModel<uint32_t, address, 8, 2>;\n    /**\n \
    \    * @brief PUPDR3 field\n     *\n     * Port x configuration bits (y =\n  \
    \   *               0..15)\n     */\n    using pupdr3 = FieldModel<uint32_t, address,\
    \ 6, 2>;\n    /**\n     * @brief PUPDR2 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using pupdr2 = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    /**\n     * @brief PUPDR1 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using pupdr1\
    \ = FieldModel<uint32_t, address, 2, 2>;\n    /**\n     * @brief PUPDR0 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr0 = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief PUPDR15 field\n       *\n       * Port x configuration bits (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 30,\
    \ 2> pupdr15;\n      /**\n       * @brief PUPDR14 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 28, 2> pupdr14;\n      /**\n       * @brief PUPDR13 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 26, 2> pupdr13;\n      /**\n       * @brief PUPDR12\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 24, 2> pupdr12;\n    \
    \  /**\n       * @brief PUPDR11 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 2> pupdr11;\n      /**\n       * @brief PUPDR10 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 20, 2> pupdr10;\n      /**\n       * @brief PUPDR9\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 18, 2> pupdr9;\n     \
    \ /**\n       * @brief PUPDR8 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 2> pupdr8;\n      /**\n       * @brief PUPDR7 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 14, 2> pupdr7;\n      /**\n       * @brief PUPDR6\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 12, 2> pupdr6;\n     \
    \ /**\n       * @brief PUPDR5 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 2> pupdr5;\n      /**\n       * @brief PUPDR4 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 8, 2> pupdr4;\n      /**\n       * @brief PUPDR3\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 6, 2> pupdr3;\n      /**\n\
    \       * @brief PUPDR2 field\n       *\n       * Port x configuration bits (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 2> pupdr2;\n      /**\n       * @brief PUPDR1 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 2> pupdr1;\n      /**\n       * @brief PUPDR0 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> pupdr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief PUPDR register\n\
    \   *\n   * GPIO port pull-up/pull-down\n   *           register\n   */\n  using\
    \ pupdr = PupdrReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class IdrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief IDR15 field\n     *\n     * Port input data (y =\n   \
    \  *               0..15)\n     */\n    using idr15 = FieldModel<uint32_t, address,\
    \ 15, 1>;\n    /**\n     * @brief IDR14 field\n     *\n     * Port input data\
    \ (y =\n     *               0..15)\n     */\n    using idr14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief IDR13 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief IDR12 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief IDR11 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief IDR10 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief IDR9 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief IDR8 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief IDR7 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief IDR6 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief IDR5 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief IDR4 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief IDR3 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief IDR2 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief IDR1 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief IDR0 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief IDR15 field\n       *\n\
    \       * Port input data (y =\n       *               0..15)\n       */\n   \
    \   BitFieldModel<uint32_t, 15, 1> idr15;\n      /**\n       * @brief IDR14 field\n\
    \       *\n       * Port input data (y =\n       *               0..15)\n    \
    \   */\n      BitFieldModel<uint32_t, 14, 1> idr14;\n      /**\n       * @brief\
    \ IDR13 field\n       *\n       * Port input data (y =\n       *             \
    \  0..15)\n       */\n      BitFieldModel<uint32_t, 13, 1> idr13;\n      /**\n\
    \       * @brief IDR12 field\n       *\n       * Port input data (y =\n      \
    \ *               0..15)\n       */\n      BitFieldModel<uint32_t, 12, 1> idr12;\n\
    \      /**\n       * @brief IDR11 field\n       *\n       * Port input data (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 11,\
    \ 1> idr11;\n      /**\n       * @brief IDR10 field\n       *\n       * Port input\
    \ data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> idr10;\n      /**\n       * @brief IDR9 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> idr9;\n      /**\n       * @brief IDR8 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> idr8;\n      /**\n       * @brief IDR7 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> idr7;\n      /**\n       * @brief IDR6 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> idr6;\n      /**\n       * @brief IDR5 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> idr5;\n      /**\n       * @brief IDR4 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> idr4;\n      /**\n       * @brief IDR3 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> idr3;\n      /**\n       * @brief IDR2 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> idr2;\n      /**\n       * @brief IDR1 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> idr1;\n      /**\n       * @brief IDR0 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> idr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief IDR register\n   *\n\
    \   * GPIO port input data register\n   */\n  using idr = IdrReg<BaseAddress +\
    \ 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class OdrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief ODR15\
    \ field\n     *\n     * Port output data (y =\n     *               0..15)\n \
    \    */\n    using odr15 = FieldModel<uint32_t, address, 15, 1>;\n    /**\n  \
    \   * @brief ODR14 field\n     *\n     * Port output data (y =\n     *       \
    \        0..15)\n     */\n    using odr14 = FieldModel<uint32_t, address, 14,\
    \ 1>;\n    /**\n     * @brief ODR13 field\n     *\n     * Port output data (y\
    \ =\n     *               0..15)\n     */\n    using odr13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief ODR12 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief ODR11 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief ODR10 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief ODR9 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief ODR8 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief ODR7 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief ODR6 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief ODR5 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief ODR4 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ODR3 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief ODR2 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief ODR1 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief ODR0 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief ODR15 field\n       *\n\
    \       * Port output data (y =\n       *               0..15)\n       */\n  \
    \    BitFieldModel<uint32_t, 15, 1> odr15;\n      /**\n       * @brief ODR14 field\n\
    \       *\n       * Port output data (y =\n       *               0..15)\n   \
    \    */\n      BitFieldModel<uint32_t, 14, 1> odr14;\n      /**\n       * @brief\
    \ ODR13 field\n       *\n       * Port output data (y =\n       *            \
    \   0..15)\n       */\n      BitFieldModel<uint32_t, 13, 1> odr13;\n      /**\n\
    \       * @brief ODR12 field\n       *\n       * Port output data (y =\n     \
    \  *               0..15)\n       */\n      BitFieldModel<uint32_t, 12, 1> odr12;\n\
    \      /**\n       * @brief ODR11 field\n       *\n       * Port output data (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 11,\
    \ 1> odr11;\n      /**\n       * @brief ODR10 field\n       *\n       * Port output\
    \ data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> odr10;\n      /**\n       * @brief ODR9 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> odr9;\n      /**\n       * @brief ODR8 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> odr8;\n      /**\n       * @brief ODR7 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> odr7;\n      /**\n       * @brief ODR6 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> odr6;\n      /**\n       * @brief ODR5 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> odr5;\n      /**\n       * @brief ODR4 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> odr4;\n      /**\n       * @brief ODR3 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> odr3;\n      /**\n       * @brief ODR2 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> odr2;\n      /**\n       * @brief ODR1 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> odr1;\n      /**\n       * @brief ODR0 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> odr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief ODR register\n   *\n\
    \   * GPIO port output data register\n   */\n  using odr = OdrReg<BaseAddress\
    \ + 0x0014>;\n\nprivate:\n  template<unsigned int address>\n  class BsrrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ BR15 field\n     *\n     * Port x reset bit y (y =\n     *               0..15)\n\
    \     */\n    using br15 = FieldModel<uint32_t, address, 31, 1>;\n    /**\n  \
    \   * @brief BR14 field\n     *\n     * Port x reset bit y (y =\n     *      \
    \         0..15)\n     */\n    using br14 = FieldModel<uint32_t, address, 30,\
    \ 1>;\n    /**\n     * @brief BR13 field\n     *\n     * Port x reset bit y (y\
    \ =\n     *               0..15)\n     */\n    using br13 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    /**\n     * @brief BR12 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br12 = FieldModel<uint32_t,\
    \ address, 28, 1>;\n    /**\n     * @brief BR11 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br11 = FieldModel<uint32_t,\
    \ address, 27, 1>;\n    /**\n     * @brief BR10 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br10 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    /**\n     * @brief BR9 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br9 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    /**\n     * @brief BR8 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br8 = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    /**\n     * @brief BR7 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br7 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    /**\n     * @brief BR6 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br6 = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    /**\n     * @brief BR5 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br5 = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    /**\n     * @brief BR4 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br4 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief BR3 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br3 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief BR2 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br2 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    /**\n     * @brief BR1 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br1 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    /**\n     * @brief BR0 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using br0 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    /**\n     * @brief BS15 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief BS14 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief BS13 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief BS12 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief BS11 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief BS10 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief BS9 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief BS8 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief BS7 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief BS6 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief BS5 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief BS4 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief BS3 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief BS2 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief BS1 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief BS0 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief BR15 field\n       *\n\
    \       * Port x reset bit y (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 31, 1> br15;\n      /**\n       * @brief BR14 field\n\
    \       *\n       * Port x reset bit y (y =\n       *               0..15)\n \
    \      */\n      BitFieldModel<uint32_t, 30, 1> br14;\n      /**\n       * @brief\
    \ BR13 field\n       *\n       * Port x reset bit y (y =\n       *           \
    \    0..15)\n       */\n      BitFieldModel<uint32_t, 29, 1> br13;\n      /**\n\
    \       * @brief BR12 field\n       *\n       * Port x reset bit y (y =\n    \
    \   *               0..15)\n       */\n      BitFieldModel<uint32_t, 28, 1> br12;\n\
    \      /**\n       * @brief BR11 field\n       *\n       * Port x reset bit y\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 27, 1> br11;\n      /**\n       * @brief BR10 field\n       *\n       * Port\
    \ x reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 26, 1> br10;\n      /**\n       * @brief BR9 field\n       *\n       * Port\
    \ x reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 1> br9;\n      /**\n       * @brief BR8 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 1> br8;\n      /**\n       * @brief BR7 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 1> br7;\n      /**\n       * @brief BR6 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> br6;\n      /**\n       * @brief BR5 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 1> br5;\n      /**\n       * @brief BR4 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 1> br4;\n      /**\n       * @brief BR3 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> br3;\n      /**\n       * @brief BR2 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 1> br2;\n      /**\n       * @brief BR1 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> br1;\n      /**\n       * @brief BR0 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> br0;\n      /**\n       * @brief BS15 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> bs15;\n      /**\n       * @brief BS14 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> bs14;\n      /**\n       * @brief BS13 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> bs13;\n      /**\n       * @brief BS12 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> bs12;\n      /**\n       * @brief BS11 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> bs11;\n      /**\n       * @brief BS10 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> bs10;\n      /**\n       * @brief BS9 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> bs9;\n      /**\n       * @brief BS8 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> bs8;\n      /**\n       * @brief BS7 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> bs7;\n      /**\n       * @brief BS6 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> bs6;\n      /**\n       * @brief BS5 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> bs5;\n      /**\n       * @brief BS4 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> bs4;\n      /**\n       * @brief BS3 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> bs3;\n      /**\n       * @brief BS2 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> bs2;\n      /**\n       * @brief BS1 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> bs1;\n      /**\n       * @brief BS0 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> bs0;\n    };\n  };\n\npublic:\n  /**\n   * @brief BSRR register\n   *\n\
    \   * GPIO port bit set/reset\n   *           register\n   */\n  using bsrr =\
    \ BsrrReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class LckrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief LCKK field\n     *\n     * Port x lock bit y (y=\n    \
    \ *               0..15)\n     */\n    using lckk = FieldModel<uint32_t, address,\
    \ 16, 1>;\n    /**\n     * @brief LCK15 field\n     *\n     * Port x lock bit\
    \ y (y=\n     *               0..15)\n     */\n    using lck15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief LCK14 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief LCK13 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief LCK12 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief LCK11 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief LCK10 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief LCK9 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief LCK8 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief LCK7 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief LCK6 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief LCK5 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief LCK4 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief LCK3 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief LCK2 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief LCK1 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief LCK0 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief LCKK field\n       *\n\
    \       * Port x lock bit y (y=\n       *               0..15)\n       */\n  \
    \    BitFieldModel<uint32_t, 16, 1> lckk;\n      /**\n       * @brief LCK15 field\n\
    \       *\n       * Port x lock bit y (y=\n       *               0..15)\n   \
    \    */\n      BitFieldModel<uint32_t, 15, 1> lck15;\n      /**\n       * @brief\
    \ LCK14 field\n       *\n       * Port x lock bit y (y=\n       *            \
    \   0..15)\n       */\n      BitFieldModel<uint32_t, 14, 1> lck14;\n      /**\n\
    \       * @brief LCK13 field\n       *\n       * Port x lock bit y (y=\n     \
    \  *               0..15)\n       */\n      BitFieldModel<uint32_t, 13, 1> lck13;\n\
    \      /**\n       * @brief LCK12 field\n       *\n       * Port x lock bit y\
    \ (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> lck12;\n      /**\n       * @brief LCK11 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> lck11;\n      /**\n       * @brief LCK10 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> lck10;\n      /**\n       * @brief LCK9 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> lck9;\n      /**\n       * @brief LCK8 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> lck8;\n      /**\n       * @brief LCK7 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> lck7;\n      /**\n       * @brief LCK6 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> lck6;\n      /**\n       * @brief LCK5 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> lck5;\n      /**\n       * @brief LCK4 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> lck4;\n      /**\n       * @brief LCK3 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> lck3;\n      /**\n       * @brief LCK2 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> lck2;\n      /**\n       * @brief LCK1 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> lck1;\n      /**\n       * @brief LCK0 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> lck0;\n    };\n  };\n\npublic:\n  /**\n   * @brief LCKR register\n   *\n\
    \   * GPIO port configuration lock\n   *           register\n   */\n  using lckr\
    \ = LckrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class AfrlReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief AFRL7 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl7\
    \ = FieldModel<uint32_t, address, 28, 4>;\n    /**\n     * @brief AFRL6 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl6 = FieldModel<uint32_t, address, 24,\
    \ 4>;\n    /**\n     * @brief AFRL5 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl5\
    \ = FieldModel<uint32_t, address, 20, 4>;\n    /**\n     * @brief AFRL4 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl4 = FieldModel<uint32_t, address, 16,\
    \ 4>;\n    /**\n     * @brief AFRL3 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl3\
    \ = FieldModel<uint32_t, address, 12, 4>;\n    /**\n     * @brief AFRL2 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl2 = FieldModel<uint32_t, address, 8,\
    \ 4>;\n    /**\n     * @brief AFRL1 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl1\
    \ = FieldModel<uint32_t, address, 4, 4>;\n    /**\n     * @brief AFRL0 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl0 = FieldModel<uint32_t, address, 0,\
    \ 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief AFRL7 field\n       *\n   \
    \    * Alternate function selection for port x\n       *               bit y (y\
    \ = 0..7)\n       */\n      BitFieldModel<uint32_t, 28, 4> afrl7;\n      /**\n\
    \       * @brief AFRL6 field\n       *\n       * Alternate function selection\
    \ for port x\n       *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 4> afrl6;\n      /**\n       * @brief AFRL5 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 0..7)\n   \
    \    */\n      BitFieldModel<uint32_t, 20, 4> afrl5;\n      /**\n       * @brief\
    \ AFRL4 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 4> afrl4;\n      /**\n       * @brief AFRL3 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 0..7)\n   \
    \    */\n      BitFieldModel<uint32_t, 12, 4> afrl3;\n      /**\n       * @brief\
    \ AFRL2 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 4> afrl2;\n      /**\n       * @brief AFRL1 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 0..7)\n   \
    \    */\n      BitFieldModel<uint32_t, 4, 4> afrl1;\n      /**\n       * @brief\
    \ AFRL0 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> afrl0;\n    };\n  };\n\npublic:\n  /**\n   * @brief AFRL register\n  \
    \ *\n   * GPIO alternate function low\n   *           register\n   */\n  using\
    \ afrl = AfrlReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class AfrhReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief AFRH15 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 8..15)\n     */\n    using afrh15\
    \ = FieldModel<uint32_t, address, 28, 4>;\n    /**\n     * @brief AFRH14 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 8..15)\n     */\n    using afrh14 = FieldModel<uint32_t, address,\
    \ 24, 4>;\n    /**\n     * @brief AFRH13 field\n     *\n     * Alternate function\
    \ selection for port x\n     *               bit y (y = 8..15)\n     */\n    using\
    \ afrh13 = FieldModel<uint32_t, address, 20, 4>;\n    /**\n     * @brief AFRH12\
    \ field\n     *\n     * Alternate function selection for port x\n     *      \
    \         bit y (y = 8..15)\n     */\n    using afrh12 = FieldModel<uint32_t,\
    \ address, 16, 4>;\n    /**\n     * @brief AFRH11 field\n     *\n     * Alternate\
    \ function selection for port x\n     *               bit y (y = 8..15)\n    \
    \ */\n    using afrh11 = FieldModel<uint32_t, address, 12, 4>;\n    /**\n    \
    \ * @brief AFRH10 field\n     *\n     * Alternate function selection for port\
    \ x\n     *               bit y (y = 8..15)\n     */\n    using afrh10 = FieldModel<uint32_t,\
    \ address, 8, 4>;\n    /**\n     * @brief AFRH9 field\n     *\n     * Alternate\
    \ function selection for port x\n     *               bit y (y = 8..15)\n    \
    \ */\n    using afrh9 = FieldModel<uint32_t, address, 4, 4>;\n    /**\n     *\
    \ @brief AFRH8 field\n     *\n     * Alternate function selection for port x\n\
    \     *               bit y (y = 8..15)\n     */\n    using afrh8 = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief AFRH15 field\n       *\n\
    \       * Alternate function selection for port x\n       *               bit\
    \ y (y = 8..15)\n       */\n      BitFieldModel<uint32_t, 28, 4> afrh15;\n   \
    \   /**\n       * @brief AFRH14 field\n       *\n       * Alternate function selection\
    \ for port x\n       *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 4> afrh14;\n      /**\n       * @brief AFRH13 field\n       *\n       *\
    \ Alternate function selection for port x\n       *               bit y (y = 8..15)\n\
    \       */\n      BitFieldModel<uint32_t, 20, 4> afrh13;\n      /**\n       *\
    \ @brief AFRH12 field\n       *\n       * Alternate function selection for port\
    \ x\n       *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 4> afrh12;\n      /**\n       * @brief AFRH11 field\n       *\n       *\
    \ Alternate function selection for port x\n       *               bit y (y = 8..15)\n\
    \       */\n      BitFieldModel<uint32_t, 12, 4> afrh11;\n      /**\n       *\
    \ @brief AFRH10 field\n       *\n       * Alternate function selection for port\
    \ x\n       *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 4> afrh10;\n      /**\n       * @brief AFRH9 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 8..15)\n  \
    \     */\n      BitFieldModel<uint32_t, 4, 4> afrh9;\n      /**\n       * @brief\
    \ AFRH8 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> afrh8;\n    };\n  };\n\npublic:\n  /**\n   * @brief AFRH register\n  \
    \ *\n   * GPIO alternate function high\n   *           register\n   */\n  using\
    \ afrh = AfrhReg<BaseAddress + 0x0024>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_GPIOC_H\
    \ */"
  name: GPIOC
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_GPIOB_H\n#define DRAL_STM32F411_GPIOB_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ GPIOB peripheral\n *\n * General-purpose I/Os\n */\nclass gpiob\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40020400; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class ModerReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ MODER15 field\n     *\n     * Port x configuration bits (y =\n     *       \
    \        0..15)\n     */\n    using moder15 = FieldModel<uint32_t, address, 30,\
    \ 2>;\n    /**\n     * @brief MODER14 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using moder14 = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    /**\n     * @brief MODER13 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using moder13\
    \ = FieldModel<uint32_t, address, 26, 2>;\n    /**\n     * @brief MODER12 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder12 = FieldModel<uint32_t, address, 24, 2>;\n    /**\n\
    \     * @brief MODER11 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using moder11 = FieldModel<uint32_t,\
    \ address, 22, 2>;\n    /**\n     * @brief MODER10 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using moder10\
    \ = FieldModel<uint32_t, address, 20, 2>;\n    /**\n     * @brief MODER9 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder9 = FieldModel<uint32_t, address, 18, 2>;\n    /**\n\
    \     * @brief MODER8 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using moder8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    /**\n     * @brief MODER7 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using moder7\
    \ = FieldModel<uint32_t, address, 14, 2>;\n    /**\n     * @brief MODER6 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder6 = FieldModel<uint32_t, address, 12, 2>;\n    /**\n\
    \     * @brief MODER5 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using moder5 = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    /**\n     * @brief MODER4 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using moder4\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief MODER3 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder3 = FieldModel<uint32_t, address, 6, 2>;\n    /**\n \
    \    * @brief MODER2 field\n     *\n     * Port x configuration bits (y =\n  \
    \   *               0..15)\n     */\n    using moder2 = FieldModel<uint32_t, address,\
    \ 4, 2>;\n    /**\n     * @brief MODER1 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using moder1 = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    /**\n     * @brief MODER0 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using moder0\
    \ = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ MODER15 field\n       *\n       * Port x configuration bits (y =\n       * \
    \              0..15)\n       */\n      BitFieldModel<uint32_t, 30, 2> moder15;\n\
    \      /**\n       * @brief MODER14 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 28, 2> moder14;\n      /**\n       * @brief MODER13 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 26, 2> moder13;\n      /**\n       * @brief MODER12\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 24, 2> moder12;\n    \
    \  /**\n       * @brief MODER11 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 2> moder11;\n      /**\n       * @brief MODER10 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 20, 2> moder10;\n      /**\n       * @brief MODER9\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 18, 2> moder9;\n     \
    \ /**\n       * @brief MODER8 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 2> moder8;\n      /**\n       * @brief MODER7 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 14, 2> moder7;\n      /**\n       * @brief MODER6\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 12, 2> moder6;\n     \
    \ /**\n       * @brief MODER5 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 2> moder5;\n      /**\n       * @brief MODER4 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 8, 2> moder4;\n      /**\n       * @brief MODER3\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 6, 2> moder3;\n      /**\n\
    \       * @brief MODER2 field\n       *\n       * Port x configuration bits (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 2> moder2;\n      /**\n       * @brief MODER1 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 2> moder1;\n      /**\n       * @brief MODER0 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> moder0;\n    };\n  };\n\npublic:\n  /**\n   * @brief MODER register\n\
    \   *\n   * GPIO port mode register\n   */\n  using moder = ModerReg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class OtyperReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ OT15 field\n     *\n     * Port x configuration bits (y =\n     *          \
    \     0..15)\n     */\n    using ot15 = FieldModel<uint32_t, address, 15, 1>;\n\
    \    /**\n     * @brief OT14 field\n     *\n     * Port x configuration bits (y\
    \ =\n     *               0..15)\n     */\n    using ot14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief OT13 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief OT12 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief OT11 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief OT10 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief OT9 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief OT8 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief OT7 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief OT6 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief OT5 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief OT4 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief OT3 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief OT2 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief OT1 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief OT0 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OT15 field\n       *\n\
    \       * Port x configuration bits (y =\n       *               0..15)\n    \
    \   */\n      BitFieldModel<uint32_t, 15, 1> ot15;\n      /**\n       * @brief\
    \ OT14 field\n       *\n       * Port x configuration bits (y =\n       *    \
    \           0..15)\n       */\n      BitFieldModel<uint32_t, 14, 1> ot14;\n  \
    \    /**\n       * @brief OT13 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> ot13;\n      /**\n       * @brief OT12 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> ot12;\n      /**\n       * @brief OT11 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> ot11;\n      /**\n       * @brief OT10 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> ot10;\n      /**\n       * @brief OT9 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> ot9;\n      /**\n       * @brief OT8 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> ot8;\n      /**\n       * @brief OT7 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> ot7;\n      /**\n       * @brief OT6 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> ot6;\n      /**\n       * @brief OT5 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> ot5;\n      /**\n       * @brief OT4 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> ot4;\n      /**\n       * @brief OT3 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> ot3;\n      /**\n       * @brief OT2 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> ot2;\n      /**\n       * @brief OT1 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> ot1;\n      /**\n       * @brief OT0 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> ot0;\n    };\n  };\n\npublic:\n  /**\n   * @brief OTYPER register\n  \
    \ *\n   * GPIO port output type register\n   */\n  using otyper = OtyperReg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class OspeedrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ OSPEEDR15 field\n     *\n     * Port x configuration bits (y =\n     *     \
    \          0..15)\n     */\n    using ospeedr15 = FieldModel<uint32_t, address,\
    \ 30, 2>;\n    /**\n     * @brief OSPEEDR14 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ospeedr14 = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    /**\n     * @brief OSPEEDR13 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr13\
    \ = FieldModel<uint32_t, address, 26, 2>;\n    /**\n     * @brief OSPEEDR12 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr12 = FieldModel<uint32_t, address, 24, 2>;\n    /**\n\
    \     * @brief OSPEEDR11 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr11 = FieldModel<uint32_t,\
    \ address, 22, 2>;\n    /**\n     * @brief OSPEEDR10 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr10\
    \ = FieldModel<uint32_t, address, 20, 2>;\n    /**\n     * @brief OSPEEDR9 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr9 = FieldModel<uint32_t, address, 18, 2>;\n    /**\n\
    \     * @brief OSPEEDR8 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    /**\n     * @brief OSPEEDR7 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr7\
    \ = FieldModel<uint32_t, address, 14, 2>;\n    /**\n     * @brief OSPEEDR6 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr6 = FieldModel<uint32_t, address, 12, 2>;\n    /**\n\
    \     * @brief OSPEEDR5 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr5 = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    /**\n     * @brief OSPEEDR4 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr4\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief OSPEEDR3 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr3 = FieldModel<uint32_t, address, 6, 2>;\n    /**\n\
    \     * @brief OSPEEDR2 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr2 = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    /**\n     * @brief OSPEEDR1 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr1\
    \ = FieldModel<uint32_t, address, 2, 2>;\n    /**\n     * @brief OSPEEDR0 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr0 = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief OSPEEDR15 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 30, 2> ospeedr15;\n      /**\n       * @brief OSPEEDR14 field\n       *\n  \
    \     * Port x configuration bits (y =\n       *               0..15)\n      \
    \ */\n      BitFieldModel<uint32_t, 28, 2> ospeedr14;\n      /**\n       * @brief\
    \ OSPEEDR13 field\n       *\n       * Port x configuration bits (y =\n       *\
    \               0..15)\n       */\n      BitFieldModel<uint32_t, 26, 2> ospeedr13;\n\
    \      /**\n       * @brief OSPEEDR12 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 2> ospeedr12;\n      /**\n       * @brief OSPEEDR11 field\n       *\n  \
    \     * Port x configuration bits (y =\n       *               0..15)\n      \
    \ */\n      BitFieldModel<uint32_t, 22, 2> ospeedr11;\n      /**\n       * @brief\
    \ OSPEEDR10 field\n       *\n       * Port x configuration bits (y =\n       *\
    \               0..15)\n       */\n      BitFieldModel<uint32_t, 20, 2> ospeedr10;\n\
    \      /**\n       * @brief OSPEEDR9 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 2> ospeedr9;\n      /**\n       * @brief OSPEEDR8 field\n       *\n    \
    \   * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 16, 2> ospeedr8;\n      /**\n       * @brief OSPEEDR7\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 14, 2> ospeedr7;\n   \
    \   /**\n       * @brief OSPEEDR6 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 2> ospeedr6;\n      /**\n       * @brief OSPEEDR5 field\n       *\n    \
    \   * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 10, 2> ospeedr5;\n      /**\n       * @brief OSPEEDR4\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 8, 2> ospeedr4;\n    \
    \  /**\n       * @brief OSPEEDR3 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 2> ospeedr3;\n      /**\n       * @brief OSPEEDR2 field\n       *\n     \
    \  * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 4, 2> ospeedr2;\n      /**\n       * @brief OSPEEDR1\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 2, 2> ospeedr1;\n    \
    \  /**\n       * @brief OSPEEDR0 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> ospeedr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief OSPEEDR register\n\
    \   *\n   * GPIO port output speed\n   *           register\n   */\n  using ospeedr\
    \ = OspeedrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class PupdrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief PUPDR15 field\n     *\n     * Port x configuration bits\
    \ (y =\n     *               0..15)\n     */\n    using pupdr15 = FieldModel<uint32_t,\
    \ address, 30, 2>;\n    /**\n     * @brief PUPDR14 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using pupdr14\
    \ = FieldModel<uint32_t, address, 28, 2>;\n    /**\n     * @brief PUPDR13 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr13 = FieldModel<uint32_t, address, 26, 2>;\n    /**\n\
    \     * @brief PUPDR12 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using pupdr12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    /**\n     * @brief PUPDR11 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using pupdr11\
    \ = FieldModel<uint32_t, address, 22, 2>;\n    /**\n     * @brief PUPDR10 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr10 = FieldModel<uint32_t, address, 20, 2>;\n    /**\n\
    \     * @brief PUPDR9 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using pupdr9 = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    /**\n     * @brief PUPDR8 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using pupdr8\
    \ = FieldModel<uint32_t, address, 16, 2>;\n    /**\n     * @brief PUPDR7 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr7 = FieldModel<uint32_t, address, 14, 2>;\n    /**\n\
    \     * @brief PUPDR6 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using pupdr6 = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    /**\n     * @brief PUPDR5 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using pupdr5\
    \ = FieldModel<uint32_t, address, 10, 2>;\n    /**\n     * @brief PUPDR4 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr4 = FieldModel<uint32_t, address, 8, 2>;\n    /**\n \
    \    * @brief PUPDR3 field\n     *\n     * Port x configuration bits (y =\n  \
    \   *               0..15)\n     */\n    using pupdr3 = FieldModel<uint32_t, address,\
    \ 6, 2>;\n    /**\n     * @brief PUPDR2 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using pupdr2 = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    /**\n     * @brief PUPDR1 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using pupdr1\
    \ = FieldModel<uint32_t, address, 2, 2>;\n    /**\n     * @brief PUPDR0 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr0 = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief PUPDR15 field\n       *\n       * Port x configuration bits (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 30,\
    \ 2> pupdr15;\n      /**\n       * @brief PUPDR14 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 28, 2> pupdr14;\n      /**\n       * @brief PUPDR13 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 26, 2> pupdr13;\n      /**\n       * @brief PUPDR12\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 24, 2> pupdr12;\n    \
    \  /**\n       * @brief PUPDR11 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 2> pupdr11;\n      /**\n       * @brief PUPDR10 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 20, 2> pupdr10;\n      /**\n       * @brief PUPDR9\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 18, 2> pupdr9;\n     \
    \ /**\n       * @brief PUPDR8 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 2> pupdr8;\n      /**\n       * @brief PUPDR7 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 14, 2> pupdr7;\n      /**\n       * @brief PUPDR6\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 12, 2> pupdr6;\n     \
    \ /**\n       * @brief PUPDR5 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 2> pupdr5;\n      /**\n       * @brief PUPDR4 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 8, 2> pupdr4;\n      /**\n       * @brief PUPDR3\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 6, 2> pupdr3;\n      /**\n\
    \       * @brief PUPDR2 field\n       *\n       * Port x configuration bits (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 2> pupdr2;\n      /**\n       * @brief PUPDR1 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 2> pupdr1;\n      /**\n       * @brief PUPDR0 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> pupdr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief PUPDR register\n\
    \   *\n   * GPIO port pull-up/pull-down\n   *           register\n   */\n  using\
    \ pupdr = PupdrReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class IdrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief IDR15 field\n     *\n     * Port input data (y =\n   \
    \  *               0..15)\n     */\n    using idr15 = FieldModel<uint32_t, address,\
    \ 15, 1>;\n    /**\n     * @brief IDR14 field\n     *\n     * Port input data\
    \ (y =\n     *               0..15)\n     */\n    using idr14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief IDR13 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief IDR12 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief IDR11 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief IDR10 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief IDR9 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief IDR8 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief IDR7 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief IDR6 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief IDR5 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief IDR4 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief IDR3 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief IDR2 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief IDR1 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief IDR0 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief IDR15 field\n       *\n\
    \       * Port input data (y =\n       *               0..15)\n       */\n   \
    \   BitFieldModel<uint32_t, 15, 1> idr15;\n      /**\n       * @brief IDR14 field\n\
    \       *\n       * Port input data (y =\n       *               0..15)\n    \
    \   */\n      BitFieldModel<uint32_t, 14, 1> idr14;\n      /**\n       * @brief\
    \ IDR13 field\n       *\n       * Port input data (y =\n       *             \
    \  0..15)\n       */\n      BitFieldModel<uint32_t, 13, 1> idr13;\n      /**\n\
    \       * @brief IDR12 field\n       *\n       * Port input data (y =\n      \
    \ *               0..15)\n       */\n      BitFieldModel<uint32_t, 12, 1> idr12;\n\
    \      /**\n       * @brief IDR11 field\n       *\n       * Port input data (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 11,\
    \ 1> idr11;\n      /**\n       * @brief IDR10 field\n       *\n       * Port input\
    \ data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> idr10;\n      /**\n       * @brief IDR9 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> idr9;\n      /**\n       * @brief IDR8 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> idr8;\n      /**\n       * @brief IDR7 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> idr7;\n      /**\n       * @brief IDR6 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> idr6;\n      /**\n       * @brief IDR5 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> idr5;\n      /**\n       * @brief IDR4 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> idr4;\n      /**\n       * @brief IDR3 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> idr3;\n      /**\n       * @brief IDR2 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> idr2;\n      /**\n       * @brief IDR1 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> idr1;\n      /**\n       * @brief IDR0 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> idr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief IDR register\n   *\n\
    \   * GPIO port input data register\n   */\n  using idr = IdrReg<BaseAddress +\
    \ 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class OdrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief ODR15\
    \ field\n     *\n     * Port output data (y =\n     *               0..15)\n \
    \    */\n    using odr15 = FieldModel<uint32_t, address, 15, 1>;\n    /**\n  \
    \   * @brief ODR14 field\n     *\n     * Port output data (y =\n     *       \
    \        0..15)\n     */\n    using odr14 = FieldModel<uint32_t, address, 14,\
    \ 1>;\n    /**\n     * @brief ODR13 field\n     *\n     * Port output data (y\
    \ =\n     *               0..15)\n     */\n    using odr13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief ODR12 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief ODR11 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief ODR10 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief ODR9 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief ODR8 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief ODR7 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief ODR6 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief ODR5 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief ODR4 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ODR3 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief ODR2 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief ODR1 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief ODR0 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief ODR15 field\n       *\n\
    \       * Port output data (y =\n       *               0..15)\n       */\n  \
    \    BitFieldModel<uint32_t, 15, 1> odr15;\n      /**\n       * @brief ODR14 field\n\
    \       *\n       * Port output data (y =\n       *               0..15)\n   \
    \    */\n      BitFieldModel<uint32_t, 14, 1> odr14;\n      /**\n       * @brief\
    \ ODR13 field\n       *\n       * Port output data (y =\n       *            \
    \   0..15)\n       */\n      BitFieldModel<uint32_t, 13, 1> odr13;\n      /**\n\
    \       * @brief ODR12 field\n       *\n       * Port output data (y =\n     \
    \  *               0..15)\n       */\n      BitFieldModel<uint32_t, 12, 1> odr12;\n\
    \      /**\n       * @brief ODR11 field\n       *\n       * Port output data (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 11,\
    \ 1> odr11;\n      /**\n       * @brief ODR10 field\n       *\n       * Port output\
    \ data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> odr10;\n      /**\n       * @brief ODR9 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> odr9;\n      /**\n       * @brief ODR8 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> odr8;\n      /**\n       * @brief ODR7 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> odr7;\n      /**\n       * @brief ODR6 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> odr6;\n      /**\n       * @brief ODR5 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> odr5;\n      /**\n       * @brief ODR4 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> odr4;\n      /**\n       * @brief ODR3 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> odr3;\n      /**\n       * @brief ODR2 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> odr2;\n      /**\n       * @brief ODR1 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> odr1;\n      /**\n       * @brief ODR0 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> odr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief ODR register\n   *\n\
    \   * GPIO port output data register\n   */\n  using odr = OdrReg<BaseAddress\
    \ + 0x0014>;\n\nprivate:\n  template<unsigned int address>\n  class BsrrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ BR15 field\n     *\n     * Port x reset bit y (y =\n     *               0..15)\n\
    \     */\n    using br15 = FieldModel<uint32_t, address, 31, 1>;\n    /**\n  \
    \   * @brief BR14 field\n     *\n     * Port x reset bit y (y =\n     *      \
    \         0..15)\n     */\n    using br14 = FieldModel<uint32_t, address, 30,\
    \ 1>;\n    /**\n     * @brief BR13 field\n     *\n     * Port x reset bit y (y\
    \ =\n     *               0..15)\n     */\n    using br13 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    /**\n     * @brief BR12 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br12 = FieldModel<uint32_t,\
    \ address, 28, 1>;\n    /**\n     * @brief BR11 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br11 = FieldModel<uint32_t,\
    \ address, 27, 1>;\n    /**\n     * @brief BR10 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br10 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    /**\n     * @brief BR9 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br9 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    /**\n     * @brief BR8 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br8 = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    /**\n     * @brief BR7 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br7 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    /**\n     * @brief BR6 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br6 = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    /**\n     * @brief BR5 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br5 = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    /**\n     * @brief BR4 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br4 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief BR3 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br3 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief BR2 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br2 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    /**\n     * @brief BR1 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br1 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    /**\n     * @brief BR0 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using br0 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    /**\n     * @brief BS15 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief BS14 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief BS13 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief BS12 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief BS11 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief BS10 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief BS9 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief BS8 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief BS7 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief BS6 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief BS5 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief BS4 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief BS3 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief BS2 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief BS1 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief BS0 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief BR15 field\n       *\n\
    \       * Port x reset bit y (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 31, 1> br15;\n      /**\n       * @brief BR14 field\n\
    \       *\n       * Port x reset bit y (y =\n       *               0..15)\n \
    \      */\n      BitFieldModel<uint32_t, 30, 1> br14;\n      /**\n       * @brief\
    \ BR13 field\n       *\n       * Port x reset bit y (y =\n       *           \
    \    0..15)\n       */\n      BitFieldModel<uint32_t, 29, 1> br13;\n      /**\n\
    \       * @brief BR12 field\n       *\n       * Port x reset bit y (y =\n    \
    \   *               0..15)\n       */\n      BitFieldModel<uint32_t, 28, 1> br12;\n\
    \      /**\n       * @brief BR11 field\n       *\n       * Port x reset bit y\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 27, 1> br11;\n      /**\n       * @brief BR10 field\n       *\n       * Port\
    \ x reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 26, 1> br10;\n      /**\n       * @brief BR9 field\n       *\n       * Port\
    \ x reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 1> br9;\n      /**\n       * @brief BR8 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 1> br8;\n      /**\n       * @brief BR7 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 1> br7;\n      /**\n       * @brief BR6 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> br6;\n      /**\n       * @brief BR5 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 1> br5;\n      /**\n       * @brief BR4 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 1> br4;\n      /**\n       * @brief BR3 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> br3;\n      /**\n       * @brief BR2 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 1> br2;\n      /**\n       * @brief BR1 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> br1;\n      /**\n       * @brief BR0 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> br0;\n      /**\n       * @brief BS15 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> bs15;\n      /**\n       * @brief BS14 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> bs14;\n      /**\n       * @brief BS13 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> bs13;\n      /**\n       * @brief BS12 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> bs12;\n      /**\n       * @brief BS11 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> bs11;\n      /**\n       * @brief BS10 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> bs10;\n      /**\n       * @brief BS9 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> bs9;\n      /**\n       * @brief BS8 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> bs8;\n      /**\n       * @brief BS7 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> bs7;\n      /**\n       * @brief BS6 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> bs6;\n      /**\n       * @brief BS5 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> bs5;\n      /**\n       * @brief BS4 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> bs4;\n      /**\n       * @brief BS3 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> bs3;\n      /**\n       * @brief BS2 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> bs2;\n      /**\n       * @brief BS1 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> bs1;\n      /**\n       * @brief BS0 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> bs0;\n    };\n  };\n\npublic:\n  /**\n   * @brief BSRR register\n   *\n\
    \   * GPIO port bit set/reset\n   *           register\n   */\n  using bsrr =\
    \ BsrrReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class LckrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief LCKK field\n     *\n     * Port x lock bit y (y=\n    \
    \ *               0..15)\n     */\n    using lckk = FieldModel<uint32_t, address,\
    \ 16, 1>;\n    /**\n     * @brief LCK15 field\n     *\n     * Port x lock bit\
    \ y (y=\n     *               0..15)\n     */\n    using lck15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief LCK14 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief LCK13 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief LCK12 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief LCK11 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief LCK10 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief LCK9 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief LCK8 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief LCK7 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief LCK6 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief LCK5 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief LCK4 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief LCK3 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief LCK2 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief LCK1 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief LCK0 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief LCKK field\n       *\n\
    \       * Port x lock bit y (y=\n       *               0..15)\n       */\n  \
    \    BitFieldModel<uint32_t, 16, 1> lckk;\n      /**\n       * @brief LCK15 field\n\
    \       *\n       * Port x lock bit y (y=\n       *               0..15)\n   \
    \    */\n      BitFieldModel<uint32_t, 15, 1> lck15;\n      /**\n       * @brief\
    \ LCK14 field\n       *\n       * Port x lock bit y (y=\n       *            \
    \   0..15)\n       */\n      BitFieldModel<uint32_t, 14, 1> lck14;\n      /**\n\
    \       * @brief LCK13 field\n       *\n       * Port x lock bit y (y=\n     \
    \  *               0..15)\n       */\n      BitFieldModel<uint32_t, 13, 1> lck13;\n\
    \      /**\n       * @brief LCK12 field\n       *\n       * Port x lock bit y\
    \ (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> lck12;\n      /**\n       * @brief LCK11 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> lck11;\n      /**\n       * @brief LCK10 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> lck10;\n      /**\n       * @brief LCK9 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> lck9;\n      /**\n       * @brief LCK8 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> lck8;\n      /**\n       * @brief LCK7 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> lck7;\n      /**\n       * @brief LCK6 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> lck6;\n      /**\n       * @brief LCK5 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> lck5;\n      /**\n       * @brief LCK4 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> lck4;\n      /**\n       * @brief LCK3 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> lck3;\n      /**\n       * @brief LCK2 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> lck2;\n      /**\n       * @brief LCK1 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> lck1;\n      /**\n       * @brief LCK0 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> lck0;\n    };\n  };\n\npublic:\n  /**\n   * @brief LCKR register\n   *\n\
    \   * GPIO port configuration lock\n   *           register\n   */\n  using lckr\
    \ = LckrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class AfrlReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief AFRL7 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl7\
    \ = FieldModel<uint32_t, address, 28, 4>;\n    /**\n     * @brief AFRL6 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl6 = FieldModel<uint32_t, address, 24,\
    \ 4>;\n    /**\n     * @brief AFRL5 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl5\
    \ = FieldModel<uint32_t, address, 20, 4>;\n    /**\n     * @brief AFRL4 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl4 = FieldModel<uint32_t, address, 16,\
    \ 4>;\n    /**\n     * @brief AFRL3 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl3\
    \ = FieldModel<uint32_t, address, 12, 4>;\n    /**\n     * @brief AFRL2 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl2 = FieldModel<uint32_t, address, 8,\
    \ 4>;\n    /**\n     * @brief AFRL1 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl1\
    \ = FieldModel<uint32_t, address, 4, 4>;\n    /**\n     * @brief AFRL0 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl0 = FieldModel<uint32_t, address, 0,\
    \ 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief AFRL7 field\n       *\n   \
    \    * Alternate function selection for port x\n       *               bit y (y\
    \ = 0..7)\n       */\n      BitFieldModel<uint32_t, 28, 4> afrl7;\n      /**\n\
    \       * @brief AFRL6 field\n       *\n       * Alternate function selection\
    \ for port x\n       *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 4> afrl6;\n      /**\n       * @brief AFRL5 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 0..7)\n   \
    \    */\n      BitFieldModel<uint32_t, 20, 4> afrl5;\n      /**\n       * @brief\
    \ AFRL4 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 4> afrl4;\n      /**\n       * @brief AFRL3 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 0..7)\n   \
    \    */\n      BitFieldModel<uint32_t, 12, 4> afrl3;\n      /**\n       * @brief\
    \ AFRL2 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 4> afrl2;\n      /**\n       * @brief AFRL1 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 0..7)\n   \
    \    */\n      BitFieldModel<uint32_t, 4, 4> afrl1;\n      /**\n       * @brief\
    \ AFRL0 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> afrl0;\n    };\n  };\n\npublic:\n  /**\n   * @brief AFRL register\n  \
    \ *\n   * GPIO alternate function low\n   *           register\n   */\n  using\
    \ afrl = AfrlReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class AfrhReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief AFRH15 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 8..15)\n     */\n    using afrh15\
    \ = FieldModel<uint32_t, address, 28, 4>;\n    /**\n     * @brief AFRH14 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 8..15)\n     */\n    using afrh14 = FieldModel<uint32_t, address,\
    \ 24, 4>;\n    /**\n     * @brief AFRH13 field\n     *\n     * Alternate function\
    \ selection for port x\n     *               bit y (y = 8..15)\n     */\n    using\
    \ afrh13 = FieldModel<uint32_t, address, 20, 4>;\n    /**\n     * @brief AFRH12\
    \ field\n     *\n     * Alternate function selection for port x\n     *      \
    \         bit y (y = 8..15)\n     */\n    using afrh12 = FieldModel<uint32_t,\
    \ address, 16, 4>;\n    /**\n     * @brief AFRH11 field\n     *\n     * Alternate\
    \ function selection for port x\n     *               bit y (y = 8..15)\n    \
    \ */\n    using afrh11 = FieldModel<uint32_t, address, 12, 4>;\n    /**\n    \
    \ * @brief AFRH10 field\n     *\n     * Alternate function selection for port\
    \ x\n     *               bit y (y = 8..15)\n     */\n    using afrh10 = FieldModel<uint32_t,\
    \ address, 8, 4>;\n    /**\n     * @brief AFRH9 field\n     *\n     * Alternate\
    \ function selection for port x\n     *               bit y (y = 8..15)\n    \
    \ */\n    using afrh9 = FieldModel<uint32_t, address, 4, 4>;\n    /**\n     *\
    \ @brief AFRH8 field\n     *\n     * Alternate function selection for port x\n\
    \     *               bit y (y = 8..15)\n     */\n    using afrh8 = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief AFRH15 field\n       *\n\
    \       * Alternate function selection for port x\n       *               bit\
    \ y (y = 8..15)\n       */\n      BitFieldModel<uint32_t, 28, 4> afrh15;\n   \
    \   /**\n       * @brief AFRH14 field\n       *\n       * Alternate function selection\
    \ for port x\n       *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 4> afrh14;\n      /**\n       * @brief AFRH13 field\n       *\n       *\
    \ Alternate function selection for port x\n       *               bit y (y = 8..15)\n\
    \       */\n      BitFieldModel<uint32_t, 20, 4> afrh13;\n      /**\n       *\
    \ @brief AFRH12 field\n       *\n       * Alternate function selection for port\
    \ x\n       *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 4> afrh12;\n      /**\n       * @brief AFRH11 field\n       *\n       *\
    \ Alternate function selection for port x\n       *               bit y (y = 8..15)\n\
    \       */\n      BitFieldModel<uint32_t, 12, 4> afrh11;\n      /**\n       *\
    \ @brief AFRH10 field\n       *\n       * Alternate function selection for port\
    \ x\n       *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 4> afrh10;\n      /**\n       * @brief AFRH9 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 8..15)\n  \
    \     */\n      BitFieldModel<uint32_t, 4, 4> afrh9;\n      /**\n       * @brief\
    \ AFRH8 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> afrh8;\n    };\n  };\n\npublic:\n  /**\n   * @brief AFRH register\n  \
    \ *\n   * GPIO alternate function high\n   *           register\n   */\n  using\
    \ afrh = AfrhReg<BaseAddress + 0x0024>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_GPIOB_H\
    \ */"
  name: GPIOB
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_GPIOA_H\n#define DRAL_STM32F411_GPIOA_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ GPIOA peripheral\n *\n * General-purpose I/Os\n */\nclass gpioa\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40020000; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class ModerReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ MODER15 field\n     *\n     * Port x configuration bits (y =\n     *       \
    \        0..15)\n     */\n    using moder15 = FieldModel<uint32_t, address, 30,\
    \ 2>;\n    /**\n     * @brief MODER14 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using moder14 = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    /**\n     * @brief MODER13 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using moder13\
    \ = FieldModel<uint32_t, address, 26, 2>;\n    /**\n     * @brief MODER12 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder12 = FieldModel<uint32_t, address, 24, 2>;\n    /**\n\
    \     * @brief MODER11 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using moder11 = FieldModel<uint32_t,\
    \ address, 22, 2>;\n    /**\n     * @brief MODER10 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using moder10\
    \ = FieldModel<uint32_t, address, 20, 2>;\n    /**\n     * @brief MODER9 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder9 = FieldModel<uint32_t, address, 18, 2>;\n    /**\n\
    \     * @brief MODER8 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using moder8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    /**\n     * @brief MODER7 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using moder7\
    \ = FieldModel<uint32_t, address, 14, 2>;\n    /**\n     * @brief MODER6 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder6 = FieldModel<uint32_t, address, 12, 2>;\n    /**\n\
    \     * @brief MODER5 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using moder5 = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    /**\n     * @brief MODER4 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using moder4\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief MODER3 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using moder3 = FieldModel<uint32_t, address, 6, 2>;\n    /**\n \
    \    * @brief MODER2 field\n     *\n     * Port x configuration bits (y =\n  \
    \   *               0..15)\n     */\n    using moder2 = FieldModel<uint32_t, address,\
    \ 4, 2>;\n    /**\n     * @brief MODER1 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using moder1 = FieldModel<uint32_t,\
    \ address, 2, 2>;\n    /**\n     * @brief MODER0 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using moder0\
    \ = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ MODER15 field\n       *\n       * Port x configuration bits (y =\n       * \
    \              0..15)\n       */\n      BitFieldModel<uint32_t, 30, 2> moder15;\n\
    \      /**\n       * @brief MODER14 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 28, 2> moder14;\n      /**\n       * @brief MODER13 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 26, 2> moder13;\n      /**\n       * @brief MODER12\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 24, 2> moder12;\n    \
    \  /**\n       * @brief MODER11 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 2> moder11;\n      /**\n       * @brief MODER10 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 20, 2> moder10;\n      /**\n       * @brief MODER9\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 18, 2> moder9;\n     \
    \ /**\n       * @brief MODER8 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 2> moder8;\n      /**\n       * @brief MODER7 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 14, 2> moder7;\n      /**\n       * @brief MODER6\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 12, 2> moder6;\n     \
    \ /**\n       * @brief MODER5 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 2> moder5;\n      /**\n       * @brief MODER4 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 8, 2> moder4;\n      /**\n       * @brief MODER3\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 6, 2> moder3;\n      /**\n\
    \       * @brief MODER2 field\n       *\n       * Port x configuration bits (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 2> moder2;\n      /**\n       * @brief MODER1 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 2> moder1;\n      /**\n       * @brief MODER0 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> moder0;\n    };\n  };\n\npublic:\n  /**\n   * @brief MODER register\n\
    \   *\n   * GPIO port mode register\n   */\n  using moder = ModerReg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class OtyperReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ OT15 field\n     *\n     * Port x configuration bits (y =\n     *          \
    \     0..15)\n     */\n    using ot15 = FieldModel<uint32_t, address, 15, 1>;\n\
    \    /**\n     * @brief OT14 field\n     *\n     * Port x configuration bits (y\
    \ =\n     *               0..15)\n     */\n    using ot14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief OT13 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief OT12 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief OT11 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief OT10 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief OT9 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief OT8 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief OT7 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief OT6 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief OT5 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief OT4 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief OT3 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief OT2 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief OT1 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief OT0 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ot0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief OT15 field\n       *\n\
    \       * Port x configuration bits (y =\n       *               0..15)\n    \
    \   */\n      BitFieldModel<uint32_t, 15, 1> ot15;\n      /**\n       * @brief\
    \ OT14 field\n       *\n       * Port x configuration bits (y =\n       *    \
    \           0..15)\n       */\n      BitFieldModel<uint32_t, 14, 1> ot14;\n  \
    \    /**\n       * @brief OT13 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> ot13;\n      /**\n       * @brief OT12 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> ot12;\n      /**\n       * @brief OT11 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> ot11;\n      /**\n       * @brief OT10 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> ot10;\n      /**\n       * @brief OT9 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> ot9;\n      /**\n       * @brief OT8 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> ot8;\n      /**\n       * @brief OT7 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> ot7;\n      /**\n       * @brief OT6 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> ot6;\n      /**\n       * @brief OT5 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> ot5;\n      /**\n       * @brief OT4 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> ot4;\n      /**\n       * @brief OT3 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> ot3;\n      /**\n       * @brief OT2 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> ot2;\n      /**\n       * @brief OT1 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> ot1;\n      /**\n       * @brief OT0 field\n       *\n       * Port x\
    \ configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> ot0;\n    };\n  };\n\npublic:\n  /**\n   * @brief OTYPER register\n  \
    \ *\n   * GPIO port output type register\n   */\n  using otyper = OtyperReg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class OspeedrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ OSPEEDR15 field\n     *\n     * Port x configuration bits (y =\n     *     \
    \          0..15)\n     */\n    using ospeedr15 = FieldModel<uint32_t, address,\
    \ 30, 2>;\n    /**\n     * @brief OSPEEDR14 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using ospeedr14 = FieldModel<uint32_t,\
    \ address, 28, 2>;\n    /**\n     * @brief OSPEEDR13 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr13\
    \ = FieldModel<uint32_t, address, 26, 2>;\n    /**\n     * @brief OSPEEDR12 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr12 = FieldModel<uint32_t, address, 24, 2>;\n    /**\n\
    \     * @brief OSPEEDR11 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr11 = FieldModel<uint32_t,\
    \ address, 22, 2>;\n    /**\n     * @brief OSPEEDR10 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr10\
    \ = FieldModel<uint32_t, address, 20, 2>;\n    /**\n     * @brief OSPEEDR9 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr9 = FieldModel<uint32_t, address, 18, 2>;\n    /**\n\
    \     * @brief OSPEEDR8 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr8 = FieldModel<uint32_t,\
    \ address, 16, 2>;\n    /**\n     * @brief OSPEEDR7 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr7\
    \ = FieldModel<uint32_t, address, 14, 2>;\n    /**\n     * @brief OSPEEDR6 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr6 = FieldModel<uint32_t, address, 12, 2>;\n    /**\n\
    \     * @brief OSPEEDR5 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr5 = FieldModel<uint32_t,\
    \ address, 10, 2>;\n    /**\n     * @brief OSPEEDR4 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr4\
    \ = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief OSPEEDR3 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr3 = FieldModel<uint32_t, address, 6, 2>;\n    /**\n\
    \     * @brief OSPEEDR2 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using ospeedr2 = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    /**\n     * @brief OSPEEDR1 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using ospeedr1\
    \ = FieldModel<uint32_t, address, 2, 2>;\n    /**\n     * @brief OSPEEDR0 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using ospeedr0 = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief OSPEEDR15 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 30, 2> ospeedr15;\n      /**\n       * @brief OSPEEDR14 field\n       *\n  \
    \     * Port x configuration bits (y =\n       *               0..15)\n      \
    \ */\n      BitFieldModel<uint32_t, 28, 2> ospeedr14;\n      /**\n       * @brief\
    \ OSPEEDR13 field\n       *\n       * Port x configuration bits (y =\n       *\
    \               0..15)\n       */\n      BitFieldModel<uint32_t, 26, 2> ospeedr13;\n\
    \      /**\n       * @brief OSPEEDR12 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 2> ospeedr12;\n      /**\n       * @brief OSPEEDR11 field\n       *\n  \
    \     * Port x configuration bits (y =\n       *               0..15)\n      \
    \ */\n      BitFieldModel<uint32_t, 22, 2> ospeedr11;\n      /**\n       * @brief\
    \ OSPEEDR10 field\n       *\n       * Port x configuration bits (y =\n       *\
    \               0..15)\n       */\n      BitFieldModel<uint32_t, 20, 2> ospeedr10;\n\
    \      /**\n       * @brief OSPEEDR9 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 2> ospeedr9;\n      /**\n       * @brief OSPEEDR8 field\n       *\n    \
    \   * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 16, 2> ospeedr8;\n      /**\n       * @brief OSPEEDR7\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 14, 2> ospeedr7;\n   \
    \   /**\n       * @brief OSPEEDR6 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 2> ospeedr6;\n      /**\n       * @brief OSPEEDR5 field\n       *\n    \
    \   * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 10, 2> ospeedr5;\n      /**\n       * @brief OSPEEDR4\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 8, 2> ospeedr4;\n    \
    \  /**\n       * @brief OSPEEDR3 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 2> ospeedr3;\n      /**\n       * @brief OSPEEDR2 field\n       *\n     \
    \  * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 4, 2> ospeedr2;\n      /**\n       * @brief OSPEEDR1\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 2, 2> ospeedr1;\n    \
    \  /**\n       * @brief OSPEEDR0 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> ospeedr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief OSPEEDR register\n\
    \   *\n   * GPIO port output speed\n   *           register\n   */\n  using ospeedr\
    \ = OspeedrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class PupdrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief PUPDR15 field\n     *\n     * Port x configuration bits\
    \ (y =\n     *               0..15)\n     */\n    using pupdr15 = FieldModel<uint32_t,\
    \ address, 30, 2>;\n    /**\n     * @brief PUPDR14 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using pupdr14\
    \ = FieldModel<uint32_t, address, 28, 2>;\n    /**\n     * @brief PUPDR13 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr13 = FieldModel<uint32_t, address, 26, 2>;\n    /**\n\
    \     * @brief PUPDR12 field\n     *\n     * Port x configuration bits (y =\n\
    \     *               0..15)\n     */\n    using pupdr12 = FieldModel<uint32_t,\
    \ address, 24, 2>;\n    /**\n     * @brief PUPDR11 field\n     *\n     * Port\
    \ x configuration bits (y =\n     *               0..15)\n     */\n    using pupdr11\
    \ = FieldModel<uint32_t, address, 22, 2>;\n    /**\n     * @brief PUPDR10 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr10 = FieldModel<uint32_t, address, 20, 2>;\n    /**\n\
    \     * @brief PUPDR9 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using pupdr9 = FieldModel<uint32_t,\
    \ address, 18, 2>;\n    /**\n     * @brief PUPDR8 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using pupdr8\
    \ = FieldModel<uint32_t, address, 16, 2>;\n    /**\n     * @brief PUPDR7 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr7 = FieldModel<uint32_t, address, 14, 2>;\n    /**\n\
    \     * @brief PUPDR6 field\n     *\n     * Port x configuration bits (y =\n \
    \    *               0..15)\n     */\n    using pupdr6 = FieldModel<uint32_t,\
    \ address, 12, 2>;\n    /**\n     * @brief PUPDR5 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using pupdr5\
    \ = FieldModel<uint32_t, address, 10, 2>;\n    /**\n     * @brief PUPDR4 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr4 = FieldModel<uint32_t, address, 8, 2>;\n    /**\n \
    \    * @brief PUPDR3 field\n     *\n     * Port x configuration bits (y =\n  \
    \   *               0..15)\n     */\n    using pupdr3 = FieldModel<uint32_t, address,\
    \ 6, 2>;\n    /**\n     * @brief PUPDR2 field\n     *\n     * Port x configuration\
    \ bits (y =\n     *               0..15)\n     */\n    using pupdr2 = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    /**\n     * @brief PUPDR1 field\n     *\n     * Port x\
    \ configuration bits (y =\n     *               0..15)\n     */\n    using pupdr1\
    \ = FieldModel<uint32_t, address, 2, 2>;\n    /**\n     * @brief PUPDR0 field\n\
    \     *\n     * Port x configuration bits (y =\n     *               0..15)\n\
    \     */\n    using pupdr0 = FieldModel<uint32_t, address, 0, 2>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief PUPDR15 field\n       *\n       * Port x configuration bits (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 30,\
    \ 2> pupdr15;\n      /**\n       * @brief PUPDR14 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 28, 2> pupdr14;\n      /**\n       * @brief PUPDR13 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 26, 2> pupdr13;\n      /**\n       * @brief PUPDR12\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 24, 2> pupdr12;\n    \
    \  /**\n       * @brief PUPDR11 field\n       *\n       * Port x configuration\
    \ bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 2> pupdr11;\n      /**\n       * @brief PUPDR10 field\n       *\n      \
    \ * Port x configuration bits (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 20, 2> pupdr10;\n      /**\n       * @brief PUPDR9\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 18, 2> pupdr9;\n     \
    \ /**\n       * @brief PUPDR8 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 2> pupdr8;\n      /**\n       * @brief PUPDR7 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 14, 2> pupdr7;\n      /**\n       * @brief PUPDR6\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 12, 2> pupdr6;\n     \
    \ /**\n       * @brief PUPDR5 field\n       *\n       * Port x configuration bits\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 2> pupdr5;\n      /**\n       * @brief PUPDR4 field\n       *\n       *\
    \ Port x configuration bits (y =\n       *               0..15)\n       */\n \
    \     BitFieldModel<uint32_t, 8, 2> pupdr4;\n      /**\n       * @brief PUPDR3\
    \ field\n       *\n       * Port x configuration bits (y =\n       *         \
    \      0..15)\n       */\n      BitFieldModel<uint32_t, 6, 2> pupdr3;\n      /**\n\
    \       * @brief PUPDR2 field\n       *\n       * Port x configuration bits (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 2> pupdr2;\n      /**\n       * @brief PUPDR1 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 2> pupdr1;\n      /**\n       * @brief PUPDR0 field\n       *\n       * Port\
    \ x configuration bits (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 2> pupdr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief PUPDR register\n\
    \   *\n   * GPIO port pull-up/pull-down\n   *           register\n   */\n  using\
    \ pupdr = PupdrReg<BaseAddress + 0x000C>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class IdrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief IDR15 field\n     *\n     * Port input data (y =\n   \
    \  *               0..15)\n     */\n    using idr15 = FieldModel<uint32_t, address,\
    \ 15, 1>;\n    /**\n     * @brief IDR14 field\n     *\n     * Port input data\
    \ (y =\n     *               0..15)\n     */\n    using idr14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief IDR13 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief IDR12 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief IDR11 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief IDR10 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief IDR9 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief IDR8 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief IDR7 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief IDR6 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief IDR5 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief IDR4 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief IDR3 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief IDR2 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief IDR1 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief IDR0 field\n     *\n     * Port input\
    \ data (y =\n     *               0..15)\n     */\n    using idr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief IDR15 field\n       *\n\
    \       * Port input data (y =\n       *               0..15)\n       */\n   \
    \   BitFieldModel<uint32_t, 15, 1> idr15;\n      /**\n       * @brief IDR14 field\n\
    \       *\n       * Port input data (y =\n       *               0..15)\n    \
    \   */\n      BitFieldModel<uint32_t, 14, 1> idr14;\n      /**\n       * @brief\
    \ IDR13 field\n       *\n       * Port input data (y =\n       *             \
    \  0..15)\n       */\n      BitFieldModel<uint32_t, 13, 1> idr13;\n      /**\n\
    \       * @brief IDR12 field\n       *\n       * Port input data (y =\n      \
    \ *               0..15)\n       */\n      BitFieldModel<uint32_t, 12, 1> idr12;\n\
    \      /**\n       * @brief IDR11 field\n       *\n       * Port input data (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 11,\
    \ 1> idr11;\n      /**\n       * @brief IDR10 field\n       *\n       * Port input\
    \ data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> idr10;\n      /**\n       * @brief IDR9 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> idr9;\n      /**\n       * @brief IDR8 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> idr8;\n      /**\n       * @brief IDR7 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> idr7;\n      /**\n       * @brief IDR6 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> idr6;\n      /**\n       * @brief IDR5 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> idr5;\n      /**\n       * @brief IDR4 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> idr4;\n      /**\n       * @brief IDR3 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> idr3;\n      /**\n       * @brief IDR2 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> idr2;\n      /**\n       * @brief IDR1 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> idr1;\n      /**\n       * @brief IDR0 field\n       *\n       * Port\
    \ input data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> idr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief IDR register\n   *\n\
    \   * GPIO port input data register\n   */\n  using idr = IdrReg<BaseAddress +\
    \ 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class OdrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief ODR15\
    \ field\n     *\n     * Port output data (y =\n     *               0..15)\n \
    \    */\n    using odr15 = FieldModel<uint32_t, address, 15, 1>;\n    /**\n  \
    \   * @brief ODR14 field\n     *\n     * Port output data (y =\n     *       \
    \        0..15)\n     */\n    using odr14 = FieldModel<uint32_t, address, 14,\
    \ 1>;\n    /**\n     * @brief ODR13 field\n     *\n     * Port output data (y\
    \ =\n     *               0..15)\n     */\n    using odr13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief ODR12 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief ODR11 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief ODR10 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief ODR9 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief ODR8 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief ODR7 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief ODR6 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief ODR5 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief ODR4 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ODR3 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief ODR2 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief ODR1 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief ODR0 field\n     *\n     * Port output\
    \ data (y =\n     *               0..15)\n     */\n    using odr0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief ODR15 field\n       *\n\
    \       * Port output data (y =\n       *               0..15)\n       */\n  \
    \    BitFieldModel<uint32_t, 15, 1> odr15;\n      /**\n       * @brief ODR14 field\n\
    \       *\n       * Port output data (y =\n       *               0..15)\n   \
    \    */\n      BitFieldModel<uint32_t, 14, 1> odr14;\n      /**\n       * @brief\
    \ ODR13 field\n       *\n       * Port output data (y =\n       *            \
    \   0..15)\n       */\n      BitFieldModel<uint32_t, 13, 1> odr13;\n      /**\n\
    \       * @brief ODR12 field\n       *\n       * Port output data (y =\n     \
    \  *               0..15)\n       */\n      BitFieldModel<uint32_t, 12, 1> odr12;\n\
    \      /**\n       * @brief ODR11 field\n       *\n       * Port output data (y\
    \ =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t, 11,\
    \ 1> odr11;\n      /**\n       * @brief ODR10 field\n       *\n       * Port output\
    \ data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> odr10;\n      /**\n       * @brief ODR9 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> odr9;\n      /**\n       * @brief ODR8 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> odr8;\n      /**\n       * @brief ODR7 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> odr7;\n      /**\n       * @brief ODR6 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> odr6;\n      /**\n       * @brief ODR5 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> odr5;\n      /**\n       * @brief ODR4 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> odr4;\n      /**\n       * @brief ODR3 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> odr3;\n      /**\n       * @brief ODR2 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> odr2;\n      /**\n       * @brief ODR1 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> odr1;\n      /**\n       * @brief ODR0 field\n       *\n       * Port\
    \ output data (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> odr0;\n    };\n  };\n\npublic:\n  /**\n   * @brief ODR register\n   *\n\
    \   * GPIO port output data register\n   */\n  using odr = OdrReg<BaseAddress\
    \ + 0x0014>;\n\nprivate:\n  template<unsigned int address>\n  class BsrrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ BR15 field\n     *\n     * Port x reset bit y (y =\n     *               0..15)\n\
    \     */\n    using br15 = FieldModel<uint32_t, address, 31, 1>;\n    /**\n  \
    \   * @brief BR14 field\n     *\n     * Port x reset bit y (y =\n     *      \
    \         0..15)\n     */\n    using br14 = FieldModel<uint32_t, address, 30,\
    \ 1>;\n    /**\n     * @brief BR13 field\n     *\n     * Port x reset bit y (y\
    \ =\n     *               0..15)\n     */\n    using br13 = FieldModel<uint32_t,\
    \ address, 29, 1>;\n    /**\n     * @brief BR12 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br12 = FieldModel<uint32_t,\
    \ address, 28, 1>;\n    /**\n     * @brief BR11 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br11 = FieldModel<uint32_t,\
    \ address, 27, 1>;\n    /**\n     * @brief BR10 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br10 = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    /**\n     * @brief BR9 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br9 = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    /**\n     * @brief BR8 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br8 = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    /**\n     * @brief BR7 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br7 = FieldModel<uint32_t,\
    \ address, 23, 1>;\n    /**\n     * @brief BR6 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br6 = FieldModel<uint32_t,\
    \ address, 22, 1>;\n    /**\n     * @brief BR5 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br5 = FieldModel<uint32_t,\
    \ address, 21, 1>;\n    /**\n     * @brief BR4 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br4 = FieldModel<uint32_t,\
    \ address, 20, 1>;\n    /**\n     * @brief BR3 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br3 = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief BR2 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br2 = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    /**\n     * @brief BR1 field\n     *\n     * Port x reset\
    \ bit y (y =\n     *               0..15)\n     */\n    using br1 = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    /**\n     * @brief BR0 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using br0 = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    /**\n     * @brief BS15 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief BS14 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief BS13 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief BS12 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief BS11 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief BS10 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief BS9 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief BS8 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief BS7 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief BS6 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief BS5 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief BS4 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief BS3 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief BS2 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief BS1 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief BS0 field\n     *\n     * Port x set\
    \ bit y (y=\n     *               0..15)\n     */\n    using bs0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief BR15 field\n       *\n\
    \       * Port x reset bit y (y =\n       *               0..15)\n       */\n\
    \      BitFieldModel<uint32_t, 31, 1> br15;\n      /**\n       * @brief BR14 field\n\
    \       *\n       * Port x reset bit y (y =\n       *               0..15)\n \
    \      */\n      BitFieldModel<uint32_t, 30, 1> br14;\n      /**\n       * @brief\
    \ BR13 field\n       *\n       * Port x reset bit y (y =\n       *           \
    \    0..15)\n       */\n      BitFieldModel<uint32_t, 29, 1> br13;\n      /**\n\
    \       * @brief BR12 field\n       *\n       * Port x reset bit y (y =\n    \
    \   *               0..15)\n       */\n      BitFieldModel<uint32_t, 28, 1> br12;\n\
    \      /**\n       * @brief BR11 field\n       *\n       * Port x reset bit y\
    \ (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 27, 1> br11;\n      /**\n       * @brief BR10 field\n       *\n       * Port\
    \ x reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 26, 1> br10;\n      /**\n       * @brief BR9 field\n       *\n       * Port\
    \ x reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 1> br9;\n      /**\n       * @brief BR8 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 1> br8;\n      /**\n       * @brief BR7 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 23, 1> br7;\n      /**\n       * @brief BR6 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 1> br6;\n      /**\n       * @brief BR5 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 21, 1> br5;\n      /**\n       * @brief BR4 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 20, 1> br4;\n      /**\n       * @brief BR3 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> br3;\n      /**\n       * @brief BR2 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 1> br2;\n      /**\n       * @brief BR1 field\n       *\n       * Port x\
    \ reset bit y (y =\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 17, 1> br1;\n      /**\n       * @brief BR0 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> br0;\n      /**\n       * @brief BS15 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> bs15;\n      /**\n       * @brief BS14 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> bs14;\n      /**\n       * @brief BS13 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> bs13;\n      /**\n       * @brief BS12 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> bs12;\n      /**\n       * @brief BS11 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> bs11;\n      /**\n       * @brief BS10 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> bs10;\n      /**\n       * @brief BS9 field\n       *\n       * Port\
    \ x set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> bs9;\n      /**\n       * @brief BS8 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> bs8;\n      /**\n       * @brief BS7 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> bs7;\n      /**\n       * @brief BS6 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> bs6;\n      /**\n       * @brief BS5 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> bs5;\n      /**\n       * @brief BS4 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> bs4;\n      /**\n       * @brief BS3 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> bs3;\n      /**\n       * @brief BS2 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> bs2;\n      /**\n       * @brief BS1 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> bs1;\n      /**\n       * @brief BS0 field\n       *\n       * Port x\
    \ set bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> bs0;\n    };\n  };\n\npublic:\n  /**\n   * @brief BSRR register\n   *\n\
    \   * GPIO port bit set/reset\n   *           register\n   */\n  using bsrr =\
    \ BsrrReg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class LckrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief LCKK field\n     *\n     * Port x lock bit y (y=\n    \
    \ *               0..15)\n     */\n    using lckk = FieldModel<uint32_t, address,\
    \ 16, 1>;\n    /**\n     * @brief LCK15 field\n     *\n     * Port x lock bit\
    \ y (y=\n     *               0..15)\n     */\n    using lck15 = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief LCK14 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck14 = FieldModel<uint32_t,\
    \ address, 14, 1>;\n    /**\n     * @brief LCK13 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck13 = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief LCK12 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck12 = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief LCK11 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck11 = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief LCK10 field\n     *\n     * Port x\
    \ lock bit y (y=\n     *               0..15)\n     */\n    using lck10 = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief LCK9 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck9 = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief LCK8 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck8 = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief LCK7 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck7 = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief LCK6 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck6 = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief LCK5 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck5 = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief LCK4 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck4 = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief LCK3 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck3 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief LCK2 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck2 = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief LCK1 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck1 = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief LCK0 field\n     *\n     * Port x lock\
    \ bit y (y=\n     *               0..15)\n     */\n    using lck0 = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief LCKK field\n       *\n\
    \       * Port x lock bit y (y=\n       *               0..15)\n       */\n  \
    \    BitFieldModel<uint32_t, 16, 1> lckk;\n      /**\n       * @brief LCK15 field\n\
    \       *\n       * Port x lock bit y (y=\n       *               0..15)\n   \
    \    */\n      BitFieldModel<uint32_t, 15, 1> lck15;\n      /**\n       * @brief\
    \ LCK14 field\n       *\n       * Port x lock bit y (y=\n       *            \
    \   0..15)\n       */\n      BitFieldModel<uint32_t, 14, 1> lck14;\n      /**\n\
    \       * @brief LCK13 field\n       *\n       * Port x lock bit y (y=\n     \
    \  *               0..15)\n       */\n      BitFieldModel<uint32_t, 13, 1> lck13;\n\
    \      /**\n       * @brief LCK12 field\n       *\n       * Port x lock bit y\
    \ (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> lck12;\n      /**\n       * @brief LCK11 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> lck11;\n      /**\n       * @brief LCK10 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> lck10;\n      /**\n       * @brief LCK9 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> lck9;\n      /**\n       * @brief LCK8 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> lck8;\n      /**\n       * @brief LCK7 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> lck7;\n      /**\n       * @brief LCK6 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> lck6;\n      /**\n       * @brief LCK5 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> lck5;\n      /**\n       * @brief LCK4 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> lck4;\n      /**\n       * @brief LCK3 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> lck3;\n      /**\n       * @brief LCK2 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> lck2;\n      /**\n       * @brief LCK1 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> lck1;\n      /**\n       * @brief LCK0 field\n       *\n       * Port\
    \ x lock bit y (y=\n       *               0..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> lck0;\n    };\n  };\n\npublic:\n  /**\n   * @brief LCKR register\n   *\n\
    \   * GPIO port configuration lock\n   *           register\n   */\n  using lckr\
    \ = LckrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class AfrlReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief AFRL7 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl7\
    \ = FieldModel<uint32_t, address, 28, 4>;\n    /**\n     * @brief AFRL6 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl6 = FieldModel<uint32_t, address, 24,\
    \ 4>;\n    /**\n     * @brief AFRL5 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl5\
    \ = FieldModel<uint32_t, address, 20, 4>;\n    /**\n     * @brief AFRL4 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl4 = FieldModel<uint32_t, address, 16,\
    \ 4>;\n    /**\n     * @brief AFRL3 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl3\
    \ = FieldModel<uint32_t, address, 12, 4>;\n    /**\n     * @brief AFRL2 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl2 = FieldModel<uint32_t, address, 8,\
    \ 4>;\n    /**\n     * @brief AFRL1 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 0..7)\n     */\n    using afrl1\
    \ = FieldModel<uint32_t, address, 4, 4>;\n    /**\n     * @brief AFRL0 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 0..7)\n     */\n    using afrl0 = FieldModel<uint32_t, address, 0,\
    \ 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief AFRL7 field\n       *\n   \
    \    * Alternate function selection for port x\n       *               bit y (y\
    \ = 0..7)\n       */\n      BitFieldModel<uint32_t, 28, 4> afrl7;\n      /**\n\
    \       * @brief AFRL6 field\n       *\n       * Alternate function selection\
    \ for port x\n       *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 4> afrl6;\n      /**\n       * @brief AFRL5 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 0..7)\n   \
    \    */\n      BitFieldModel<uint32_t, 20, 4> afrl5;\n      /**\n       * @brief\
    \ AFRL4 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 4> afrl4;\n      /**\n       * @brief AFRL3 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 0..7)\n   \
    \    */\n      BitFieldModel<uint32_t, 12, 4> afrl3;\n      /**\n       * @brief\
    \ AFRL2 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 4> afrl2;\n      /**\n       * @brief AFRL1 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 0..7)\n   \
    \    */\n      BitFieldModel<uint32_t, 4, 4> afrl1;\n      /**\n       * @brief\
    \ AFRL0 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 0..7)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> afrl0;\n    };\n  };\n\npublic:\n  /**\n   * @brief AFRL register\n  \
    \ *\n   * GPIO alternate function low\n   *           register\n   */\n  using\
    \ afrl = AfrlReg<BaseAddress + 0x0020>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class AfrhReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief AFRH15 field\n     *\n     * Alternate function selection\
    \ for port x\n     *               bit y (y = 8..15)\n     */\n    using afrh15\
    \ = FieldModel<uint32_t, address, 28, 4>;\n    /**\n     * @brief AFRH14 field\n\
    \     *\n     * Alternate function selection for port x\n     *              \
    \ bit y (y = 8..15)\n     */\n    using afrh14 = FieldModel<uint32_t, address,\
    \ 24, 4>;\n    /**\n     * @brief AFRH13 field\n     *\n     * Alternate function\
    \ selection for port x\n     *               bit y (y = 8..15)\n     */\n    using\
    \ afrh13 = FieldModel<uint32_t, address, 20, 4>;\n    /**\n     * @brief AFRH12\
    \ field\n     *\n     * Alternate function selection for port x\n     *      \
    \         bit y (y = 8..15)\n     */\n    using afrh12 = FieldModel<uint32_t,\
    \ address, 16, 4>;\n    /**\n     * @brief AFRH11 field\n     *\n     * Alternate\
    \ function selection for port x\n     *               bit y (y = 8..15)\n    \
    \ */\n    using afrh11 = FieldModel<uint32_t, address, 12, 4>;\n    /**\n    \
    \ * @brief AFRH10 field\n     *\n     * Alternate function selection for port\
    \ x\n     *               bit y (y = 8..15)\n     */\n    using afrh10 = FieldModel<uint32_t,\
    \ address, 8, 4>;\n    /**\n     * @brief AFRH9 field\n     *\n     * Alternate\
    \ function selection for port x\n     *               bit y (y = 8..15)\n    \
    \ */\n    using afrh9 = FieldModel<uint32_t, address, 4, 4>;\n    /**\n     *\
    \ @brief AFRH8 field\n     *\n     * Alternate function selection for port x\n\
    \     *               bit y (y = 8..15)\n     */\n    using afrh8 = FieldModel<uint32_t,\
    \ address, 0, 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief AFRH15 field\n       *\n\
    \       * Alternate function selection for port x\n       *               bit\
    \ y (y = 8..15)\n       */\n      BitFieldModel<uint32_t, 28, 4> afrh15;\n   \
    \   /**\n       * @brief AFRH14 field\n       *\n       * Alternate function selection\
    \ for port x\n       *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 4> afrh14;\n      /**\n       * @brief AFRH13 field\n       *\n       *\
    \ Alternate function selection for port x\n       *               bit y (y = 8..15)\n\
    \       */\n      BitFieldModel<uint32_t, 20, 4> afrh13;\n      /**\n       *\
    \ @brief AFRH12 field\n       *\n       * Alternate function selection for port\
    \ x\n       *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 4> afrh12;\n      /**\n       * @brief AFRH11 field\n       *\n       *\
    \ Alternate function selection for port x\n       *               bit y (y = 8..15)\n\
    \       */\n      BitFieldModel<uint32_t, 12, 4> afrh11;\n      /**\n       *\
    \ @brief AFRH10 field\n       *\n       * Alternate function selection for port\
    \ x\n       *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 4> afrh10;\n      /**\n       * @brief AFRH9 field\n       *\n       * Alternate\
    \ function selection for port x\n       *               bit y (y = 8..15)\n  \
    \     */\n      BitFieldModel<uint32_t, 4, 4> afrh9;\n      /**\n       * @brief\
    \ AFRH8 field\n       *\n       * Alternate function selection for port x\n  \
    \     *               bit y (y = 8..15)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> afrh8;\n    };\n  };\n\npublic:\n  /**\n   * @brief AFRH register\n  \
    \ *\n   * GPIO alternate function high\n   *           register\n   */\n  using\
    \ afrh = AfrhReg<BaseAddress + 0x0024>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_GPIOA_H\
    \ */"
  name: GPIOA
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_I2C3_H\n#define DRAL_STM32F411_I2C3_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ I2C3 peripheral\n *\n * Inter-integrated circuit\n */\nclass i2c3\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40005C00; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief SWRST\
    \ field\n     *\n     * Software reset\n     */\n    using swrst = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief ALERT field\n     *\n     * SMBus alert\n\
    \     */\n    using alert = FieldModel<uint32_t, address, 13, 1>;\n    /**\n \
    \    * @brief PEC field\n     *\n     * Packet error checking\n     */\n    using\
    \ pec = FieldModel<uint32_t, address, 12, 1>;\n    /**\n     * @brief POS field\n\
    \     *\n     * Acknowledge/PEC Position (for data\n     *               reception)\n\
    \     */\n    using pos = FieldModel<uint32_t, address, 11, 1>;\n    /**\n   \
    \  * @brief ACK field\n     *\n     * Acknowledge enable\n     */\n    using ack\
    \ = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief STOP field\n\
    \     *\n     * Stop generation\n     */\n    using stop = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief START field\n     *\n     * Start generation\n\
    \     */\n    using start = FieldModel<uint32_t, address, 8, 1>;\n    /**\n  \
    \   * @brief NOSTRETCH field\n     *\n     * Clock stretching disable (Slave\n\
    \     *               mode)\n     */\n    using nostretch = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief ENGC field\n     *\n     * General call\
    \ enable\n     */\n    using engc = FieldModel<uint32_t, address, 6, 1>;\n   \
    \ /**\n     * @brief ENPEC field\n     *\n     * PEC enable\n     */\n    using\
    \ enpec = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief ENARP field\n\
    \     *\n     * ARP enable\n     */\n    using enarp = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief SMBTYPE field\n     *\n     * SMBus type\n  \
    \   */\n    using smbtype = FieldModel<uint32_t, address, 3, 1>;\n    /**\n  \
    \   * @brief SMBUS field\n     *\n     * SMBus mode\n     */\n    using smbus\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief PE field\n  \
    \   *\n     * Peripheral enable\n     */\n    using pe = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief SWRST field\n       *\n\
    \       * Software reset\n       */\n      BitFieldModel<uint32_t, 15, 1> swrst;\n\
    \      /**\n       * @brief ALERT field\n       *\n       * SMBus alert\n    \
    \   */\n      BitFieldModel<uint32_t, 13, 1> alert;\n      /**\n       * @brief\
    \ PEC field\n       *\n       * Packet error checking\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> pec;\n      /**\n       * @brief POS field\n       *\n       * Acknowledge/PEC\
    \ Position (for data\n       *               reception)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> pos;\n      /**\n       * @brief ACK field\n       *\n       * Acknowledge\
    \ enable\n       */\n      BitFieldModel<uint32_t, 10, 1> ack;\n      /**\n  \
    \     * @brief STOP field\n       *\n       * Stop generation\n       */\n   \
    \   BitFieldModel<uint32_t, 9, 1> stop;\n      /**\n       * @brief START field\n\
    \       *\n       * Start generation\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> start;\n      /**\n       * @brief NOSTRETCH field\n       *\n       *\
    \ Clock stretching disable (Slave\n       *               mode)\n       */\n \
    \     BitFieldModel<uint32_t, 7, 1> nostretch;\n      /**\n       * @brief ENGC\
    \ field\n       *\n       * General call enable\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> engc;\n      /**\n       * @brief ENPEC field\n       *\n       * PEC\
    \ enable\n       */\n      BitFieldModel<uint32_t, 5, 1> enpec;\n      /**\n \
    \      * @brief ENARP field\n       *\n       * ARP enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> enarp;\n      /**\n       * @brief SMBTYPE field\n       *\n       * SMBus\
    \ type\n       */\n      BitFieldModel<uint32_t, 3, 1> smbtype;\n      /**\n \
    \      * @brief SMBUS field\n       *\n       * SMBus mode\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> smbus;\n      /**\n       * @brief PE field\n       *\n       * Peripheral\
    \ enable\n       */\n      BitFieldModel<uint32_t, 0, 1> pe;\n    };\n  };\n\n\
    public:\n  /**\n   * @brief CR1 register\n   *\n   * Control register 1\n   */\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief LAST field\n     *\n     * DMA last transfer\n\
    \     */\n    using last = FieldModel<uint32_t, address, 12, 1>;\n    /**\n  \
    \   * @brief DMAEN field\n     *\n     * DMA requests enable\n     */\n    using\
    \ dmaen = FieldModel<uint32_t, address, 11, 1>;\n    /**\n     * @brief ITBUFEN\
    \ field\n     *\n     * Buffer interrupt enable\n     */\n    using itbufen =\
    \ FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief ITEVTEN field\n\
    \     *\n     * Event interrupt enable\n     */\n    using itevten = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief ITERREN field\n     *\n     * Error\
    \ interrupt enable\n     */\n    using iterren = FieldModel<uint32_t, address,\
    \ 8, 1>;\n    /**\n     * @brief FREQ field\n     *\n     * Peripheral clock frequency\n\
    \     */\n    using freq = FieldModel<uint32_t, address, 0, 6>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief LAST field\n       *\n       * DMA last transfer\n       */\n\
    \      BitFieldModel<uint32_t, 12, 1> last;\n      /**\n       * @brief DMAEN\
    \ field\n       *\n       * DMA requests enable\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> dmaen;\n      /**\n       * @brief ITBUFEN field\n       *\n       *\
    \ Buffer interrupt enable\n       */\n      BitFieldModel<uint32_t, 10, 1> itbufen;\n\
    \      /**\n       * @brief ITEVTEN field\n       *\n       * Event interrupt\
    \ enable\n       */\n      BitFieldModel<uint32_t, 9, 1> itevten;\n      /**\n\
    \       * @brief ITERREN field\n       *\n       * Error interrupt enable\n  \
    \     */\n      BitFieldModel<uint32_t, 8, 1> iterren;\n      /**\n       * @brief\
    \ FREQ field\n       *\n       * Peripheral clock frequency\n       */\n     \
    \ BitFieldModel<uint32_t, 0, 6> freq;\n    };\n  };\n\npublic:\n  /**\n   * @brief\
    \ CR2 register\n   *\n   * Control register 2\n   */\n  using cr2 = Cr2Reg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class Oar1Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ ADDMODE field\n     *\n     * Addressing mode (slave\n     *               mode)\n\
    \     */\n    using addmode = FieldModel<uint32_t, address, 15, 1>;\n    /**\n\
    \     * @brief ADD10 field\n     *\n     * Interface address\n     */\n    using\
    \ add10 = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief ADD7 field\n\
    \     *\n     * Interface address\n     */\n    using add7 = FieldModel<uint32_t,\
    \ address, 1, 7>;\n    /**\n     * @brief ADD0 field\n     *\n     * Interface\
    \ address\n     */\n    using add0 = FieldModel<uint32_t, address, 0, 1>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief ADDMODE field\n       *\n       * Addressing\
    \ mode (slave\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> addmode;\n      /**\n       * @brief ADD10 field\n       *\n       *\
    \ Interface address\n       */\n      BitFieldModel<uint32_t, 8, 2> add10;\n \
    \     /**\n       * @brief ADD7 field\n       *\n       * Interface address\n\
    \       */\n      BitFieldModel<uint32_t, 1, 7> add7;\n      /**\n       * @brief\
    \ ADD0 field\n       *\n       * Interface address\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> add0;\n    };\n  };\n\npublic:\n  /**\n   * @brief OAR1 register\n   *\n\
    \   * Own address register 1\n   */\n  using oar1 = Oar1Reg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Oar2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief ADD2 field\n     *\n     *\
    \ Interface address\n     */\n    using add2 = FieldModel<uint32_t, address, 1,\
    \ 7>;\n    /**\n     * @brief ENDUAL field\n     *\n     * Dual addressing mode\n\
    \     *               enable\n     */\n    using endual = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief ADD2 field\n       *\n\
    \       * Interface address\n       */\n      BitFieldModel<uint32_t, 1, 7> add2;\n\
    \      /**\n       * @brief ENDUAL field\n       *\n       * Dual addressing mode\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 0, 1>\
    \ endual;\n    };\n  };\n\npublic:\n  /**\n   * @brief OAR2 register\n   *\n \
    \  * Own address register 2\n   */\n  using oar2 = Oar2Reg<BaseAddress + 0x000C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief DR field\n     *\n     * 8-bit\
    \ data register\n     */\n    using dr = FieldModel<uint32_t, address, 0, 8>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief DR field\n       *\n       * 8-bit data register\n\
    \       */\n      BitFieldModel<uint32_t, 0, 8> dr;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief DR register\n   *\n   * Data register\n   */\n  using dr =\
    \ DrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Sr1Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief SMBALERT field\n     *\n     * SMBus alert\n     */\n  \
    \  using smbalert = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief\
    \ TIMEOUT field\n     *\n     * Timeout or Tlow error\n     */\n    using timeout\
    \ = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief PECERR field\n\
    \     *\n     * PEC Error in reception\n     */\n    using pecerr = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief OVR field\n     *\n     * Overrun/Underrun\n\
    \     */\n    using ovr = FieldModel<uint32_t, address, 11, 1>;\n    /**\n   \
    \  * @brief AF field\n     *\n     * Acknowledge failure\n     */\n    using af\
    \ = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief ARLO field\n\
    \     *\n     * Arbitration lost (master\n     *               mode)\n     */\n\
    \    using arlo = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief\
    \ BERR field\n     *\n     * Bus error\n     */\n    using berr = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief TXE field\n     *\n     * Data register\
    \ empty\n     *               (transmitters)\n     */\n    using txe = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief RXNE field\n     *\n     * Data register\
    \ not empty\n     *               (receivers)\n     */\n    using rxne = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief STOPF field\n     *\n     * Stop detection\
    \ (slave\n     *               mode)\n     */\n    using stopf = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ADD10 field\n     *\n     * 10-bit header\
    \ sent (Master\n     *               mode)\n     */\n    using add10 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief BTF field\n     *\n     * Byte transfer\
    \ finished\n     */\n    using btf = FieldModel<uint32_t, address, 2, 1>;\n  \
    \  /**\n     * @brief ADDR field\n     *\n     * Address sent (master mode)/matched\n\
    \     *               (slave mode)\n     */\n    using addr = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief SB field\n     *\n     * Start bit (Master\
    \ mode)\n     */\n    using sb = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief SMBALERT field\n       *\n       * SMBus alert\n       */\n \
    \     BitFieldModel<uint32_t, 15, 1> smbalert;\n      /**\n       * @brief TIMEOUT\
    \ field\n       *\n       * Timeout or Tlow error\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> timeout;\n      /**\n       * @brief PECERR field\n       *\n       *\
    \ PEC Error in reception\n       */\n      BitFieldModel<uint32_t, 12, 1> pecerr;\n\
    \      /**\n       * @brief OVR field\n       *\n       * Overrun/Underrun\n \
    \      */\n      BitFieldModel<uint32_t, 11, 1> ovr;\n      /**\n       * @brief\
    \ AF field\n       *\n       * Acknowledge failure\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> af;\n      /**\n       * @brief ARLO field\n       *\n       * Arbitration\
    \ lost (master\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> arlo;\n      /**\n       * @brief BERR field\n       *\n       * Bus error\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> berr;\n      /**\n       * @brief\
    \ TXE field\n       *\n       * Data register empty\n       *               (transmitters)\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> txe;\n      /**\n       * @brief\
    \ RXNE field\n       *\n       * Data register not empty\n       *           \
    \    (receivers)\n       */\n      BitFieldModel<uint32_t, 6, 1> rxne;\n     \
    \ /**\n       * @brief STOPF field\n       *\n       * Stop detection (slave\n\
    \       *               mode)\n       */\n      BitFieldModel<uint32_t, 4, 1>\
    \ stopf;\n      /**\n       * @brief ADD10 field\n       *\n       * 10-bit header\
    \ sent (Master\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> add10;\n      /**\n       * @brief BTF field\n       *\n       * Byte\
    \ transfer finished\n       */\n      BitFieldModel<uint32_t, 2, 1> btf;\n   \
    \   /**\n       * @brief ADDR field\n       *\n       * Address sent (master mode)/matched\n\
    \       *               (slave mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> addr;\n      /**\n       * @brief SB field\n       *\n       * Start bit\
    \ (Master mode)\n       */\n      BitFieldModel<uint32_t, 0, 1> sb;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief SR1 register\n   *\n   * Status register\
    \ 1\n   */\n  using sr1 = Sr1Reg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Sr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief PEC field\n     *\n     * acket error checking\n\
    \     *               register\n     */\n    using pec = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    /**\n     * @brief DUALF field\n     *\n     * Dual flag\
    \ (Slave mode)\n     */\n    using dualf = FieldModel<uint32_t, address, 7, 1>;\n\
    \    /**\n     * @brief SMBHOST field\n     *\n     * SMBus host header (Slave\n\
    \     *               mode)\n     */\n    using smbhost = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief SMBDEFAULT field\n     *\n     * SMBus\
    \ device default address (Slave\n     *               mode)\n     */\n    using\
    \ smbdefault = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief GENCALL\
    \ field\n     *\n     * General call address (Slave\n     *               mode)\n\
    \     */\n    using gencall = FieldModel<uint32_t, address, 4, 1>;\n    /**\n\
    \     * @brief TRA field\n     *\n     * Transmitter/receiver\n     */\n    using\
    \ tra = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief BUSY field\n\
    \     *\n     * Bus busy\n     */\n    using busy = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    /**\n     * @brief MSL field\n     *\n     * Master/slave\n    \
    \ */\n    using msl = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ PEC field\n       *\n       * acket error checking\n       *               register\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> pec;\n      /**\n       * @brief\
    \ DUALF field\n       *\n       * Dual flag (Slave mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> dualf;\n      /**\n       * @brief SMBHOST field\n       *\n       * SMBus\
    \ host header (Slave\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> smbhost;\n      /**\n       * @brief SMBDEFAULT field\n       *\n    \
    \   * SMBus device default address (Slave\n       *               mode)\n    \
    \   */\n      BitFieldModel<uint32_t, 5, 1> smbdefault;\n      /**\n       * @brief\
    \ GENCALL field\n       *\n       * General call address (Slave\n       *    \
    \           mode)\n       */\n      BitFieldModel<uint32_t, 4, 1> gencall;\n \
    \     /**\n       * @brief TRA field\n       *\n       * Transmitter/receiver\n\
    \       */\n      BitFieldModel<uint32_t, 2, 1> tra;\n      /**\n       * @brief\
    \ BUSY field\n       *\n       * Bus busy\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> busy;\n      /**\n       * @brief MSL field\n       *\n       * Master/slave\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> msl;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief SR2 register\n   *\n   * Status register 2\n   */\n  using\
    \ sr2 = Sr2Reg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class CcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief F_S field\n     *\n     * I2C master mode selection\n  \
    \   */\n    using f_s = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     *\
    \ @brief DUTY field\n     *\n     * Fast mode duty cycle\n     */\n    using duty\
    \ = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief CCR field\n\
    \     *\n     * Clock control register in Fast/Standard\n     *              \
    \ mode (Master mode)\n     */\n    using ccr = FieldModel<uint32_t, address, 0,\
    \ 12>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief F_S field\n       *\n     \
    \  * I2C master mode selection\n       */\n      BitFieldModel<uint32_t, 15, 1>\
    \ f_s;\n      /**\n       * @brief DUTY field\n       *\n       * Fast mode duty\
    \ cycle\n       */\n      BitFieldModel<uint32_t, 14, 1> duty;\n      /**\n  \
    \     * @brief CCR field\n       *\n       * Clock control register in Fast/Standard\n\
    \       *               mode (Master mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 12> ccr;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCR register\n   *\n\
    \   * Clock control register\n   */\n  using ccr = CcrReg<BaseAddress + 0x001C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class TriseReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief TRISE field\n     *\n     *\
    \ Maximum rise time in Fast/Standard mode\n     *               (Master mode)\n\
    \     */\n    using trise = FieldModel<uint32_t, address, 0, 6>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief TRISE field\n       *\n       * Maximum rise time in Fast/Standard\
    \ mode\n       *               (Master mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 6> trise;\n    };\n  };\n\npublic:\n  /**\n   * @brief TRISE register\n \
    \  *\n   * TRISE register\n   */\n  using trise = TriseReg<BaseAddress + 0x0020>;\n\
    \n};\n\n}\n\n#endif /* DRAL_STM32F411_I2C3_H */"
  name: I2C3
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_I2C2_H\n#define DRAL_STM32F411_I2C2_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ I2C2 peripheral\n *\n * Inter-integrated circuit\n */\nclass i2c2\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40005800; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief SWRST\
    \ field\n     *\n     * Software reset\n     */\n    using swrst = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief ALERT field\n     *\n     * SMBus alert\n\
    \     */\n    using alert = FieldModel<uint32_t, address, 13, 1>;\n    /**\n \
    \    * @brief PEC field\n     *\n     * Packet error checking\n     */\n    using\
    \ pec = FieldModel<uint32_t, address, 12, 1>;\n    /**\n     * @brief POS field\n\
    \     *\n     * Acknowledge/PEC Position (for data\n     *               reception)\n\
    \     */\n    using pos = FieldModel<uint32_t, address, 11, 1>;\n    /**\n   \
    \  * @brief ACK field\n     *\n     * Acknowledge enable\n     */\n    using ack\
    \ = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief STOP field\n\
    \     *\n     * Stop generation\n     */\n    using stop = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief START field\n     *\n     * Start generation\n\
    \     */\n    using start = FieldModel<uint32_t, address, 8, 1>;\n    /**\n  \
    \   * @brief NOSTRETCH field\n     *\n     * Clock stretching disable (Slave\n\
    \     *               mode)\n     */\n    using nostretch = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief ENGC field\n     *\n     * General call\
    \ enable\n     */\n    using engc = FieldModel<uint32_t, address, 6, 1>;\n   \
    \ /**\n     * @brief ENPEC field\n     *\n     * PEC enable\n     */\n    using\
    \ enpec = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief ENARP field\n\
    \     *\n     * ARP enable\n     */\n    using enarp = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief SMBTYPE field\n     *\n     * SMBus type\n  \
    \   */\n    using smbtype = FieldModel<uint32_t, address, 3, 1>;\n    /**\n  \
    \   * @brief SMBUS field\n     *\n     * SMBus mode\n     */\n    using smbus\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief PE field\n  \
    \   *\n     * Peripheral enable\n     */\n    using pe = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief SWRST field\n       *\n\
    \       * Software reset\n       */\n      BitFieldModel<uint32_t, 15, 1> swrst;\n\
    \      /**\n       * @brief ALERT field\n       *\n       * SMBus alert\n    \
    \   */\n      BitFieldModel<uint32_t, 13, 1> alert;\n      /**\n       * @brief\
    \ PEC field\n       *\n       * Packet error checking\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> pec;\n      /**\n       * @brief POS field\n       *\n       * Acknowledge/PEC\
    \ Position (for data\n       *               reception)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> pos;\n      /**\n       * @brief ACK field\n       *\n       * Acknowledge\
    \ enable\n       */\n      BitFieldModel<uint32_t, 10, 1> ack;\n      /**\n  \
    \     * @brief STOP field\n       *\n       * Stop generation\n       */\n   \
    \   BitFieldModel<uint32_t, 9, 1> stop;\n      /**\n       * @brief START field\n\
    \       *\n       * Start generation\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> start;\n      /**\n       * @brief NOSTRETCH field\n       *\n       *\
    \ Clock stretching disable (Slave\n       *               mode)\n       */\n \
    \     BitFieldModel<uint32_t, 7, 1> nostretch;\n      /**\n       * @brief ENGC\
    \ field\n       *\n       * General call enable\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> engc;\n      /**\n       * @brief ENPEC field\n       *\n       * PEC\
    \ enable\n       */\n      BitFieldModel<uint32_t, 5, 1> enpec;\n      /**\n \
    \      * @brief ENARP field\n       *\n       * ARP enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> enarp;\n      /**\n       * @brief SMBTYPE field\n       *\n       * SMBus\
    \ type\n       */\n      BitFieldModel<uint32_t, 3, 1> smbtype;\n      /**\n \
    \      * @brief SMBUS field\n       *\n       * SMBus mode\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> smbus;\n      /**\n       * @brief PE field\n       *\n       * Peripheral\
    \ enable\n       */\n      BitFieldModel<uint32_t, 0, 1> pe;\n    };\n  };\n\n\
    public:\n  /**\n   * @brief CR1 register\n   *\n   * Control register 1\n   */\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief LAST field\n     *\n     * DMA last transfer\n\
    \     */\n    using last = FieldModel<uint32_t, address, 12, 1>;\n    /**\n  \
    \   * @brief DMAEN field\n     *\n     * DMA requests enable\n     */\n    using\
    \ dmaen = FieldModel<uint32_t, address, 11, 1>;\n    /**\n     * @brief ITBUFEN\
    \ field\n     *\n     * Buffer interrupt enable\n     */\n    using itbufen =\
    \ FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief ITEVTEN field\n\
    \     *\n     * Event interrupt enable\n     */\n    using itevten = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief ITERREN field\n     *\n     * Error\
    \ interrupt enable\n     */\n    using iterren = FieldModel<uint32_t, address,\
    \ 8, 1>;\n    /**\n     * @brief FREQ field\n     *\n     * Peripheral clock frequency\n\
    \     */\n    using freq = FieldModel<uint32_t, address, 0, 6>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief LAST field\n       *\n       * DMA last transfer\n       */\n\
    \      BitFieldModel<uint32_t, 12, 1> last;\n      /**\n       * @brief DMAEN\
    \ field\n       *\n       * DMA requests enable\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> dmaen;\n      /**\n       * @brief ITBUFEN field\n       *\n       *\
    \ Buffer interrupt enable\n       */\n      BitFieldModel<uint32_t, 10, 1> itbufen;\n\
    \      /**\n       * @brief ITEVTEN field\n       *\n       * Event interrupt\
    \ enable\n       */\n      BitFieldModel<uint32_t, 9, 1> itevten;\n      /**\n\
    \       * @brief ITERREN field\n       *\n       * Error interrupt enable\n  \
    \     */\n      BitFieldModel<uint32_t, 8, 1> iterren;\n      /**\n       * @brief\
    \ FREQ field\n       *\n       * Peripheral clock frequency\n       */\n     \
    \ BitFieldModel<uint32_t, 0, 6> freq;\n    };\n  };\n\npublic:\n  /**\n   * @brief\
    \ CR2 register\n   *\n   * Control register 2\n   */\n  using cr2 = Cr2Reg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class Oar1Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ ADDMODE field\n     *\n     * Addressing mode (slave\n     *               mode)\n\
    \     */\n    using addmode = FieldModel<uint32_t, address, 15, 1>;\n    /**\n\
    \     * @brief ADD10 field\n     *\n     * Interface address\n     */\n    using\
    \ add10 = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief ADD7 field\n\
    \     *\n     * Interface address\n     */\n    using add7 = FieldModel<uint32_t,\
    \ address, 1, 7>;\n    /**\n     * @brief ADD0 field\n     *\n     * Interface\
    \ address\n     */\n    using add0 = FieldModel<uint32_t, address, 0, 1>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief ADDMODE field\n       *\n       * Addressing\
    \ mode (slave\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> addmode;\n      /**\n       * @brief ADD10 field\n       *\n       *\
    \ Interface address\n       */\n      BitFieldModel<uint32_t, 8, 2> add10;\n \
    \     /**\n       * @brief ADD7 field\n       *\n       * Interface address\n\
    \       */\n      BitFieldModel<uint32_t, 1, 7> add7;\n      /**\n       * @brief\
    \ ADD0 field\n       *\n       * Interface address\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> add0;\n    };\n  };\n\npublic:\n  /**\n   * @brief OAR1 register\n   *\n\
    \   * Own address register 1\n   */\n  using oar1 = Oar1Reg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Oar2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief ADD2 field\n     *\n     *\
    \ Interface address\n     */\n    using add2 = FieldModel<uint32_t, address, 1,\
    \ 7>;\n    /**\n     * @brief ENDUAL field\n     *\n     * Dual addressing mode\n\
    \     *               enable\n     */\n    using endual = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief ADD2 field\n       *\n\
    \       * Interface address\n       */\n      BitFieldModel<uint32_t, 1, 7> add2;\n\
    \      /**\n       * @brief ENDUAL field\n       *\n       * Dual addressing mode\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 0, 1>\
    \ endual;\n    };\n  };\n\npublic:\n  /**\n   * @brief OAR2 register\n   *\n \
    \  * Own address register 2\n   */\n  using oar2 = Oar2Reg<BaseAddress + 0x000C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief DR field\n     *\n     * 8-bit\
    \ data register\n     */\n    using dr = FieldModel<uint32_t, address, 0, 8>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief DR field\n       *\n       * 8-bit data register\n\
    \       */\n      BitFieldModel<uint32_t, 0, 8> dr;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief DR register\n   *\n   * Data register\n   */\n  using dr =\
    \ DrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Sr1Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief SMBALERT field\n     *\n     * SMBus alert\n     */\n  \
    \  using smbalert = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief\
    \ TIMEOUT field\n     *\n     * Timeout or Tlow error\n     */\n    using timeout\
    \ = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief PECERR field\n\
    \     *\n     * PEC Error in reception\n     */\n    using pecerr = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief OVR field\n     *\n     * Overrun/Underrun\n\
    \     */\n    using ovr = FieldModel<uint32_t, address, 11, 1>;\n    /**\n   \
    \  * @brief AF field\n     *\n     * Acknowledge failure\n     */\n    using af\
    \ = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief ARLO field\n\
    \     *\n     * Arbitration lost (master\n     *               mode)\n     */\n\
    \    using arlo = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief\
    \ BERR field\n     *\n     * Bus error\n     */\n    using berr = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief TXE field\n     *\n     * Data register\
    \ empty\n     *               (transmitters)\n     */\n    using txe = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief RXNE field\n     *\n     * Data register\
    \ not empty\n     *               (receivers)\n     */\n    using rxne = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief STOPF field\n     *\n     * Stop detection\
    \ (slave\n     *               mode)\n     */\n    using stopf = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ADD10 field\n     *\n     * 10-bit header\
    \ sent (Master\n     *               mode)\n     */\n    using add10 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief BTF field\n     *\n     * Byte transfer\
    \ finished\n     */\n    using btf = FieldModel<uint32_t, address, 2, 1>;\n  \
    \  /**\n     * @brief ADDR field\n     *\n     * Address sent (master mode)/matched\n\
    \     *               (slave mode)\n     */\n    using addr = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief SB field\n     *\n     * Start bit (Master\
    \ mode)\n     */\n    using sb = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief SMBALERT field\n       *\n       * SMBus alert\n       */\n \
    \     BitFieldModel<uint32_t, 15, 1> smbalert;\n      /**\n       * @brief TIMEOUT\
    \ field\n       *\n       * Timeout or Tlow error\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> timeout;\n      /**\n       * @brief PECERR field\n       *\n       *\
    \ PEC Error in reception\n       */\n      BitFieldModel<uint32_t, 12, 1> pecerr;\n\
    \      /**\n       * @brief OVR field\n       *\n       * Overrun/Underrun\n \
    \      */\n      BitFieldModel<uint32_t, 11, 1> ovr;\n      /**\n       * @brief\
    \ AF field\n       *\n       * Acknowledge failure\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> af;\n      /**\n       * @brief ARLO field\n       *\n       * Arbitration\
    \ lost (master\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> arlo;\n      /**\n       * @brief BERR field\n       *\n       * Bus error\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> berr;\n      /**\n       * @brief\
    \ TXE field\n       *\n       * Data register empty\n       *               (transmitters)\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> txe;\n      /**\n       * @brief\
    \ RXNE field\n       *\n       * Data register not empty\n       *           \
    \    (receivers)\n       */\n      BitFieldModel<uint32_t, 6, 1> rxne;\n     \
    \ /**\n       * @brief STOPF field\n       *\n       * Stop detection (slave\n\
    \       *               mode)\n       */\n      BitFieldModel<uint32_t, 4, 1>\
    \ stopf;\n      /**\n       * @brief ADD10 field\n       *\n       * 10-bit header\
    \ sent (Master\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> add10;\n      /**\n       * @brief BTF field\n       *\n       * Byte\
    \ transfer finished\n       */\n      BitFieldModel<uint32_t, 2, 1> btf;\n   \
    \   /**\n       * @brief ADDR field\n       *\n       * Address sent (master mode)/matched\n\
    \       *               (slave mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> addr;\n      /**\n       * @brief SB field\n       *\n       * Start bit\
    \ (Master mode)\n       */\n      BitFieldModel<uint32_t, 0, 1> sb;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief SR1 register\n   *\n   * Status register\
    \ 1\n   */\n  using sr1 = Sr1Reg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Sr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief PEC field\n     *\n     * acket error checking\n\
    \     *               register\n     */\n    using pec = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    /**\n     * @brief DUALF field\n     *\n     * Dual flag\
    \ (Slave mode)\n     */\n    using dualf = FieldModel<uint32_t, address, 7, 1>;\n\
    \    /**\n     * @brief SMBHOST field\n     *\n     * SMBus host header (Slave\n\
    \     *               mode)\n     */\n    using smbhost = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief SMBDEFAULT field\n     *\n     * SMBus\
    \ device default address (Slave\n     *               mode)\n     */\n    using\
    \ smbdefault = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief GENCALL\
    \ field\n     *\n     * General call address (Slave\n     *               mode)\n\
    \     */\n    using gencall = FieldModel<uint32_t, address, 4, 1>;\n    /**\n\
    \     * @brief TRA field\n     *\n     * Transmitter/receiver\n     */\n    using\
    \ tra = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief BUSY field\n\
    \     *\n     * Bus busy\n     */\n    using busy = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    /**\n     * @brief MSL field\n     *\n     * Master/slave\n    \
    \ */\n    using msl = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ PEC field\n       *\n       * acket error checking\n       *               register\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> pec;\n      /**\n       * @brief\
    \ DUALF field\n       *\n       * Dual flag (Slave mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> dualf;\n      /**\n       * @brief SMBHOST field\n       *\n       * SMBus\
    \ host header (Slave\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> smbhost;\n      /**\n       * @brief SMBDEFAULT field\n       *\n    \
    \   * SMBus device default address (Slave\n       *               mode)\n    \
    \   */\n      BitFieldModel<uint32_t, 5, 1> smbdefault;\n      /**\n       * @brief\
    \ GENCALL field\n       *\n       * General call address (Slave\n       *    \
    \           mode)\n       */\n      BitFieldModel<uint32_t, 4, 1> gencall;\n \
    \     /**\n       * @brief TRA field\n       *\n       * Transmitter/receiver\n\
    \       */\n      BitFieldModel<uint32_t, 2, 1> tra;\n      /**\n       * @brief\
    \ BUSY field\n       *\n       * Bus busy\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> busy;\n      /**\n       * @brief MSL field\n       *\n       * Master/slave\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> msl;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief SR2 register\n   *\n   * Status register 2\n   */\n  using\
    \ sr2 = Sr2Reg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class CcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief F_S field\n     *\n     * I2C master mode selection\n  \
    \   */\n    using f_s = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     *\
    \ @brief DUTY field\n     *\n     * Fast mode duty cycle\n     */\n    using duty\
    \ = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief CCR field\n\
    \     *\n     * Clock control register in Fast/Standard\n     *              \
    \ mode (Master mode)\n     */\n    using ccr = FieldModel<uint32_t, address, 0,\
    \ 12>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief F_S field\n       *\n     \
    \  * I2C master mode selection\n       */\n      BitFieldModel<uint32_t, 15, 1>\
    \ f_s;\n      /**\n       * @brief DUTY field\n       *\n       * Fast mode duty\
    \ cycle\n       */\n      BitFieldModel<uint32_t, 14, 1> duty;\n      /**\n  \
    \     * @brief CCR field\n       *\n       * Clock control register in Fast/Standard\n\
    \       *               mode (Master mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 12> ccr;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCR register\n   *\n\
    \   * Clock control register\n   */\n  using ccr = CcrReg<BaseAddress + 0x001C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class TriseReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief TRISE field\n     *\n     *\
    \ Maximum rise time in Fast/Standard mode\n     *               (Master mode)\n\
    \     */\n    using trise = FieldModel<uint32_t, address, 0, 6>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief TRISE field\n       *\n       * Maximum rise time in Fast/Standard\
    \ mode\n       *               (Master mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 6> trise;\n    };\n  };\n\npublic:\n  /**\n   * @brief TRISE register\n \
    \  *\n   * TRISE register\n   */\n  using trise = TriseReg<BaseAddress + 0x0020>;\n\
    \n};\n\n}\n\n#endif /* DRAL_STM32F411_I2C2_H */"
  name: I2C2
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_I2C1_H\n#define DRAL_STM32F411_I2C1_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ I2C1 peripheral\n *\n * Inter-integrated circuit\n */\nclass i2c1\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40005400; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief SWRST\
    \ field\n     *\n     * Software reset\n     */\n    using swrst = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief ALERT field\n     *\n     * SMBus alert\n\
    \     */\n    using alert = FieldModel<uint32_t, address, 13, 1>;\n    /**\n \
    \    * @brief PEC field\n     *\n     * Packet error checking\n     */\n    using\
    \ pec = FieldModel<uint32_t, address, 12, 1>;\n    /**\n     * @brief POS field\n\
    \     *\n     * Acknowledge/PEC Position (for data\n     *               reception)\n\
    \     */\n    using pos = FieldModel<uint32_t, address, 11, 1>;\n    /**\n   \
    \  * @brief ACK field\n     *\n     * Acknowledge enable\n     */\n    using ack\
    \ = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief STOP field\n\
    \     *\n     * Stop generation\n     */\n    using stop = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief START field\n     *\n     * Start generation\n\
    \     */\n    using start = FieldModel<uint32_t, address, 8, 1>;\n    /**\n  \
    \   * @brief NOSTRETCH field\n     *\n     * Clock stretching disable (Slave\n\
    \     *               mode)\n     */\n    using nostretch = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief ENGC field\n     *\n     * General call\
    \ enable\n     */\n    using engc = FieldModel<uint32_t, address, 6, 1>;\n   \
    \ /**\n     * @brief ENPEC field\n     *\n     * PEC enable\n     */\n    using\
    \ enpec = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief ENARP field\n\
    \     *\n     * ARP enable\n     */\n    using enarp = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief SMBTYPE field\n     *\n     * SMBus type\n  \
    \   */\n    using smbtype = FieldModel<uint32_t, address, 3, 1>;\n    /**\n  \
    \   * @brief SMBUS field\n     *\n     * SMBus mode\n     */\n    using smbus\
    \ = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief PE field\n  \
    \   *\n     * Peripheral enable\n     */\n    using pe = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief SWRST field\n       *\n\
    \       * Software reset\n       */\n      BitFieldModel<uint32_t, 15, 1> swrst;\n\
    \      /**\n       * @brief ALERT field\n       *\n       * SMBus alert\n    \
    \   */\n      BitFieldModel<uint32_t, 13, 1> alert;\n      /**\n       * @brief\
    \ PEC field\n       *\n       * Packet error checking\n       */\n      BitFieldModel<uint32_t,\
    \ 12, 1> pec;\n      /**\n       * @brief POS field\n       *\n       * Acknowledge/PEC\
    \ Position (for data\n       *               reception)\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> pos;\n      /**\n       * @brief ACK field\n       *\n       * Acknowledge\
    \ enable\n       */\n      BitFieldModel<uint32_t, 10, 1> ack;\n      /**\n  \
    \     * @brief STOP field\n       *\n       * Stop generation\n       */\n   \
    \   BitFieldModel<uint32_t, 9, 1> stop;\n      /**\n       * @brief START field\n\
    \       *\n       * Start generation\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> start;\n      /**\n       * @brief NOSTRETCH field\n       *\n       *\
    \ Clock stretching disable (Slave\n       *               mode)\n       */\n \
    \     BitFieldModel<uint32_t, 7, 1> nostretch;\n      /**\n       * @brief ENGC\
    \ field\n       *\n       * General call enable\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> engc;\n      /**\n       * @brief ENPEC field\n       *\n       * PEC\
    \ enable\n       */\n      BitFieldModel<uint32_t, 5, 1> enpec;\n      /**\n \
    \      * @brief ENARP field\n       *\n       * ARP enable\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> enarp;\n      /**\n       * @brief SMBTYPE field\n       *\n       * SMBus\
    \ type\n       */\n      BitFieldModel<uint32_t, 3, 1> smbtype;\n      /**\n \
    \      * @brief SMBUS field\n       *\n       * SMBus mode\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> smbus;\n      /**\n       * @brief PE field\n       *\n       * Peripheral\
    \ enable\n       */\n      BitFieldModel<uint32_t, 0, 1> pe;\n    };\n  };\n\n\
    public:\n  /**\n   * @brief CR1 register\n   *\n   * Control register 1\n   */\n\
    \  using cr1 = Cr1Reg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Cr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief LAST field\n     *\n     * DMA last transfer\n\
    \     */\n    using last = FieldModel<uint32_t, address, 12, 1>;\n    /**\n  \
    \   * @brief DMAEN field\n     *\n     * DMA requests enable\n     */\n    using\
    \ dmaen = FieldModel<uint32_t, address, 11, 1>;\n    /**\n     * @brief ITBUFEN\
    \ field\n     *\n     * Buffer interrupt enable\n     */\n    using itbufen =\
    \ FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief ITEVTEN field\n\
    \     *\n     * Event interrupt enable\n     */\n    using itevten = FieldModel<uint32_t,\
    \ address, 9, 1>;\n    /**\n     * @brief ITERREN field\n     *\n     * Error\
    \ interrupt enable\n     */\n    using iterren = FieldModel<uint32_t, address,\
    \ 8, 1>;\n    /**\n     * @brief FREQ field\n     *\n     * Peripheral clock frequency\n\
    \     */\n    using freq = FieldModel<uint32_t, address, 0, 6>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief LAST field\n       *\n       * DMA last transfer\n       */\n\
    \      BitFieldModel<uint32_t, 12, 1> last;\n      /**\n       * @brief DMAEN\
    \ field\n       *\n       * DMA requests enable\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> dmaen;\n      /**\n       * @brief ITBUFEN field\n       *\n       *\
    \ Buffer interrupt enable\n       */\n      BitFieldModel<uint32_t, 10, 1> itbufen;\n\
    \      /**\n       * @brief ITEVTEN field\n       *\n       * Event interrupt\
    \ enable\n       */\n      BitFieldModel<uint32_t, 9, 1> itevten;\n      /**\n\
    \       * @brief ITERREN field\n       *\n       * Error interrupt enable\n  \
    \     */\n      BitFieldModel<uint32_t, 8, 1> iterren;\n      /**\n       * @brief\
    \ FREQ field\n       *\n       * Peripheral clock frequency\n       */\n     \
    \ BitFieldModel<uint32_t, 0, 6> freq;\n    };\n  };\n\npublic:\n  /**\n   * @brief\
    \ CR2 register\n   *\n   * Control register 2\n   */\n  using cr2 = Cr2Reg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class Oar1Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ ADDMODE field\n     *\n     * Addressing mode (slave\n     *               mode)\n\
    \     */\n    using addmode = FieldModel<uint32_t, address, 15, 1>;\n    /**\n\
    \     * @brief ADD10 field\n     *\n     * Interface address\n     */\n    using\
    \ add10 = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief ADD7 field\n\
    \     *\n     * Interface address\n     */\n    using add7 = FieldModel<uint32_t,\
    \ address, 1, 7>;\n    /**\n     * @brief ADD0 field\n     *\n     * Interface\
    \ address\n     */\n    using add0 = FieldModel<uint32_t, address, 0, 1>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief ADDMODE field\n       *\n       * Addressing\
    \ mode (slave\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 15, 1> addmode;\n      /**\n       * @brief ADD10 field\n       *\n       *\
    \ Interface address\n       */\n      BitFieldModel<uint32_t, 8, 2> add10;\n \
    \     /**\n       * @brief ADD7 field\n       *\n       * Interface address\n\
    \       */\n      BitFieldModel<uint32_t, 1, 7> add7;\n      /**\n       * @brief\
    \ ADD0 field\n       *\n       * Interface address\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> add0;\n    };\n  };\n\npublic:\n  /**\n   * @brief OAR1 register\n   *\n\
    \   * Own address register 1\n   */\n  using oar1 = Oar1Reg<BaseAddress + 0x0008>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Oar2Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief ADD2 field\n     *\n     *\
    \ Interface address\n     */\n    using add2 = FieldModel<uint32_t, address, 1,\
    \ 7>;\n    /**\n     * @brief ENDUAL field\n     *\n     * Dual addressing mode\n\
    \     *               enable\n     */\n    using endual = FieldModel<uint32_t,\
    \ address, 0, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief ADD2 field\n       *\n\
    \       * Interface address\n       */\n      BitFieldModel<uint32_t, 1, 7> add2;\n\
    \      /**\n       * @brief ENDUAL field\n       *\n       * Dual addressing mode\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 0, 1>\
    \ endual;\n    };\n  };\n\npublic:\n  /**\n   * @brief OAR2 register\n   *\n \
    \  * Own address register 2\n   */\n  using oar2 = Oar2Reg<BaseAddress + 0x000C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class DrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief DR field\n     *\n     * 8-bit\
    \ data register\n     */\n    using dr = FieldModel<uint32_t, address, 0, 8>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief DR field\n       *\n       * 8-bit data register\n\
    \       */\n      BitFieldModel<uint32_t, 0, 8> dr;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief DR register\n   *\n   * Data register\n   */\n  using dr =\
    \ DrReg<BaseAddress + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class Sr1Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief SMBALERT field\n     *\n     * SMBus alert\n     */\n  \
    \  using smbalert = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     * @brief\
    \ TIMEOUT field\n     *\n     * Timeout or Tlow error\n     */\n    using timeout\
    \ = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief PECERR field\n\
    \     *\n     * PEC Error in reception\n     */\n    using pecerr = FieldModel<uint32_t,\
    \ address, 12, 1>;\n    /**\n     * @brief OVR field\n     *\n     * Overrun/Underrun\n\
    \     */\n    using ovr = FieldModel<uint32_t, address, 11, 1>;\n    /**\n   \
    \  * @brief AF field\n     *\n     * Acknowledge failure\n     */\n    using af\
    \ = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     * @brief ARLO field\n\
    \     *\n     * Arbitration lost (master\n     *               mode)\n     */\n\
    \    using arlo = FieldModel<uint32_t, address, 9, 1>;\n    /**\n     * @brief\
    \ BERR field\n     *\n     * Bus error\n     */\n    using berr = FieldModel<uint32_t,\
    \ address, 8, 1>;\n    /**\n     * @brief TXE field\n     *\n     * Data register\
    \ empty\n     *               (transmitters)\n     */\n    using txe = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief RXNE field\n     *\n     * Data register\
    \ not empty\n     *               (receivers)\n     */\n    using rxne = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief STOPF field\n     *\n     * Stop detection\
    \ (slave\n     *               mode)\n     */\n    using stopf = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief ADD10 field\n     *\n     * 10-bit header\
    \ sent (Master\n     *               mode)\n     */\n    using add10 = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief BTF field\n     *\n     * Byte transfer\
    \ finished\n     */\n    using btf = FieldModel<uint32_t, address, 2, 1>;\n  \
    \  /**\n     * @brief ADDR field\n     *\n     * Address sent (master mode)/matched\n\
    \     *               (slave mode)\n     */\n    using addr = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief SB field\n     *\n     * Start bit (Master\
    \ mode)\n     */\n    using sb = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief SMBALERT field\n       *\n       * SMBus alert\n       */\n \
    \     BitFieldModel<uint32_t, 15, 1> smbalert;\n      /**\n       * @brief TIMEOUT\
    \ field\n       *\n       * Timeout or Tlow error\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> timeout;\n      /**\n       * @brief PECERR field\n       *\n       *\
    \ PEC Error in reception\n       */\n      BitFieldModel<uint32_t, 12, 1> pecerr;\n\
    \      /**\n       * @brief OVR field\n       *\n       * Overrun/Underrun\n \
    \      */\n      BitFieldModel<uint32_t, 11, 1> ovr;\n      /**\n       * @brief\
    \ AF field\n       *\n       * Acknowledge failure\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> af;\n      /**\n       * @brief ARLO field\n       *\n       * Arbitration\
    \ lost (master\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> arlo;\n      /**\n       * @brief BERR field\n       *\n       * Bus error\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> berr;\n      /**\n       * @brief\
    \ TXE field\n       *\n       * Data register empty\n       *               (transmitters)\n\
    \       */\n      BitFieldModel<uint32_t, 7, 1> txe;\n      /**\n       * @brief\
    \ RXNE field\n       *\n       * Data register not empty\n       *           \
    \    (receivers)\n       */\n      BitFieldModel<uint32_t, 6, 1> rxne;\n     \
    \ /**\n       * @brief STOPF field\n       *\n       * Stop detection (slave\n\
    \       *               mode)\n       */\n      BitFieldModel<uint32_t, 4, 1>\
    \ stopf;\n      /**\n       * @brief ADD10 field\n       *\n       * 10-bit header\
    \ sent (Master\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> add10;\n      /**\n       * @brief BTF field\n       *\n       * Byte\
    \ transfer finished\n       */\n      BitFieldModel<uint32_t, 2, 1> btf;\n   \
    \   /**\n       * @brief ADDR field\n       *\n       * Address sent (master mode)/matched\n\
    \       *               (slave mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> addr;\n      /**\n       * @brief SB field\n       *\n       * Start bit\
    \ (Master mode)\n       */\n      BitFieldModel<uint32_t, 0, 1> sb;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief SR1 register\n   *\n   * Status register\
    \ 1\n   */\n  using sr1 = Sr1Reg<BaseAddress + 0x0014>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Sr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief PEC field\n     *\n     * acket error checking\n\
    \     *               register\n     */\n    using pec = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    /**\n     * @brief DUALF field\n     *\n     * Dual flag\
    \ (Slave mode)\n     */\n    using dualf = FieldModel<uint32_t, address, 7, 1>;\n\
    \    /**\n     * @brief SMBHOST field\n     *\n     * SMBus host header (Slave\n\
    \     *               mode)\n     */\n    using smbhost = FieldModel<uint32_t,\
    \ address, 6, 1>;\n    /**\n     * @brief SMBDEFAULT field\n     *\n     * SMBus\
    \ device default address (Slave\n     *               mode)\n     */\n    using\
    \ smbdefault = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief GENCALL\
    \ field\n     *\n     * General call address (Slave\n     *               mode)\n\
    \     */\n    using gencall = FieldModel<uint32_t, address, 4, 1>;\n    /**\n\
    \     * @brief TRA field\n     *\n     * Transmitter/receiver\n     */\n    using\
    \ tra = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief BUSY field\n\
    \     *\n     * Bus busy\n     */\n    using busy = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    /**\n     * @brief MSL field\n     *\n     * Master/slave\n    \
    \ */\n    using msl = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ PEC field\n       *\n       * acket error checking\n       *               register\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> pec;\n      /**\n       * @brief\
    \ DUALF field\n       *\n       * Dual flag (Slave mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> dualf;\n      /**\n       * @brief SMBHOST field\n       *\n       * SMBus\
    \ host header (Slave\n       *               mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> smbhost;\n      /**\n       * @brief SMBDEFAULT field\n       *\n    \
    \   * SMBus device default address (Slave\n       *               mode)\n    \
    \   */\n      BitFieldModel<uint32_t, 5, 1> smbdefault;\n      /**\n       * @brief\
    \ GENCALL field\n       *\n       * General call address (Slave\n       *    \
    \           mode)\n       */\n      BitFieldModel<uint32_t, 4, 1> gencall;\n \
    \     /**\n       * @brief TRA field\n       *\n       * Transmitter/receiver\n\
    \       */\n      BitFieldModel<uint32_t, 2, 1> tra;\n      /**\n       * @brief\
    \ BUSY field\n       *\n       * Bus busy\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> busy;\n      /**\n       * @brief MSL field\n       *\n       * Master/slave\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> msl;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief SR2 register\n   *\n   * Status register 2\n   */\n  using\
    \ sr2 = Sr2Reg<BaseAddress + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class CcrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n  \
    \  /**\n     * @brief F_S field\n     *\n     * I2C master mode selection\n  \
    \   */\n    using f_s = FieldModel<uint32_t, address, 15, 1>;\n    /**\n     *\
    \ @brief DUTY field\n     *\n     * Fast mode duty cycle\n     */\n    using duty\
    \ = FieldModel<uint32_t, address, 14, 1>;\n    /**\n     * @brief CCR field\n\
    \     *\n     * Clock control register in Fast/Standard\n     *              \
    \ mode (Master mode)\n     */\n    using ccr = FieldModel<uint32_t, address, 0,\
    \ 12>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief F_S field\n       *\n     \
    \  * I2C master mode selection\n       */\n      BitFieldModel<uint32_t, 15, 1>\
    \ f_s;\n      /**\n       * @brief DUTY field\n       *\n       * Fast mode duty\
    \ cycle\n       */\n      BitFieldModel<uint32_t, 14, 1> duty;\n      /**\n  \
    \     * @brief CCR field\n       *\n       * Clock control register in Fast/Standard\n\
    \       *               mode (Master mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 12> ccr;\n    };\n  };\n\npublic:\n  /**\n   * @brief CCR register\n   *\n\
    \   * Clock control register\n   */\n  using ccr = CcrReg<BaseAddress + 0x001C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class TriseReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief TRISE field\n     *\n     *\
    \ Maximum rise time in Fast/Standard mode\n     *               (Master mode)\n\
    \     */\n    using trise = FieldModel<uint32_t, address, 0, 6>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief TRISE field\n       *\n       * Maximum rise time in Fast/Standard\
    \ mode\n       *               (Master mode)\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 6> trise;\n    };\n  };\n\npublic:\n  /**\n   * @brief TRISE register\n \
    \  *\n   * TRISE register\n   */\n  using trise = TriseReg<BaseAddress + 0x0020>;\n\
    \n};\n\n}\n\n#endif /* DRAL_STM32F411_I2C1_H */"
  name: I2C1
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_I2S2EXT_H\n#define DRAL_STM32F411_I2S2EXT_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ I2S2EXT peripheral\n *\n * Serial peripheral interface\n */\nclass i2s2ext\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40003400; /**< Peripheral\
    \ base address */\n\nprivate:\n  template<unsigned int address>\n  class Cr1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ BIDIMODE field\n     *\n     * Bidirectional data mode\n     *             \
    \  enable\n     */\n    using bidimode = FieldModel<uint32_t, address, 15, 1>;\n\
    \    /**\n     * @brief BIDIOE field\n     *\n     * Output enable in bidirectional\n\
    \     *               mode\n     */\n    using bidioe = FieldModel<uint32_t, address,\
    \ 14, 1>;\n    /**\n     * @brief CRCEN field\n     *\n     * Hardware CRC calculation\n\
    \     *               enable\n     */\n    using crcen = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief CRCNEXT field\n     *\n     * CRC transfer\
    \ next\n     */\n    using crcnext = FieldModel<uint32_t, address, 12, 1>;\n \
    \   /**\n     * @brief DFF field\n     *\n     * Data frame format\n     */\n\
    \    using dff = FieldModel<uint32_t, address, 11, 1>;\n    /**\n     * @brief\
    \ RXONLY field\n     *\n     * Receive only\n     */\n    using rxonly = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief SSM field\n     *\n     * Software\
    \ slave management\n     */\n    using ssm = FieldModel<uint32_t, address, 9,\
    \ 1>;\n    /**\n     * @brief SSI field\n     *\n     * Internal slave select\n\
    \     */\n    using ssi = FieldModel<uint32_t, address, 8, 1>;\n    /**\n    \
    \ * @brief LSBFIRST field\n     *\n     * Frame format\n     */\n    using lsbfirst\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief SPE field\n \
    \    *\n     * SPI enable\n     */\n    using spe = FieldModel<uint32_t, address,\
    \ 6, 1>;\n    /**\n     * @brief BR field\n     *\n     * Baud rate control\n\
    \     */\n    using br = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     *\
    \ @brief MSTR field\n     *\n     * Master selection\n     */\n    using mstr\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief CPOL field\n\
    \     *\n     * Clock polarity\n     */\n    using cpol = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief CPHA field\n     *\n     * Clock phase\n\
    \     */\n    using cpha = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BIDIMODE field\n       *\n       * Bidirectional data mode\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 15, 1>\
    \ bidimode;\n      /**\n       * @brief BIDIOE field\n       *\n       * Output\
    \ enable in bidirectional\n       *               mode\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> bidioe;\n      /**\n       * @brief CRCEN field\n       *\n       * Hardware\
    \ CRC calculation\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> crcen;\n      /**\n       * @brief CRCNEXT field\n       *\n       *\
    \ CRC transfer next\n       */\n      BitFieldModel<uint32_t, 12, 1> crcnext;\n\
    \      /**\n       * @brief DFF field\n       *\n       * Data frame format\n\
    \       */\n      BitFieldModel<uint32_t, 11, 1> dff;\n      /**\n       * @brief\
    \ RXONLY field\n       *\n       * Receive only\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> rxonly;\n      /**\n       * @brief SSM field\n       *\n       * Software\
    \ slave management\n       */\n      BitFieldModel<uint32_t, 9, 1> ssm;\n    \
    \  /**\n       * @brief SSI field\n       *\n       * Internal slave select\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> ssi;\n      /**\n       * @brief\
    \ LSBFIRST field\n       *\n       * Frame format\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> lsbfirst;\n      /**\n       * @brief SPE field\n       *\n       * SPI\
    \ enable\n       */\n      BitFieldModel<uint32_t, 6, 1> spe;\n      /**\n   \
    \    * @brief BR field\n       *\n       * Baud rate control\n       */\n    \
    \  BitFieldModel<uint32_t, 3, 3> br;\n      /**\n       * @brief MSTR field\n\
    \       *\n       * Master selection\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> mstr;\n      /**\n       * @brief CPOL field\n       *\n       * Clock\
    \ polarity\n       */\n      BitFieldModel<uint32_t, 1, 1> cpol;\n      /**\n\
    \       * @brief CPHA field\n       *\n       * Clock phase\n       */\n     \
    \ BitFieldModel<uint32_t, 0, 1> cpha;\n    };\n  };\n\npublic:\n  /**\n   * @brief\
    \ CR1 register\n   *\n   * control register 1\n   */\n  using cr1 = Cr1Reg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class Cr2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief TXEIE\
    \ field\n     *\n     * Tx buffer empty interrupt\n     *               enable\n\
    \     */\n    using txeie = FieldModel<uint32_t, address, 7, 1>;\n    /**\n  \
    \   * @brief RXNEIE field\n     *\n     * RX buffer not empty interrupt\n    \
    \ *               enable\n     */\n    using rxneie = FieldModel<uint32_t, address,\
    \ 6, 1>;\n    /**\n     * @brief ERRIE field\n     *\n     * Error interrupt enable\n\
    \     */\n    using errie = FieldModel<uint32_t, address, 5, 1>;\n    /**\n  \
    \   * @brief FRF field\n     *\n     * Frame format\n     */\n    using frf =\
    \ FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief SSOE field\n  \
    \   *\n     * SS output enable\n     */\n    using ssoe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief TXDMAEN field\n     *\n     * Tx buffer\
    \ DMA enable\n     */\n    using txdmaen = FieldModel<uint32_t, address, 1, 1>;\n\
    \    /**\n     * @brief RXDMAEN field\n     *\n     * Rx buffer DMA enable\n \
    \    */\n    using rxdmaen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief TXEIE field\n       *\n       * Tx buffer empty interrupt\n \
    \      *               enable\n       */\n      BitFieldModel<uint32_t, 7, 1>\
    \ txeie;\n      /**\n       * @brief RXNEIE field\n       *\n       * RX buffer\
    \ not empty interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> rxneie;\n      /**\n       * @brief ERRIE field\n       *\n       * Error\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 5, 1> errie;\n  \
    \    /**\n       * @brief FRF field\n       *\n       * Frame format\n       */\n\
    \      BitFieldModel<uint32_t, 4, 1> frf;\n      /**\n       * @brief SSOE field\n\
    \       *\n       * SS output enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> ssoe;\n      /**\n       * @brief TXDMAEN field\n       *\n       * Tx\
    \ buffer DMA enable\n       */\n      BitFieldModel<uint32_t, 1, 1> txdmaen;\n\
    \      /**\n       * @brief RXDMAEN field\n       *\n       * Rx buffer DMA enable\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> rxdmaen;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR2 register\n   *\n   * control register 2\n   */\n  using\
    \ cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class SrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ /**\n     * @brief TIFRFE field\n     *\n     * TI frame format error\n    \
    \ */\n    using tifrfe = FieldModel<uint32_t, address, 8, 1>;\n    /**\n     *\
    \ @brief BSY field\n     *\n     * Busy flag\n     */\n    using bsy = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief OVR field\n     *\n     * Overrun flag\n\
    \     */\n    using ovr = FieldModel<uint32_t, address, 6, 1>;\n    /**\n    \
    \ * @brief MODF field\n     *\n     * Mode fault\n     */\n    using modf = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief CRCERR field\n     *\n     * CRC error\
    \ flag\n     */\n    using crcerr = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ /**\n     * @brief UDR field\n     *\n     * Underrun flag\n     */\n    using\
    \ udr = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief CHSIDE field\n\
    \     *\n     * Channel side\n     */\n    using chside = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief TXE field\n     *\n     * Transmit buffer\
    \ empty\n     */\n    using txe = FieldModel<uint32_t, address, 1, 1>;\n    /**\n\
    \     * @brief RXNE field\n     *\n     * Receive buffer not empty\n     */\n\
    \    using rxne = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ TIFRFE field\n       *\n       * TI frame format error\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> tifrfe;\n      /**\n       * @brief BSY field\n       *\n       * Busy\
    \ flag\n       */\n      BitFieldModel<uint32_t, 7, 1> bsy;\n      /**\n     \
    \  * @brief OVR field\n       *\n       * Overrun flag\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> ovr;\n      /**\n       * @brief MODF field\n       *\n       * Mode fault\n\
    \       */\n      BitFieldModel<uint32_t, 5, 1> modf;\n      /**\n       * @brief\
    \ CRCERR field\n       *\n       * CRC error flag\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> crcerr;\n      /**\n       * @brief UDR field\n       *\n       * Underrun\
    \ flag\n       */\n      BitFieldModel<uint32_t, 3, 1> udr;\n      /**\n     \
    \  * @brief CHSIDE field\n       *\n       * Channel side\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> chside;\n      /**\n       * @brief TXE field\n       *\n       * Transmit\
    \ buffer empty\n       */\n      BitFieldModel<uint32_t, 1, 1> txe;\n      /**\n\
    \       * @brief RXNE field\n       *\n       * Receive buffer not empty\n   \
    \    */\n      BitFieldModel<uint32_t, 0, 1> rxne;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief SR register\n   *\n   * status register\n   */\n  using sr\
    \ = SrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class DrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ /**\n     * @brief DR field\n     *\n     * Data register\n     */\n    using\
    \ dr = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ DR field\n       *\n       * Data register\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> dr;\n    };\n  };\n\npublic:\n  /**\n   * @brief DR register\n   *\n\
    \   * data register\n   */\n  using dr = DrReg<BaseAddress + 0x000C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class CrcprReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CRCPOLY field\n     *\n   \
    \  * CRC polynomial register\n     */\n    using crcpoly = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CRCPOLY field\n       *\n\
    \       * CRC polynomial register\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 16> crcpoly;\n    };\n  };\n\npublic:\n  /**\n   * @brief CRCPR register\n \
    \  *\n   * CRC polynomial register\n   */\n  using crcpr = CrcprReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class RxcrcrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ RXCRC field\n     *\n     * Rx CRC register\n     */\n    using rxcrc = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief RXCRC field\n       *\n\
    \       * Rx CRC register\n       */\n      BitFieldModel<uint32_t, 0, 16> rxcrc;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief RXCRCR register\n   *\n   * RX CRC\
    \ register\n   */\n  using rxcrcr = RxcrcrReg<BaseAddress + 0x0014>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class TxcrcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief TXCRC field\n     *\n     *\
    \ Tx CRC register\n     */\n    using txcrc = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief TXCRC field\n       *\n   \
    \    * Tx CRC register\n       */\n      BitFieldModel<uint32_t, 0, 16> txcrc;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief TXCRCR register\n   *\n   * TX CRC\
    \ register\n   */\n  using txcrcr = TxcrcrReg<BaseAddress + 0x0018>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class I2scfgrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief I2SMOD field\n     *\n    \
    \ * I2S mode selection\n     */\n    using i2smod = FieldModel<uint32_t, address,\
    \ 11, 1>;\n    /**\n     * @brief I2SE field\n     *\n     * I2S Enable\n    \
    \ */\n    using i2se = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     *\
    \ @brief I2SCFG field\n     *\n     * I2S configuration mode\n     */\n    using\
    \ i2scfg = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief PCMSYNC\
    \ field\n     *\n     * PCM frame synchronization\n     */\n    using pcmsync\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief I2SSTD field\n\
    \     *\n     * I2S standard selection\n     */\n    using i2sstd = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    /**\n     * @brief CKPOL field\n     *\n     * Steady state\
    \ clock\n     *               polarity\n     */\n    using ckpol = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief DATLEN field\n     *\n     * Data length\
    \ to be\n     *               transferred\n     */\n    using datlen = FieldModel<uint32_t,\
    \ address, 1, 2>;\n    /**\n     * @brief CHLEN field\n     *\n     * Channel\
    \ length (number of bits per audio\n     *               channel)\n     */\n \
    \   using chlen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ I2SMOD field\n       *\n       * I2S mode selection\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> i2smod;\n      /**\n       * @brief I2SE field\n       *\n       * I2S\
    \ Enable\n       */\n      BitFieldModel<uint32_t, 10, 1> i2se;\n      /**\n \
    \      * @brief I2SCFG field\n       *\n       * I2S configuration mode\n    \
    \   */\n      BitFieldModel<uint32_t, 8, 2> i2scfg;\n      /**\n       * @brief\
    \ PCMSYNC field\n       *\n       * PCM frame synchronization\n       */\n   \
    \   BitFieldModel<uint32_t, 7, 1> pcmsync;\n      /**\n       * @brief I2SSTD\
    \ field\n       *\n       * I2S standard selection\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 2> i2sstd;\n      /**\n       * @brief CKPOL field\n       *\n       * Steady\
    \ state clock\n       *               polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> ckpol;\n      /**\n       * @brief DATLEN field\n       *\n       * Data\
    \ length to be\n       *               transferred\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 2> datlen;\n      /**\n       * @brief CHLEN field\n       *\n       * Channel\
    \ length (number of bits per audio\n       *               channel)\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> chlen;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief I2SCFGR register\n   *\n   * I2S configuration register\n   */\n\
    \  using i2scfgr = I2scfgrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class I2sprReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief MCKOE field\n     *\n     * Master clock\
    \ output enable\n     */\n    using mckoe = FieldModel<uint32_t, address, 9, 1>;\n\
    \    /**\n     * @brief ODD field\n     *\n     * Odd factor for the\n     * \
    \              prescaler\n     */\n    using odd = FieldModel<uint32_t, address,\
    \ 8, 1>;\n    /**\n     * @brief I2SDIV field\n     *\n     * I2S Linear prescaler\n\
    \     */\n    using i2sdiv = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief MCKOE field\n       *\n       * Master clock output enable\n\
    \       */\n      BitFieldModel<uint32_t, 9, 1> mckoe;\n      /**\n       * @brief\
    \ ODD field\n       *\n       * Odd factor for the\n       *               prescaler\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> odd;\n      /**\n       * @brief\
    \ I2SDIV field\n       *\n       * I2S Linear prescaler\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> i2sdiv;\n    };\n  };\n\npublic:\n  /**\n   * @brief I2SPR register\n\
    \   *\n   * I2S prescaler register\n   */\n  using i2spr = I2sprReg<BaseAddress\
    \ + 0x0020>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_I2S2EXT_H */"
  name: I2S2ext
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_I2S3EXT_H\n#define DRAL_STM32F411_I2S3EXT_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ I2S3EXT peripheral\n *\n * Serial peripheral interface\n */\nclass i2s3ext\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0x40004000; /**< Peripheral\
    \ base address */\n\nprivate:\n  template<unsigned int address>\n  class Cr1Reg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ BIDIMODE field\n     *\n     * Bidirectional data mode\n     *             \
    \  enable\n     */\n    using bidimode = FieldModel<uint32_t, address, 15, 1>;\n\
    \    /**\n     * @brief BIDIOE field\n     *\n     * Output enable in bidirectional\n\
    \     *               mode\n     */\n    using bidioe = FieldModel<uint32_t, address,\
    \ 14, 1>;\n    /**\n     * @brief CRCEN field\n     *\n     * Hardware CRC calculation\n\
    \     *               enable\n     */\n    using crcen = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief CRCNEXT field\n     *\n     * CRC transfer\
    \ next\n     */\n    using crcnext = FieldModel<uint32_t, address, 12, 1>;\n \
    \   /**\n     * @brief DFF field\n     *\n     * Data frame format\n     */\n\
    \    using dff = FieldModel<uint32_t, address, 11, 1>;\n    /**\n     * @brief\
    \ RXONLY field\n     *\n     * Receive only\n     */\n    using rxonly = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief SSM field\n     *\n     * Software\
    \ slave management\n     */\n    using ssm = FieldModel<uint32_t, address, 9,\
    \ 1>;\n    /**\n     * @brief SSI field\n     *\n     * Internal slave select\n\
    \     */\n    using ssi = FieldModel<uint32_t, address, 8, 1>;\n    /**\n    \
    \ * @brief LSBFIRST field\n     *\n     * Frame format\n     */\n    using lsbfirst\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief SPE field\n \
    \    *\n     * SPI enable\n     */\n    using spe = FieldModel<uint32_t, address,\
    \ 6, 1>;\n    /**\n     * @brief BR field\n     *\n     * Baud rate control\n\
    \     */\n    using br = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     *\
    \ @brief MSTR field\n     *\n     * Master selection\n     */\n    using mstr\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief CPOL field\n\
    \     *\n     * Clock polarity\n     */\n    using cpol = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief CPHA field\n     *\n     * Clock phase\n\
    \     */\n    using cpha = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BIDIMODE field\n       *\n       * Bidirectional data mode\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 15, 1>\
    \ bidimode;\n      /**\n       * @brief BIDIOE field\n       *\n       * Output\
    \ enable in bidirectional\n       *               mode\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> bidioe;\n      /**\n       * @brief CRCEN field\n       *\n       * Hardware\
    \ CRC calculation\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> crcen;\n      /**\n       * @brief CRCNEXT field\n       *\n       *\
    \ CRC transfer next\n       */\n      BitFieldModel<uint32_t, 12, 1> crcnext;\n\
    \      /**\n       * @brief DFF field\n       *\n       * Data frame format\n\
    \       */\n      BitFieldModel<uint32_t, 11, 1> dff;\n      /**\n       * @brief\
    \ RXONLY field\n       *\n       * Receive only\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> rxonly;\n      /**\n       * @brief SSM field\n       *\n       * Software\
    \ slave management\n       */\n      BitFieldModel<uint32_t, 9, 1> ssm;\n    \
    \  /**\n       * @brief SSI field\n       *\n       * Internal slave select\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> ssi;\n      /**\n       * @brief\
    \ LSBFIRST field\n       *\n       * Frame format\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> lsbfirst;\n      /**\n       * @brief SPE field\n       *\n       * SPI\
    \ enable\n       */\n      BitFieldModel<uint32_t, 6, 1> spe;\n      /**\n   \
    \    * @brief BR field\n       *\n       * Baud rate control\n       */\n    \
    \  BitFieldModel<uint32_t, 3, 3> br;\n      /**\n       * @brief MSTR field\n\
    \       *\n       * Master selection\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> mstr;\n      /**\n       * @brief CPOL field\n       *\n       * Clock\
    \ polarity\n       */\n      BitFieldModel<uint32_t, 1, 1> cpol;\n      /**\n\
    \       * @brief CPHA field\n       *\n       * Clock phase\n       */\n     \
    \ BitFieldModel<uint32_t, 0, 1> cpha;\n    };\n  };\n\npublic:\n  /**\n   * @brief\
    \ CR1 register\n   *\n   * control register 1\n   */\n  using cr1 = Cr1Reg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class Cr2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief TXEIE\
    \ field\n     *\n     * Tx buffer empty interrupt\n     *               enable\n\
    \     */\n    using txeie = FieldModel<uint32_t, address, 7, 1>;\n    /**\n  \
    \   * @brief RXNEIE field\n     *\n     * RX buffer not empty interrupt\n    \
    \ *               enable\n     */\n    using rxneie = FieldModel<uint32_t, address,\
    \ 6, 1>;\n    /**\n     * @brief ERRIE field\n     *\n     * Error interrupt enable\n\
    \     */\n    using errie = FieldModel<uint32_t, address, 5, 1>;\n    /**\n  \
    \   * @brief FRF field\n     *\n     * Frame format\n     */\n    using frf =\
    \ FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief SSOE field\n  \
    \   *\n     * SS output enable\n     */\n    using ssoe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief TXDMAEN field\n     *\n     * Tx buffer\
    \ DMA enable\n     */\n    using txdmaen = FieldModel<uint32_t, address, 1, 1>;\n\
    \    /**\n     * @brief RXDMAEN field\n     *\n     * Rx buffer DMA enable\n \
    \    */\n    using rxdmaen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief TXEIE field\n       *\n       * Tx buffer empty interrupt\n \
    \      *               enable\n       */\n      BitFieldModel<uint32_t, 7, 1>\
    \ txeie;\n      /**\n       * @brief RXNEIE field\n       *\n       * RX buffer\
    \ not empty interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> rxneie;\n      /**\n       * @brief ERRIE field\n       *\n       * Error\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 5, 1> errie;\n  \
    \    /**\n       * @brief FRF field\n       *\n       * Frame format\n       */\n\
    \      BitFieldModel<uint32_t, 4, 1> frf;\n      /**\n       * @brief SSOE field\n\
    \       *\n       * SS output enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> ssoe;\n      /**\n       * @brief TXDMAEN field\n       *\n       * Tx\
    \ buffer DMA enable\n       */\n      BitFieldModel<uint32_t, 1, 1> txdmaen;\n\
    \      /**\n       * @brief RXDMAEN field\n       *\n       * Rx buffer DMA enable\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> rxdmaen;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR2 register\n   *\n   * control register 2\n   */\n  using\
    \ cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class SrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ /**\n     * @brief TIFRFE field\n     *\n     * TI frame format error\n    \
    \ */\n    using tifrfe = FieldModel<uint32_t, address, 8, 1>;\n    /**\n     *\
    \ @brief BSY field\n     *\n     * Busy flag\n     */\n    using bsy = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief OVR field\n     *\n     * Overrun flag\n\
    \     */\n    using ovr = FieldModel<uint32_t, address, 6, 1>;\n    /**\n    \
    \ * @brief MODF field\n     *\n     * Mode fault\n     */\n    using modf = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief CRCERR field\n     *\n     * CRC error\
    \ flag\n     */\n    using crcerr = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ /**\n     * @brief UDR field\n     *\n     * Underrun flag\n     */\n    using\
    \ udr = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief CHSIDE field\n\
    \     *\n     * Channel side\n     */\n    using chside = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief TXE field\n     *\n     * Transmit buffer\
    \ empty\n     */\n    using txe = FieldModel<uint32_t, address, 1, 1>;\n    /**\n\
    \     * @brief RXNE field\n     *\n     * Receive buffer not empty\n     */\n\
    \    using rxne = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ TIFRFE field\n       *\n       * TI frame format error\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> tifrfe;\n      /**\n       * @brief BSY field\n       *\n       * Busy\
    \ flag\n       */\n      BitFieldModel<uint32_t, 7, 1> bsy;\n      /**\n     \
    \  * @brief OVR field\n       *\n       * Overrun flag\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> ovr;\n      /**\n       * @brief MODF field\n       *\n       * Mode fault\n\
    \       */\n      BitFieldModel<uint32_t, 5, 1> modf;\n      /**\n       * @brief\
    \ CRCERR field\n       *\n       * CRC error flag\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> crcerr;\n      /**\n       * @brief UDR field\n       *\n       * Underrun\
    \ flag\n       */\n      BitFieldModel<uint32_t, 3, 1> udr;\n      /**\n     \
    \  * @brief CHSIDE field\n       *\n       * Channel side\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> chside;\n      /**\n       * @brief TXE field\n       *\n       * Transmit\
    \ buffer empty\n       */\n      BitFieldModel<uint32_t, 1, 1> txe;\n      /**\n\
    \       * @brief RXNE field\n       *\n       * Receive buffer not empty\n   \
    \    */\n      BitFieldModel<uint32_t, 0, 1> rxne;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief SR register\n   *\n   * status register\n   */\n  using sr\
    \ = SrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class DrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ /**\n     * @brief DR field\n     *\n     * Data register\n     */\n    using\
    \ dr = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ DR field\n       *\n       * Data register\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> dr;\n    };\n  };\n\npublic:\n  /**\n   * @brief DR register\n   *\n\
    \   * data register\n   */\n  using dr = DrReg<BaseAddress + 0x000C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class CrcprReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CRCPOLY field\n     *\n   \
    \  * CRC polynomial register\n     */\n    using crcpoly = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CRCPOLY field\n       *\n\
    \       * CRC polynomial register\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 16> crcpoly;\n    };\n  };\n\npublic:\n  /**\n   * @brief CRCPR register\n \
    \  *\n   * CRC polynomial register\n   */\n  using crcpr = CrcprReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class RxcrcrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ RXCRC field\n     *\n     * Rx CRC register\n     */\n    using rxcrc = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief RXCRC field\n       *\n\
    \       * Rx CRC register\n       */\n      BitFieldModel<uint32_t, 0, 16> rxcrc;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief RXCRCR register\n   *\n   * RX CRC\
    \ register\n   */\n  using rxcrcr = RxcrcrReg<BaseAddress + 0x0014>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class TxcrcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief TXCRC field\n     *\n     *\
    \ Tx CRC register\n     */\n    using txcrc = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief TXCRC field\n       *\n   \
    \    * Tx CRC register\n       */\n      BitFieldModel<uint32_t, 0, 16> txcrc;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief TXCRCR register\n   *\n   * TX CRC\
    \ register\n   */\n  using txcrcr = TxcrcrReg<BaseAddress + 0x0018>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class I2scfgrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief I2SMOD field\n     *\n    \
    \ * I2S mode selection\n     */\n    using i2smod = FieldModel<uint32_t, address,\
    \ 11, 1>;\n    /**\n     * @brief I2SE field\n     *\n     * I2S Enable\n    \
    \ */\n    using i2se = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     *\
    \ @brief I2SCFG field\n     *\n     * I2S configuration mode\n     */\n    using\
    \ i2scfg = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief PCMSYNC\
    \ field\n     *\n     * PCM frame synchronization\n     */\n    using pcmsync\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief I2SSTD field\n\
    \     *\n     * I2S standard selection\n     */\n    using i2sstd = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    /**\n     * @brief CKPOL field\n     *\n     * Steady state\
    \ clock\n     *               polarity\n     */\n    using ckpol = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief DATLEN field\n     *\n     * Data length\
    \ to be\n     *               transferred\n     */\n    using datlen = FieldModel<uint32_t,\
    \ address, 1, 2>;\n    /**\n     * @brief CHLEN field\n     *\n     * Channel\
    \ length (number of bits per audio\n     *               channel)\n     */\n \
    \   using chlen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ I2SMOD field\n       *\n       * I2S mode selection\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> i2smod;\n      /**\n       * @brief I2SE field\n       *\n       * I2S\
    \ Enable\n       */\n      BitFieldModel<uint32_t, 10, 1> i2se;\n      /**\n \
    \      * @brief I2SCFG field\n       *\n       * I2S configuration mode\n    \
    \   */\n      BitFieldModel<uint32_t, 8, 2> i2scfg;\n      /**\n       * @brief\
    \ PCMSYNC field\n       *\n       * PCM frame synchronization\n       */\n   \
    \   BitFieldModel<uint32_t, 7, 1> pcmsync;\n      /**\n       * @brief I2SSTD\
    \ field\n       *\n       * I2S standard selection\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 2> i2sstd;\n      /**\n       * @brief CKPOL field\n       *\n       * Steady\
    \ state clock\n       *               polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> ckpol;\n      /**\n       * @brief DATLEN field\n       *\n       * Data\
    \ length to be\n       *               transferred\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 2> datlen;\n      /**\n       * @brief CHLEN field\n       *\n       * Channel\
    \ length (number of bits per audio\n       *               channel)\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> chlen;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief I2SCFGR register\n   *\n   * I2S configuration register\n   */\n\
    \  using i2scfgr = I2scfgrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class I2sprReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief MCKOE field\n     *\n     * Master clock\
    \ output enable\n     */\n    using mckoe = FieldModel<uint32_t, address, 9, 1>;\n\
    \    /**\n     * @brief ODD field\n     *\n     * Odd factor for the\n     * \
    \              prescaler\n     */\n    using odd = FieldModel<uint32_t, address,\
    \ 8, 1>;\n    /**\n     * @brief I2SDIV field\n     *\n     * I2S Linear prescaler\n\
    \     */\n    using i2sdiv = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief MCKOE field\n       *\n       * Master clock output enable\n\
    \       */\n      BitFieldModel<uint32_t, 9, 1> mckoe;\n      /**\n       * @brief\
    \ ODD field\n       *\n       * Odd factor for the\n       *               prescaler\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> odd;\n      /**\n       * @brief\
    \ I2SDIV field\n       *\n       * I2S Linear prescaler\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> i2sdiv;\n    };\n  };\n\npublic:\n  /**\n   * @brief I2SPR register\n\
    \   *\n   * I2S prescaler register\n   */\n  using i2spr = I2sprReg<BaseAddress\
    \ + 0x0020>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_I2S3EXT_H */"
  name: I2S3ext
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_SPI1_H\n#define DRAL_STM32F411_SPI1_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ SPI1 peripheral\n *\n * Serial peripheral interface\n */\nclass spi1\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40013000; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief BIDIMODE\
    \ field\n     *\n     * Bidirectional data mode\n     *               enable\n\
    \     */\n    using bidimode = FieldModel<uint32_t, address, 15, 1>;\n    /**\n\
    \     * @brief BIDIOE field\n     *\n     * Output enable in bidirectional\n \
    \    *               mode\n     */\n    using bidioe = FieldModel<uint32_t, address,\
    \ 14, 1>;\n    /**\n     * @brief CRCEN field\n     *\n     * Hardware CRC calculation\n\
    \     *               enable\n     */\n    using crcen = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief CRCNEXT field\n     *\n     * CRC transfer\
    \ next\n     */\n    using crcnext = FieldModel<uint32_t, address, 12, 1>;\n \
    \   /**\n     * @brief DFF field\n     *\n     * Data frame format\n     */\n\
    \    using dff = FieldModel<uint32_t, address, 11, 1>;\n    /**\n     * @brief\
    \ RXONLY field\n     *\n     * Receive only\n     */\n    using rxonly = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief SSM field\n     *\n     * Software\
    \ slave management\n     */\n    using ssm = FieldModel<uint32_t, address, 9,\
    \ 1>;\n    /**\n     * @brief SSI field\n     *\n     * Internal slave select\n\
    \     */\n    using ssi = FieldModel<uint32_t, address, 8, 1>;\n    /**\n    \
    \ * @brief LSBFIRST field\n     *\n     * Frame format\n     */\n    using lsbfirst\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief SPE field\n \
    \    *\n     * SPI enable\n     */\n    using spe = FieldModel<uint32_t, address,\
    \ 6, 1>;\n    /**\n     * @brief BR field\n     *\n     * Baud rate control\n\
    \     */\n    using br = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     *\
    \ @brief MSTR field\n     *\n     * Master selection\n     */\n    using mstr\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief CPOL field\n\
    \     *\n     * Clock polarity\n     */\n    using cpol = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief CPHA field\n     *\n     * Clock phase\n\
    \     */\n    using cpha = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BIDIMODE field\n       *\n       * Bidirectional data mode\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 15, 1>\
    \ bidimode;\n      /**\n       * @brief BIDIOE field\n       *\n       * Output\
    \ enable in bidirectional\n       *               mode\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> bidioe;\n      /**\n       * @brief CRCEN field\n       *\n       * Hardware\
    \ CRC calculation\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> crcen;\n      /**\n       * @brief CRCNEXT field\n       *\n       *\
    \ CRC transfer next\n       */\n      BitFieldModel<uint32_t, 12, 1> crcnext;\n\
    \      /**\n       * @brief DFF field\n       *\n       * Data frame format\n\
    \       */\n      BitFieldModel<uint32_t, 11, 1> dff;\n      /**\n       * @brief\
    \ RXONLY field\n       *\n       * Receive only\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> rxonly;\n      /**\n       * @brief SSM field\n       *\n       * Software\
    \ slave management\n       */\n      BitFieldModel<uint32_t, 9, 1> ssm;\n    \
    \  /**\n       * @brief SSI field\n       *\n       * Internal slave select\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> ssi;\n      /**\n       * @brief\
    \ LSBFIRST field\n       *\n       * Frame format\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> lsbfirst;\n      /**\n       * @brief SPE field\n       *\n       * SPI\
    \ enable\n       */\n      BitFieldModel<uint32_t, 6, 1> spe;\n      /**\n   \
    \    * @brief BR field\n       *\n       * Baud rate control\n       */\n    \
    \  BitFieldModel<uint32_t, 3, 3> br;\n      /**\n       * @brief MSTR field\n\
    \       *\n       * Master selection\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> mstr;\n      /**\n       * @brief CPOL field\n       *\n       * Clock\
    \ polarity\n       */\n      BitFieldModel<uint32_t, 1, 1> cpol;\n      /**\n\
    \       * @brief CPHA field\n       *\n       * Clock phase\n       */\n     \
    \ BitFieldModel<uint32_t, 0, 1> cpha;\n    };\n  };\n\npublic:\n  /**\n   * @brief\
    \ CR1 register\n   *\n   * control register 1\n   */\n  using cr1 = Cr1Reg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class Cr2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief TXEIE\
    \ field\n     *\n     * Tx buffer empty interrupt\n     *               enable\n\
    \     */\n    using txeie = FieldModel<uint32_t, address, 7, 1>;\n    /**\n  \
    \   * @brief RXNEIE field\n     *\n     * RX buffer not empty interrupt\n    \
    \ *               enable\n     */\n    using rxneie = FieldModel<uint32_t, address,\
    \ 6, 1>;\n    /**\n     * @brief ERRIE field\n     *\n     * Error interrupt enable\n\
    \     */\n    using errie = FieldModel<uint32_t, address, 5, 1>;\n    /**\n  \
    \   * @brief FRF field\n     *\n     * Frame format\n     */\n    using frf =\
    \ FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief SSOE field\n  \
    \   *\n     * SS output enable\n     */\n    using ssoe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief TXDMAEN field\n     *\n     * Tx buffer\
    \ DMA enable\n     */\n    using txdmaen = FieldModel<uint32_t, address, 1, 1>;\n\
    \    /**\n     * @brief RXDMAEN field\n     *\n     * Rx buffer DMA enable\n \
    \    */\n    using rxdmaen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief TXEIE field\n       *\n       * Tx buffer empty interrupt\n \
    \      *               enable\n       */\n      BitFieldModel<uint32_t, 7, 1>\
    \ txeie;\n      /**\n       * @brief RXNEIE field\n       *\n       * RX buffer\
    \ not empty interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> rxneie;\n      /**\n       * @brief ERRIE field\n       *\n       * Error\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 5, 1> errie;\n  \
    \    /**\n       * @brief FRF field\n       *\n       * Frame format\n       */\n\
    \      BitFieldModel<uint32_t, 4, 1> frf;\n      /**\n       * @brief SSOE field\n\
    \       *\n       * SS output enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> ssoe;\n      /**\n       * @brief TXDMAEN field\n       *\n       * Tx\
    \ buffer DMA enable\n       */\n      BitFieldModel<uint32_t, 1, 1> txdmaen;\n\
    \      /**\n       * @brief RXDMAEN field\n       *\n       * Rx buffer DMA enable\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> rxdmaen;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR2 register\n   *\n   * control register 2\n   */\n  using\
    \ cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class SrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ /**\n     * @brief TIFRFE field\n     *\n     * TI frame format error\n    \
    \ */\n    using tifrfe = FieldModel<uint32_t, address, 8, 1>;\n    /**\n     *\
    \ @brief BSY field\n     *\n     * Busy flag\n     */\n    using bsy = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief OVR field\n     *\n     * Overrun flag\n\
    \     */\n    using ovr = FieldModel<uint32_t, address, 6, 1>;\n    /**\n    \
    \ * @brief MODF field\n     *\n     * Mode fault\n     */\n    using modf = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief CRCERR field\n     *\n     * CRC error\
    \ flag\n     */\n    using crcerr = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ /**\n     * @brief UDR field\n     *\n     * Underrun flag\n     */\n    using\
    \ udr = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief CHSIDE field\n\
    \     *\n     * Channel side\n     */\n    using chside = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief TXE field\n     *\n     * Transmit buffer\
    \ empty\n     */\n    using txe = FieldModel<uint32_t, address, 1, 1>;\n    /**\n\
    \     * @brief RXNE field\n     *\n     * Receive buffer not empty\n     */\n\
    \    using rxne = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ TIFRFE field\n       *\n       * TI frame format error\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> tifrfe;\n      /**\n       * @brief BSY field\n       *\n       * Busy\
    \ flag\n       */\n      BitFieldModel<uint32_t, 7, 1> bsy;\n      /**\n     \
    \  * @brief OVR field\n       *\n       * Overrun flag\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> ovr;\n      /**\n       * @brief MODF field\n       *\n       * Mode fault\n\
    \       */\n      BitFieldModel<uint32_t, 5, 1> modf;\n      /**\n       * @brief\
    \ CRCERR field\n       *\n       * CRC error flag\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> crcerr;\n      /**\n       * @brief UDR field\n       *\n       * Underrun\
    \ flag\n       */\n      BitFieldModel<uint32_t, 3, 1> udr;\n      /**\n     \
    \  * @brief CHSIDE field\n       *\n       * Channel side\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> chside;\n      /**\n       * @brief TXE field\n       *\n       * Transmit\
    \ buffer empty\n       */\n      BitFieldModel<uint32_t, 1, 1> txe;\n      /**\n\
    \       * @brief RXNE field\n       *\n       * Receive buffer not empty\n   \
    \    */\n      BitFieldModel<uint32_t, 0, 1> rxne;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief SR register\n   *\n   * status register\n   */\n  using sr\
    \ = SrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class DrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ /**\n     * @brief DR field\n     *\n     * Data register\n     */\n    using\
    \ dr = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ DR field\n       *\n       * Data register\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> dr;\n    };\n  };\n\npublic:\n  /**\n   * @brief DR register\n   *\n\
    \   * data register\n   */\n  using dr = DrReg<BaseAddress + 0x000C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class CrcprReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CRCPOLY field\n     *\n   \
    \  * CRC polynomial register\n     */\n    using crcpoly = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CRCPOLY field\n       *\n\
    \       * CRC polynomial register\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 16> crcpoly;\n    };\n  };\n\npublic:\n  /**\n   * @brief CRCPR register\n \
    \  *\n   * CRC polynomial register\n   */\n  using crcpr = CrcprReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class RxcrcrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ RXCRC field\n     *\n     * Rx CRC register\n     */\n    using rxcrc = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief RXCRC field\n       *\n\
    \       * Rx CRC register\n       */\n      BitFieldModel<uint32_t, 0, 16> rxcrc;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief RXCRCR register\n   *\n   * RX CRC\
    \ register\n   */\n  using rxcrcr = RxcrcrReg<BaseAddress + 0x0014>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class TxcrcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief TXCRC field\n     *\n     *\
    \ Tx CRC register\n     */\n    using txcrc = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief TXCRC field\n       *\n   \
    \    * Tx CRC register\n       */\n      BitFieldModel<uint32_t, 0, 16> txcrc;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief TXCRCR register\n   *\n   * TX CRC\
    \ register\n   */\n  using txcrcr = TxcrcrReg<BaseAddress + 0x0018>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class I2scfgrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief I2SMOD field\n     *\n    \
    \ * I2S mode selection\n     */\n    using i2smod = FieldModel<uint32_t, address,\
    \ 11, 1>;\n    /**\n     * @brief I2SE field\n     *\n     * I2S Enable\n    \
    \ */\n    using i2se = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     *\
    \ @brief I2SCFG field\n     *\n     * I2S configuration mode\n     */\n    using\
    \ i2scfg = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief PCMSYNC\
    \ field\n     *\n     * PCM frame synchronization\n     */\n    using pcmsync\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief I2SSTD field\n\
    \     *\n     * I2S standard selection\n     */\n    using i2sstd = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    /**\n     * @brief CKPOL field\n     *\n     * Steady state\
    \ clock\n     *               polarity\n     */\n    using ckpol = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief DATLEN field\n     *\n     * Data length\
    \ to be\n     *               transferred\n     */\n    using datlen = FieldModel<uint32_t,\
    \ address, 1, 2>;\n    /**\n     * @brief CHLEN field\n     *\n     * Channel\
    \ length (number of bits per audio\n     *               channel)\n     */\n \
    \   using chlen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ I2SMOD field\n       *\n       * I2S mode selection\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> i2smod;\n      /**\n       * @brief I2SE field\n       *\n       * I2S\
    \ Enable\n       */\n      BitFieldModel<uint32_t, 10, 1> i2se;\n      /**\n \
    \      * @brief I2SCFG field\n       *\n       * I2S configuration mode\n    \
    \   */\n      BitFieldModel<uint32_t, 8, 2> i2scfg;\n      /**\n       * @brief\
    \ PCMSYNC field\n       *\n       * PCM frame synchronization\n       */\n   \
    \   BitFieldModel<uint32_t, 7, 1> pcmsync;\n      /**\n       * @brief I2SSTD\
    \ field\n       *\n       * I2S standard selection\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 2> i2sstd;\n      /**\n       * @brief CKPOL field\n       *\n       * Steady\
    \ state clock\n       *               polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> ckpol;\n      /**\n       * @brief DATLEN field\n       *\n       * Data\
    \ length to be\n       *               transferred\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 2> datlen;\n      /**\n       * @brief CHLEN field\n       *\n       * Channel\
    \ length (number of bits per audio\n       *               channel)\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> chlen;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief I2SCFGR register\n   *\n   * I2S configuration register\n   */\n\
    \  using i2scfgr = I2scfgrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class I2sprReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief MCKOE field\n     *\n     * Master clock\
    \ output enable\n     */\n    using mckoe = FieldModel<uint32_t, address, 9, 1>;\n\
    \    /**\n     * @brief ODD field\n     *\n     * Odd factor for the\n     * \
    \              prescaler\n     */\n    using odd = FieldModel<uint32_t, address,\
    \ 8, 1>;\n    /**\n     * @brief I2SDIV field\n     *\n     * I2S Linear prescaler\n\
    \     */\n    using i2sdiv = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief MCKOE field\n       *\n       * Master clock output enable\n\
    \       */\n      BitFieldModel<uint32_t, 9, 1> mckoe;\n      /**\n       * @brief\
    \ ODD field\n       *\n       * Odd factor for the\n       *               prescaler\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> odd;\n      /**\n       * @brief\
    \ I2SDIV field\n       *\n       * I2S Linear prescaler\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> i2sdiv;\n    };\n  };\n\npublic:\n  /**\n   * @brief I2SPR register\n\
    \   *\n   * I2S prescaler register\n   */\n  using i2spr = I2sprReg<BaseAddress\
    \ + 0x0020>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_SPI1_H */"
  name: SPI1
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_SPI2_H\n#define DRAL_STM32F411_SPI2_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ SPI2 peripheral\n *\n * Serial peripheral interface\n */\nclass spi2\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40003800; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief BIDIMODE\
    \ field\n     *\n     * Bidirectional data mode\n     *               enable\n\
    \     */\n    using bidimode = FieldModel<uint32_t, address, 15, 1>;\n    /**\n\
    \     * @brief BIDIOE field\n     *\n     * Output enable in bidirectional\n \
    \    *               mode\n     */\n    using bidioe = FieldModel<uint32_t, address,\
    \ 14, 1>;\n    /**\n     * @brief CRCEN field\n     *\n     * Hardware CRC calculation\n\
    \     *               enable\n     */\n    using crcen = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief CRCNEXT field\n     *\n     * CRC transfer\
    \ next\n     */\n    using crcnext = FieldModel<uint32_t, address, 12, 1>;\n \
    \   /**\n     * @brief DFF field\n     *\n     * Data frame format\n     */\n\
    \    using dff = FieldModel<uint32_t, address, 11, 1>;\n    /**\n     * @brief\
    \ RXONLY field\n     *\n     * Receive only\n     */\n    using rxonly = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief SSM field\n     *\n     * Software\
    \ slave management\n     */\n    using ssm = FieldModel<uint32_t, address, 9,\
    \ 1>;\n    /**\n     * @brief SSI field\n     *\n     * Internal slave select\n\
    \     */\n    using ssi = FieldModel<uint32_t, address, 8, 1>;\n    /**\n    \
    \ * @brief LSBFIRST field\n     *\n     * Frame format\n     */\n    using lsbfirst\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief SPE field\n \
    \    *\n     * SPI enable\n     */\n    using spe = FieldModel<uint32_t, address,\
    \ 6, 1>;\n    /**\n     * @brief BR field\n     *\n     * Baud rate control\n\
    \     */\n    using br = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     *\
    \ @brief MSTR field\n     *\n     * Master selection\n     */\n    using mstr\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief CPOL field\n\
    \     *\n     * Clock polarity\n     */\n    using cpol = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief CPHA field\n     *\n     * Clock phase\n\
    \     */\n    using cpha = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BIDIMODE field\n       *\n       * Bidirectional data mode\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 15, 1>\
    \ bidimode;\n      /**\n       * @brief BIDIOE field\n       *\n       * Output\
    \ enable in bidirectional\n       *               mode\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> bidioe;\n      /**\n       * @brief CRCEN field\n       *\n       * Hardware\
    \ CRC calculation\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> crcen;\n      /**\n       * @brief CRCNEXT field\n       *\n       *\
    \ CRC transfer next\n       */\n      BitFieldModel<uint32_t, 12, 1> crcnext;\n\
    \      /**\n       * @brief DFF field\n       *\n       * Data frame format\n\
    \       */\n      BitFieldModel<uint32_t, 11, 1> dff;\n      /**\n       * @brief\
    \ RXONLY field\n       *\n       * Receive only\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> rxonly;\n      /**\n       * @brief SSM field\n       *\n       * Software\
    \ slave management\n       */\n      BitFieldModel<uint32_t, 9, 1> ssm;\n    \
    \  /**\n       * @brief SSI field\n       *\n       * Internal slave select\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> ssi;\n      /**\n       * @brief\
    \ LSBFIRST field\n       *\n       * Frame format\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> lsbfirst;\n      /**\n       * @brief SPE field\n       *\n       * SPI\
    \ enable\n       */\n      BitFieldModel<uint32_t, 6, 1> spe;\n      /**\n   \
    \    * @brief BR field\n       *\n       * Baud rate control\n       */\n    \
    \  BitFieldModel<uint32_t, 3, 3> br;\n      /**\n       * @brief MSTR field\n\
    \       *\n       * Master selection\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> mstr;\n      /**\n       * @brief CPOL field\n       *\n       * Clock\
    \ polarity\n       */\n      BitFieldModel<uint32_t, 1, 1> cpol;\n      /**\n\
    \       * @brief CPHA field\n       *\n       * Clock phase\n       */\n     \
    \ BitFieldModel<uint32_t, 0, 1> cpha;\n    };\n  };\n\npublic:\n  /**\n   * @brief\
    \ CR1 register\n   *\n   * control register 1\n   */\n  using cr1 = Cr1Reg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class Cr2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief TXEIE\
    \ field\n     *\n     * Tx buffer empty interrupt\n     *               enable\n\
    \     */\n    using txeie = FieldModel<uint32_t, address, 7, 1>;\n    /**\n  \
    \   * @brief RXNEIE field\n     *\n     * RX buffer not empty interrupt\n    \
    \ *               enable\n     */\n    using rxneie = FieldModel<uint32_t, address,\
    \ 6, 1>;\n    /**\n     * @brief ERRIE field\n     *\n     * Error interrupt enable\n\
    \     */\n    using errie = FieldModel<uint32_t, address, 5, 1>;\n    /**\n  \
    \   * @brief FRF field\n     *\n     * Frame format\n     */\n    using frf =\
    \ FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief SSOE field\n  \
    \   *\n     * SS output enable\n     */\n    using ssoe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief TXDMAEN field\n     *\n     * Tx buffer\
    \ DMA enable\n     */\n    using txdmaen = FieldModel<uint32_t, address, 1, 1>;\n\
    \    /**\n     * @brief RXDMAEN field\n     *\n     * Rx buffer DMA enable\n \
    \    */\n    using rxdmaen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief TXEIE field\n       *\n       * Tx buffer empty interrupt\n \
    \      *               enable\n       */\n      BitFieldModel<uint32_t, 7, 1>\
    \ txeie;\n      /**\n       * @brief RXNEIE field\n       *\n       * RX buffer\
    \ not empty interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> rxneie;\n      /**\n       * @brief ERRIE field\n       *\n       * Error\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 5, 1> errie;\n  \
    \    /**\n       * @brief FRF field\n       *\n       * Frame format\n       */\n\
    \      BitFieldModel<uint32_t, 4, 1> frf;\n      /**\n       * @brief SSOE field\n\
    \       *\n       * SS output enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> ssoe;\n      /**\n       * @brief TXDMAEN field\n       *\n       * Tx\
    \ buffer DMA enable\n       */\n      BitFieldModel<uint32_t, 1, 1> txdmaen;\n\
    \      /**\n       * @brief RXDMAEN field\n       *\n       * Rx buffer DMA enable\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> rxdmaen;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR2 register\n   *\n   * control register 2\n   */\n  using\
    \ cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class SrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ /**\n     * @brief TIFRFE field\n     *\n     * TI frame format error\n    \
    \ */\n    using tifrfe = FieldModel<uint32_t, address, 8, 1>;\n    /**\n     *\
    \ @brief BSY field\n     *\n     * Busy flag\n     */\n    using bsy = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief OVR field\n     *\n     * Overrun flag\n\
    \     */\n    using ovr = FieldModel<uint32_t, address, 6, 1>;\n    /**\n    \
    \ * @brief MODF field\n     *\n     * Mode fault\n     */\n    using modf = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief CRCERR field\n     *\n     * CRC error\
    \ flag\n     */\n    using crcerr = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ /**\n     * @brief UDR field\n     *\n     * Underrun flag\n     */\n    using\
    \ udr = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief CHSIDE field\n\
    \     *\n     * Channel side\n     */\n    using chside = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief TXE field\n     *\n     * Transmit buffer\
    \ empty\n     */\n    using txe = FieldModel<uint32_t, address, 1, 1>;\n    /**\n\
    \     * @brief RXNE field\n     *\n     * Receive buffer not empty\n     */\n\
    \    using rxne = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ TIFRFE field\n       *\n       * TI frame format error\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> tifrfe;\n      /**\n       * @brief BSY field\n       *\n       * Busy\
    \ flag\n       */\n      BitFieldModel<uint32_t, 7, 1> bsy;\n      /**\n     \
    \  * @brief OVR field\n       *\n       * Overrun flag\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> ovr;\n      /**\n       * @brief MODF field\n       *\n       * Mode fault\n\
    \       */\n      BitFieldModel<uint32_t, 5, 1> modf;\n      /**\n       * @brief\
    \ CRCERR field\n       *\n       * CRC error flag\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> crcerr;\n      /**\n       * @brief UDR field\n       *\n       * Underrun\
    \ flag\n       */\n      BitFieldModel<uint32_t, 3, 1> udr;\n      /**\n     \
    \  * @brief CHSIDE field\n       *\n       * Channel side\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> chside;\n      /**\n       * @brief TXE field\n       *\n       * Transmit\
    \ buffer empty\n       */\n      BitFieldModel<uint32_t, 1, 1> txe;\n      /**\n\
    \       * @brief RXNE field\n       *\n       * Receive buffer not empty\n   \
    \    */\n      BitFieldModel<uint32_t, 0, 1> rxne;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief SR register\n   *\n   * status register\n   */\n  using sr\
    \ = SrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class DrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ /**\n     * @brief DR field\n     *\n     * Data register\n     */\n    using\
    \ dr = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ DR field\n       *\n       * Data register\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> dr;\n    };\n  };\n\npublic:\n  /**\n   * @brief DR register\n   *\n\
    \   * data register\n   */\n  using dr = DrReg<BaseAddress + 0x000C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class CrcprReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CRCPOLY field\n     *\n   \
    \  * CRC polynomial register\n     */\n    using crcpoly = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CRCPOLY field\n       *\n\
    \       * CRC polynomial register\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 16> crcpoly;\n    };\n  };\n\npublic:\n  /**\n   * @brief CRCPR register\n \
    \  *\n   * CRC polynomial register\n   */\n  using crcpr = CrcprReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class RxcrcrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ RXCRC field\n     *\n     * Rx CRC register\n     */\n    using rxcrc = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief RXCRC field\n       *\n\
    \       * Rx CRC register\n       */\n      BitFieldModel<uint32_t, 0, 16> rxcrc;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief RXCRCR register\n   *\n   * RX CRC\
    \ register\n   */\n  using rxcrcr = RxcrcrReg<BaseAddress + 0x0014>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class TxcrcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief TXCRC field\n     *\n     *\
    \ Tx CRC register\n     */\n    using txcrc = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief TXCRC field\n       *\n   \
    \    * Tx CRC register\n       */\n      BitFieldModel<uint32_t, 0, 16> txcrc;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief TXCRCR register\n   *\n   * TX CRC\
    \ register\n   */\n  using txcrcr = TxcrcrReg<BaseAddress + 0x0018>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class I2scfgrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief I2SMOD field\n     *\n    \
    \ * I2S mode selection\n     */\n    using i2smod = FieldModel<uint32_t, address,\
    \ 11, 1>;\n    /**\n     * @brief I2SE field\n     *\n     * I2S Enable\n    \
    \ */\n    using i2se = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     *\
    \ @brief I2SCFG field\n     *\n     * I2S configuration mode\n     */\n    using\
    \ i2scfg = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief PCMSYNC\
    \ field\n     *\n     * PCM frame synchronization\n     */\n    using pcmsync\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief I2SSTD field\n\
    \     *\n     * I2S standard selection\n     */\n    using i2sstd = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    /**\n     * @brief CKPOL field\n     *\n     * Steady state\
    \ clock\n     *               polarity\n     */\n    using ckpol = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief DATLEN field\n     *\n     * Data length\
    \ to be\n     *               transferred\n     */\n    using datlen = FieldModel<uint32_t,\
    \ address, 1, 2>;\n    /**\n     * @brief CHLEN field\n     *\n     * Channel\
    \ length (number of bits per audio\n     *               channel)\n     */\n \
    \   using chlen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ I2SMOD field\n       *\n       * I2S mode selection\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> i2smod;\n      /**\n       * @brief I2SE field\n       *\n       * I2S\
    \ Enable\n       */\n      BitFieldModel<uint32_t, 10, 1> i2se;\n      /**\n \
    \      * @brief I2SCFG field\n       *\n       * I2S configuration mode\n    \
    \   */\n      BitFieldModel<uint32_t, 8, 2> i2scfg;\n      /**\n       * @brief\
    \ PCMSYNC field\n       *\n       * PCM frame synchronization\n       */\n   \
    \   BitFieldModel<uint32_t, 7, 1> pcmsync;\n      /**\n       * @brief I2SSTD\
    \ field\n       *\n       * I2S standard selection\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 2> i2sstd;\n      /**\n       * @brief CKPOL field\n       *\n       * Steady\
    \ state clock\n       *               polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> ckpol;\n      /**\n       * @brief DATLEN field\n       *\n       * Data\
    \ length to be\n       *               transferred\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 2> datlen;\n      /**\n       * @brief CHLEN field\n       *\n       * Channel\
    \ length (number of bits per audio\n       *               channel)\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> chlen;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief I2SCFGR register\n   *\n   * I2S configuration register\n   */\n\
    \  using i2scfgr = I2scfgrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class I2sprReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief MCKOE field\n     *\n     * Master clock\
    \ output enable\n     */\n    using mckoe = FieldModel<uint32_t, address, 9, 1>;\n\
    \    /**\n     * @brief ODD field\n     *\n     * Odd factor for the\n     * \
    \              prescaler\n     */\n    using odd = FieldModel<uint32_t, address,\
    \ 8, 1>;\n    /**\n     * @brief I2SDIV field\n     *\n     * I2S Linear prescaler\n\
    \     */\n    using i2sdiv = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief MCKOE field\n       *\n       * Master clock output enable\n\
    \       */\n      BitFieldModel<uint32_t, 9, 1> mckoe;\n      /**\n       * @brief\
    \ ODD field\n       *\n       * Odd factor for the\n       *               prescaler\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> odd;\n      /**\n       * @brief\
    \ I2SDIV field\n       *\n       * I2S Linear prescaler\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> i2sdiv;\n    };\n  };\n\npublic:\n  /**\n   * @brief I2SPR register\n\
    \   *\n   * I2S prescaler register\n   */\n  using i2spr = I2sprReg<BaseAddress\
    \ + 0x0020>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_SPI2_H */"
  name: SPI2
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_SPI3_H\n#define DRAL_STM32F411_SPI3_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ SPI3 peripheral\n *\n * Serial peripheral interface\n */\nclass spi3\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40003C00; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief BIDIMODE\
    \ field\n     *\n     * Bidirectional data mode\n     *               enable\n\
    \     */\n    using bidimode = FieldModel<uint32_t, address, 15, 1>;\n    /**\n\
    \     * @brief BIDIOE field\n     *\n     * Output enable in bidirectional\n \
    \    *               mode\n     */\n    using bidioe = FieldModel<uint32_t, address,\
    \ 14, 1>;\n    /**\n     * @brief CRCEN field\n     *\n     * Hardware CRC calculation\n\
    \     *               enable\n     */\n    using crcen = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief CRCNEXT field\n     *\n     * CRC transfer\
    \ next\n     */\n    using crcnext = FieldModel<uint32_t, address, 12, 1>;\n \
    \   /**\n     * @brief DFF field\n     *\n     * Data frame format\n     */\n\
    \    using dff = FieldModel<uint32_t, address, 11, 1>;\n    /**\n     * @brief\
    \ RXONLY field\n     *\n     * Receive only\n     */\n    using rxonly = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief SSM field\n     *\n     * Software\
    \ slave management\n     */\n    using ssm = FieldModel<uint32_t, address, 9,\
    \ 1>;\n    /**\n     * @brief SSI field\n     *\n     * Internal slave select\n\
    \     */\n    using ssi = FieldModel<uint32_t, address, 8, 1>;\n    /**\n    \
    \ * @brief LSBFIRST field\n     *\n     * Frame format\n     */\n    using lsbfirst\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief SPE field\n \
    \    *\n     * SPI enable\n     */\n    using spe = FieldModel<uint32_t, address,\
    \ 6, 1>;\n    /**\n     * @brief BR field\n     *\n     * Baud rate control\n\
    \     */\n    using br = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     *\
    \ @brief MSTR field\n     *\n     * Master selection\n     */\n    using mstr\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief CPOL field\n\
    \     *\n     * Clock polarity\n     */\n    using cpol = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief CPHA field\n     *\n     * Clock phase\n\
    \     */\n    using cpha = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BIDIMODE field\n       *\n       * Bidirectional data mode\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 15, 1>\
    \ bidimode;\n      /**\n       * @brief BIDIOE field\n       *\n       * Output\
    \ enable in bidirectional\n       *               mode\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> bidioe;\n      /**\n       * @brief CRCEN field\n       *\n       * Hardware\
    \ CRC calculation\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> crcen;\n      /**\n       * @brief CRCNEXT field\n       *\n       *\
    \ CRC transfer next\n       */\n      BitFieldModel<uint32_t, 12, 1> crcnext;\n\
    \      /**\n       * @brief DFF field\n       *\n       * Data frame format\n\
    \       */\n      BitFieldModel<uint32_t, 11, 1> dff;\n      /**\n       * @brief\
    \ RXONLY field\n       *\n       * Receive only\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> rxonly;\n      /**\n       * @brief SSM field\n       *\n       * Software\
    \ slave management\n       */\n      BitFieldModel<uint32_t, 9, 1> ssm;\n    \
    \  /**\n       * @brief SSI field\n       *\n       * Internal slave select\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> ssi;\n      /**\n       * @brief\
    \ LSBFIRST field\n       *\n       * Frame format\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> lsbfirst;\n      /**\n       * @brief SPE field\n       *\n       * SPI\
    \ enable\n       */\n      BitFieldModel<uint32_t, 6, 1> spe;\n      /**\n   \
    \    * @brief BR field\n       *\n       * Baud rate control\n       */\n    \
    \  BitFieldModel<uint32_t, 3, 3> br;\n      /**\n       * @brief MSTR field\n\
    \       *\n       * Master selection\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> mstr;\n      /**\n       * @brief CPOL field\n       *\n       * Clock\
    \ polarity\n       */\n      BitFieldModel<uint32_t, 1, 1> cpol;\n      /**\n\
    \       * @brief CPHA field\n       *\n       * Clock phase\n       */\n     \
    \ BitFieldModel<uint32_t, 0, 1> cpha;\n    };\n  };\n\npublic:\n  /**\n   * @brief\
    \ CR1 register\n   *\n   * control register 1\n   */\n  using cr1 = Cr1Reg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class Cr2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief TXEIE\
    \ field\n     *\n     * Tx buffer empty interrupt\n     *               enable\n\
    \     */\n    using txeie = FieldModel<uint32_t, address, 7, 1>;\n    /**\n  \
    \   * @brief RXNEIE field\n     *\n     * RX buffer not empty interrupt\n    \
    \ *               enable\n     */\n    using rxneie = FieldModel<uint32_t, address,\
    \ 6, 1>;\n    /**\n     * @brief ERRIE field\n     *\n     * Error interrupt enable\n\
    \     */\n    using errie = FieldModel<uint32_t, address, 5, 1>;\n    /**\n  \
    \   * @brief FRF field\n     *\n     * Frame format\n     */\n    using frf =\
    \ FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief SSOE field\n  \
    \   *\n     * SS output enable\n     */\n    using ssoe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief TXDMAEN field\n     *\n     * Tx buffer\
    \ DMA enable\n     */\n    using txdmaen = FieldModel<uint32_t, address, 1, 1>;\n\
    \    /**\n     * @brief RXDMAEN field\n     *\n     * Rx buffer DMA enable\n \
    \    */\n    using rxdmaen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief TXEIE field\n       *\n       * Tx buffer empty interrupt\n \
    \      *               enable\n       */\n      BitFieldModel<uint32_t, 7, 1>\
    \ txeie;\n      /**\n       * @brief RXNEIE field\n       *\n       * RX buffer\
    \ not empty interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> rxneie;\n      /**\n       * @brief ERRIE field\n       *\n       * Error\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 5, 1> errie;\n  \
    \    /**\n       * @brief FRF field\n       *\n       * Frame format\n       */\n\
    \      BitFieldModel<uint32_t, 4, 1> frf;\n      /**\n       * @brief SSOE field\n\
    \       *\n       * SS output enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> ssoe;\n      /**\n       * @brief TXDMAEN field\n       *\n       * Tx\
    \ buffer DMA enable\n       */\n      BitFieldModel<uint32_t, 1, 1> txdmaen;\n\
    \      /**\n       * @brief RXDMAEN field\n       *\n       * Rx buffer DMA enable\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> rxdmaen;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR2 register\n   *\n   * control register 2\n   */\n  using\
    \ cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class SrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ /**\n     * @brief TIFRFE field\n     *\n     * TI frame format error\n    \
    \ */\n    using tifrfe = FieldModel<uint32_t, address, 8, 1>;\n    /**\n     *\
    \ @brief BSY field\n     *\n     * Busy flag\n     */\n    using bsy = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief OVR field\n     *\n     * Overrun flag\n\
    \     */\n    using ovr = FieldModel<uint32_t, address, 6, 1>;\n    /**\n    \
    \ * @brief MODF field\n     *\n     * Mode fault\n     */\n    using modf = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief CRCERR field\n     *\n     * CRC error\
    \ flag\n     */\n    using crcerr = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ /**\n     * @brief UDR field\n     *\n     * Underrun flag\n     */\n    using\
    \ udr = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief CHSIDE field\n\
    \     *\n     * Channel side\n     */\n    using chside = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief TXE field\n     *\n     * Transmit buffer\
    \ empty\n     */\n    using txe = FieldModel<uint32_t, address, 1, 1>;\n    /**\n\
    \     * @brief RXNE field\n     *\n     * Receive buffer not empty\n     */\n\
    \    using rxne = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ TIFRFE field\n       *\n       * TI frame format error\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> tifrfe;\n      /**\n       * @brief BSY field\n       *\n       * Busy\
    \ flag\n       */\n      BitFieldModel<uint32_t, 7, 1> bsy;\n      /**\n     \
    \  * @brief OVR field\n       *\n       * Overrun flag\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> ovr;\n      /**\n       * @brief MODF field\n       *\n       * Mode fault\n\
    \       */\n      BitFieldModel<uint32_t, 5, 1> modf;\n      /**\n       * @brief\
    \ CRCERR field\n       *\n       * CRC error flag\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> crcerr;\n      /**\n       * @brief UDR field\n       *\n       * Underrun\
    \ flag\n       */\n      BitFieldModel<uint32_t, 3, 1> udr;\n      /**\n     \
    \  * @brief CHSIDE field\n       *\n       * Channel side\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> chside;\n      /**\n       * @brief TXE field\n       *\n       * Transmit\
    \ buffer empty\n       */\n      BitFieldModel<uint32_t, 1, 1> txe;\n      /**\n\
    \       * @brief RXNE field\n       *\n       * Receive buffer not empty\n   \
    \    */\n      BitFieldModel<uint32_t, 0, 1> rxne;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief SR register\n   *\n   * status register\n   */\n  using sr\
    \ = SrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class DrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ /**\n     * @brief DR field\n     *\n     * Data register\n     */\n    using\
    \ dr = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ DR field\n       *\n       * Data register\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> dr;\n    };\n  };\n\npublic:\n  /**\n   * @brief DR register\n   *\n\
    \   * data register\n   */\n  using dr = DrReg<BaseAddress + 0x000C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class CrcprReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CRCPOLY field\n     *\n   \
    \  * CRC polynomial register\n     */\n    using crcpoly = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CRCPOLY field\n       *\n\
    \       * CRC polynomial register\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 16> crcpoly;\n    };\n  };\n\npublic:\n  /**\n   * @brief CRCPR register\n \
    \  *\n   * CRC polynomial register\n   */\n  using crcpr = CrcprReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class RxcrcrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ RXCRC field\n     *\n     * Rx CRC register\n     */\n    using rxcrc = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief RXCRC field\n       *\n\
    \       * Rx CRC register\n       */\n      BitFieldModel<uint32_t, 0, 16> rxcrc;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief RXCRCR register\n   *\n   * RX CRC\
    \ register\n   */\n  using rxcrcr = RxcrcrReg<BaseAddress + 0x0014>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class TxcrcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief TXCRC field\n     *\n     *\
    \ Tx CRC register\n     */\n    using txcrc = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief TXCRC field\n       *\n   \
    \    * Tx CRC register\n       */\n      BitFieldModel<uint32_t, 0, 16> txcrc;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief TXCRCR register\n   *\n   * TX CRC\
    \ register\n   */\n  using txcrcr = TxcrcrReg<BaseAddress + 0x0018>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class I2scfgrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief I2SMOD field\n     *\n    \
    \ * I2S mode selection\n     */\n    using i2smod = FieldModel<uint32_t, address,\
    \ 11, 1>;\n    /**\n     * @brief I2SE field\n     *\n     * I2S Enable\n    \
    \ */\n    using i2se = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     *\
    \ @brief I2SCFG field\n     *\n     * I2S configuration mode\n     */\n    using\
    \ i2scfg = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief PCMSYNC\
    \ field\n     *\n     * PCM frame synchronization\n     */\n    using pcmsync\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief I2SSTD field\n\
    \     *\n     * I2S standard selection\n     */\n    using i2sstd = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    /**\n     * @brief CKPOL field\n     *\n     * Steady state\
    \ clock\n     *               polarity\n     */\n    using ckpol = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief DATLEN field\n     *\n     * Data length\
    \ to be\n     *               transferred\n     */\n    using datlen = FieldModel<uint32_t,\
    \ address, 1, 2>;\n    /**\n     * @brief CHLEN field\n     *\n     * Channel\
    \ length (number of bits per audio\n     *               channel)\n     */\n \
    \   using chlen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ I2SMOD field\n       *\n       * I2S mode selection\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> i2smod;\n      /**\n       * @brief I2SE field\n       *\n       * I2S\
    \ Enable\n       */\n      BitFieldModel<uint32_t, 10, 1> i2se;\n      /**\n \
    \      * @brief I2SCFG field\n       *\n       * I2S configuration mode\n    \
    \   */\n      BitFieldModel<uint32_t, 8, 2> i2scfg;\n      /**\n       * @brief\
    \ PCMSYNC field\n       *\n       * PCM frame synchronization\n       */\n   \
    \   BitFieldModel<uint32_t, 7, 1> pcmsync;\n      /**\n       * @brief I2SSTD\
    \ field\n       *\n       * I2S standard selection\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 2> i2sstd;\n      /**\n       * @brief CKPOL field\n       *\n       * Steady\
    \ state clock\n       *               polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> ckpol;\n      /**\n       * @brief DATLEN field\n       *\n       * Data\
    \ length to be\n       *               transferred\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 2> datlen;\n      /**\n       * @brief CHLEN field\n       *\n       * Channel\
    \ length (number of bits per audio\n       *               channel)\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> chlen;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief I2SCFGR register\n   *\n   * I2S configuration register\n   */\n\
    \  using i2scfgr = I2scfgrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class I2sprReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief MCKOE field\n     *\n     * Master clock\
    \ output enable\n     */\n    using mckoe = FieldModel<uint32_t, address, 9, 1>;\n\
    \    /**\n     * @brief ODD field\n     *\n     * Odd factor for the\n     * \
    \              prescaler\n     */\n    using odd = FieldModel<uint32_t, address,\
    \ 8, 1>;\n    /**\n     * @brief I2SDIV field\n     *\n     * I2S Linear prescaler\n\
    \     */\n    using i2sdiv = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief MCKOE field\n       *\n       * Master clock output enable\n\
    \       */\n      BitFieldModel<uint32_t, 9, 1> mckoe;\n      /**\n       * @brief\
    \ ODD field\n       *\n       * Odd factor for the\n       *               prescaler\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> odd;\n      /**\n       * @brief\
    \ I2SDIV field\n       *\n       * I2S Linear prescaler\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> i2sdiv;\n    };\n  };\n\npublic:\n  /**\n   * @brief I2SPR register\n\
    \   *\n   * I2S prescaler register\n   */\n  using i2spr = I2sprReg<BaseAddress\
    \ + 0x0020>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_SPI3_H */"
  name: SPI3
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_SPI4_H\n#define DRAL_STM32F411_SPI4_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ SPI4 peripheral\n *\n * Serial peripheral interface\n */\nclass spi4\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40013400; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief BIDIMODE\
    \ field\n     *\n     * Bidirectional data mode\n     *               enable\n\
    \     */\n    using bidimode = FieldModel<uint32_t, address, 15, 1>;\n    /**\n\
    \     * @brief BIDIOE field\n     *\n     * Output enable in bidirectional\n \
    \    *               mode\n     */\n    using bidioe = FieldModel<uint32_t, address,\
    \ 14, 1>;\n    /**\n     * @brief CRCEN field\n     *\n     * Hardware CRC calculation\n\
    \     *               enable\n     */\n    using crcen = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief CRCNEXT field\n     *\n     * CRC transfer\
    \ next\n     */\n    using crcnext = FieldModel<uint32_t, address, 12, 1>;\n \
    \   /**\n     * @brief DFF field\n     *\n     * Data frame format\n     */\n\
    \    using dff = FieldModel<uint32_t, address, 11, 1>;\n    /**\n     * @brief\
    \ RXONLY field\n     *\n     * Receive only\n     */\n    using rxonly = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief SSM field\n     *\n     * Software\
    \ slave management\n     */\n    using ssm = FieldModel<uint32_t, address, 9,\
    \ 1>;\n    /**\n     * @brief SSI field\n     *\n     * Internal slave select\n\
    \     */\n    using ssi = FieldModel<uint32_t, address, 8, 1>;\n    /**\n    \
    \ * @brief LSBFIRST field\n     *\n     * Frame format\n     */\n    using lsbfirst\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief SPE field\n \
    \    *\n     * SPI enable\n     */\n    using spe = FieldModel<uint32_t, address,\
    \ 6, 1>;\n    /**\n     * @brief BR field\n     *\n     * Baud rate control\n\
    \     */\n    using br = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     *\
    \ @brief MSTR field\n     *\n     * Master selection\n     */\n    using mstr\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief CPOL field\n\
    \     *\n     * Clock polarity\n     */\n    using cpol = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief CPHA field\n     *\n     * Clock phase\n\
    \     */\n    using cpha = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BIDIMODE field\n       *\n       * Bidirectional data mode\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 15, 1>\
    \ bidimode;\n      /**\n       * @brief BIDIOE field\n       *\n       * Output\
    \ enable in bidirectional\n       *               mode\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> bidioe;\n      /**\n       * @brief CRCEN field\n       *\n       * Hardware\
    \ CRC calculation\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> crcen;\n      /**\n       * @brief CRCNEXT field\n       *\n       *\
    \ CRC transfer next\n       */\n      BitFieldModel<uint32_t, 12, 1> crcnext;\n\
    \      /**\n       * @brief DFF field\n       *\n       * Data frame format\n\
    \       */\n      BitFieldModel<uint32_t, 11, 1> dff;\n      /**\n       * @brief\
    \ RXONLY field\n       *\n       * Receive only\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> rxonly;\n      /**\n       * @brief SSM field\n       *\n       * Software\
    \ slave management\n       */\n      BitFieldModel<uint32_t, 9, 1> ssm;\n    \
    \  /**\n       * @brief SSI field\n       *\n       * Internal slave select\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> ssi;\n      /**\n       * @brief\
    \ LSBFIRST field\n       *\n       * Frame format\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> lsbfirst;\n      /**\n       * @brief SPE field\n       *\n       * SPI\
    \ enable\n       */\n      BitFieldModel<uint32_t, 6, 1> spe;\n      /**\n   \
    \    * @brief BR field\n       *\n       * Baud rate control\n       */\n    \
    \  BitFieldModel<uint32_t, 3, 3> br;\n      /**\n       * @brief MSTR field\n\
    \       *\n       * Master selection\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> mstr;\n      /**\n       * @brief CPOL field\n       *\n       * Clock\
    \ polarity\n       */\n      BitFieldModel<uint32_t, 1, 1> cpol;\n      /**\n\
    \       * @brief CPHA field\n       *\n       * Clock phase\n       */\n     \
    \ BitFieldModel<uint32_t, 0, 1> cpha;\n    };\n  };\n\npublic:\n  /**\n   * @brief\
    \ CR1 register\n   *\n   * control register 1\n   */\n  using cr1 = Cr1Reg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class Cr2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief TXEIE\
    \ field\n     *\n     * Tx buffer empty interrupt\n     *               enable\n\
    \     */\n    using txeie = FieldModel<uint32_t, address, 7, 1>;\n    /**\n  \
    \   * @brief RXNEIE field\n     *\n     * RX buffer not empty interrupt\n    \
    \ *               enable\n     */\n    using rxneie = FieldModel<uint32_t, address,\
    \ 6, 1>;\n    /**\n     * @brief ERRIE field\n     *\n     * Error interrupt enable\n\
    \     */\n    using errie = FieldModel<uint32_t, address, 5, 1>;\n    /**\n  \
    \   * @brief FRF field\n     *\n     * Frame format\n     */\n    using frf =\
    \ FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief SSOE field\n  \
    \   *\n     * SS output enable\n     */\n    using ssoe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief TXDMAEN field\n     *\n     * Tx buffer\
    \ DMA enable\n     */\n    using txdmaen = FieldModel<uint32_t, address, 1, 1>;\n\
    \    /**\n     * @brief RXDMAEN field\n     *\n     * Rx buffer DMA enable\n \
    \    */\n    using rxdmaen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief TXEIE field\n       *\n       * Tx buffer empty interrupt\n \
    \      *               enable\n       */\n      BitFieldModel<uint32_t, 7, 1>\
    \ txeie;\n      /**\n       * @brief RXNEIE field\n       *\n       * RX buffer\
    \ not empty interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> rxneie;\n      /**\n       * @brief ERRIE field\n       *\n       * Error\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 5, 1> errie;\n  \
    \    /**\n       * @brief FRF field\n       *\n       * Frame format\n       */\n\
    \      BitFieldModel<uint32_t, 4, 1> frf;\n      /**\n       * @brief SSOE field\n\
    \       *\n       * SS output enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> ssoe;\n      /**\n       * @brief TXDMAEN field\n       *\n       * Tx\
    \ buffer DMA enable\n       */\n      BitFieldModel<uint32_t, 1, 1> txdmaen;\n\
    \      /**\n       * @brief RXDMAEN field\n       *\n       * Rx buffer DMA enable\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> rxdmaen;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR2 register\n   *\n   * control register 2\n   */\n  using\
    \ cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class SrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ /**\n     * @brief TIFRFE field\n     *\n     * TI frame format error\n    \
    \ */\n    using tifrfe = FieldModel<uint32_t, address, 8, 1>;\n    /**\n     *\
    \ @brief BSY field\n     *\n     * Busy flag\n     */\n    using bsy = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief OVR field\n     *\n     * Overrun flag\n\
    \     */\n    using ovr = FieldModel<uint32_t, address, 6, 1>;\n    /**\n    \
    \ * @brief MODF field\n     *\n     * Mode fault\n     */\n    using modf = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief CRCERR field\n     *\n     * CRC error\
    \ flag\n     */\n    using crcerr = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ /**\n     * @brief UDR field\n     *\n     * Underrun flag\n     */\n    using\
    \ udr = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief CHSIDE field\n\
    \     *\n     * Channel side\n     */\n    using chside = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief TXE field\n     *\n     * Transmit buffer\
    \ empty\n     */\n    using txe = FieldModel<uint32_t, address, 1, 1>;\n    /**\n\
    \     * @brief RXNE field\n     *\n     * Receive buffer not empty\n     */\n\
    \    using rxne = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ TIFRFE field\n       *\n       * TI frame format error\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> tifrfe;\n      /**\n       * @brief BSY field\n       *\n       * Busy\
    \ flag\n       */\n      BitFieldModel<uint32_t, 7, 1> bsy;\n      /**\n     \
    \  * @brief OVR field\n       *\n       * Overrun flag\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> ovr;\n      /**\n       * @brief MODF field\n       *\n       * Mode fault\n\
    \       */\n      BitFieldModel<uint32_t, 5, 1> modf;\n      /**\n       * @brief\
    \ CRCERR field\n       *\n       * CRC error flag\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> crcerr;\n      /**\n       * @brief UDR field\n       *\n       * Underrun\
    \ flag\n       */\n      BitFieldModel<uint32_t, 3, 1> udr;\n      /**\n     \
    \  * @brief CHSIDE field\n       *\n       * Channel side\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> chside;\n      /**\n       * @brief TXE field\n       *\n       * Transmit\
    \ buffer empty\n       */\n      BitFieldModel<uint32_t, 1, 1> txe;\n      /**\n\
    \       * @brief RXNE field\n       *\n       * Receive buffer not empty\n   \
    \    */\n      BitFieldModel<uint32_t, 0, 1> rxne;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief SR register\n   *\n   * status register\n   */\n  using sr\
    \ = SrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class DrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ /**\n     * @brief DR field\n     *\n     * Data register\n     */\n    using\
    \ dr = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ DR field\n       *\n       * Data register\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> dr;\n    };\n  };\n\npublic:\n  /**\n   * @brief DR register\n   *\n\
    \   * data register\n   */\n  using dr = DrReg<BaseAddress + 0x000C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class CrcprReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CRCPOLY field\n     *\n   \
    \  * CRC polynomial register\n     */\n    using crcpoly = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CRCPOLY field\n       *\n\
    \       * CRC polynomial register\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 16> crcpoly;\n    };\n  };\n\npublic:\n  /**\n   * @brief CRCPR register\n \
    \  *\n   * CRC polynomial register\n   */\n  using crcpr = CrcprReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class RxcrcrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ RXCRC field\n     *\n     * Rx CRC register\n     */\n    using rxcrc = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief RXCRC field\n       *\n\
    \       * Rx CRC register\n       */\n      BitFieldModel<uint32_t, 0, 16> rxcrc;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief RXCRCR register\n   *\n   * RX CRC\
    \ register\n   */\n  using rxcrcr = RxcrcrReg<BaseAddress + 0x0014>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class TxcrcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief TXCRC field\n     *\n     *\
    \ Tx CRC register\n     */\n    using txcrc = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief TXCRC field\n       *\n   \
    \    * Tx CRC register\n       */\n      BitFieldModel<uint32_t, 0, 16> txcrc;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief TXCRCR register\n   *\n   * TX CRC\
    \ register\n   */\n  using txcrcr = TxcrcrReg<BaseAddress + 0x0018>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class I2scfgrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief I2SMOD field\n     *\n    \
    \ * I2S mode selection\n     */\n    using i2smod = FieldModel<uint32_t, address,\
    \ 11, 1>;\n    /**\n     * @brief I2SE field\n     *\n     * I2S Enable\n    \
    \ */\n    using i2se = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     *\
    \ @brief I2SCFG field\n     *\n     * I2S configuration mode\n     */\n    using\
    \ i2scfg = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief PCMSYNC\
    \ field\n     *\n     * PCM frame synchronization\n     */\n    using pcmsync\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief I2SSTD field\n\
    \     *\n     * I2S standard selection\n     */\n    using i2sstd = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    /**\n     * @brief CKPOL field\n     *\n     * Steady state\
    \ clock\n     *               polarity\n     */\n    using ckpol = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief DATLEN field\n     *\n     * Data length\
    \ to be\n     *               transferred\n     */\n    using datlen = FieldModel<uint32_t,\
    \ address, 1, 2>;\n    /**\n     * @brief CHLEN field\n     *\n     * Channel\
    \ length (number of bits per audio\n     *               channel)\n     */\n \
    \   using chlen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ I2SMOD field\n       *\n       * I2S mode selection\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> i2smod;\n      /**\n       * @brief I2SE field\n       *\n       * I2S\
    \ Enable\n       */\n      BitFieldModel<uint32_t, 10, 1> i2se;\n      /**\n \
    \      * @brief I2SCFG field\n       *\n       * I2S configuration mode\n    \
    \   */\n      BitFieldModel<uint32_t, 8, 2> i2scfg;\n      /**\n       * @brief\
    \ PCMSYNC field\n       *\n       * PCM frame synchronization\n       */\n   \
    \   BitFieldModel<uint32_t, 7, 1> pcmsync;\n      /**\n       * @brief I2SSTD\
    \ field\n       *\n       * I2S standard selection\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 2> i2sstd;\n      /**\n       * @brief CKPOL field\n       *\n       * Steady\
    \ state clock\n       *               polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> ckpol;\n      /**\n       * @brief DATLEN field\n       *\n       * Data\
    \ length to be\n       *               transferred\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 2> datlen;\n      /**\n       * @brief CHLEN field\n       *\n       * Channel\
    \ length (number of bits per audio\n       *               channel)\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> chlen;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief I2SCFGR register\n   *\n   * I2S configuration register\n   */\n\
    \  using i2scfgr = I2scfgrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class I2sprReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief MCKOE field\n     *\n     * Master clock\
    \ output enable\n     */\n    using mckoe = FieldModel<uint32_t, address, 9, 1>;\n\
    \    /**\n     * @brief ODD field\n     *\n     * Odd factor for the\n     * \
    \              prescaler\n     */\n    using odd = FieldModel<uint32_t, address,\
    \ 8, 1>;\n    /**\n     * @brief I2SDIV field\n     *\n     * I2S Linear prescaler\n\
    \     */\n    using i2sdiv = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief MCKOE field\n       *\n       * Master clock output enable\n\
    \       */\n      BitFieldModel<uint32_t, 9, 1> mckoe;\n      /**\n       * @brief\
    \ ODD field\n       *\n       * Odd factor for the\n       *               prescaler\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> odd;\n      /**\n       * @brief\
    \ I2SDIV field\n       *\n       * I2S Linear prescaler\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> i2sdiv;\n    };\n  };\n\npublic:\n  /**\n   * @brief I2SPR register\n\
    \   *\n   * I2S prescaler register\n   */\n  using i2spr = I2sprReg<BaseAddress\
    \ + 0x0020>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_SPI4_H */"
  name: SPI4
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_SPI5_H\n#define DRAL_STM32F411_SPI5_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ SPI5 peripheral\n *\n * Serial peripheral interface\n */\nclass spi5\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0x40015000; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class Cr1Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief BIDIMODE\
    \ field\n     *\n     * Bidirectional data mode\n     *               enable\n\
    \     */\n    using bidimode = FieldModel<uint32_t, address, 15, 1>;\n    /**\n\
    \     * @brief BIDIOE field\n     *\n     * Output enable in bidirectional\n \
    \    *               mode\n     */\n    using bidioe = FieldModel<uint32_t, address,\
    \ 14, 1>;\n    /**\n     * @brief CRCEN field\n     *\n     * Hardware CRC calculation\n\
    \     *               enable\n     */\n    using crcen = FieldModel<uint32_t,\
    \ address, 13, 1>;\n    /**\n     * @brief CRCNEXT field\n     *\n     * CRC transfer\
    \ next\n     */\n    using crcnext = FieldModel<uint32_t, address, 12, 1>;\n \
    \   /**\n     * @brief DFF field\n     *\n     * Data frame format\n     */\n\
    \    using dff = FieldModel<uint32_t, address, 11, 1>;\n    /**\n     * @brief\
    \ RXONLY field\n     *\n     * Receive only\n     */\n    using rxonly = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief SSM field\n     *\n     * Software\
    \ slave management\n     */\n    using ssm = FieldModel<uint32_t, address, 9,\
    \ 1>;\n    /**\n     * @brief SSI field\n     *\n     * Internal slave select\n\
    \     */\n    using ssi = FieldModel<uint32_t, address, 8, 1>;\n    /**\n    \
    \ * @brief LSBFIRST field\n     *\n     * Frame format\n     */\n    using lsbfirst\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief SPE field\n \
    \    *\n     * SPI enable\n     */\n    using spe = FieldModel<uint32_t, address,\
    \ 6, 1>;\n    /**\n     * @brief BR field\n     *\n     * Baud rate control\n\
    \     */\n    using br = FieldModel<uint32_t, address, 3, 3>;\n    /**\n     *\
    \ @brief MSTR field\n     *\n     * Master selection\n     */\n    using mstr\
    \ = FieldModel<uint32_t, address, 2, 1>;\n    /**\n     * @brief CPOL field\n\
    \     *\n     * Clock polarity\n     */\n    using cpol = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief CPHA field\n     *\n     * Clock phase\n\
    \     */\n    using cpha = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief BIDIMODE field\n       *\n       * Bidirectional data mode\n\
    \       *               enable\n       */\n      BitFieldModel<uint32_t, 15, 1>\
    \ bidimode;\n      /**\n       * @brief BIDIOE field\n       *\n       * Output\
    \ enable in bidirectional\n       *               mode\n       */\n      BitFieldModel<uint32_t,\
    \ 14, 1> bidioe;\n      /**\n       * @brief CRCEN field\n       *\n       * Hardware\
    \ CRC calculation\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> crcen;\n      /**\n       * @brief CRCNEXT field\n       *\n       *\
    \ CRC transfer next\n       */\n      BitFieldModel<uint32_t, 12, 1> crcnext;\n\
    \      /**\n       * @brief DFF field\n       *\n       * Data frame format\n\
    \       */\n      BitFieldModel<uint32_t, 11, 1> dff;\n      /**\n       * @brief\
    \ RXONLY field\n       *\n       * Receive only\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> rxonly;\n      /**\n       * @brief SSM field\n       *\n       * Software\
    \ slave management\n       */\n      BitFieldModel<uint32_t, 9, 1> ssm;\n    \
    \  /**\n       * @brief SSI field\n       *\n       * Internal slave select\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> ssi;\n      /**\n       * @brief\
    \ LSBFIRST field\n       *\n       * Frame format\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> lsbfirst;\n      /**\n       * @brief SPE field\n       *\n       * SPI\
    \ enable\n       */\n      BitFieldModel<uint32_t, 6, 1> spe;\n      /**\n   \
    \    * @brief BR field\n       *\n       * Baud rate control\n       */\n    \
    \  BitFieldModel<uint32_t, 3, 3> br;\n      /**\n       * @brief MSTR field\n\
    \       *\n       * Master selection\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> mstr;\n      /**\n       * @brief CPOL field\n       *\n       * Clock\
    \ polarity\n       */\n      BitFieldModel<uint32_t, 1, 1> cpol;\n      /**\n\
    \       * @brief CPHA field\n       *\n       * Clock phase\n       */\n     \
    \ BitFieldModel<uint32_t, 0, 1> cpha;\n    };\n  };\n\npublic:\n  /**\n   * @brief\
    \ CR1 register\n   *\n   * control register 1\n   */\n  using cr1 = Cr1Reg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class Cr2Reg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief TXEIE\
    \ field\n     *\n     * Tx buffer empty interrupt\n     *               enable\n\
    \     */\n    using txeie = FieldModel<uint32_t, address, 7, 1>;\n    /**\n  \
    \   * @brief RXNEIE field\n     *\n     * RX buffer not empty interrupt\n    \
    \ *               enable\n     */\n    using rxneie = FieldModel<uint32_t, address,\
    \ 6, 1>;\n    /**\n     * @brief ERRIE field\n     *\n     * Error interrupt enable\n\
    \     */\n    using errie = FieldModel<uint32_t, address, 5, 1>;\n    /**\n  \
    \   * @brief FRF field\n     *\n     * Frame format\n     */\n    using frf =\
    \ FieldModel<uint32_t, address, 4, 1>;\n    /**\n     * @brief SSOE field\n  \
    \   *\n     * SS output enable\n     */\n    using ssoe = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief TXDMAEN field\n     *\n     * Tx buffer\
    \ DMA enable\n     */\n    using txdmaen = FieldModel<uint32_t, address, 1, 1>;\n\
    \    /**\n     * @brief RXDMAEN field\n     *\n     * Rx buffer DMA enable\n \
    \    */\n    using rxdmaen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief TXEIE field\n       *\n       * Tx buffer empty interrupt\n \
    \      *               enable\n       */\n      BitFieldModel<uint32_t, 7, 1>\
    \ txeie;\n      /**\n       * @brief RXNEIE field\n       *\n       * RX buffer\
    \ not empty interrupt\n       *               enable\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> rxneie;\n      /**\n       * @brief ERRIE field\n       *\n       * Error\
    \ interrupt enable\n       */\n      BitFieldModel<uint32_t, 5, 1> errie;\n  \
    \    /**\n       * @brief FRF field\n       *\n       * Frame format\n       */\n\
    \      BitFieldModel<uint32_t, 4, 1> frf;\n      /**\n       * @brief SSOE field\n\
    \       *\n       * SS output enable\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> ssoe;\n      /**\n       * @brief TXDMAEN field\n       *\n       * Tx\
    \ buffer DMA enable\n       */\n      BitFieldModel<uint32_t, 1, 1> txdmaen;\n\
    \      /**\n       * @brief RXDMAEN field\n       *\n       * Rx buffer DMA enable\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> rxdmaen;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief CR2 register\n   *\n   * control register 2\n   */\n  using\
    \ cr2 = Cr2Reg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class SrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ /**\n     * @brief TIFRFE field\n     *\n     * TI frame format error\n    \
    \ */\n    using tifrfe = FieldModel<uint32_t, address, 8, 1>;\n    /**\n     *\
    \ @brief BSY field\n     *\n     * Busy flag\n     */\n    using bsy = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief OVR field\n     *\n     * Overrun flag\n\
    \     */\n    using ovr = FieldModel<uint32_t, address, 6, 1>;\n    /**\n    \
    \ * @brief MODF field\n     *\n     * Mode fault\n     */\n    using modf = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief CRCERR field\n     *\n     * CRC error\
    \ flag\n     */\n    using crcerr = FieldModel<uint32_t, address, 4, 1>;\n   \
    \ /**\n     * @brief UDR field\n     *\n     * Underrun flag\n     */\n    using\
    \ udr = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief CHSIDE field\n\
    \     *\n     * Channel side\n     */\n    using chside = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief TXE field\n     *\n     * Transmit buffer\
    \ empty\n     */\n    using txe = FieldModel<uint32_t, address, 1, 1>;\n    /**\n\
    \     * @brief RXNE field\n     *\n     * Receive buffer not empty\n     */\n\
    \    using rxne = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ TIFRFE field\n       *\n       * TI frame format error\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> tifrfe;\n      /**\n       * @brief BSY field\n       *\n       * Busy\
    \ flag\n       */\n      BitFieldModel<uint32_t, 7, 1> bsy;\n      /**\n     \
    \  * @brief OVR field\n       *\n       * Overrun flag\n       */\n      BitFieldModel<uint32_t,\
    \ 6, 1> ovr;\n      /**\n       * @brief MODF field\n       *\n       * Mode fault\n\
    \       */\n      BitFieldModel<uint32_t, 5, 1> modf;\n      /**\n       * @brief\
    \ CRCERR field\n       *\n       * CRC error flag\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> crcerr;\n      /**\n       * @brief UDR field\n       *\n       * Underrun\
    \ flag\n       */\n      BitFieldModel<uint32_t, 3, 1> udr;\n      /**\n     \
    \  * @brief CHSIDE field\n       *\n       * Channel side\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> chside;\n      /**\n       * @brief TXE field\n       *\n       * Transmit\
    \ buffer empty\n       */\n      BitFieldModel<uint32_t, 1, 1> txe;\n      /**\n\
    \       * @brief RXNE field\n       *\n       * Receive buffer not empty\n   \
    \    */\n      BitFieldModel<uint32_t, 0, 1> rxne;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief SR register\n   *\n   * status register\n   */\n  using sr\
    \ = SrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class DrReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n   \
    \ /**\n     * @brief DR field\n     *\n     * Data register\n     */\n    using\
    \ dr = FieldModel<uint32_t, address, 0, 16>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ DR field\n       *\n       * Data register\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 16> dr;\n    };\n  };\n\npublic:\n  /**\n   * @brief DR register\n   *\n\
    \   * data register\n   */\n  using dr = DrReg<BaseAddress + 0x000C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class CrcprReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CRCPOLY field\n     *\n   \
    \  * CRC polynomial register\n     */\n    using crcpoly = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CRCPOLY field\n       *\n\
    \       * CRC polynomial register\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 16> crcpoly;\n    };\n  };\n\npublic:\n  /**\n   * @brief CRCPR register\n \
    \  *\n   * CRC polynomial register\n   */\n  using crcpr = CrcprReg<BaseAddress\
    \ + 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class RxcrcrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ RXCRC field\n     *\n     * Rx CRC register\n     */\n    using rxcrc = FieldModel<uint32_t,\
    \ address, 0, 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief RXCRC field\n       *\n\
    \       * Rx CRC register\n       */\n      BitFieldModel<uint32_t, 0, 16> rxcrc;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief RXCRCR register\n   *\n   * RX CRC\
    \ register\n   */\n  using rxcrcr = RxcrcrReg<BaseAddress + 0x0014>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class TxcrcrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief TXCRC field\n     *\n     *\
    \ Tx CRC register\n     */\n    using txcrc = FieldModel<uint32_t, address, 0,\
    \ 16>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief TXCRC field\n       *\n   \
    \    * Tx CRC register\n       */\n      BitFieldModel<uint32_t, 0, 16> txcrc;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief TXCRCR register\n   *\n   * TX CRC\
    \ register\n   */\n  using txcrcr = TxcrcrReg<BaseAddress + 0x0018>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class I2scfgrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief I2SMOD field\n     *\n    \
    \ * I2S mode selection\n     */\n    using i2smod = FieldModel<uint32_t, address,\
    \ 11, 1>;\n    /**\n     * @brief I2SE field\n     *\n     * I2S Enable\n    \
    \ */\n    using i2se = FieldModel<uint32_t, address, 10, 1>;\n    /**\n     *\
    \ @brief I2SCFG field\n     *\n     * I2S configuration mode\n     */\n    using\
    \ i2scfg = FieldModel<uint32_t, address, 8, 2>;\n    /**\n     * @brief PCMSYNC\
    \ field\n     *\n     * PCM frame synchronization\n     */\n    using pcmsync\
    \ = FieldModel<uint32_t, address, 7, 1>;\n    /**\n     * @brief I2SSTD field\n\
    \     *\n     * I2S standard selection\n     */\n    using i2sstd = FieldModel<uint32_t,\
    \ address, 4, 2>;\n    /**\n     * @brief CKPOL field\n     *\n     * Steady state\
    \ clock\n     *               polarity\n     */\n    using ckpol = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief DATLEN field\n     *\n     * Data length\
    \ to be\n     *               transferred\n     */\n    using datlen = FieldModel<uint32_t,\
    \ address, 1, 2>;\n    /**\n     * @brief CHLEN field\n     *\n     * Channel\
    \ length (number of bits per audio\n     *               channel)\n     */\n \
    \   using chlen = FieldModel<uint32_t, address, 0, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ I2SMOD field\n       *\n       * I2S mode selection\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> i2smod;\n      /**\n       * @brief I2SE field\n       *\n       * I2S\
    \ Enable\n       */\n      BitFieldModel<uint32_t, 10, 1> i2se;\n      /**\n \
    \      * @brief I2SCFG field\n       *\n       * I2S configuration mode\n    \
    \   */\n      BitFieldModel<uint32_t, 8, 2> i2scfg;\n      /**\n       * @brief\
    \ PCMSYNC field\n       *\n       * PCM frame synchronization\n       */\n   \
    \   BitFieldModel<uint32_t, 7, 1> pcmsync;\n      /**\n       * @brief I2SSTD\
    \ field\n       *\n       * I2S standard selection\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 2> i2sstd;\n      /**\n       * @brief CKPOL field\n       *\n       * Steady\
    \ state clock\n       *               polarity\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> ckpol;\n      /**\n       * @brief DATLEN field\n       *\n       * Data\
    \ length to be\n       *               transferred\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 2> datlen;\n      /**\n       * @brief CHLEN field\n       *\n       * Channel\
    \ length (number of bits per audio\n       *               channel)\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> chlen;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief I2SCFGR register\n   *\n   * I2S configuration register\n   */\n\
    \  using i2scfgr = I2scfgrReg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class I2sprReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief MCKOE field\n     *\n     * Master clock\
    \ output enable\n     */\n    using mckoe = FieldModel<uint32_t, address, 9, 1>;\n\
    \    /**\n     * @brief ODD field\n     *\n     * Odd factor for the\n     * \
    \              prescaler\n     */\n    using odd = FieldModel<uint32_t, address,\
    \ 8, 1>;\n    /**\n     * @brief I2SDIV field\n     *\n     * I2S Linear prescaler\n\
    \     */\n    using i2sdiv = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief MCKOE field\n       *\n       * Master clock output enable\n\
    \       */\n      BitFieldModel<uint32_t, 9, 1> mckoe;\n      /**\n       * @brief\
    \ ODD field\n       *\n       * Odd factor for the\n       *               prescaler\n\
    \       */\n      BitFieldModel<uint32_t, 8, 1> odd;\n      /**\n       * @brief\
    \ I2SDIV field\n       *\n       * I2S Linear prescaler\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> i2sdiv;\n    };\n  };\n\npublic:\n  /**\n   * @brief I2SPR register\n\
    \   *\n   * I2S prescaler register\n   */\n  using i2spr = I2sprReg<BaseAddress\
    \ + 0x0020>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_SPI5_H */"
  name: SPI5
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_NVIC_H\n#define DRAL_STM32F411_NVIC_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ NVIC peripheral\n *\n * Nested Vectored Interrupt\n *       Controller\n */\n\
    class nvic\n{\npublic:\n  static constexpr unsigned int BaseAddress = 0xE000E100;\
    \ /**< Peripheral base address */\n\nprivate:\n  template<unsigned int address>\n\
    \  class Iser0Reg : public RegisterModel<uint32_t, address>\n  {\n  public:\n\
    \    /**\n     * @brief SETENA field\n     *\n     * SETENA\n     */\n    using\
    \ setena = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n     *\
    \ @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ SETENA field\n       *\n       * SETENA\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> setena;\n    };\n  };\n\npublic:\n  /**\n   * @brief ISER0 register\n\
    \   *\n   * Interrupt Set-Enable Register\n   */\n  using iser0 = Iser0Reg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class Iser1Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ SETENA field\n     *\n     * SETENA\n     */\n    using setena = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief SETENA field\n       *\n\
    \       * SETENA\n       */\n      BitFieldModel<uint32_t, 0, 32> setena;\n  \
    \  };\n  };\n\npublic:\n  /**\n   * @brief ISER1 register\n   *\n   * Interrupt\
    \ Set-Enable Register\n   */\n  using iser1 = Iser1Reg<BaseAddress + 0x0004>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Icer0Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CLRENA field\n     *\n    \
    \ * CLRENA\n     */\n    using clrena = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief CLRENA field\n       *\n       * CLRENA\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> clrena;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief ICER0 register\n   *\n   * Interrupt Clear-Enable\n   *  \
    \         Register\n   */\n  using icer0 = Icer0Reg<BaseAddress + 0x0080>;\n\n\
    private:\n  template<unsigned int address>\n  class Icer1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief CLRENA field\n     *\n    \
    \ * CLRENA\n     */\n    using clrena = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief CLRENA field\n       *\n       * CLRENA\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> clrena;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief ICER1 register\n   *\n   * Interrupt Clear-Enable\n   *  \
    \         Register\n   */\n  using icer1 = Icer1Reg<BaseAddress + 0x0084>;\n\n\
    private:\n  template<unsigned int address>\n  class Ispr0Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief SETPEND field\n     *\n   \
    \  * SETPEND\n     */\n    using setpend = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief SETPEND field\n       *\n       * SETPEND\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> setpend;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief ISPR0 register\n   *\n   * Interrupt Set-Pending Register\n\
    \   */\n  using ispr0 = Ispr0Reg<BaseAddress + 0x0100>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ispr1Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief SETPEND field\n     *\n     * SETPEND\n\
    \     */\n    using setpend = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief SETPEND field\n       *\n       * SETPEND\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> setpend;\n    };\n  };\n\npublic:\n  /**\n   * @brief ISPR1 register\n\
    \   *\n   * Interrupt Set-Pending Register\n   */\n  using ispr1 = Ispr1Reg<BaseAddress\
    \ + 0x0104>;\n\nprivate:\n  template<unsigned int address>\n  class Icpr0Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ CLRPEND field\n     *\n     * CLRPEND\n     */\n    using clrpend = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CLRPEND field\n       *\n\
    \       * CLRPEND\n       */\n      BitFieldModel<uint32_t, 0, 32> clrpend;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief ICPR0 register\n   *\n   * Interrupt\
    \ Clear-Pending\n   *           Register\n   */\n  using icpr0 = Icpr0Reg<BaseAddress\
    \ + 0x0180>;\n\nprivate:\n  template<unsigned int address>\n  class Icpr1Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ CLRPEND field\n     *\n     * CLRPEND\n     */\n    using clrpend = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CLRPEND field\n       *\n\
    \       * CLRPEND\n       */\n      BitFieldModel<uint32_t, 0, 32> clrpend;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief ICPR1 register\n   *\n   * Interrupt\
    \ Clear-Pending\n   *           Register\n   */\n  using icpr1 = Icpr1Reg<BaseAddress\
    \ + 0x0184>;\n\nprivate:\n  template<unsigned int address>\n  class Iabr0Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ ACTIVE field\n     *\n     * ACTIVE\n     */\n    using active = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief ACTIVE field\n       *\n\
    \       * ACTIVE\n       */\n      BitFieldModel<uint32_t, 0, 32> active;\n  \
    \  };\n  };\n\npublic:\n  /**\n   * @brief IABR0 register\n   *\n   * Interrupt\
    \ Active Bit Register\n   */\n  using iabr0 = Iabr0Reg<BaseAddress + 0x0200>;\n\
    \nprivate:\n  template<unsigned int address>\n  class Iabr1Reg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief ACTIVE field\n     *\n    \
    \ * ACTIVE\n     */\n    using active = FieldModel<uint32_t, address, 0, 32>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief ACTIVE field\n       *\n       * ACTIVE\n\
    \       */\n      BitFieldModel<uint32_t, 0, 32> active;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief IABR1 register\n   *\n   * Interrupt Active Bit Register\n\
    \   */\n  using iabr1 = Iabr1Reg<BaseAddress + 0x0204>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr0Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief IPR_N0 field\n     *\n     * IPR_N0\n     */\n\
    \    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    /**\n     * @brief\
    \ IPR_N1 field\n     *\n     * IPR_N1\n     */\n    using ipr_n1 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    /**\n     * @brief IPR_N2 field\n     *\n     * IPR_N2\n\
    \     */\n    using ipr_n2 = FieldModel<uint32_t, address, 16, 8>;\n    /**\n\
    \     * @brief IPR_N3 field\n     *\n     * IPR_N3\n     */\n    using ipr_n3\
    \ = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ IPR_N0 field\n       *\n       * IPR_N0\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      /**\n       * @brief IPR_N1 field\n       *\n       * IPR_N1\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      /**\n       * @brief\
    \ IPR_N2 field\n       *\n       * IPR_N2\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      /**\n       * @brief IPR_N3 field\n       *\n       *\
    \ IPR_N3\n       */\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief IPR0 register\n   *\n   * Interrupt Priority Register\n\
    \   */\n  using ipr0 = Ipr0Reg<BaseAddress + 0x0300>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr1Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief IPR_N0 field\n     *\n     * IPR_N0\n     */\n\
    \    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    /**\n     * @brief\
    \ IPR_N1 field\n     *\n     * IPR_N1\n     */\n    using ipr_n1 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    /**\n     * @brief IPR_N2 field\n     *\n     * IPR_N2\n\
    \     */\n    using ipr_n2 = FieldModel<uint32_t, address, 16, 8>;\n    /**\n\
    \     * @brief IPR_N3 field\n     *\n     * IPR_N3\n     */\n    using ipr_n3\
    \ = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ IPR_N0 field\n       *\n       * IPR_N0\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      /**\n       * @brief IPR_N1 field\n       *\n       * IPR_N1\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      /**\n       * @brief\
    \ IPR_N2 field\n       *\n       * IPR_N2\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      /**\n       * @brief IPR_N3 field\n       *\n       *\
    \ IPR_N3\n       */\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief IPR1 register\n   *\n   * Interrupt Priority Register\n\
    \   */\n  using ipr1 = Ipr1Reg<BaseAddress + 0x0304>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr2Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief IPR_N0 field\n     *\n     * IPR_N0\n     */\n\
    \    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    /**\n     * @brief\
    \ IPR_N1 field\n     *\n     * IPR_N1\n     */\n    using ipr_n1 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    /**\n     * @brief IPR_N2 field\n     *\n     * IPR_N2\n\
    \     */\n    using ipr_n2 = FieldModel<uint32_t, address, 16, 8>;\n    /**\n\
    \     * @brief IPR_N3 field\n     *\n     * IPR_N3\n     */\n    using ipr_n3\
    \ = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ IPR_N0 field\n       *\n       * IPR_N0\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      /**\n       * @brief IPR_N1 field\n       *\n       * IPR_N1\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      /**\n       * @brief\
    \ IPR_N2 field\n       *\n       * IPR_N2\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      /**\n       * @brief IPR_N3 field\n       *\n       *\
    \ IPR_N3\n       */\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief IPR2 register\n   *\n   * Interrupt Priority Register\n\
    \   */\n  using ipr2 = Ipr2Reg<BaseAddress + 0x0308>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr3Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief IPR_N0 field\n     *\n     * IPR_N0\n     */\n\
    \    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    /**\n     * @brief\
    \ IPR_N1 field\n     *\n     * IPR_N1\n     */\n    using ipr_n1 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    /**\n     * @brief IPR_N2 field\n     *\n     * IPR_N2\n\
    \     */\n    using ipr_n2 = FieldModel<uint32_t, address, 16, 8>;\n    /**\n\
    \     * @brief IPR_N3 field\n     *\n     * IPR_N3\n     */\n    using ipr_n3\
    \ = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ IPR_N0 field\n       *\n       * IPR_N0\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      /**\n       * @brief IPR_N1 field\n       *\n       * IPR_N1\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      /**\n       * @brief\
    \ IPR_N2 field\n       *\n       * IPR_N2\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      /**\n       * @brief IPR_N3 field\n       *\n       *\
    \ IPR_N3\n       */\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief IPR3 register\n   *\n   * Interrupt Priority Register\n\
    \   */\n  using ipr3 = Ipr3Reg<BaseAddress + 0x030C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr4Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief IPR_N0 field\n     *\n     * IPR_N0\n     */\n\
    \    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    /**\n     * @brief\
    \ IPR_N1 field\n     *\n     * IPR_N1\n     */\n    using ipr_n1 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    /**\n     * @brief IPR_N2 field\n     *\n     * IPR_N2\n\
    \     */\n    using ipr_n2 = FieldModel<uint32_t, address, 16, 8>;\n    /**\n\
    \     * @brief IPR_N3 field\n     *\n     * IPR_N3\n     */\n    using ipr_n3\
    \ = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ IPR_N0 field\n       *\n       * IPR_N0\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      /**\n       * @brief IPR_N1 field\n       *\n       * IPR_N1\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      /**\n       * @brief\
    \ IPR_N2 field\n       *\n       * IPR_N2\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      /**\n       * @brief IPR_N3 field\n       *\n       *\
    \ IPR_N3\n       */\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief IPR4 register\n   *\n   * Interrupt Priority Register\n\
    \   */\n  using ipr4 = Ipr4Reg<BaseAddress + 0x0310>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr5Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief IPR_N0 field\n     *\n     * IPR_N0\n     */\n\
    \    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    /**\n     * @brief\
    \ IPR_N1 field\n     *\n     * IPR_N1\n     */\n    using ipr_n1 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    /**\n     * @brief IPR_N2 field\n     *\n     * IPR_N2\n\
    \     */\n    using ipr_n2 = FieldModel<uint32_t, address, 16, 8>;\n    /**\n\
    \     * @brief IPR_N3 field\n     *\n     * IPR_N3\n     */\n    using ipr_n3\
    \ = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ IPR_N0 field\n       *\n       * IPR_N0\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      /**\n       * @brief IPR_N1 field\n       *\n       * IPR_N1\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      /**\n       * @brief\
    \ IPR_N2 field\n       *\n       * IPR_N2\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      /**\n       * @brief IPR_N3 field\n       *\n       *\
    \ IPR_N3\n       */\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief IPR5 register\n   *\n   * Interrupt Priority Register\n\
    \   */\n  using ipr5 = Ipr5Reg<BaseAddress + 0x0314>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr6Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief IPR_N0 field\n     *\n     * IPR_N0\n     */\n\
    \    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    /**\n     * @brief\
    \ IPR_N1 field\n     *\n     * IPR_N1\n     */\n    using ipr_n1 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    /**\n     * @brief IPR_N2 field\n     *\n     * IPR_N2\n\
    \     */\n    using ipr_n2 = FieldModel<uint32_t, address, 16, 8>;\n    /**\n\
    \     * @brief IPR_N3 field\n     *\n     * IPR_N3\n     */\n    using ipr_n3\
    \ = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ IPR_N0 field\n       *\n       * IPR_N0\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      /**\n       * @brief IPR_N1 field\n       *\n       * IPR_N1\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      /**\n       * @brief\
    \ IPR_N2 field\n       *\n       * IPR_N2\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      /**\n       * @brief IPR_N3 field\n       *\n       *\
    \ IPR_N3\n       */\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief IPR6 register\n   *\n   * Interrupt Priority Register\n\
    \   */\n  using ipr6 = Ipr6Reg<BaseAddress + 0x0318>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr7Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief IPR_N0 field\n     *\n     * IPR_N0\n     */\n\
    \    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    /**\n     * @brief\
    \ IPR_N1 field\n     *\n     * IPR_N1\n     */\n    using ipr_n1 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    /**\n     * @brief IPR_N2 field\n     *\n     * IPR_N2\n\
    \     */\n    using ipr_n2 = FieldModel<uint32_t, address, 16, 8>;\n    /**\n\
    \     * @brief IPR_N3 field\n     *\n     * IPR_N3\n     */\n    using ipr_n3\
    \ = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ IPR_N0 field\n       *\n       * IPR_N0\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      /**\n       * @brief IPR_N1 field\n       *\n       * IPR_N1\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      /**\n       * @brief\
    \ IPR_N2 field\n       *\n       * IPR_N2\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      /**\n       * @brief IPR_N3 field\n       *\n       *\
    \ IPR_N3\n       */\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief IPR7 register\n   *\n   * Interrupt Priority Register\n\
    \   */\n  using ipr7 = Ipr7Reg<BaseAddress + 0x031C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr8Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief IPR_N0 field\n     *\n     * IPR_N0\n     */\n\
    \    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    /**\n     * @brief\
    \ IPR_N1 field\n     *\n     * IPR_N1\n     */\n    using ipr_n1 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    /**\n     * @brief IPR_N2 field\n     *\n     * IPR_N2\n\
    \     */\n    using ipr_n2 = FieldModel<uint32_t, address, 16, 8>;\n    /**\n\
    \     * @brief IPR_N3 field\n     *\n     * IPR_N3\n     */\n    using ipr_n3\
    \ = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ IPR_N0 field\n       *\n       * IPR_N0\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      /**\n       * @brief IPR_N1 field\n       *\n       * IPR_N1\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      /**\n       * @brief\
    \ IPR_N2 field\n       *\n       * IPR_N2\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      /**\n       * @brief IPR_N3 field\n       *\n       *\
    \ IPR_N3\n       */\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief IPR8 register\n   *\n   * Interrupt Priority Register\n\
    \   */\n  using ipr8 = Ipr8Reg<BaseAddress + 0x0320>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr9Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief IPR_N0 field\n     *\n     * IPR_N0\n     */\n\
    \    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    /**\n     * @brief\
    \ IPR_N1 field\n     *\n     * IPR_N1\n     */\n    using ipr_n1 = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    /**\n     * @brief IPR_N2 field\n     *\n     * IPR_N2\n\
    \     */\n    using ipr_n2 = FieldModel<uint32_t, address, 16, 8>;\n    /**\n\
    \     * @brief IPR_N3 field\n     *\n     * IPR_N3\n     */\n    using ipr_n3\
    \ = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ IPR_N0 field\n       *\n       * IPR_N0\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      /**\n       * @brief IPR_N1 field\n       *\n       * IPR_N1\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      /**\n       * @brief\
    \ IPR_N2 field\n       *\n       * IPR_N2\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      /**\n       * @brief IPR_N3 field\n       *\n       *\
    \ IPR_N3\n       */\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief IPR9 register\n   *\n   * Interrupt Priority Register\n\
    \   */\n  using ipr9 = Ipr9Reg<BaseAddress + 0x0324>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr10Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief IPR_N0 field\n     *\n     * IPR_N0\n \
    \    */\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    /**\n  \
    \   * @brief IPR_N1 field\n     *\n     * IPR_N1\n     */\n    using ipr_n1 =\
    \ FieldModel<uint32_t, address, 8, 8>;\n    /**\n     * @brief IPR_N2 field\n\
    \     *\n     * IPR_N2\n     */\n    using ipr_n2 = FieldModel<uint32_t, address,\
    \ 16, 8>;\n    /**\n     * @brief IPR_N3 field\n     *\n     * IPR_N3\n     */\n\
    \    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ IPR_N0 field\n       *\n       * IPR_N0\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      /**\n       * @brief IPR_N1 field\n       *\n       * IPR_N1\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      /**\n       * @brief\
    \ IPR_N2 field\n       *\n       * IPR_N2\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      /**\n       * @brief IPR_N3 field\n       *\n       *\
    \ IPR_N3\n       */\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief IPR10 register\n   *\n   * Interrupt Priority Register\n\
    \   */\n  using ipr10 = Ipr10Reg<BaseAddress + 0x0328>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr11Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief IPR_N0 field\n     *\n     * IPR_N0\n \
    \    */\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    /**\n  \
    \   * @brief IPR_N1 field\n     *\n     * IPR_N1\n     */\n    using ipr_n1 =\
    \ FieldModel<uint32_t, address, 8, 8>;\n    /**\n     * @brief IPR_N2 field\n\
    \     *\n     * IPR_N2\n     */\n    using ipr_n2 = FieldModel<uint32_t, address,\
    \ 16, 8>;\n    /**\n     * @brief IPR_N3 field\n     *\n     * IPR_N3\n     */\n\
    \    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ IPR_N0 field\n       *\n       * IPR_N0\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      /**\n       * @brief IPR_N1 field\n       *\n       * IPR_N1\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      /**\n       * @brief\
    \ IPR_N2 field\n       *\n       * IPR_N2\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      /**\n       * @brief IPR_N3 field\n       *\n       *\
    \ IPR_N3\n       */\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief IPR11 register\n   *\n   * Interrupt Priority Register\n\
    \   */\n  using ipr11 = Ipr11Reg<BaseAddress + 0x032C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr12Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief IPR_N0 field\n     *\n     * IPR_N0\n \
    \    */\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    /**\n  \
    \   * @brief IPR_N1 field\n     *\n     * IPR_N1\n     */\n    using ipr_n1 =\
    \ FieldModel<uint32_t, address, 8, 8>;\n    /**\n     * @brief IPR_N2 field\n\
    \     *\n     * IPR_N2\n     */\n    using ipr_n2 = FieldModel<uint32_t, address,\
    \ 16, 8>;\n    /**\n     * @brief IPR_N3 field\n     *\n     * IPR_N3\n     */\n\
    \    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ IPR_N0 field\n       *\n       * IPR_N0\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      /**\n       * @brief IPR_N1 field\n       *\n       * IPR_N1\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      /**\n       * @brief\
    \ IPR_N2 field\n       *\n       * IPR_N2\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      /**\n       * @brief IPR_N3 field\n       *\n       *\
    \ IPR_N3\n       */\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief IPR12 register\n   *\n   * Interrupt Priority Register\n\
    \   */\n  using ipr12 = Ipr12Reg<BaseAddress + 0x0330>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr13Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief IPR_N0 field\n     *\n     * IPR_N0\n \
    \    */\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    /**\n  \
    \   * @brief IPR_N1 field\n     *\n     * IPR_N1\n     */\n    using ipr_n1 =\
    \ FieldModel<uint32_t, address, 8, 8>;\n    /**\n     * @brief IPR_N2 field\n\
    \     *\n     * IPR_N2\n     */\n    using ipr_n2 = FieldModel<uint32_t, address,\
    \ 16, 8>;\n    /**\n     * @brief IPR_N3 field\n     *\n     * IPR_N3\n     */\n\
    \    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ IPR_N0 field\n       *\n       * IPR_N0\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      /**\n       * @brief IPR_N1 field\n       *\n       * IPR_N1\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      /**\n       * @brief\
    \ IPR_N2 field\n       *\n       * IPR_N2\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      /**\n       * @brief IPR_N3 field\n       *\n       *\
    \ IPR_N3\n       */\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief IPR13 register\n   *\n   * Interrupt Priority Register\n\
    \   */\n  using ipr13 = Ipr13Reg<BaseAddress + 0x0334>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr14Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief IPR_N0 field\n     *\n     * IPR_N0\n \
    \    */\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    /**\n  \
    \   * @brief IPR_N1 field\n     *\n     * IPR_N1\n     */\n    using ipr_n1 =\
    \ FieldModel<uint32_t, address, 8, 8>;\n    /**\n     * @brief IPR_N2 field\n\
    \     *\n     * IPR_N2\n     */\n    using ipr_n2 = FieldModel<uint32_t, address,\
    \ 16, 8>;\n    /**\n     * @brief IPR_N3 field\n     *\n     * IPR_N3\n     */\n\
    \    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ IPR_N0 field\n       *\n       * IPR_N0\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      /**\n       * @brief IPR_N1 field\n       *\n       * IPR_N1\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      /**\n       * @brief\
    \ IPR_N2 field\n       *\n       * IPR_N2\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      /**\n       * @brief IPR_N3 field\n       *\n       *\
    \ IPR_N3\n       */\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief IPR14 register\n   *\n   * Interrupt Priority Register\n\
    \   */\n  using ipr14 = Ipr14Reg<BaseAddress + 0x0338>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr15Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief IPR_N0 field\n     *\n     * IPR_N0\n \
    \    */\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    /**\n  \
    \   * @brief IPR_N1 field\n     *\n     * IPR_N1\n     */\n    using ipr_n1 =\
    \ FieldModel<uint32_t, address, 8, 8>;\n    /**\n     * @brief IPR_N2 field\n\
    \     *\n     * IPR_N2\n     */\n    using ipr_n2 = FieldModel<uint32_t, address,\
    \ 16, 8>;\n    /**\n     * @brief IPR_N3 field\n     *\n     * IPR_N3\n     */\n\
    \    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ IPR_N0 field\n       *\n       * IPR_N0\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      /**\n       * @brief IPR_N1 field\n       *\n       * IPR_N1\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      /**\n       * @brief\
    \ IPR_N2 field\n       *\n       * IPR_N2\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      /**\n       * @brief IPR_N3 field\n       *\n       *\
    \ IPR_N3\n       */\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief IPR15 register\n   *\n   * Interrupt Priority Register\n\
    \   */\n  using ipr15 = Ipr15Reg<BaseAddress + 0x033C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr16Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief IPR_N0 field\n     *\n     * IPR_N0\n \
    \    */\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    /**\n  \
    \   * @brief IPR_N1 field\n     *\n     * IPR_N1\n     */\n    using ipr_n1 =\
    \ FieldModel<uint32_t, address, 8, 8>;\n    /**\n     * @brief IPR_N2 field\n\
    \     *\n     * IPR_N2\n     */\n    using ipr_n2 = FieldModel<uint32_t, address,\
    \ 16, 8>;\n    /**\n     * @brief IPR_N3 field\n     *\n     * IPR_N3\n     */\n\
    \    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ IPR_N0 field\n       *\n       * IPR_N0\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      /**\n       * @brief IPR_N1 field\n       *\n       * IPR_N1\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      /**\n       * @brief\
    \ IPR_N2 field\n       *\n       * IPR_N2\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      /**\n       * @brief IPR_N3 field\n       *\n       *\
    \ IPR_N3\n       */\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief IPR16 register\n   *\n   * Interrupt Priority Register\n\
    \   */\n  using ipr16 = Ipr16Reg<BaseAddress + 0x0340>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr17Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief IPR_N0 field\n     *\n     * IPR_N0\n \
    \    */\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    /**\n  \
    \   * @brief IPR_N1 field\n     *\n     * IPR_N1\n     */\n    using ipr_n1 =\
    \ FieldModel<uint32_t, address, 8, 8>;\n    /**\n     * @brief IPR_N2 field\n\
    \     *\n     * IPR_N2\n     */\n    using ipr_n2 = FieldModel<uint32_t, address,\
    \ 16, 8>;\n    /**\n     * @brief IPR_N3 field\n     *\n     * IPR_N3\n     */\n\
    \    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ IPR_N0 field\n       *\n       * IPR_N0\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      /**\n       * @brief IPR_N1 field\n       *\n       * IPR_N1\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      /**\n       * @brief\
    \ IPR_N2 field\n       *\n       * IPR_N2\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      /**\n       * @brief IPR_N3 field\n       *\n       *\
    \ IPR_N3\n       */\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief IPR17 register\n   *\n   * Interrupt Priority Register\n\
    \   */\n  using ipr17 = Ipr17Reg<BaseAddress + 0x0344>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr18Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief IPR_N0 field\n     *\n     * IPR_N0\n \
    \    */\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    /**\n  \
    \   * @brief IPR_N1 field\n     *\n     * IPR_N1\n     */\n    using ipr_n1 =\
    \ FieldModel<uint32_t, address, 8, 8>;\n    /**\n     * @brief IPR_N2 field\n\
    \     *\n     * IPR_N2\n     */\n    using ipr_n2 = FieldModel<uint32_t, address,\
    \ 16, 8>;\n    /**\n     * @brief IPR_N3 field\n     *\n     * IPR_N3\n     */\n\
    \    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ IPR_N0 field\n       *\n       * IPR_N0\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      /**\n       * @brief IPR_N1 field\n       *\n       * IPR_N1\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      /**\n       * @brief\
    \ IPR_N2 field\n       *\n       * IPR_N2\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      /**\n       * @brief IPR_N3 field\n       *\n       *\
    \ IPR_N3\n       */\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief IPR18 register\n   *\n   * Interrupt Priority Register\n\
    \   */\n  using ipr18 = Ipr18Reg<BaseAddress + 0x0348>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr19Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief IPR_N0 field\n     *\n     * IPR_N0\n \
    \    */\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8>;\n    /**\n  \
    \   * @brief IPR_N1 field\n     *\n     * IPR_N1\n     */\n    using ipr_n1 =\
    \ FieldModel<uint32_t, address, 8, 8>;\n    /**\n     * @brief IPR_N2 field\n\
    \     *\n     * IPR_N2\n     */\n    using ipr_n2 = FieldModel<uint32_t, address,\
    \ 16, 8>;\n    /**\n     * @brief IPR_N3 field\n     *\n     * IPR_N3\n     */\n\
    \    using ipr_n3 = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ IPR_N0 field\n       *\n       * IPR_N0\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 8> ipr_n0;\n      /**\n       * @brief IPR_N1 field\n       *\n       * IPR_N1\n\
    \       */\n      BitFieldModel<uint32_t, 8, 8> ipr_n1;\n      /**\n       * @brief\
    \ IPR_N2 field\n       *\n       * IPR_N2\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 8> ipr_n2;\n      /**\n       * @brief IPR_N3 field\n       *\n       *\
    \ IPR_N3\n       */\n      BitFieldModel<uint32_t, 24, 8> ipr_n3;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief IPR19 register\n   *\n   * Interrupt Priority Register\n\
    \   */\n  using ipr19 = Ipr19Reg<BaseAddress + 0x034C>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr20Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n\n  public:\n    /**\n     * @brief Register union\n     *\n \
    \    * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n    };\n  };\n\npublic:\n  /**\n   * @brief IPR20\
    \ register\n   *\n   * Interrupt Priority Register\n   */\n  using ipr20 = Ipr20Reg<BaseAddress\
    \ + 0x0350>;\n\nprivate:\n  template<unsigned int address>\n  class Ipr21Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief IPR21 register\n   *\n   * Interrupt Priority Register\n \
    \  */\n  using ipr21 = Ipr21Reg<BaseAddress + 0x0354>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Ipr22Reg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n\n  public:\n    /**\n     * @brief Register union\n     *\n \
    \    * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n    };\n  };\n\npublic:\n  /**\n   * @brief IPR22\
    \ register\n   *\n   * Interrupt Priority Register\n   */\n  using ipr22 = Ipr22Reg<BaseAddress\
    \ + 0x0358>;\n\nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n\
    \  class IserxBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n\
    \  {\n  public:\n    /**\n     * @brief SETENA field\n     *\n     * SETENA\n\
    \     */\n    using setena = FieldModel<uint32_t, address, 0, 32, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      /**\n       *\
    \ @brief SETENA field\n       *\n       * SETENA\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> setena;\n    };\n  };\n\npublic:\n  /**\n   * @brief ISERX register bank\n\
    \   *\n   * Interrupt Set-Enable Register\n   */\n  using iserx = IserxBankReg<BaseAddress\
    \ + 0x0000, 0x0004>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class IcerxBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    /**\n     * @brief CLRENA field\n     *\n \
    \    * CLRENA\n     */\n    using clrena = FieldModel<uint32_t, address, 0, 32,\
    \ bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n   \
    \   /**\n       * @brief CLRENA field\n       *\n       * CLRENA\n       */\n\
    \      BitFieldModel<uint32_t, 0, 32> clrena;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief ICERX register bank\n   *\n   * Interrupt Clear-Enable\n   *    \
    \       Register\n   */\n  using icerx = IcerxBankReg<BaseAddress + 0x0080, 0x0004>;\n\
    \nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n  class\
    \ IsprxBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n  {\n\
    \  public:\n    /**\n     * @brief SETPEND field\n     *\n     * SETPEND\n   \
    \  */\n    using setpend = FieldModel<uint32_t, address, 0, 32, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      /**\n       *\
    \ @brief SETPEND field\n       *\n       * SETPEND\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> setpend;\n    };\n  };\n\npublic:\n  /**\n   * @brief ISPRX register\
    \ bank\n   *\n   * Interrupt Set-Pending Register\n   */\n  using isprx = IsprxBankReg<BaseAddress\
    \ + 0x0100, 0x0004>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class IcprxBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    /**\n     * @brief CLRPEND field\n     *\n\
    \     * CLRPEND\n     */\n    using clrpend = FieldModel<uint32_t, address, 0,\
    \ 32, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t value;\n\
    \      /**\n       * @brief CLRPEND field\n       *\n       * CLRPEND\n      \
    \ */\n      BitFieldModel<uint32_t, 0, 32> clrpend;\n    };\n  };\n\npublic:\n\
    \  /**\n   * @brief ICPRX register bank\n   *\n   * Interrupt Clear-Pending\n\
    \   *           Register\n   */\n  using icprx = IcprxBankReg<BaseAddress + 0x0180,\
    \ 0x0004>;\n\nprivate:\n  template<unsigned int address, unsigned int bankOffset>\n\
    \  class IabrxBankReg : public RegisterBankModel<uint32_t, address, bankOffset>\n\
    \  {\n  public:\n    /**\n     * @brief ACTIVE field\n     *\n     * ACTIVE\n\
    \     */\n    using active = FieldModel<uint32_t, address, 0, 32, bankOffset>;\n\
    \n  public:\n    union reg\n    {\n      uint32_t value;\n      /**\n       *\
    \ @brief ACTIVE field\n       *\n       * ACTIVE\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 32> active;\n    };\n  };\n\npublic:\n  /**\n   * @brief IABRX register bank\n\
    \   *\n   * Interrupt Active Bit Register\n   */\n  using iabrx = IabrxBankReg<BaseAddress\
    \ + 0x0200, 0x0004>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class IprxBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n    /**\n     * @brief IPR_N0 field\n     *\n \
    \    * IPR_N0\n     */\n    using ipr_n0 = FieldModel<uint32_t, address, 0, 8,\
    \ bankOffset>;\n    /**\n     * @brief IPR_N1 field\n     *\n     * IPR_N1\n \
    \    */\n    using ipr_n1 = FieldModel<uint32_t, address, 8, 8, bankOffset>;\n\
    \    /**\n     * @brief IPR_N2 field\n     *\n     * IPR_N2\n     */\n    using\
    \ ipr_n2 = FieldModel<uint32_t, address, 16, 8, bankOffset>;\n    /**\n     *\
    \ @brief IPR_N3 field\n     *\n     * IPR_N3\n     */\n    using ipr_n3 = FieldModel<uint32_t,\
    \ address, 24, 8, bankOffset>;\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief IPR_N0 field\n       *\n       * IPR_N0\n\
    \       */\n      BitFieldModel<uint32_t, 0, 8> ipr_n0;\n      /**\n       * @brief\
    \ IPR_N1 field\n       *\n       * IPR_N1\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 8> ipr_n1;\n      /**\n       * @brief IPR_N2 field\n       *\n       * IPR_N2\n\
    \       */\n      BitFieldModel<uint32_t, 16, 8> ipr_n2;\n      /**\n       *\
    \ @brief IPR_N3 field\n       *\n       * IPR_N3\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 8> ipr_n3;\n    };\n  };\n\npublic:\n  /**\n   * @brief IPRX register bank\n\
    \   *\n   * Interrupt Priority Register\n   */\n  using iprx = IprxBankReg<BaseAddress\
    \ + 0x0300, 0x0004>;\n\nprivate:\n  template<unsigned int address, unsigned int\
    \ bankOffset>\n  class Ipr2xBankReg : public RegisterBankModel<uint32_t, address,\
    \ bankOffset>\n  {\n  public:\n\n  public:\n    union reg\n    {\n      uint32_t\
    \ value;\n    };\n  };\n\npublic:\n  /**\n   * @brief IPR2X register bank\n  \
    \ *\n   * Interrupt Priority Register\n   */\n  using ipr2x = Ipr2xBankReg<BaseAddress\
    \ + 0x0350, 0x0004>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_NVIC_H */"
  name: NVIC
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_FPU_H\n#define DRAL_STM32F411_FPU_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ FPU peripheral\n *\n * Floting point unit\n */\nclass fpu\n{\npublic:\n  static\
    \ constexpr unsigned int BaseAddress = 0xE000EF34; /**< Peripheral base address\
    \ */\n\nprivate:\n  template<unsigned int address>\n  class FpccrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief LSPACT\
    \ field\n     *\n     * LSPACT\n     */\n    using lspact = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    /**\n     * @brief USER field\n     *\n     * USER\n  \
    \   */\n    using user = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     *\
    \ @brief THREAD field\n     *\n     * THREAD\n     */\n    using thread = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief HFRDY field\n     *\n     * HFRDY\n\
    \     */\n    using hfrdy = FieldModel<uint32_t, address, 4, 1>;\n    /**\n  \
    \   * @brief MMRDY field\n     *\n     * MMRDY\n     */\n    using mmrdy = FieldModel<uint32_t,\
    \ address, 5, 1>;\n    /**\n     * @brief BFRDY field\n     *\n     * BFRDY\n\
    \     */\n    using bfrdy = FieldModel<uint32_t, address, 6, 1>;\n    /**\n  \
    \   * @brief MONRDY field\n     *\n     * MONRDY\n     */\n    using monrdy =\
    \ FieldModel<uint32_t, address, 8, 1>;\n    /**\n     * @brief LSPEN field\n \
    \    *\n     * LSPEN\n     */\n    using lspen = FieldModel<uint32_t, address,\
    \ 30, 1>;\n    /**\n     * @brief ASPEN field\n     *\n     * ASPEN\n     */\n\
    \    using aspen = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ LSPACT field\n       *\n       * LSPACT\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> lspact;\n      /**\n       * @brief USER field\n       *\n       * USER\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> user;\n      /**\n       * @brief\
    \ THREAD field\n       *\n       * THREAD\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> thread;\n      /**\n       * @brief HFRDY field\n       *\n       * HFRDY\n\
    \       */\n      BitFieldModel<uint32_t, 4, 1> hfrdy;\n      /**\n       * @brief\
    \ MMRDY field\n       *\n       * MMRDY\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> mmrdy;\n      /**\n       * @brief BFRDY field\n       *\n       * BFRDY\n\
    \       */\n      BitFieldModel<uint32_t, 6, 1> bfrdy;\n      /**\n       * @brief\
    \ MONRDY field\n       *\n       * MONRDY\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> monrdy;\n      /**\n       * @brief LSPEN field\n       *\n       * LSPEN\n\
    \       */\n      BitFieldModel<uint32_t, 30, 1> lspen;\n      /**\n       * @brief\
    \ ASPEN field\n       *\n       * ASPEN\n       */\n      BitFieldModel<uint32_t,\
    \ 31, 1> aspen;\n    };\n  };\n\npublic:\n  /**\n   * @brief FPCCR register\n\
    \   *\n   * Floating-point context control\n   *           register\n   */\n \
    \ using fpccr = FpccrReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class FpcarReg : public RegisterModel<uint32_t, address>\n \
    \ {\n  public:\n    /**\n     * @brief ADDRESS field\n     *\n     * Location\
    \ of unpopulated\n     *               floating-point\n     */\n    using address_\
    \ = FieldModel<uint32_t, address, 3, 29>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ ADDRESS field\n       *\n       * Location of unpopulated\n       *        \
    \       floating-point\n       */\n      BitFieldModel<uint32_t, 3, 29> address_;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief FPCAR register\n   *\n   * Floating-point\
    \ context address\n   *           register\n   */\n  using fpcar = FpcarReg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class FpscrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ IOC field\n     *\n     * Invalid operation cumulative exception\n     *   \
    \            bit\n     */\n    using ioc = FieldModel<uint32_t, address, 0, 1>;\n\
    \    /**\n     * @brief DZC field\n     *\n     * Division by zero cumulative\
    \ exception\n     *               bit.\n     */\n    using dzc = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief OFC field\n     *\n     * Overflow cumulative\
    \ exception\n     *               bit\n     */\n    using ofc = FieldModel<uint32_t,\
    \ address, 2, 1>;\n    /**\n     * @brief UFC field\n     *\n     * Underflow\
    \ cumulative exception\n     *               bit\n     */\n    using ufc = FieldModel<uint32_t,\
    \ address, 3, 1>;\n    /**\n     * @brief IXC field\n     *\n     * Inexact cumulative\
    \ exception\n     *               bit\n     */\n    using ixc = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief IDC field\n     *\n     * Input denormal\
    \ cumulative exception\n     *               bit.\n     */\n    using idc = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief RMODE field\n     *\n     * Rounding\
    \ Mode control\n     *               field\n     */\n    using rmode = FieldModel<uint32_t,\
    \ address, 22, 2>;\n    /**\n     * @brief FZ field\n     *\n     * Flush-to-zero\
    \ mode control\n     *               bit:\n     */\n    using fz = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    /**\n     * @brief DN field\n     *\n     * Default NaN\
    \ mode control\n     *               bit\n     */\n    using dn = FieldModel<uint32_t,\
    \ address, 25, 1>;\n    /**\n     * @brief AHP field\n     *\n     * Alternative\
    \ half-precision control\n     *               bit\n     */\n    using ahp = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    /**\n     * @brief V field\n     *\n     * Overflow condition\
    \ code\n     *               flag\n     */\n    using v = FieldModel<uint32_t,\
    \ address, 28, 1>;\n    /**\n     * @brief C field\n     *\n     * Carry condition\
    \ code flag\n     */\n    using c = FieldModel<uint32_t, address, 29, 1>;\n  \
    \  /**\n     * @brief Z field\n     *\n     * Zero condition code flag\n     */\n\
    \    using z = FieldModel<uint32_t, address, 30, 1>;\n    /**\n     * @brief N\
    \ field\n     *\n     * Negative condition code\n     *               flag\n \
    \    */\n    using n = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n  \
    \  /**\n     * @brief Register union\n     *\n     * Can be used to create a local\
    \ register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief IOC field\n       *\n       * Invalid operation cumulative exception\n\
    \       *               bit\n       */\n      BitFieldModel<uint32_t, 0, 1> ioc;\n\
    \      /**\n       * @brief DZC field\n       *\n       * Division by zero cumulative\
    \ exception\n       *               bit.\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> dzc;\n      /**\n       * @brief OFC field\n       *\n       * Overflow\
    \ cumulative exception\n       *               bit\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> ofc;\n      /**\n       * @brief UFC field\n       *\n       * Underflow\
    \ cumulative exception\n       *               bit\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> ufc;\n      /**\n       * @brief IXC field\n       *\n       * Inexact\
    \ cumulative exception\n       *               bit\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 1> ixc;\n      /**\n       * @brief IDC field\n       *\n       * Input denormal\
    \ cumulative exception\n       *               bit.\n       */\n      BitFieldModel<uint32_t,\
    \ 7, 1> idc;\n      /**\n       * @brief RMODE field\n       *\n       * Rounding\
    \ Mode control\n       *               field\n       */\n      BitFieldModel<uint32_t,\
    \ 22, 2> rmode;\n      /**\n       * @brief FZ field\n       *\n       * Flush-to-zero\
    \ mode control\n       *               bit:\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 1> fz;\n      /**\n       * @brief DN field\n       *\n       * Default\
    \ NaN mode control\n       *               bit\n       */\n      BitFieldModel<uint32_t,\
    \ 25, 1> dn;\n      /**\n       * @brief AHP field\n       *\n       * Alternative\
    \ half-precision control\n       *               bit\n       */\n      BitFieldModel<uint32_t,\
    \ 26, 1> ahp;\n      /**\n       * @brief V field\n       *\n       * Overflow\
    \ condition code\n       *               flag\n       */\n      BitFieldModel<uint32_t,\
    \ 28, 1> v;\n      /**\n       * @brief C field\n       *\n       * Carry condition\
    \ code flag\n       */\n      BitFieldModel<uint32_t, 29, 1> c;\n      /**\n \
    \      * @brief Z field\n       *\n       * Zero condition code flag\n       */\n\
    \      BitFieldModel<uint32_t, 30, 1> z;\n      /**\n       * @brief N field\n\
    \       *\n       * Negative condition code\n       *               flag\n   \
    \    */\n      BitFieldModel<uint32_t, 31, 1> n;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief FPSCR register\n   *\n   * Floating-point status control\n   *  \
    \         register\n   */\n  using fpscr = FpscrReg<BaseAddress + 0x0008>;\n\n\
    };\n\n}\n\n#endif /* DRAL_STM32F411_FPU_H */"
  name: FPU
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_MPU_H\n#define DRAL_STM32F411_MPU_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ MPU peripheral\n *\n * Memory protection unit\n */\nclass mpu\n{\npublic:\n\
    \  static constexpr unsigned int BaseAddress = 0xE000ED90; /**< Peripheral base\
    \ address */\n\nprivate:\n  template<unsigned int address>\n  class Mpu_typerReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ SEPARATE field\n     *\n     * Separate flag\n     */\n    using separate =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief DREGION field\n\
    \     *\n     * Number of MPU data regions\n     */\n    using dregion = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    /**\n     * @brief IREGION field\n     *\n     * Number\
    \ of MPU instruction\n     *               regions\n     */\n    using iregion\
    \ = FieldModel<uint32_t, address, 16, 8>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ SEPARATE field\n       *\n       * Separate flag\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> separate;\n      /**\n       * @brief DREGION field\n       *\n      \
    \ * Number of MPU data regions\n       */\n      BitFieldModel<uint32_t, 8, 8>\
    \ dregion;\n      /**\n       * @brief IREGION field\n       *\n       * Number\
    \ of MPU instruction\n       *               regions\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 8> iregion;\n    };\n  };\n\npublic:\n  /**\n   * @brief MPU_TYPER register\n\
    \   *\n   * MPU type register\n   */\n  using mpu_typer = Mpu_typerReg<BaseAddress\
    \ + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n  class Mpu_ctrlReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ ENABLE field\n     *\n     * Enables the MPU\n     */\n    using enable = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    /**\n     * @brief HFNMIENA field\n     *\n     * Enables\
    \ the operation of MPU during hard\n     *               fault\n     */\n    using\
    \ hfnmiena = FieldModel<uint32_t, address, 1, 1>;\n    /**\n     * @brief PRIVDEFENA\
    \ field\n     *\n     * Enable priviliged software access to\n     *         \
    \      default memory map\n     */\n    using privdefena = FieldModel<uint32_t,\
    \ address, 2, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief ENABLE field\n       *\n\
    \       * Enables the MPU\n       */\n      BitFieldModel<uint32_t, 0, 1> enable;\n\
    \      /**\n       * @brief HFNMIENA field\n       *\n       * Enables the operation\
    \ of MPU during hard\n       *               fault\n       */\n      BitFieldModel<uint32_t,\
    \ 1, 1> hfnmiena;\n      /**\n       * @brief PRIVDEFENA field\n       *\n   \
    \    * Enable priviliged software access to\n       *               default memory\
    \ map\n       */\n      BitFieldModel<uint32_t, 2, 1> privdefena;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief MPU_CTRL register\n   *\n   * MPU control register\n\
    \   */\n  using mpu_ctrl = Mpu_ctrlReg<BaseAddress + 0x0004>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Mpu_rnrReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief REGION field\n     *\n     * MPU region\n\
    \     */\n    using region = FieldModel<uint32_t, address, 0, 8>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief REGION field\n       *\n       * MPU region\n       */\n    \
    \  BitFieldModel<uint32_t, 0, 8> region;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief MPU_RNR register\n   *\n   * MPU region number register\n   */\n  using\
    \ mpu_rnr = Mpu_rnrReg<BaseAddress + 0x0008>;\n\nprivate:\n  template<unsigned\
    \ int address>\n  class Mpu_rbarReg : public RegisterModel<uint32_t, address>\n\
    \  {\n  public:\n    /**\n     * @brief REGION field\n     *\n     * MPU region\
    \ field\n     */\n    using region = FieldModel<uint32_t, address, 0, 4>;\n  \
    \  /**\n     * @brief VALID field\n     *\n     * MPU region number valid\n  \
    \   */\n    using valid = FieldModel<uint32_t, address, 4, 1>;\n    /**\n    \
    \ * @brief ADDR field\n     *\n     * Region base address field\n     */\n   \
    \ using addr = FieldModel<uint32_t, address, 5, 27>;\n\n  public:\n    /**\n \
    \    * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ REGION field\n       *\n       * MPU region field\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> region;\n      /**\n       * @brief VALID field\n       *\n       * MPU\
    \ region number valid\n       */\n      BitFieldModel<uint32_t, 4, 1> valid;\n\
    \      /**\n       * @brief ADDR field\n       *\n       * Region base address\
    \ field\n       */\n      BitFieldModel<uint32_t, 5, 27> addr;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief MPU_RBAR register\n   *\n   * MPU region base address\n\
    \   *           register\n   */\n  using mpu_rbar = Mpu_rbarReg<BaseAddress +\
    \ 0x000C>;\n\nprivate:\n  template<unsigned int address>\n  class Mpu_rasrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ ENABLE field\n     *\n     * Region enable bit.\n     */\n    using enable =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief SIZE field\n  \
    \   *\n     * Size of the MPU protection\n     *               region\n     */\n\
    \    using size = FieldModel<uint32_t, address, 1, 5>;\n    /**\n     * @brief\
    \ SRD field\n     *\n     * Subregion disable bits\n     */\n    using srd = FieldModel<uint32_t,\
    \ address, 8, 8>;\n    /**\n     * @brief B field\n     *\n     * memory attribute\n\
    \     */\n    using b = FieldModel<uint32_t, address, 16, 1>;\n    /**\n     *\
    \ @brief C field\n     *\n     * memory attribute\n     */\n    using c = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    /**\n     * @brief S field\n     *\n     * Shareable memory\
    \ attribute\n     */\n    using s = FieldModel<uint32_t, address, 18, 1>;\n  \
    \  /**\n     * @brief TEX field\n     *\n     * memory attribute\n     */\n  \
    \  using tex = FieldModel<uint32_t, address, 19, 3>;\n    /**\n     * @brief AP\
    \ field\n     *\n     * Access permission\n     */\n    using ap = FieldModel<uint32_t,\
    \ address, 24, 3>;\n    /**\n     * @brief XN field\n     *\n     * Instruction\
    \ access disable\n     *               bit\n     */\n    using xn = FieldModel<uint32_t,\
    \ address, 28, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief ENABLE field\n       *\n\
    \       * Region enable bit.\n       */\n      BitFieldModel<uint32_t, 0, 1> enable;\n\
    \      /**\n       * @brief SIZE field\n       *\n       * Size of the MPU protection\n\
    \       *               region\n       */\n      BitFieldModel<uint32_t, 1, 5>\
    \ size;\n      /**\n       * @brief SRD field\n       *\n       * Subregion disable\
    \ bits\n       */\n      BitFieldModel<uint32_t, 8, 8> srd;\n      /**\n     \
    \  * @brief B field\n       *\n       * memory attribute\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> b;\n      /**\n       * @brief C field\n       *\n       * memory attribute\n\
    \       */\n      BitFieldModel<uint32_t, 17, 1> c;\n      /**\n       * @brief\
    \ S field\n       *\n       * Shareable memory attribute\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 1> s;\n      /**\n       * @brief TEX field\n       *\n       * memory attribute\n\
    \       */\n      BitFieldModel<uint32_t, 19, 3> tex;\n      /**\n       * @brief\
    \ AP field\n       *\n       * Access permission\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 3> ap;\n      /**\n       * @brief XN field\n       *\n       * Instruction\
    \ access disable\n       *               bit\n       */\n      BitFieldModel<uint32_t,\
    \ 28, 1> xn;\n    };\n  };\n\npublic:\n  /**\n   * @brief MPU_RASR register\n\
    \   *\n   * MPU region attribute and size\n   *           register\n   */\n  using\
    \ mpu_rasr = Mpu_rasrReg<BaseAddress + 0x0010>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_MPU_H\
    \ */"
  name: MPU
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_STK_H\n#define DRAL_STM32F411_STK_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ STK peripheral\n *\n * SysTick timer\n */\nclass stk\n{\npublic:\n  static constexpr\
    \ unsigned int BaseAddress = 0xE000E010; /**< Peripheral base address */\n\nprivate:\n\
    \  template<unsigned int address>\n  class CtrlReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief ENABLE field\n     *\n    \
    \ * Counter enable\n     */\n    using enable = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    /**\n     * @brief TICKINT field\n     *\n     * SysTick exception\
    \ request\n     *               enable\n     */\n    using tickint = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief CLKSOURCE field\n     *\n     * Clock\
    \ source selection\n     */\n    using clksource = FieldModel<uint32_t, address,\
    \ 2, 1>;\n    /**\n     * @brief COUNTFLAG field\n     *\n     * COUNTFLAG\n \
    \    */\n    using countflag = FieldModel<uint32_t, address, 16, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief ENABLE field\n       *\n       * Counter enable\n       */\n\
    \      BitFieldModel<uint32_t, 0, 1> enable;\n      /**\n       * @brief TICKINT\
    \ field\n       *\n       * SysTick exception request\n       *              \
    \ enable\n       */\n      BitFieldModel<uint32_t, 1, 1> tickint;\n      /**\n\
    \       * @brief CLKSOURCE field\n       *\n       * Clock source selection\n\
    \       */\n      BitFieldModel<uint32_t, 2, 1> clksource;\n      /**\n      \
    \ * @brief COUNTFLAG field\n       *\n       * COUNTFLAG\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> countflag;\n    };\n  };\n\npublic:\n  /**\n   * @brief CTRL register\n\
    \   *\n   * SysTick control and status\n   *           register\n   */\n  using\
    \ ctrl = CtrlReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int address>\n\
    \  class LoadReg : public RegisterModel<uint32_t, address>\n  {\n  public:\n \
    \   /**\n     * @brief RELOAD field\n     *\n     * RELOAD value\n     */\n  \
    \  using reload = FieldModel<uint32_t, address, 0, 24>;\n\n  public:\n    /**\n\
    \     * @brief Register union\n     *\n     * Can be used to create a local register\
    \ variable for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ RELOAD field\n       *\n       * RELOAD value\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 24> reload;\n    };\n  };\n\npublic:\n  /**\n   * @brief LOAD register\n\
    \   *\n   * SysTick reload value register\n   */\n  using load = LoadReg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class ValReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief CURRENT\
    \ field\n     *\n     * Current counter value\n     */\n    using current = FieldModel<uint32_t,\
    \ address, 0, 24>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CURRENT field\n       *\n\
    \       * Current counter value\n       */\n      BitFieldModel<uint32_t, 0, 24>\
    \ current;\n    };\n  };\n\npublic:\n  /**\n   * @brief VAL register\n   *\n \
    \  * SysTick current value register\n   */\n  using val = ValReg<BaseAddress +\
    \ 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class CalibReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief TENMS\
    \ field\n     *\n     * Calibration value\n     */\n    using tenms = FieldModel<uint32_t,\
    \ address, 0, 24>;\n    /**\n     * @brief SKEW field\n     *\n     * SKEW flag:\
    \ Indicates whether the TENMS\n     *               value is exact\n     */\n\
    \    using skew = FieldModel<uint32_t, address, 30, 1>;\n    /**\n     * @brief\
    \ NOREF field\n     *\n     * NOREF flag. Reads as zero\n     */\n    using noref\
    \ = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ TENMS field\n       *\n       * Calibration value\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 24> tenms;\n      /**\n       * @brief SKEW field\n       *\n       * SKEW\
    \ flag: Indicates whether the TENMS\n       *               value is exact\n \
    \      */\n      BitFieldModel<uint32_t, 30, 1> skew;\n      /**\n       * @brief\
    \ NOREF field\n       *\n       * NOREF flag. Reads as zero\n       */\n     \
    \ BitFieldModel<uint32_t, 31, 1> noref;\n    };\n  };\n\npublic:\n  /**\n   *\
    \ @brief CALIB register\n   *\n   * SysTick calibration value\n   *          \
    \ register\n   */\n  using calib = CalibReg<BaseAddress + 0x000C>;\n\n};\n\n}\n\
    \n#endif /* DRAL_STM32F411_STK_H */"
  name: STK
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_SCB_H\n#define DRAL_STM32F411_SCB_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ SCB peripheral\n *\n * System control block\n */\nclass scb\n{\npublic:\n  static\
    \ constexpr unsigned int BaseAddress = 0xE000ED00; /**< Peripheral base address\
    \ */\n\nprivate:\n  template<unsigned int address>\n  class CpuidReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief REVISION\
    \ field\n     *\n     * Revision number\n     */\n    using revision = FieldModel<uint32_t,\
    \ address, 0, 4>;\n    /**\n     * @brief PARTNO field\n     *\n     * Part number\
    \ of the\n     *               processor\n     */\n    using partno = FieldModel<uint32_t,\
    \ address, 4, 12>;\n    /**\n     * @brief CONSTANT field\n     *\n     * Reads\
    \ as 0xF\n     */\n    using constant = FieldModel<uint32_t, address, 16, 4>;\n\
    \    /**\n     * @brief VARIANT field\n     *\n     * Variant number\n     */\n\
    \    using variant = FieldModel<uint32_t, address, 20, 4>;\n    /**\n     * @brief\
    \ IMPLEMENTER field\n     *\n     * Implementer code\n     */\n    using implementer\
    \ = FieldModel<uint32_t, address, 24, 8>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ REVISION field\n       *\n       * Revision number\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 4> revision;\n      /**\n       * @brief PARTNO field\n       *\n       *\
    \ Part number of the\n       *               processor\n       */\n      BitFieldModel<uint32_t,\
    \ 4, 12> partno;\n      /**\n       * @brief CONSTANT field\n       *\n      \
    \ * Reads as 0xF\n       */\n      BitFieldModel<uint32_t, 16, 4> constant;\n\
    \      /**\n       * @brief VARIANT field\n       *\n       * Variant number\n\
    \       */\n      BitFieldModel<uint32_t, 20, 4> variant;\n      /**\n       *\
    \ @brief IMPLEMENTER field\n       *\n       * Implementer code\n       */\n \
    \     BitFieldModel<uint32_t, 24, 8> implementer;\n    };\n  };\n\npublic:\n \
    \ /**\n   * @brief CPUID register\n   *\n   * CPUID base register\n   */\n  using\
    \ cpuid = CpuidReg<BaseAddress + 0x0000>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class IcsrReg : public RegisterModel<uint32_t, address>\n  {\n \
    \ public:\n    /**\n     * @brief VECTACTIVE field\n     *\n     * Active vector\n\
    \     */\n    using vectactive = FieldModel<uint32_t, address, 0, 9>;\n    /**\n\
    \     * @brief RETTOBASE field\n     *\n     * Return to base level\n     */\n\
    \    using rettobase = FieldModel<uint32_t, address, 11, 1>;\n    /**\n     *\
    \ @brief VECTPENDING field\n     *\n     * Pending vector\n     */\n    using\
    \ vectpending = FieldModel<uint32_t, address, 12, 7>;\n    /**\n     * @brief\
    \ ISRPENDING field\n     *\n     * Interrupt pending flag\n     */\n    using\
    \ isrpending = FieldModel<uint32_t, address, 22, 1>;\n    /**\n     * @brief PENDSTCLR\
    \ field\n     *\n     * SysTick exception clear-pending\n     *              \
    \ bit\n     */\n    using pendstclr = FieldModel<uint32_t, address, 25, 1>;\n\
    \    /**\n     * @brief PENDSTSET field\n     *\n     * SysTick exception set-pending\n\
    \     *               bit\n     */\n    using pendstset = FieldModel<uint32_t,\
    \ address, 26, 1>;\n    /**\n     * @brief PENDSVCLR field\n     *\n     * PendSV\
    \ clear-pending bit\n     */\n    using pendsvclr = FieldModel<uint32_t, address,\
    \ 27, 1>;\n    /**\n     * @brief PENDSVSET field\n     *\n     * PendSV set-pending\
    \ bit\n     */\n    using pendsvset = FieldModel<uint32_t, address, 28, 1>;\n\
    \    /**\n     * @brief NMIPENDSET field\n     *\n     * NMI set-pending bit.\n\
    \     */\n    using nmipendset = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief VECTACTIVE field\n       *\n       * Active vector\n       */\n\
    \      BitFieldModel<uint32_t, 0, 9> vectactive;\n      /**\n       * @brief RETTOBASE\
    \ field\n       *\n       * Return to base level\n       */\n      BitFieldModel<uint32_t,\
    \ 11, 1> rettobase;\n      /**\n       * @brief VECTPENDING field\n       *\n\
    \       * Pending vector\n       */\n      BitFieldModel<uint32_t, 12, 7> vectpending;\n\
    \      /**\n       * @brief ISRPENDING field\n       *\n       * Interrupt pending\
    \ flag\n       */\n      BitFieldModel<uint32_t, 22, 1> isrpending;\n      /**\n\
    \       * @brief PENDSTCLR field\n       *\n       * SysTick exception clear-pending\n\
    \       *               bit\n       */\n      BitFieldModel<uint32_t, 25, 1> pendstclr;\n\
    \      /**\n       * @brief PENDSTSET field\n       *\n       * SysTick exception\
    \ set-pending\n       *               bit\n       */\n      BitFieldModel<uint32_t,\
    \ 26, 1> pendstset;\n      /**\n       * @brief PENDSVCLR field\n       *\n  \
    \     * PendSV clear-pending bit\n       */\n      BitFieldModel<uint32_t, 27,\
    \ 1> pendsvclr;\n      /**\n       * @brief PENDSVSET field\n       *\n      \
    \ * PendSV set-pending bit\n       */\n      BitFieldModel<uint32_t, 28, 1> pendsvset;\n\
    \      /**\n       * @brief NMIPENDSET field\n       *\n       * NMI set-pending\
    \ bit.\n       */\n      BitFieldModel<uint32_t, 31, 1> nmipendset;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief ICSR register\n   *\n   * Interrupt control\
    \ and state\n   *           register\n   */\n  using icsr = IcsrReg<BaseAddress\
    \ + 0x0004>;\n\nprivate:\n  template<unsigned int address>\n  class VtorReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ TBLOFF field\n     *\n     * Vector table base offset\n     *              \
    \ field\n     */\n    using tbloff = FieldModel<uint32_t, address, 9, 21>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief TBLOFF field\n       *\n       * Vector table\
    \ base offset\n       *               field\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 21> tbloff;\n    };\n  };\n\npublic:\n  /**\n   * @brief VTOR register\n\
    \   *\n   * Vector table offset register\n   */\n  using vtor = VtorReg<BaseAddress\
    \ + 0x0008>;\n\nprivate:\n  template<unsigned int address>\n  class AircrReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ VECTRESET field\n     *\n     * VECTRESET\n     */\n    using vectreset = FieldModel<uint32_t,\
    \ address, 0, 1>;\n    /**\n     * @brief VECTCLRACTIVE field\n     *\n     *\
    \ VECTCLRACTIVE\n     */\n    using vectclractive = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    /**\n     * @brief SYSRESETREQ field\n     *\n     * SYSRESETREQ\n\
    \     */\n    using sysresetreq = FieldModel<uint32_t, address, 2, 1>;\n    /**\n\
    \     * @brief PRIGROUP field\n     *\n     * PRIGROUP\n     */\n    using prigroup\
    \ = FieldModel<uint32_t, address, 8, 3>;\n    /**\n     * @brief ENDIANESS field\n\
    \     *\n     * ENDIANESS\n     */\n    using endianess = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief VECTKEYSTAT field\n     *\n     * Register\
    \ key\n     */\n    using vectkeystat = FieldModel<uint32_t, address, 16, 16>;\n\
    \n  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief VECTRESET field\n       *\n       * VECTRESET\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> vectreset;\n      /**\n      \
    \ * @brief VECTCLRACTIVE field\n       *\n       * VECTCLRACTIVE\n       */\n\
    \      BitFieldModel<uint32_t, 1, 1> vectclractive;\n      /**\n       * @brief\
    \ SYSRESETREQ field\n       *\n       * SYSRESETREQ\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> sysresetreq;\n      /**\n       * @brief PRIGROUP field\n       *\n  \
    \     * PRIGROUP\n       */\n      BitFieldModel<uint32_t, 8, 3> prigroup;\n \
    \     /**\n       * @brief ENDIANESS field\n       *\n       * ENDIANESS\n   \
    \    */\n      BitFieldModel<uint32_t, 15, 1> endianess;\n      /**\n       *\
    \ @brief VECTKEYSTAT field\n       *\n       * Register key\n       */\n     \
    \ BitFieldModel<uint32_t, 16, 16> vectkeystat;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief AIRCR register\n   *\n   * Application interrupt and reset control\n\
    \   *           register\n   */\n  using aircr = AircrReg<BaseAddress + 0x000C>;\n\
    \nprivate:\n  template<unsigned int address>\n  class ScrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief SLEEPONEXIT field\n     *\n\
    \     * SLEEPONEXIT\n     */\n    using sleeponexit = FieldModel<uint32_t, address,\
    \ 1, 1>;\n    /**\n     * @brief SLEEPDEEP field\n     *\n     * SLEEPDEEP\n \
    \    */\n    using sleepdeep = FieldModel<uint32_t, address, 2, 1>;\n    /**\n\
    \     * @brief SEVEONPEND field\n     *\n     * Send Event on Pending bit\n  \
    \   */\n    using seveonpend = FieldModel<uint32_t, address, 4, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief SLEEPONEXIT field\n       *\n       * SLEEPONEXIT\n       */\n\
    \      BitFieldModel<uint32_t, 1, 1> sleeponexit;\n      /**\n       * @brief\
    \ SLEEPDEEP field\n       *\n       * SLEEPDEEP\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> sleepdeep;\n      /**\n       * @brief SEVEONPEND field\n       *\n  \
    \     * Send Event on Pending bit\n       */\n      BitFieldModel<uint32_t, 4,\
    \ 1> seveonpend;\n    };\n  };\n\npublic:\n  /**\n   * @brief SCR register\n \
    \  *\n   * System control register\n   */\n  using scr = ScrReg<BaseAddress +\
    \ 0x0010>;\n\nprivate:\n  template<unsigned int address>\n  class CcrReg : public\
    \ RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief NONBASETHRDENA\
    \ field\n     *\n     * Configures how the processor enters\n     *          \
    \     Thread mode\n     */\n    using nonbasethrdena = FieldModel<uint32_t, address,\
    \ 0, 1>;\n    /**\n     * @brief USERSETMPEND field\n     *\n     * USERSETMPEND\n\
    \     */\n    using usersetmpend = FieldModel<uint32_t, address, 1, 1>;\n    /**\n\
    \     * @brief UNALIGN__TRP field\n     *\n     * UNALIGN_ TRP\n     */\n    using\
    \ unalign__trp = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief\
    \ DIV_0_TRP field\n     *\n     * DIV_0_TRP\n     */\n    using div_0_trp = FieldModel<uint32_t,\
    \ address, 4, 1>;\n    /**\n     * @brief BFHFNMIGN field\n     *\n     * BFHFNMIGN\n\
    \     */\n    using bfhfnmign = FieldModel<uint32_t, address, 8, 1>;\n    /**\n\
    \     * @brief STKALIGN field\n     *\n     * STKALIGN\n     */\n    using stkalign\
    \ = FieldModel<uint32_t, address, 9, 1>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ NONBASETHRDENA field\n       *\n       * Configures how the processor enters\n\
    \       *               Thread mode\n       */\n      BitFieldModel<uint32_t,\
    \ 0, 1> nonbasethrdena;\n      /**\n       * @brief USERSETMPEND field\n     \
    \  *\n       * USERSETMPEND\n       */\n      BitFieldModel<uint32_t, 1, 1> usersetmpend;\n\
    \      /**\n       * @brief UNALIGN__TRP field\n       *\n       * UNALIGN_ TRP\n\
    \       */\n      BitFieldModel<uint32_t, 3, 1> unalign__trp;\n      /**\n   \
    \    * @brief DIV_0_TRP field\n       *\n       * DIV_0_TRP\n       */\n     \
    \ BitFieldModel<uint32_t, 4, 1> div_0_trp;\n      /**\n       * @brief BFHFNMIGN\
    \ field\n       *\n       * BFHFNMIGN\n       */\n      BitFieldModel<uint32_t,\
    \ 8, 1> bfhfnmign;\n      /**\n       * @brief STKALIGN field\n       *\n    \
    \   * STKALIGN\n       */\n      BitFieldModel<uint32_t, 9, 1> stkalign;\n   \
    \ };\n  };\n\npublic:\n  /**\n   * @brief CCR register\n   *\n   * Configuration\
    \ and control\n   *           register\n   */\n  using ccr = CcrReg<BaseAddress\
    \ + 0x0014>;\n\nprivate:\n  template<unsigned int address>\n  class Shpr1Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ PRI_4 field\n     *\n     * Priority of system handler\n     *             \
    \  4\n     */\n    using pri_4 = FieldModel<uint32_t, address, 0, 8>;\n    /**\n\
    \     * @brief PRI_5 field\n     *\n     * Priority of system handler\n     *\
    \               5\n     */\n    using pri_5 = FieldModel<uint32_t, address, 8,\
    \ 8>;\n    /**\n     * @brief PRI_6 field\n     *\n     * Priority of system handler\n\
    \     *               6\n     */\n    using pri_6 = FieldModel<uint32_t, address,\
    \ 16, 8>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief PRI_4 field\n       *\n\
    \       * Priority of system handler\n       *               4\n       */\n  \
    \    BitFieldModel<uint32_t, 0, 8> pri_4;\n      /**\n       * @brief PRI_5 field\n\
    \       *\n       * Priority of system handler\n       *               5\n   \
    \    */\n      BitFieldModel<uint32_t, 8, 8> pri_5;\n      /**\n       * @brief\
    \ PRI_6 field\n       *\n       * Priority of system handler\n       *       \
    \        6\n       */\n      BitFieldModel<uint32_t, 16, 8> pri_6;\n    };\n \
    \ };\n\npublic:\n  /**\n   * @brief SHPR1 register\n   *\n   * System handler\
    \ priority\n   *           registers\n   */\n  using shpr1 = Shpr1Reg<BaseAddress\
    \ + 0x0018>;\n\nprivate:\n  template<unsigned int address>\n  class Shpr2Reg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ PRI_11 field\n     *\n     * Priority of system handler\n     *            \
    \   11\n     */\n    using pri_11 = FieldModel<uint32_t, address, 24, 8>;\n\n\
    \  public:\n    /**\n     * @brief Register union\n     *\n     * Can be used\
    \ to create a local register variable for easy bit manipulation.\n     * Useful\
    \ for read-modify-write operations.\n     */\n    union reg\n    {\n      uint32_t\
    \ value;\n      /**\n       * @brief PRI_11 field\n       *\n       * Priority\
    \ of system handler\n       *               11\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 8> pri_11;\n    };\n  };\n\npublic:\n  /**\n   * @brief SHPR2 register\n\
    \   *\n   * System handler priority\n   *           registers\n   */\n  using\
    \ shpr2 = Shpr2Reg<BaseAddress + 0x001C>;\n\nprivate:\n  template<unsigned int\
    \ address>\n  class Shpr3Reg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief PRI_14 field\n     *\n     * Priority of system\
    \ handler\n     *               14\n     */\n    using pri_14 = FieldModel<uint32_t,\
    \ address, 16, 8>;\n    /**\n     * @brief PRI_15 field\n     *\n     * Priority\
    \ of system handler\n     *               15\n     */\n    using pri_15 = FieldModel<uint32_t,\
    \ address, 24, 8>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief PRI_14 field\n       *\n\
    \       * Priority of system handler\n       *               14\n       */\n \
    \     BitFieldModel<uint32_t, 16, 8> pri_14;\n      /**\n       * @brief PRI_15\
    \ field\n       *\n       * Priority of system handler\n       *             \
    \  15\n       */\n      BitFieldModel<uint32_t, 24, 8> pri_15;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief SHPR3 register\n   *\n   * System handler priority\n\
    \   *           registers\n   */\n  using shpr3 = Shpr3Reg<BaseAddress + 0x0020>;\n\
    \nprivate:\n  template<unsigned int address>\n  class ShcsrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief MEMFAULTACT field\n     *\n\
    \     * Memory management fault exception active\n     *               bit\n \
    \    */\n    using memfaultact = FieldModel<uint32_t, address, 0, 1>;\n    /**\n\
    \     * @brief BUSFAULTACT field\n     *\n     * Bus fault exception active\n\
    \     *               bit\n     */\n    using busfaultact = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief USGFAULTACT field\n     *\n     * Usage\
    \ fault exception active\n     *               bit\n     */\n    using usgfaultact\
    \ = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief SVCALLACT field\n\
    \     *\n     * SVC call active bit\n     */\n    using svcallact = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief MONITORACT field\n     *\n     * Debug\
    \ monitor active bit\n     */\n    using monitoract = FieldModel<uint32_t, address,\
    \ 8, 1>;\n    /**\n     * @brief PENDSVACT field\n     *\n     * PendSV exception\
    \ active\n     *               bit\n     */\n    using pendsvact = FieldModel<uint32_t,\
    \ address, 10, 1>;\n    /**\n     * @brief SYSTICKACT field\n     *\n     * SysTick\
    \ exception active\n     *               bit\n     */\n    using systickact =\
    \ FieldModel<uint32_t, address, 11, 1>;\n    /**\n     * @brief USGFAULTPENDED\
    \ field\n     *\n     * Usage fault exception pending\n     *               bit\n\
    \     */\n    using usgfaultpended = FieldModel<uint32_t, address, 12, 1>;\n \
    \   /**\n     * @brief MEMFAULTPENDED field\n     *\n     * Memory management\
    \ fault exception\n     *               pending bit\n     */\n    using memfaultpended\
    \ = FieldModel<uint32_t, address, 13, 1>;\n    /**\n     * @brief BUSFAULTPENDED\
    \ field\n     *\n     * Bus fault exception pending\n     *               bit\n\
    \     */\n    using busfaultpended = FieldModel<uint32_t, address, 14, 1>;\n \
    \   /**\n     * @brief SVCALLPENDED field\n     *\n     * SVC call pending bit\n\
    \     */\n    using svcallpended = FieldModel<uint32_t, address, 15, 1>;\n   \
    \ /**\n     * @brief MEMFAULTENA field\n     *\n     * Memory management fault\
    \ enable\n     *               bit\n     */\n    using memfaultena = FieldModel<uint32_t,\
    \ address, 16, 1>;\n    /**\n     * @brief BUSFAULTENA field\n     *\n     * Bus\
    \ fault enable bit\n     */\n    using busfaultena = FieldModel<uint32_t, address,\
    \ 17, 1>;\n    /**\n     * @brief USGFAULTENA field\n     *\n     * Usage fault\
    \ enable bit\n     */\n    using usgfaultena = FieldModel<uint32_t, address, 18,\
    \ 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief MEMFAULTACT field\n       *\n\
    \       * Memory management fault exception active\n       *               bit\n\
    \       */\n      BitFieldModel<uint32_t, 0, 1> memfaultact;\n      /**\n    \
    \   * @brief BUSFAULTACT field\n       *\n       * Bus fault exception active\n\
    \       *               bit\n       */\n      BitFieldModel<uint32_t, 1, 1> busfaultact;\n\
    \      /**\n       * @brief USGFAULTACT field\n       *\n       * Usage fault\
    \ exception active\n       *               bit\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> usgfaultact;\n      /**\n       * @brief SVCALLACT field\n       *\n \
    \      * SVC call active bit\n       */\n      BitFieldModel<uint32_t, 7, 1> svcallact;\n\
    \      /**\n       * @brief MONITORACT field\n       *\n       * Debug monitor\
    \ active bit\n       */\n      BitFieldModel<uint32_t, 8, 1> monitoract;\n   \
    \   /**\n       * @brief PENDSVACT field\n       *\n       * PendSV exception\
    \ active\n       *               bit\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> pendsvact;\n      /**\n       * @brief SYSTICKACT field\n       *\n \
    \      * SysTick exception active\n       *               bit\n       */\n   \
    \   BitFieldModel<uint32_t, 11, 1> systickact;\n      /**\n       * @brief USGFAULTPENDED\
    \ field\n       *\n       * Usage fault exception pending\n       *          \
    \     bit\n       */\n      BitFieldModel<uint32_t, 12, 1> usgfaultpended;\n \
    \     /**\n       * @brief MEMFAULTPENDED field\n       *\n       * Memory management\
    \ fault exception\n       *               pending bit\n       */\n      BitFieldModel<uint32_t,\
    \ 13, 1> memfaultpended;\n      /**\n       * @brief BUSFAULTPENDED field\n  \
    \     *\n       * Bus fault exception pending\n       *               bit\n  \
    \     */\n      BitFieldModel<uint32_t, 14, 1> busfaultpended;\n      /**\n  \
    \     * @brief SVCALLPENDED field\n       *\n       * SVC call pending bit\n \
    \      */\n      BitFieldModel<uint32_t, 15, 1> svcallpended;\n      /**\n   \
    \    * @brief MEMFAULTENA field\n       *\n       * Memory management fault enable\n\
    \       *               bit\n       */\n      BitFieldModel<uint32_t, 16, 1> memfaultena;\n\
    \      /**\n       * @brief BUSFAULTENA field\n       *\n       * Bus fault enable\
    \ bit\n       */\n      BitFieldModel<uint32_t, 17, 1> busfaultena;\n      /**\n\
    \       * @brief USGFAULTENA field\n       *\n       * Usage fault enable bit\n\
    \       */\n      BitFieldModel<uint32_t, 18, 1> usgfaultena;\n    };\n  };\n\n\
    public:\n  /**\n   * @brief SHCSR register\n   *\n   * System handler control\
    \ and state\n   *           register\n   */\n  using shcsr = ShcsrReg<BaseAddress\
    \ + 0x0024>;\n\nprivate:\n  template<unsigned int address>\n  class Cfsr_ufsr_bfsr_mmfsrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ IACCVIOL field\n     *\n     * Instruction access violation\n     *        \
    \       flag\n     */\n    using iaccviol = FieldModel<uint32_t, address, 1, 1>;\n\
    \    /**\n     * @brief MUNSTKERR field\n     *\n     * Memory manager fault on\
    \ unstacking for a\n     *               return from exception\n     */\n    using\
    \ munstkerr = FieldModel<uint32_t, address, 3, 1>;\n    /**\n     * @brief MSTKERR\
    \ field\n     *\n     * Memory manager fault on stacking for\n     *         \
    \      exception entry.\n     */\n    using mstkerr = FieldModel<uint32_t, address,\
    \ 4, 1>;\n    /**\n     * @brief MLSPERR field\n     *\n     * MLSPERR\n     */\n\
    \    using mlsperr = FieldModel<uint32_t, address, 5, 1>;\n    /**\n     * @brief\
    \ MMARVALID field\n     *\n     * Memory Management Fault Address Register\n \
    \    *               (MMAR) valid flag\n     */\n    using mmarvalid = FieldModel<uint32_t,\
    \ address, 7, 1>;\n    /**\n     * @brief IBUSERR field\n     *\n     * Instruction\
    \ bus error\n     */\n    using ibuserr = FieldModel<uint32_t, address, 8, 1>;\n\
    \    /**\n     * @brief PRECISERR field\n     *\n     * Precise data bus error\n\
    \     */\n    using preciserr = FieldModel<uint32_t, address, 9, 1>;\n    /**\n\
    \     * @brief IMPRECISERR field\n     *\n     * Imprecise data bus error\n  \
    \   */\n    using impreciserr = FieldModel<uint32_t, address, 10, 1>;\n    /**\n\
    \     * @brief UNSTKERR field\n     *\n     * Bus fault on unstacking for a return\n\
    \     *               from exception\n     */\n    using unstkerr = FieldModel<uint32_t,\
    \ address, 11, 1>;\n    /**\n     * @brief STKERR field\n     *\n     * Bus fault\
    \ on stacking for exception\n     *               entry\n     */\n    using stkerr\
    \ = FieldModel<uint32_t, address, 12, 1>;\n    /**\n     * @brief LSPERR field\n\
    \     *\n     * Bus fault on floating-point lazy state\n     *               preservation\n\
    \     */\n    using lsperr = FieldModel<uint32_t, address, 13, 1>;\n    /**\n\
    \     * @brief BFARVALID field\n     *\n     * Bus Fault Address Register (BFAR)\
    \ valid\n     *               flag\n     */\n    using bfarvalid = FieldModel<uint32_t,\
    \ address, 15, 1>;\n    /**\n     * @brief UNDEFINSTR field\n     *\n     * Undefined\
    \ instruction usage\n     *               fault\n     */\n    using undefinstr\
    \ = FieldModel<uint32_t, address, 16, 1>;\n    /**\n     * @brief INVSTATE field\n\
    \     *\n     * Invalid state usage fault\n     */\n    using invstate = FieldModel<uint32_t,\
    \ address, 17, 1>;\n    /**\n     * @brief INVPC field\n     *\n     * Invalid\
    \ PC load usage\n     *               fault\n     */\n    using invpc = FieldModel<uint32_t,\
    \ address, 18, 1>;\n    /**\n     * @brief NOCP field\n     *\n     * No coprocessor\
    \ usage\n     *               fault.\n     */\n    using nocp = FieldModel<uint32_t,\
    \ address, 19, 1>;\n    /**\n     * @brief UNALIGNED field\n     *\n     * Unaligned\
    \ access usage\n     *               fault\n     */\n    using unaligned = FieldModel<uint32_t,\
    \ address, 24, 1>;\n    /**\n     * @brief DIVBYZERO field\n     *\n     * Divide\
    \ by zero usage fault\n     */\n    using divbyzero = FieldModel<uint32_t, address,\
    \ 25, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief IACCVIOL field\n      \
    \ *\n       * Instruction access violation\n       *               flag\n    \
    \   */\n      BitFieldModel<uint32_t, 1, 1> iaccviol;\n      /**\n       * @brief\
    \ MUNSTKERR field\n       *\n       * Memory manager fault on unstacking for a\n\
    \       *               return from exception\n       */\n      BitFieldModel<uint32_t,\
    \ 3, 1> munstkerr;\n      /**\n       * @brief MSTKERR field\n       *\n     \
    \  * Memory manager fault on stacking for\n       *               exception entry.\n\
    \       */\n      BitFieldModel<uint32_t, 4, 1> mstkerr;\n      /**\n       *\
    \ @brief MLSPERR field\n       *\n       * MLSPERR\n       */\n      BitFieldModel<uint32_t,\
    \ 5, 1> mlsperr;\n      /**\n       * @brief MMARVALID field\n       *\n     \
    \  * Memory Management Fault Address Register\n       *               (MMAR) valid\
    \ flag\n       */\n      BitFieldModel<uint32_t, 7, 1> mmarvalid;\n      /**\n\
    \       * @brief IBUSERR field\n       *\n       * Instruction bus error\n   \
    \    */\n      BitFieldModel<uint32_t, 8, 1> ibuserr;\n      /**\n       * @brief\
    \ PRECISERR field\n       *\n       * Precise data bus error\n       */\n    \
    \  BitFieldModel<uint32_t, 9, 1> preciserr;\n      /**\n       * @brief IMPRECISERR\
    \ field\n       *\n       * Imprecise data bus error\n       */\n      BitFieldModel<uint32_t,\
    \ 10, 1> impreciserr;\n      /**\n       * @brief UNSTKERR field\n       *\n \
    \      * Bus fault on unstacking for a return\n       *               from exception\n\
    \       */\n      BitFieldModel<uint32_t, 11, 1> unstkerr;\n      /**\n      \
    \ * @brief STKERR field\n       *\n       * Bus fault on stacking for exception\n\
    \       *               entry\n       */\n      BitFieldModel<uint32_t, 12, 1>\
    \ stkerr;\n      /**\n       * @brief LSPERR field\n       *\n       * Bus fault\
    \ on floating-point lazy state\n       *               preservation\n       */\n\
    \      BitFieldModel<uint32_t, 13, 1> lsperr;\n      /**\n       * @brief BFARVALID\
    \ field\n       *\n       * Bus Fault Address Register (BFAR) valid\n       *\
    \               flag\n       */\n      BitFieldModel<uint32_t, 15, 1> bfarvalid;\n\
    \      /**\n       * @brief UNDEFINSTR field\n       *\n       * Undefined instruction\
    \ usage\n       *               fault\n       */\n      BitFieldModel<uint32_t,\
    \ 16, 1> undefinstr;\n      /**\n       * @brief INVSTATE field\n       *\n  \
    \     * Invalid state usage fault\n       */\n      BitFieldModel<uint32_t, 17,\
    \ 1> invstate;\n      /**\n       * @brief INVPC field\n       *\n       * Invalid\
    \ PC load usage\n       *               fault\n       */\n      BitFieldModel<uint32_t,\
    \ 18, 1> invpc;\n      /**\n       * @brief NOCP field\n       *\n       * No\
    \ coprocessor usage\n       *               fault.\n       */\n      BitFieldModel<uint32_t,\
    \ 19, 1> nocp;\n      /**\n       * @brief UNALIGNED field\n       *\n       *\
    \ Unaligned access usage\n       *               fault\n       */\n      BitFieldModel<uint32_t,\
    \ 24, 1> unaligned;\n      /**\n       * @brief DIVBYZERO field\n       *\n  \
    \     * Divide by zero usage fault\n       */\n      BitFieldModel<uint32_t, 25,\
    \ 1> divbyzero;\n    };\n  };\n\npublic:\n  /**\n   * @brief CFSR_UFSR_BFSR_MMFSR\
    \ register\n   *\n   * Configurable fault status\n   *           register\n  \
    \ */\n  using cfsr_ufsr_bfsr_mmfsr = Cfsr_ufsr_bfsr_mmfsrReg<BaseAddress + 0x0028>;\n\
    \nprivate:\n  template<unsigned int address>\n  class HfsrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief VECTTBL field\n     *\n   \
    \  * Vector table hard fault\n     */\n    using vecttbl = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief FORCED field\n     *\n     * Forced\
    \ hard fault\n     */\n    using forced = FieldModel<uint32_t, address, 30, 1>;\n\
    \    /**\n     * @brief DEBUG_VT field\n     *\n     * Reserved for Debug use\n\
    \     */\n    using debug_vt = FieldModel<uint32_t, address, 31, 1>;\n\n  public:\n\
    \    /**\n     * @brief Register union\n     *\n     * Can be used to create a\
    \ local register variable for easy bit manipulation.\n     * Useful for read-modify-write\
    \ operations.\n     */\n    union reg\n    {\n      uint32_t value;\n      /**\n\
    \       * @brief VECTTBL field\n       *\n       * Vector table hard fault\n \
    \      */\n      BitFieldModel<uint32_t, 1, 1> vecttbl;\n      /**\n       * @brief\
    \ FORCED field\n       *\n       * Forced hard fault\n       */\n      BitFieldModel<uint32_t,\
    \ 30, 1> forced;\n      /**\n       * @brief DEBUG_VT field\n       *\n      \
    \ * Reserved for Debug use\n       */\n      BitFieldModel<uint32_t, 31, 1> debug_vt;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief HFSR register\n   *\n   * Hard fault\
    \ status register\n   */\n  using hfsr = HfsrReg<BaseAddress + 0x002C>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class MmfarReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief MMFAR field\n     *\n     *\
    \ Memory management fault\n     *               address\n     */\n    using mmfar\
    \ = FieldModel<uint32_t, address, 0, 32>;\n\n  public:\n    /**\n     * @brief\
    \ Register union\n     *\n     * Can be used to create a local register variable\
    \ for easy bit manipulation.\n     * Useful for read-modify-write operations.\n\
    \     */\n    union reg\n    {\n      uint32_t value;\n      /**\n       * @brief\
    \ MMFAR field\n       *\n       * Memory management fault\n       *          \
    \     address\n       */\n      BitFieldModel<uint32_t, 0, 32> mmfar;\n    };\n\
    \  };\n\npublic:\n  /**\n   * @brief MMFAR register\n   *\n   * Memory management\
    \ fault address\n   *           register\n   */\n  using mmfar = MmfarReg<BaseAddress\
    \ + 0x0034>;\n\nprivate:\n  template<unsigned int address>\n  class BfarReg :\
    \ public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ BFAR field\n     *\n     * Bus fault address\n     */\n    using bfar = FieldModel<uint32_t,\
    \ address, 0, 32>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief BFAR field\n       *\n\
    \       * Bus fault address\n       */\n      BitFieldModel<uint32_t, 0, 32> bfar;\n\
    \    };\n  };\n\npublic:\n  /**\n   * @brief BFAR register\n   *\n   * Bus fault\
    \ address register\n   */\n  using bfar = BfarReg<BaseAddress + 0x0038>;\n\nprivate:\n\
    \  template<unsigned int address>\n  class AfsrReg : public RegisterModel<uint32_t,\
    \ address>\n  {\n  public:\n    /**\n     * @brief IMPDEF field\n     *\n    \
    \ * Implementation defined\n     */\n    using impdef = FieldModel<uint32_t, address,\
    \ 0, 32>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief IMPDEF field\n       *\n\
    \       * Implementation defined\n       */\n      BitFieldModel<uint32_t, 0,\
    \ 32> impdef;\n    };\n  };\n\npublic:\n  /**\n   * @brief AFSR register\n   *\n\
    \   * Auxiliary fault status\n   *           register\n   */\n  using afsr = AfsrReg<BaseAddress\
    \ + 0x003C>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_SCB_H */"
  name: SCB
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_NVIC_STIR_H\n#define DRAL_STM32F411_NVIC_STIR_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ NVIC_STIR peripheral\n *\n * Nested vectored interrupt\n *       controller\n\
    \ */\nclass nvic_stir\n{\npublic:\n  static constexpr unsigned int BaseAddress\
    \ = 0xE000EF00; /**< Peripheral base address */\n\nprivate:\n  template<unsigned\
    \ int address>\n  class StirReg : public RegisterModel<uint32_t, address>\n  {\n\
    \  public:\n    /**\n     * @brief INTID field\n     *\n     * Software generated\
    \ interrupt\n     *               ID\n     */\n    using intid = FieldModel<uint32_t,\
    \ address, 0, 9>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n\
    \     * Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief INTID field\n       *\n\
    \       * Software generated interrupt\n       *               ID\n       */\n\
    \      BitFieldModel<uint32_t, 0, 9> intid;\n    };\n  };\n\npublic:\n  /**\n\
    \   * @brief STIR register\n   *\n   * Software trigger interrupt\n   *      \
    \     register\n   */\n  using stir = StirReg<BaseAddress + 0x0000>;\n\n};\n\n\
    }\n\n#endif /* DRAL_STM32F411_NVIC_STIR_H */"
  name: NVIC_STIR
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_FPU_CPACR_H\n#define DRAL_STM32F411_FPU_CPACR_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ FPU_CPACR peripheral\n *\n * Floating point unit CPACR\n */\nclass fpu_cpacr\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0xE000ED88; /**< Peripheral\
    \ base address */\n\nprivate:\n  template<unsigned int address>\n  class CpacrReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ CP field\n     *\n     * CP\n     */\n    using cp = FieldModel<uint32_t, address,\
    \ 20, 4>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     *\
    \ Can be used to create a local register variable for easy bit manipulation.\n\
    \     * Useful for read-modify-write operations.\n     */\n    union reg\n   \
    \ {\n      uint32_t value;\n      /**\n       * @brief CP field\n       *\n  \
    \     * CP\n       */\n      BitFieldModel<uint32_t, 20, 4> cp;\n    };\n  };\n\
    \npublic:\n  /**\n   * @brief CPACR register\n   *\n   * Coprocessor access control\n\
    \   *           register\n   */\n  using cpacr = CpacrReg<BaseAddress + 0x0000>;\n\
    \n};\n\n}\n\n#endif /* DRAL_STM32F411_FPU_CPACR_H */"
  name: FPU_CPACR
- content: "/*\n * D-RAL - Device Register Access Layer\n * https://github.com/gembcior/d-ral\n\
    \ *\n * MIT License\n *\n * Copyright (c) 2023 Gembcior\n *\n * Permission is\
    \ hereby granted, free of charge, to any person obtaining a copy\n * of this software\
    \ and associated documentation files (the \"Software\"), to deal\n * in the Software\
    \ without restriction, including without limitation the rights\n * to use, copy,\
    \ modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the\
    \ Software, and to permit persons to whom the Software is\n * furnished to do\
    \ so, subject to the following conditions:\n *\n * The above copyright notice\
    \ and this permission notice shall be included in all\n * copies or substantial\
    \ portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\
    \ WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE\
    \ WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
    \ IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\
    \ DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\
    \ ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\
    \ DEALINGS IN THE\n * SOFTWARE.\n *\n * This is an auto generated file. Do not\
    \ modify!\n */\n\n#ifndef DRAL_STM32F411_SCB_ACTRL_H\n#define DRAL_STM32F411_SCB_ACTRL_H\n\
    \n#include \"../register_model.h\"\n\nnamespace dral::stm32f411 {\n\n/**\n * @brief\
    \ SCB_ACTRL peripheral\n *\n * System control block ACTLR\n */\nclass scb_actrl\n\
    {\npublic:\n  static constexpr unsigned int BaseAddress = 0xE000E008; /**< Peripheral\
    \ base address */\n\nprivate:\n  template<unsigned int address>\n  class ActrlReg\
    \ : public RegisterModel<uint32_t, address>\n  {\n  public:\n    /**\n     * @brief\
    \ DISMCYCINT field\n     *\n     * DISMCYCINT\n     */\n    using dismcycint =\
    \ FieldModel<uint32_t, address, 0, 1>;\n    /**\n     * @brief DISDEFWBUF field\n\
    \     *\n     * DISDEFWBUF\n     */\n    using disdefwbuf = FieldModel<uint32_t,\
    \ address, 1, 1>;\n    /**\n     * @brief DISFOLD field\n     *\n     * DISFOLD\n\
    \     */\n    using disfold = FieldModel<uint32_t, address, 2, 1>;\n    /**\n\
    \     * @brief DISFPCA field\n     *\n     * DISFPCA\n     */\n    using disfpca\
    \ = FieldModel<uint32_t, address, 8, 1>;\n    /**\n     * @brief DISOOFP field\n\
    \     *\n     * DISOOFP\n     */\n    using disoofp = FieldModel<uint32_t, address,\
    \ 9, 1>;\n\n  public:\n    /**\n     * @brief Register union\n     *\n     * Can\
    \ be used to create a local register variable for easy bit manipulation.\n   \
    \  * Useful for read-modify-write operations.\n     */\n    union reg\n    {\n\
    \      uint32_t value;\n      /**\n       * @brief DISMCYCINT field\n       *\n\
    \       * DISMCYCINT\n       */\n      BitFieldModel<uint32_t, 0, 1> dismcycint;\n\
    \      /**\n       * @brief DISDEFWBUF field\n       *\n       * DISDEFWBUF\n\
    \       */\n      BitFieldModel<uint32_t, 1, 1> disdefwbuf;\n      /**\n     \
    \  * @brief DISFOLD field\n       *\n       * DISFOLD\n       */\n      BitFieldModel<uint32_t,\
    \ 2, 1> disfold;\n      /**\n       * @brief DISFPCA field\n       *\n       *\
    \ DISFPCA\n       */\n      BitFieldModel<uint32_t, 8, 1> disfpca;\n      /**\n\
    \       * @brief DISOOFP field\n       *\n       * DISOOFP\n       */\n      BitFieldModel<uint32_t,\
    \ 9, 1> disoofp;\n    };\n  };\n\npublic:\n  /**\n   * @brief ACTRL register\n\
    \   *\n   * Auxiliary control register\n   */\n  using actrl = ActrlReg<BaseAddress\
    \ + 0x0000>;\n\n};\n\n}\n\n#endif /* DRAL_STM32F411_SCB_ACTRL_H */"
  name: SCB_ACTRL
